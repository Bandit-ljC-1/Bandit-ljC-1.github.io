<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理（七）——输入输出系统</title>
      <link href="/2024/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（七）——输入输出系统"><a href="#计算机组成原理（七）——输入输出系统" class="headerlink" title="计算机组成原理（七）——输入输出系统"></a>计算机组成原理（七）——输入输出系统</h1><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h2><p>本章和操作系统的最后一章有很强的联系，操作系统在探讨输入输出系统的时候更多的是在探讨输入输出系统的软件部分，就是操作系统如何来管理这些输入输出设备。而计组这门课更着重探讨硬件的实现。</p><h2 id="1-输入输出系统和IO控制方式"><a href="#1-输入输出系统和IO控制方式" class="headerlink" title="1. 输入输出系统和IO控制方式"></a>1. 输入输出系统和IO控制方式</h2><img src="https://pic.imgdb.cn/item/66a768c6d9c307b7e90f5d77.png" alt="计算机组成原理（七）——输入输出系统——现代计算机结构.png"><p>现代的计算机大致上可以分为主机和外设两个部分，外设就是所谓的IO设备，I&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备。</p><p>下图是常见的IO设备：</p><img src="https://pic.imgdb.cn/item/66a768fad9c307b7e90f8eb6.png" alt="计算机组成原理（七）——输入输出系统——常见的IO设备.png"><p>接下来探讨主机如何与IO设备进行交互：</p><img src="https://pic.imgdb.cn/item/66a7692cd9c307b7e90fb51f.png" alt="计算机组成原理（七）——输入输出系统——主机与IO设备交互.png"><p>如上图是一个单总线的结构，可以看到IO接口的下面会挂着一个一个IO设备。</p><p>现在来说一下什么是IO接口，**<font color=red>I&#x2F;O接口又称I&#x2F;O控制器(I&#x2F;O Controller)、设备控制器，负责协调主机与外部设备之间的数据传输</font>**。</p><p>由于IO设备的种类繁多，因此IO接口的种类也会非常多，因此会制定相应的标准来规定如何设置IO控制器。所以，CPU的厂商想要通过IO控制器来控制某一些具体的设备，只需要遵守制定的IO接口标准，按照标准来IO控制器发出相应的命令。在常用的计算机中，这种IO接口通常就是一块芯片，一般来说会被集成在主板上，然后通过主板上的总线和CPU、内存等进行连接。</p><p>下面可以看一下主板图：</p><img src="https://pic.imgdb.cn/item/66a76960d9c307b7e90fe449.png" alt="计算机组成原理（七）——输入输出系统——IO控制器.png"><p>总之，IO接口是一个电子部件，会被集成在主板上，而IO设备是指看得见摸得着的外部设备。IO设备要和主机进行数据的交互、控制信息的传输，都需要经过IO接口的中转和处理。</p><p>接下来用一个简单的例子说明一下，CPU是如何通过IO接口与某一种外部设备进行交互的：</p><img src="https://pic.imgdb.cn/item/66a769bfd9c307b7e9102ea6.png" alt="计算机组成原理（七）——输入输出系统——IO控制方式简介1.png"><p>假设电脑上连接了一个键盘，然后可以通过上图左下角的获取键盘的输入，当程序执行到scanf的时候，会被卡在这一步，只有等待到键盘有字符输入以后，才会继续向后执行。而程序卡在scanf的地方，就相当于CPU此时正在等待键盘的输入数据，那么CPU应该如何控制键盘的IO操作的完成呢？</p><p>在此之前，先来看一下IO接口的结构，IO接口里面会包含一系列的寄存器，其中数据寄存器用来存放主机要输出到外设的数据或者外设要输入到主机的数据。控制寄存器里存储控制信息，其内容可以直接反映某一个外设具体需要做什么动作。状态寄存器里存储着当前外设的状态，比如当前这个外设是否完成工作，是否处于忙碌状态。</p><p>了解了三个寄存器的大致功能以后，现在看一下CPU在处理scanf的背后做了什么：</p><p>首先，CPU会通过控制总线向IO接口发出读命令，同时可以通过地址总线指明要读的是哪一个设备。另外地址总线还可以用于指明要从这个设备读入的数据应该放到哪一个寄存器。现在对IO设备的读命令已经发出了，那如何判断要读的字符数据有没有被输入呢？</p><p>其中一个比较容易想到的办法是可以让CPU不断轮询检查l&#x2F;O控制器中的“状态寄存器”，检测到状态为“已完成”之后，再从数据寄存器取出输入数据。这种方案意味着CPU需要不断检查状态寄存器，而不能去做其它的事情。这意味着，程序卡在了scanf这一句时，如果一直没有输入，那么CPU就不可以去做其它的事情，其它的后台程序都需要暂停。显然这种方式是很低效的。</p><p>为了解决这个低效的问题，可以采取另一种IO设备的控制方式——程序中断方式。这种方式在等待键盘l&#x2F;O时CPU可以先去执行其他程序，键盘I&#x2F;O完成后I&#x2F;O控制器向CPU发出中断请求，CPU响应中断请求，并取走输入数据。因此，程序中断方式就可以解放CPU的工作时间，CPU不需要再陷入忙等。</p><p>现在介绍的这两种IO控制方式的数据流都是：键盘→IO接口的数据寄存器→数据总线→CPU某寄存器→主存，即键盘通过外部的一个连接线，把数据输入到IO接口内部的数据寄存器当中，然后接下来数据寄存器的内容通过数据总线先传给CPU的某寄存器里，但是对于scanf操作来说，想要输入一个字符，并且把字符赋值给变量i，而程序里定义的变量都是放在主存里的，所以CPU取得刚才输入的字符之后，还需要把刚才取得这个数据把它写入主存。也就是说采用上面的两种IO设备的控制方式(程序查询方式和程序中断方式)，每输入或者每输出一个字，就需要CPU介入一次，CPU需要作为中转站，进行主存和IO设备之间的一个中转。</p><p>接下来再用图示把刚才的过程给捋一遍：</p><img src="https://pic.imgdb.cn/item/66a769fed9c307b7e9105e89.png" alt="计算机组成原理（七）——输入输出系统——IO控制方式简介2.png"><p>采用程序查询方式来控制IO设备的一个流程：首先CPU执行某个程序，当这个程序中间需要进行一次IO操作的时候，会通过IO指令来启动一次数据的读或者写，在IO设备准备数据的这段时间内，CPU会一直忙等，不断的去查询IO接口里面的状态寄存器，直到这次IO操作完成之后，CPU才会继续执行之前的那个程序。</p><p>采用程序中断方式来控制IO设备的一个流程：首先CPU执行某个程序，如果这个程序中间需要进行一次IO操作的时候，那么当这个IO设备在准备数据的过程当中CPU是可以去做其它的事情的，不需要进行忙等，接下来IO操作完成之后，IO接口会向CPU发出一个中断请求，CPU在每一条指令执行的末尾，都会例行的检查，此时有没有中断请求的到来，如果说检测到中断请求的信号，就会转而执行处理中断请求的中断处理程序。当CPU处理完这次中断请求后，就可以回去执行之前的程序，同时也可以发出下一条IO指令，让IO设备继续的输入或者输出一个数据。所以采用程序中断方式，可以使得CPU的忙碌时间变得更多，CPU的利用率可以得到大幅度的提升。</p><p>现在思考一个问题：刚才举得例子键盘，属于一种很慢速的设备，手速再块，一秒钟最多也就敲击5、6次，也就是说每秒钟会给CPU发送五六次中断请求，对于CPU来说，中断的频率不算特别高。那么对于快速IO设备，如“磁盘”，每准备好一个字就给CPU发送一次中断请求，会导致什么问题?</p><p>对于快速IO设备磁盘，如果每准备好一个字就给CPU发送一次中断请求，会导致CPU接收到的中断频率特别高，而每一次中断请求，都会导致CPU需要运行一段中断处理程序，这也会导致CPU利用率下降。</p><p>因此为了让快速的IO设备与主机之间的数据交互更有效率，可以采用DMA控制方式，如下图：</p><img src="https://pic.imgdb.cn/item/66a76a2ed9c307b7e9107fe5.png" alt="计算机组成原理（七）——输入输出系统——DMA控制方式.png"><p>DMA控制方式：主存与高速I&#x2F;O设备之间有一条直接数据通路（DMA总线）。CPU向DMA接口发出“读&#x2F;写”命令，并指明主存地址、磁盘地址、读写数据量等参数。CPU给DMA接口说明了这些参数以后，就可以去做其它的事情，接下来DMA控制器会自动控制磁盘与主存的数据读写，直到完成一整块数据读写（如1KB为一整块）之后，DMA接口才向CPU发出一次中断请求。</p><img src="https://pic.imgdb.cn/item/66a76a5bd9c307b7e9109ff7.png" alt="计算机组成原理（七）——输入输出系统——IO控制方式简介3.png"><p>引入DMA方式之后，如果此时某个程序需要进行数据的读写，那么CPU会通过IO指令向DMA控制器指明此次要读或者要写的数据存放在哪，应该转存到什么位置，转存多大的数据。发出这个IO指令之后，CPU就可以去做其它的事情，而IO设备可以慢慢的准备这个数据，IO设备准备好的数据会先存到DMA控制器当中，每准备好一个字的内容，DMA控制器就会发出一个DMA请求。接下来DMA控制器会占用一个存取周期，往主存对应位置写入一个字的数据，如果在存取周期内CPU也想要访问主存，CPU就需要先等待DMA写好这个字的数据之后，CPU才可以继续的访存主存。 因为在三总线结构图里可以看到，主存是被CPU和DMA控制器同时共享的，当DMA控制器对主存进行读或者写操作的时候，CPU就不能对主存进行读和写，因此DMA控制器每次往主存里写数据的时候，都需要占用一个存取周期，不过一个存取周期的时间肯定要比CPU执行中断处理程序的时间更短。</p><p>DMA控制器与主存每次传送1个字，每传送1个字需要一个存取周期，而程序中断方式每传送一个字需要一个中断，一个存取周期的时间要比CPU执行中断处理程序的时间更短，DMA方式只有传送完一整块数据后才向CPU发出中断请求，所有DMA方式要比程序中断方式效率高。</p><p>DMA方式对于个人使用的微型计算机已经够用，但是对于某些商用的中型机或大型机，这些机器可能会接上很多的IO设备，所以即使使用DMA方式，每个IO设备传送完一整块的数据都向CPU发出一个中断请求，CPU也需要花费很多时间来处理中断，因此为了让CPU从繁杂的IO设备管理工作当中解脱出来，人们就发明了一种专门用于管理各种IO设备的硬件部件叫做通道。</p><img src="https://pic.imgdb.cn/item/66a76a92d9c307b7e910c6c5.png" alt="计算机组成原理（七）——输入输出系统——通道控制方式1.png"><p>通道是一种特殊的处理器，但是它的功能没有CPU强大，它可以执行一些特定的通道指令，然后通过通道指令的执行就可以管理各种各样的IO设备，所以引入通道之后，CPU与各种IO接口之间不会再直接的进行交互，这些IO接口的管理工作都是由通道通过IO总线来进行的。</p><p>下面简单说一下通道控制方式的工作原理：</p><img src="https://pic.imgdb.cn/item/66a76ac7d9c307b7e910f34d.png" alt="计算机组成原理（七）——输入输出系统——通道控制方式2.png"><p>通道：可以理解为是“弱鸡版的CPU”，它可以识别并执行一系列通道指令，而通道指令种类、功能通常比较单一。</p><p>CPU、主存和通道可以通过总线进行连接，如果此时CPU想要操作某一个IO设备，那么CPU会通过IO指令给通道指明一个具体的任务，CPU会告诉通道应该处理的IO设备是哪一个，另外当通道管理这个IO设备的时候，应该执行的通道程序被存放在内存的什么位置。接下来通道可以根据CPU的指示，去内存当中一条一条的取出这些通道指令，然后每一条通道指令的执行都会对应着给IO设备发出一个具体的命令。当通道执行完一系列的指令以后，才会向CPU发出一个中断请求，接下来CPU再对中请求进行相应的处理。</p><p>因此，引入通道之后，CPU对IO设备的繁杂的管理工作又可以进一步得到解放。</p><p>对于之前提到的DMA方式来说，只能连续的读入或者写出一整块的数据，每传送完一整块的数据都需要CPU介入。而引入通道之后，对数据的存取位置，到底应该输出到哪些设备或者应该从哪些设备依次的输入，这些控制都可以变得非常灵活，只需要提前编制好通道程序就可以。只有通道完成了这一大堆工作以后，才需要CPU介入一次，这就是通道控制方式。</p><p>接下来看IO系统的组成：</p><img src="https://pic.imgdb.cn/item/66a76b15d9c307b7e9112f3f.png" alt="计算机组成原理（七）——输入输出系统——IO系统基本组成.png"><p>一般来说，I&#x2F;O系统由I&#x2F;O软件和I&#x2F;O硬件两部分构成。IO硬件主要包括的是IO接口和IO设备这两个部分，并且前面也简要说明了主机是如何通过IO接口来控制IO设备的。接下来研究一下IO软件部分。</p><p>IO软件包括驱动程序、用户程序、管理程序、升级补丁等。通常采用I&#x2F;O指令和通道指令实现主机和I&#x2F;O设备的信息交换。</p><p>需要强调的是，IO指令和通道指令是不一样的，IO指令是给CPU执行的，而通道指令是给通道执行的。逻辑上IO指令的结构可以分为操作码、命令码和设备码三个部分，如上图。值得一提的是，命令码这个部分是多变的，甚至命令码部分和具体的IO设备有关，而为了能让发出的IO指令能够正确的指示相应的设备进行正确的动作，因此各个厂商在生产这些设备的时候，都会提供配套的驱动程序。</p><p>而通道程序，即通道指令的序列是提前编制好，然后放在主存里的，所以主存当中即会保存CPU要执行的程序，也会保存通道要执行的通道程序，在含有通道的计算机中，CPU执行I&#x2F;O指令对通道发出命令，然后由通道执行一系列通道指令，代替CPU对l&#x2F;O设备进行管理。</p><p>最后一点需要注意的是，I&#x2F;O指令与普通指令格式略有不同，其中的操作码指明了CPU要对lO接口做什么，而命令码指明了IO接口要对设备做什么，这一点需要注意。</p><p>下面对本部分进行小结：</p><img src="https://pic.imgdb.cn/item/66a76b4dd9c307b7e9115533.png" alt="计算机组成原理（七）——输入输出系统——输入输出系统和IO控制方式小结.png"><h2 id="2-外部设备"><a href="#2-外部设备" class="headerlink" title="2. 外部设备"></a>2. 外部设备</h2><img src="https://pic.imgdb.cn/item/66a77b66d9c307b7e91e84c5.png" alt="计算机组成原理（七）——输入输出系统——外部设备知识总览.png"><p>外部设备可以分为输入设备、输出设备和外存储器设备这三大类，本节学习输入和输出设备。本节重要考点是VRAM的计算，即显存的计算。</p><img src="https://pic.imgdb.cn/item/66a77b98d9c307b7e91eabb9.png" alt="计算机组成原理（七）——输入输出系统——外部设备.png"><p>外部设备分为输入设备、输出设备和外存设备，其中最为熟悉的应该是输入设备，如下图：</p><img src="https://pic.imgdb.cn/item/66a77bd1d9c307b7e91ed768.png" alt="计算机组成原理（七）——输入输出系统——输入设备.png"><p>键盘是最常用的输入设备，通过它可发出命令或输入数据。每个键相当于一个开关，当按下键时，电信号连通；当松开键时，弹簧把键弹起，电信号断开。</p><p>键盘输入信息可分为3个步骤：①查出按下的是哪个键；②将该键翻译成能被主机接收的编码，如ASCIl码；③将编码传送给主机，这一部分的传送需要使用到上一节提到过的IO接口。</p><p>接下来看鼠标，鼠标是常用的定位输入设备，它把用户的操作与计算机屏幕上的位置信息相联系。常用的鼠标有机械式和光电式两种。</p><p>鼠标的工作原理：当鼠标在平面上移动时，其底部传感器把运动的方向和距离检测出来，从而控制光标做相应运动。</p><p>接下来再看输出设备：</p><img src="https://pic.imgdb.cn/item/66a77c21d9c307b7e91f143d.png" alt="计算机组成原理（七）——输入输出系统——显示器1.png"><p>我们每天都在使用的输出设备就是显示器，根据显示器使用的显示器件的显示原理的不一样，可以把显示器分为阴极射线管显示器，液晶显示器，还有LED显示器。</p><p>如果根据显示器要显示的信息内容不同，把显示器分为字符型显示器、图形显示器和图像显示器。</p><p>接下来重点关注显示器的某一些参数以及性能指标， 大部分的传参数及性能指标上图已经给出，这里重点看一下显示存储器。</p><p>显示存储器就是显存，英文缩写是VRAM，显存当中存放的是接下来要在显示器上面播放的这一帧的图像的信息，是用来刷新显示器图像的，所以也称刷新存储器。为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其存储容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大。</p><p>既然显存里要存放的是一帧图像的信息，那么就可以算出显存至少应该有多大，即至少应该能够存放一帧图像的信息。所以可以得到理论上显存可以达到的最小容量：VRAM容量&#x3D;分辨率×灰度级位数。如果比这个容量还小，那么显示器就没法工作。</p><p>上面算出的是一帧图像的大小，但是显示器是有刷新频率在的，比如60Hz刷新频率的显示器意味着他一秒钟会切换60帧的图像信息，这也意味着在1秒钟内，需要往显存里写入60帧的数据，因此对VRAM的写入速度就会有最低要求，这个最低要求就是VRAM带宽&#x3D;分辨率×灰度级位数×帧频。</p><p>下图是某台电脑显示器参数：</p><img src="https://pic.imgdb.cn/item/66a77c72d9c307b7e91f4d57.png" alt="计算机组成原理（七）——输入输出系统——显示器2.png"><p>从上图可以看到这个显示器的相关参数，VRAM是1536MB；显示器类型是LCD；屏幕分辨率是1440×900；帧缓冲深度是24位彩色，也就是说每一个像素点的信息需要用24个比特来表示。</p><p>所以对上图所示例子的电脑的显示器来说，一帧的大小就是分辨率乘每个像素点的大小，即1440*900*3 B≈3.7MB (一帧的大小即为显存的理论最小值)。如果显示器刷新率&#x3D;60Hz，则显存带宽至少要3.7*60 &#x3D; 222MB&#x2F;S。</p><p>现在产生一个问题，理论上显存最小只需要3.7MB就可以，但是上图的VRAM有1536MB这么大，这是为什么？这是因为，现代计算机中，显存除了作为当前显示帧的缓存，还会用于保存即将渲染的图像数据。</p><p>另一方面，上图电脑是集成显卡，它的显存处写了动态最大值，对于没有独立显卡的计算机来说，通常显存并不是一块单独的专门的存储芯片，而是会从内存里划出一小片控制作为显存。而如果是独立显卡的电脑，那么一般来说，独立显卡的内部也会有一个存储芯片，专门作为显存来使用。</p><p>接下来简单认识一下不同类型的显示器：</p><img src="https://pic.imgdb.cn/item/66a77cc0d9c307b7e91f8418.png" alt="计算机组成原理（七）——输入输出系统——显示器3.png"><p>首先看阴极射线管显示器，如上图，以前的老式电视机采用的就是阴极射线管显示器，这个电视机这么厚重的原因就是，它里面会有一个阴极射线管，如上图右，在电视剧尾部处会有一个电子发射器，电子发射时，两侧会有一系列的电路来控制电子的偏移，当电子打到荧光屏上，就会在显示屏上显示出对应的一些颜色图像。</p><p>下面看液晶显示和LED显示器：</p><img src="https://pic.imgdb.cn/item/66a77d13d9c307b7e91fbc89.png" alt="计算机组成原理（七）——输入输出系统——显示器4.png"><p>LCD和LED显示器表面上看非常类似，但是他们的发光原理不一样，液晶显示器利用液晶的电光效应，由图像信号电压直接控制薄膜晶。LED显示器通过控制半导体发光二极管进行显示，用来显示文字、图形、图像等各种信息。</p><p>LCD和LED这两种发光方式有各自的优缺点，与LCD相比，LED显示器在亮度、功耗、可视角度和刷新速率等方面都更具优势。</p><p>这部分做个了解即可，接下来重点关注一下，阴极射线管显示器在显示不同的信息的时候，显示的原理：</p><img src="https://pic.imgdb.cn/item/66a77d80d9c307b7e92006ad.png" alt="计算机组成原理（七）——输入输出系统——阴极射线管显示器.png"><p>首先，当显示器只用于显示字符信息的时候，这个显示器就是一种字符显示器，显示字符的方法以点阵为基础。点阵是指由m×n个点组成的阵列。点阵的多少取决于显示字符的质量和字符窗口的大小。字符窗口是指每个字符在屏幕上所占的点数，它包括字符显示点阵和字符间隔。</p><p>这里补充一个字形码的概念：如上图右下，中文汉字“你”可以用如图的点阵信息来表示，每一个像素点的亮或者灭可以用二进制的0和1来表示，这样一堆的0和1就描述了中文字符“你”该如何显示，把描述中文字符显示形状的二进制码称为字形码，也可以叫字母码。</p><p>接下来看一下阴极射线管显示器显示字符的原理：</p><img src="https://pic.imgdb.cn/item/66a9fcb2d9c307b7e914f5da.png" alt="计算机组成原理（七）——输入输出系统——阴极射线管显示器0.png"><p>如上图下，通过接口电路的处理，可以把键盘输入的信息或者主机想要显示的一些字符信息，先把这些字符的ASCLL码写入到显存里面。接下来在阴极射线管控制器的控制下，显存里的这些字符会一个一个的用电信号的方式发送给字符发生器，在字符发生器内部，除了控制电路之外，也会有一个ROM用来存放每一个ASCLL码所对应的字形码。接下来根据字符的ASCLL码和CRT的控制信息选中某一个字符的字形码，所存的ROM存储单元。接下来把字符信息送到输出缓冲寄存器里，然后再通过另一个电路的控制把这个字形的信息通过电子往外射的方式，把其给射出去，然后在屏幕上打出字符的样子。</p><p>接下来再看图形显示器：</p><img src="https://pic.imgdb.cn/item/66a77e1fd9c307b7e9207389.png" alt="计算机组成原理（七）——输入输出系统——阴极射线管显示器2.png"><p>图形显示器了解一下即可，这里要注意一点，图形显示器和图像显示器是不同的概念，图形显示器一般来说就是用于显示一系列的矢量图形。图像显示器就是电脑手机的显示器，可以显示丰富多彩的图像信息。</p><p>另外，对于图形显示器来说，按扫描方式不同可分为光栅扫描显示器和随机扫描显示器。</p><p>接下来看另一个大家比较熟悉的输出设备——打印机：</p><img src="https://pic.imgdb.cn/item/66a77e65d9c307b7e920a25a.png" alt="计算机组成原理（七）——输入输出系统——打印机1.png"><p>打印机按印字原理不同，可以分为击打式打印机和非击打式打印机。值得注意的是，击打式打印机常用于机打发票或银行回执单等，因为击打式打印机的防伪性很好。所以即使击打式打印机的噪声大，速度慢，但其依然没有被淘汰。</p><p>打印机按工作方式不同可分为串行打印机和行式打印机。</p><p>接下来看打印机按工作方式分类：</p><img src="https://pic.imgdb.cn/item/66a77e8ed9c307b7e920be89.png" alt="计算机组成原理（七）——输入输出系统——打印机2.png"><p>上图已经详细给出按工作方式分类情况，这里不再过的阐述。</p><p>下面对本节内容进行一个小结：</p><img src="https://pic.imgdb.cn/item/66a77ec7d9c307b7e920e473.png" alt="计算机组成原理（七）——输入输出系统——外部设备小结.png"><h2 id="3-IO接口"><a href="#3-IO接口" class="headerlink" title="3. IO接口"></a>3. IO接口</h2><p>通过之前的了解，已经知道了IO接口有什么作用，IO接口在系统当中处于什么位置，本部分会把之前学习的知识进一步细化，首先会分析IO接口的作用，然后会补充IO接口的结构以及详细的工作原理，再然后会介绍IO端口相关概念，最后会简要的了解IO接口的分类。</p><img src="https://pic.imgdb.cn/item/66a78063d9c307b7e921eea8.png" alt="计算机组成原理（七）——输入输出系统——主机与IO设备的交互.png"><p>在前面说过，I&#x2F;o接口，又称I&#x2F;O控制器(I&#x2F;O Controller)、设备控制器，负责协调主机与外部设备之间的数据传输。</p><img src="https://pic.imgdb.cn/item/66a7808ed9c307b7e92211d9.png" alt="计算机组成原理（七）——输入输出系统——IO接口的作用.png"><p>CPU和外设之间的速度差距是很大的，所以在IO接口里需要有一个数据寄存器来充当一个缓冲的作用。这是IO接口的第一个功能。</p><p>另外，IO接口还需要给CPU反馈设备的状态，所以IO接口需要监测连接到它上面的各种外设，一旦外设状态出现变化，就需要修改状态寄存器相关的内容。接下来CPU就可以通过查状态寄存器来获取各种外设的工作情况。这是IO接口的第二个功能，就是要对各种外设的错误信息和工作状态信息进行一个监测。</p><p>接下来，IO接口收到CPU发来的各种命令以后，需要给相应的IO设备发出对应的控制信号，另外为了让各种外设能够和主机之间相互协调配合着工作，所以IO接口也需要通过控制总线来接收CPU发来的时钟信号，根据时钟信号决定每一步应该做什么。因此IO接口的第三个功能就是控制和定时。</p><p>很多设备输入和输出数据时，都是串行的输出的，但是CPU通过数据总线取数据时，很多系统是采用并行的方式来进行数据的传输，因此IO接口就要实现数据格式的转化。这是IO接口的第四个功能。</p><p>上面所说的所有功能，最终都是为了实现主机和设备之间的通信，主机通过IO接口和IO设备通信，这就是IO接口在系统当中的作用。</p><p>接下来把IO接口的内部进一步细化：</p><img src="https://pic.imgdb.cn/item/66a780dad9c307b7e9224a1b.png" alt="计算机组成原理（七）——输入输出系统——IO接口.png"><p>如上图，是IO接口内部进一步细化的示意图，可以看到，之前画的数据缓冲寄存器、状态寄存器、控制寄存器都存在里面。</p><p>首先看一下上图IO接口左面，主机侧的部位，这里就是IO接口用系统总线和CPU、主存进行连接的地方。这里会有一个小问题，有的教材会说主机侧数据的传输方式只能是并行传输，这句话既正确也不正确，这是因为在2000年之前，很多系统总线都是采用并行传输的方式来设计，所以在很多编写比较早的教材里会说主机侧只能采用并行传输。但是在2000年之后，总线技术很多都从并行向串行转换，所以现在的系统当中，主机侧的数据传输也有可能是串行传输的。</p><p>接下来看另一侧，设备侧。这一侧就是通过一些插座和外部的设备进行连接，和外部设备的数据传输方式，既有可能是串行，也有可能是并行。</p><p>另外，从上图可以看到，IO接口的右边写了很多的外设界面控制逻辑，也就是说这样的一个IO接口，可以同时连接多个外部设备。</p><p>下面看一个实际的USB控制器的芯片图，它的中间芯片就是IO接口芯片：</p><img src="https://pic.imgdb.cn/item/66a78115d9c307b7e92276f4.png" alt="计算机组成原理（七）——输入输出系统——IO接口1.png"><p>接下来看一下IO接口的工作原理：</p><img src="https://pic.imgdb.cn/item/66a7814cd9c307b7e922a68a.png" alt="计算机组成原理（七）——输入输出系统——IO接口工作原理.png"><p>首先，要明确，CPU是连接在左侧，外部设备是连接在右侧。</p><p>假设CPU要操控打印机进行打印任务，那首先，CPU需要把打印机所对应的命令（一串二进制码）给输入到控制寄存器里，输入一个字的信息。由于这个字是用来发出具体的命令，因此这个字称为命令字。</p><p>发出了命令以后，在IO控制逻辑的指挥下，就会根据CPU发过来的命令字去给对应的设备发出一系列的控制信号，用这样的方式来启动打印机。</p><p>接下来CPU需要从状态寄存器里读取状态字，用这种方式来确定设备此时是否已经就绪。</p><p>打印机就绪以后，CPU需要通过数据总线往数据缓冲寄存器里写入想要打印的数据，然后再在控制逻辑电路操控之下，把这些数据逐个输入到打印机当中。打印机完成工作以后，就可以给IO接口进行一个状态的反馈，当IO接口检测到设备的状态已完成之后，就会修改状态寄存器里面相应的比特位，这样的话，CPU就可以通过状态寄存器来得知这个IO操作的完成。</p><p>之前说过CPU可以用不断轮询检查的方法来检查状态寄存器，也就是轮询检查IO状态的完成。还有一种比较优秀的方法，也可以通过控制线给CPU发送一个中断请求信号，当CPU检测到中断信号的时候，再来对中断进行处理。</p><p>接下来解释一个问题，就是上图中为什么把状态寄存器和控制寄存器写在一起。通过前面的描述可以看到，当CPU要控制一个设备进行输入或者输出操作的时候，一定是CPU先向设备发送一个命令，因此可以先把命令的信息放到控制寄存器里，当IO控制逻辑取出这一条命令以后，控制寄存器就空闲了，接下来没有必要让命令字一直存放在控制寄存器里。另一个方面，IO控制逻辑启动了设备的工作之后，设备需要随时给CPU返回一些工作的状态，因此同样是刚才的寄存器，就可以把其重复利用，可以把设备的状态信息，工作的完成情况这些存放在同一个寄存器里。<strong>所以，由于控制寄存器、状态寄存器在使用时间上是错开的，因此有的I&#x2F;O接口中可将二者合二为一。</strong></p><p><strong>在IO接口内部，可由CPU访问的寄存器，通常把它们称为IO端口。</strong>比如数据寄存器就会称为数据端口，状态寄存器就称为状态端口等。由于IO接口内部会有多个寄存器，因此CPU在对这些端口的数据进行读和写的时候，就需要指明它要读写的是哪一个端口，所以这就是地址线的作用。CPU会通过地址线，来指明要往哪个寄存器里读数据或者写数据。</p><p>另外，IO总线包含地址线、数据线和控制线，地址线是用来指明CPU要读写的是哪一个端口。接下来还需要通过控制总线来发出读写的命令，用于指明对这个IO端口到底是要读还是写。除此之外，之前还说过，控制总线还会用于给CPU返回中断请求信号。而对于数据线来说，CPU要输出的数据或从外设输入的主机的数据，都会通过数据线进行传送。除了传递输入输出的数据外，数据总线也会用于传输状态字和命令字(控制字)相关的信息。</p><p>这里要补充一点，数据线还会用于传输中断类型号，比如设备完成工作会发送一个中断请求，设备故障也会发送一个中断请求，但这两种中断请求的中断信号类型肯定是不一样的，所以为了让CPU知道当前的中断请求到底怎么处理，所以也需要通过数据总线再结合状态寄存器里的内容，给CPU反馈一个具体的中断类型号，让CPU知道接下来应该怎么处理。</p><p>接下来再说一个容易产生疑惑的地方，IO接口可以接多个设备，那么CPU要操作的是哪一个设备呢，对于设备的选择信息是怎么传递的呢。可以有两种解决方案。</p><p>第一种方案，在有的系统中，地址线除了指明CPU要读写的寄存器之外，有可能被用于指明具体的设备编号，但是设备编号和寄存器的编号需要分开进行两次传输。还有一些系统会让连接的每一个外设都有一个与之对应的一组数据寄存器、状态寄存器和控制寄存器。所以如果有两组外设，就需要设置两组IO端口，两组IO端口就会有四个相互独立的寄存器，CPU对不同的寄存器进行读和写就相当于对不同的设备进行操作。</p><p>接下来对接口和端口进行一个分析：</p><img src="https://pic.imgdb.cn/item/66a78188d9c307b7e922d307.png" alt="计算机组成原理（七）——输入输出系统——接口与端口.png"><p>IO端口是IO接口内部的寄存器，由于接口内部会有多个端口，那么为了标明CPU要访问的是哪一个寄存器，因此就需要给这些端口进行一个编址。</p><p>CPU对于不同端口的操作是不一样的，对于数据端口既有可能读也有可能写，对于控制端口只有可能写，而对于状态端口只有可能读。</p><p>接下来看一下IO端口的编址：</p><img src="https://pic.imgdb.cn/item/66a781d2d9c307b7e9230d6a.png" alt="计算机组成原理（七）——输入输出系统——统一编址和独立编址.png"><p>IO端口的编址有两种方式，一种是统一编址，另一种是独立编址。</p><p>统一编址就是IO端口的地址和内存的地址是一整套的东西，如上图左，比如说内存占据0~N-1这些地址，然后从N这个地址往后，就是被IO端口给占用了，因此地址译码器可以根据地址的信号来确定当前要访问的到底是内存的某一个单元，还是要访问IO控制器里面的某一个IO端口。对于这种方式，任何可以访存的指令都可以用于访问IO端口，比如LOAD指令。很多RISC指令机器中，都会采用这种统一编址的方式。</p><p>独立编址就是IO端口的地址和内存的地址是相互独立的，如上图右，独立编址由于地址空间会出现重复的，所以为了进行区分，需要设置一些专门的IO指令访存IO端口。</p><p>接下来对这两种方式的优缺点进行一个对比：</p><img src="https://pic.imgdb.cn/item/66a783bbd9c307b7e9247f47.png" alt="计算机组成原理（七）——输入输出系统——IO端口及其编址.png"><p>上图对于两者的对比很全面，这里就不再阐述，如有不明白之处，可以跳转链接（20分07秒~25分20秒）：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=82&vd_source=7fb4b255ed876969a742738d7b84f461">7.2_IO接口</a>。</p><p>接下来看IO接口的类型：</p><img src="https://pic.imgdb.cn/item/66a783e3d9c307b7e9249ad8.png" alt="计算机组成原理（七）——输入输出系统——IO接口的类型.png"><p>这里很简单，但需要再次提醒一点，很多教材都说数据在主机一侧总是并行传送的这句话是有点过时的，在现在并不完全正确。如果有所遗忘，建议回顾一下本节IO接口内部结构细化的地方。</p><p>下面对本节内容进行一个小结：</p><img src="https://pic.imgdb.cn/item/66a7840dd9c307b7e924b854.png" alt="计算机组成原理（七）——输入输出系统——IO接口小结.png"><h2 id="4-程序查询方式"><a href="#4-程序查询方式" class="headerlink" title="4. 程序查询方式"></a>4. 程序查询方式</h2><img src="https://pic.imgdb.cn/item/66a78474d9c307b7e92524d8.png" alt="计算机组成原理（七）——输入输出系统——本章总览.png"><p>从本节开始，进入IO控制方式的研究，在本节先重点研究程序查询方式。</p><img src="https://pic.imgdb.cn/item/66a784a5d9c307b7e9254c2e.png" alt="计算机组成原理（七）——输入输出系统——IO方式的简介.png"><p>如上图，是在之前学习过程中所接触到的一个示意图。对于程序查询方式来说，CPU启动一个IO操作之后，比如启动读操作，那么当IO设备在准备数据的时候，CPU会不断的轮询检查IO接口当中的状态是否已经完成，当发现IO设备的数据输入已经完成之后，CPU才会去IO接口当中取走数据。在IO设备准备数据的过程当中，CPU是不可以干其他的事情的，它需要一直不断的检查这个IO接口的状态。</p><p>接下来把刚才说的两个过程给细化一下，CPU查询IO设备的状态，当IO设备的状态变成已完成的状态之后，CPU就可以进行数据的传送，也就是从IO接口的数据缓冲寄存器里取走数据，取到CPU内部的某一个寄存器当中，用这样的方式传输一个字的内容，然后CPU才可以继续往后执行。</p><p>为了让模糊的描述变得更具体，接下来结合x86架构当中的两条IO指令来解释一下CPU是如何通过这样的IO指令，完成字符的打印的。</p><img src="https://pic.imgdb.cn/item/66a784f2d9c307b7e92585ad.png" alt="计算机组成原理（七）——输入输出系统——程序查询方式.png"><p>假设CPU此时要打印3个字符，那么为了控制IO设备，会用到这样的两条x86指令集里的IO指令，如上图左上，一条叫IN，就是把lO端口Rs的数据输入到CPU寄存器Rd。一条叫OUT，把CPU寄存器Rs的数据输出到IO端口Rd。</p><p>现在假设数据缓冲寄存器地址是R<sub>n</sub>，状态&#x2F;控制寄存器的地址是R<sub>n+1</sub>，然后CPU内部会有两个通用寄存器分别是R0和R1。现在来看一下如何打印输出3个字符。</p><p>首先肯定要确定，要打印输出的3个字符存在什么地方，比如说存在主存里，那么可以先把这3个字符弄到CPU的寄存器里，比如说寄存器0放a这个字符，寄存器1放b这个字符，然后第三个寄存器放c这个字符。总之，要打印输出的数据，有可能本身就存在寄存器当中，也有可能是存放在主存里的，如果是存放在主存里，只需要进行一次读主存的操作，就可以先从主存里把这一次要打印输出的字符读到CPU的某一个寄存器当中。</p><p>假设此时先要打印的是字符a，那首先CPU要向打印机发出打印的一个命令字，即用OUT输出这个IO指令。比如说经过打印机的驱动程序的处理，已经把启动打印的命令字放到寄存器R1里，那么接下来应该把R1里的命令字输出到R<sub>n+1</sub>这个端口处，所以只需要用一个输出的指令就可以完成操作。因为上一小节说过，所有的IO端口都有一个地址，CPU通过地址线指明此时要输出的IO端口地址是R<sub>n+1</sub>，然后再通过控制线，指明此次是要对这个IO端口进行写操作，然后要写的命令字数据只需要通过数据线传过来就可以。所以通过OUT这个指令，就可以对打印机发出打印的命令。</p><p>但是现在，打印机的打印命令只是被放到了IO端口里面，接下IO控制逻辑电路需要根据CPU发过来的命令信号，通过控制线给打印机发送相应的控制信号，打印机收到这个命令之后，就可以开始启动。</p><p>当打印机启动的工作完成之后，会通过状态线，给IO接口进行一个反馈，IO接口发现打印机启动操作已经完成，那么同样是IO逻辑电路，会把打印机的就绪的状态信息存到R<sub>n+1</sub>这个状态寄存器里，所以之前这个寄存器本来是用来存放命令字的，但是由于命令字已经发出了，所以这个寄存器里面的命令字就不需要再保存了。</p><p>现在这个打印机的就绪状态，已经被放入到状态寄存器里了，对于CPU来说，如果它采用的是程序查询方式，那就意味着当这个CPU通过刚才的OUT指令发出打印的请求之后，CPU会一直轮询的，通过数据线来检查状态寄存器是否已经变成了就绪状态，那这个轮询检查的操作是如何实现的呢，就是用IN指令来进行的。</p><p>CPU可以不断的输入IN指令，比如说通过IN指令把R<sub>n+1</sub>这个寄存器的值给输入到CPU的R0，然后CPU再来测试取得的状态信息是否已经就绪。如果说打印机启动速度比较慢，那么CPU可能会取好多次状态，每一次都发现还没有就绪，这也是程序轮询方式的弊端。</p><p>接下来再次看到打印机的就绪状态，已经被放入到状态寄存器里了这个地方，同样的CPU这次的轮询检查，通过IN指令就可以发现打印机此时是处于就绪状态，已经准备好可以输出一个字符，因此CPU接下来就可以给打印机输出第一个字符的信息。</p><p>刚刚假设打印输出a、b、c这样的三个字符，那么首先CPU会通过地址线指明此次要操作的这个端口是R<sub>n</sub>这个端口，然后控制线指明这次是要往这个IO端口里面写入数据，同时通过数据线把a这个字符的信息打到数据线上，那么这三个信号就会导致a这个字符的数据被写入到数据缓冲寄存器当中。现在第一个字符已经到位，接下来会由IO控制逻辑把这个字符的信息通过数据线输出给打印机，同时也会发出相应的控制信号。当打印机在打印字符的时候，会处于忙碌状态，直到字符的打印工作完成之后，它又会通过状态线给IO接口反馈打印已完成的信号。IO接口会把状态寄存器再次改为就绪状态。CPU检测到就绪状态以后，就会往数据缓冲寄存器里冲入第二个字符的信息。接下来同理，最后abc这三个字符都已经输出完成之后，打印机最后一次给IO接口进行反馈，同样的，在IO控制逻辑电路的帮助下，会把状态再次改为就绪态。而对于CPU来说，当它第三次检测到这个打印机的打印动作完成以后，就意味着它要打印输出的三个字符就已经完成。当打印工作全部完成以后，CPU就可以给打印机发出一个停机的指令。接下来在IO控制逻辑的帮助下，停机的信号同样会被传给打印机，打印机的工作就此停止。这就是用程序查询方式打印三个字符的例子。</p><p>最后说一个注意点，上图的IO接口的内部构造并不是通用的，它只是在逻辑上描述了至少应该包含这样的一些部分，但实际当中的IO接口有可能还会包含更多的，更复杂的一些寄存器。</p><p>下面用流程图的方式把程序查询方式的过程给总结一遍：</p><img src="https://pic.imgdb.cn/item/66a78520d9c307b7e925a9ae.png" alt="计算机组成原理（七）——输入输出系统——程序查询方式流程图.png"><p>从流程图中可以看到，程序查询方式有踏步的现象，并且CPU与I&#x2F;O是串行工作的，IO设备在干工作的时候，CPU一直在检查。IO设备工作完成之后，再次就绪以后，CPU才可以传下次数据，资源利用率很低。</p><p>程序查询方式是早期的计算机里采用的一种IO控制方式，它的IO接口设计起来比较简单。但缺点也很明显，CPU需要花费大量时间来等待。</p><p>下面以一道例题的形式，来感受一下这部分在大题里可能出现的考察形式：</p><img src="https://pic.imgdb.cn/item/66a7855ed9c307b7e925d6f3.png" alt="计算机组成原理（七）——输入输出系统——程序查询方式例题.png"><p>题目讲解跳转视频(15分钟~23分钟)：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=83&vd_source=7fb4b255ed876969a742738d7b84f461">7.3_1_程序查询方式</a>。</p><p>下面对本节内容进行一个小结：</p><img src="https://pic.imgdb.cn/item/66a78581d9c307b7e925f32f.png" alt="计算机组成原理（七）——输入输出系统——程序查询方式小结.png"><h2 id="5-中断的作用和原理"><a href="#5-中断的作用和原理" class="headerlink" title="5. 中断的作用和原理"></a>5. 中断的作用和原理</h2><img src="https://pic.imgdb.cn/item/66a785bad9c307b7e9262109.png" alt="计算机组成原理（七）——输入输出系统——中断的作用和原理知识总览.png"><p> 上图为本节知识总览，下面首先来了解一下什么是中断：</p><img src="https://pic.imgdb.cn/item/66a785e8d9c307b7e926451a.png" alt="计算机组成原理（七）——输入输出系统——中断的基本概念.png"><p>程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。</p><p>看上图左边的一列，可以理解为主存的地址，在主存里会保存要执行的一系列指令。经过之前的学习可以知道，CPU执行指令序列的方式，就是会用一个PC程序计数器，指向当前要执行的那条指令的一个存放地址，然后取出这条指令之后，会让PC的值自动加1，指向下一条应该执行的指令。因此正常情况下，CPU对指令的执行一定是顺序执行的，除非遇到跳转指令或者函数调用之类的情况，否则指令的执行流一定是一条一条往下执行的。</p><p>但是有一个问题，那就是即使遇到跳转指令或函数调用一类的指令，接下来CPU执行的指令序列依然属于同一个进程，这也就意味着，如果一个进程的指令序列开始上CPU运行了，那么这个进程就会一直霸占着CPU。但是结合平时的使用经验可以发现，电脑里会同时运行很多的进程，并且除了当前正在运行的程序之外，CPU还会处理一些外部设备发来的信号，因此CPU如果只能按照顺序的方式来执行某一个特定程序的指令序列，那么CPU就永远无法响应用户给计算机发出的一系列请求。所以为了解决这个问题，就引入了中断系统。正常情况下，CPU依然是顺序的执行这些指令序列，但是如果计算机实现了中断系统，那么就意味着CPU每执行完一条指令之后，在这个指令周期的末尾都会例行的检查此时是否有某一种中断请求信号需要处理。如果此时有中断请求信号需要处理，那么CPU会暂时改变自己的指令执行流，会转而执行另一段中断服务程序，当执行完中断服务程序以后，才会回到刚才的程序继续往后执行。</p><p>中断请求的类型是多种多样的，比如说键盘敲击产生的中断请求和打印机输出完成这个中断请求，这两个中断请求的处理一定是不一样的，所以对于不同的中断请求，需要用不同的中断服务程序进行处理，因此CPU如何响应一个中断信号呢？</p><p>首先，像键盘、鼠标、打印机等等这一类的IO设备或者也有可能是某些时钟部件，会向CPU发送一个中断请求信号，把这种可以产生中断请求信号的部件称为中断源。</p><p>CPU在每个指令周期的末尾都会例行的检查是否有中断请求信号需要处理，如果检测到中断请求信号，那么就需要对这个信号进行一个响应。首先，CPU会判断自己当前的状态是否可以响应中断，有的时候CPU会不想理这些中断请求信号，比如说执行了关中断指令之后，CPU就会暂时不理睬这些中断信号，所以首先需要判断CPU当前的状态是否处于关中断的状态，如果处于关中断状态，那么就暂时不会响应任何中断信号；如果此时需要响应中断信号，那么就需要进行中断判优，中断判优做的事情就是如果同时有好几个中断信号都需要响应，那么会判断各个中断源的优先级是怎么样的，然后CPU会优先响应优先级更高的中断源发来的中断信号，经过中断判优之后，就可以确定接下来要响应的是哪一个中断请求信号。</p><p>刚刚说过，不同的中断请求信号对应的中断服务程序是不一样的，因此接下来要对这个中段进行处理的时候，首先需要通过中断隐指令的帮助，把CPU的指令执行流转移到正确的中断服务程序，然后接下来CPU就可以执行这一个中断服务程序。</p><p>现在思考一个问题，刚刚提到关中断的指令，如果CPU执行了关中断的指令，就意味着接下来CPU不会响应任何一个中断请求信号，那么CPU是如何判断自己当前是否处于关中断的状态呢？</p><img src="https://pic.imgdb.cn/item/66a78637d9c307b7e9268431.png" alt="计算机组成原理（七）——输入输出系统——中断请求的分类.png"><p>对于CPU如何判断自己当前是否处于关中断的状态这个问题，其方法很简单，关中断这个状态信息会被记录在PSW这个程序状态字寄存器里。上图下给出了8086这个芯片的PSW位的每一个位的名字，其中IF代表的是关中断的标志位。当IF&#x3D;1时，表示开中断状态；当IF&#x3D;0时，表示关中断状态。</p><p>当CPU执行关中断指令之后，任何的中断请求信号暂时都不会被响应，但是也有一些很特别的，优先级很高的这种中断信号必须被响应，这种中断信号就是非屏蔽中断，比如关机掉电，即使CPU处于关中断状态，但关机的中断信号也会被响应。与非屏蔽中断对应的就是可屏蔽中断，也就是在关中断状态下不会被响应的中断信号，而外部设备发来的中断请求信号基本上都是可屏蔽中断，由于本章探讨的就是IO外部设备，所以接下来如果没有特别说明，当提到中断的时候指的就是可屏蔽中断。</p><p>接下来思考一个问题，当CPU处于开中断状态，当它检测到一个中断请求信号的时候，应该如何判断这个中断请求信号到底是哪一个IO设备发过来的呢？为了解决这个问题，可以设置一个中断请求的标记寄存器，如下图：</p><img src="https://pic.imgdb.cn/item/66a7867cd9c307b7e926b2eb.png" alt="计算机组成原理（七）——输入输出系统——中断请求的标记.png"><p>可以看到，中断请求的标记寄存器是由一个一个触发器来组成的，当某一个IO设备所对应的触发器的这一个比特为1时，就意味着此时有来自于这个IO设备的中断请求需要被处理，所以当CPU检测到中断请求信号的时候，只需要看一下中断请求的标记寄存器里哪些比特是1，就可以知道接下来要处理的中断是哪个。</p><p>之前说过，对于来自CPU外部的中断，也就是来自于各种IO设备的这些中断，CPU会统一的在每一条指令执行阶段结束之前，去检查此时有没有中断请求信号以及判断这个中断请求信号是哪些部件发过来的，只有CPU检测到中断请求信号并未此时处于开中断状态，才会去响应这个中断信号。之前在第五章说过的指令执行的四个阶段中(取指、间址、执行、中断)，中断阶段就是用来检查中断请求标志寄存器，判断中断信号的。</p><p>现在问题又出现了，有的时候CPU可能会同时收到多个部件发过来的中断请求信号，那么到底应该先响应哪一个部件的中断请求呢？这就是中断判优要解决的问题。</p><img src="https://pic.imgdb.cn/item/66a786b3d9c307b7e926d867.png" alt="计算机组成原理（七）——输入输出系统——中断判优的实现.png"><p>中断判优可以通过硬件实现也可以通过软件实现。</p><p>首先看一下如何用硬件实现中断的判优，刚才说过，中断请求标志寄存器里记录了哪些中断请求信号需要被处理，那么可以用如上图左下的电路来实现硬件排队器。最左边的中断源所对应的信号是优先级最高的一个信号，然后越往右优先级越低，这也就意味着当多个中断请求信号同时到来的时候，CPU会优先响应最左边的最高优先级的中断源发来的中断请求信号。</p><p>这里说下在硬件实现中断的判优中，CPU会优先响应最左边的最高优先级的中断源发来的中断请求信号原理，看上图左下，假设现在所有中断源都同时发来中断请求信号，对于最左边这个电路，输入一个1，经过非门处理变为0，然后这个0再经过一次非门处理变为1输出，所以第一个中断源所对应的输出信号就是1。另一方面，第一个经过非门处理变为0的信号还会作为第二个与门的一个输入，然后与优先级稍低的第二个设备发来的请求信号相与，得到结果1，这个1再作为最后非门的输入，最后的输出就是0。因此如果优先级更高的中断源也发来一个中断请求信号，那么只有第一个中断源所对应的输出信号会是1，那么对于优先级更低的三和四同理，会受高优先级中断源信号影响，输出0。</p><p>接下来说一下软件判优的方法，软件的方法就是按照优先级递减的顺序，检查中断请求标志寄存器里的二进制比特位，直到发现第一个二进制的1，就可以决定接下来优先处理这个中断信号，这就是程序查询的方式。</p><p>显然用软件的方式进行判断的速度要比用硬件慢的多，所以现在的计算机当中通常都是用硬件排队器来实现中断的判优的。</p><p>接下来看一下如何设计多个中断源的优先级排序：</p><img src="https://pic.imgdb.cn/item/66a786f2d9c307b7e927025d.png" alt="计算机组成原理（七）——输入输出系统——中断判优的优先级设置.png"><p>上图是中断优先级的设计原则，这部分记忆就好，没有需要阐释的地方。</p><p>下面来看一下中断处理过程：</p><img src="https://pic.imgdb.cn/item/66a78728d9c307b7e9272868.png" alt="计算机组成原理（七）——输入输出系统——中断处理过程.png"><p>根据前面的研究，已经解决了多个中断信号到来时，先处理哪一个中断信号的问题，接下来根据选中的中断请求信号，需要找到与这个中断请求信号相对应的中断服务程序，也就是要找到中断服务程序的入口地址，所以接下来看一下这部分如何实现。</p><p>首先，CPU执行指令的时候，会让PC的值不断的加一，所以当CPU执行了K这条指令之后，PC继续加1指向K+1的位置。现在K这条指令执行结束之后，CPU发现了一个中断请求信号，接下来CPU就需要执行这个中断请求信号对应的中断服务程序，这就意味着，需要把PC的值指向这个中断服务程序的第一条指令。原本下一条应该执行的指令是K+1，但是现在这个中断事件导致程序执行流发生了改变，所以当处理完中断之后，CPU应该回到以前的位置，即让PC的值恢复到K+1处。因此，在执行中断服务程序之前，在PC还未改变的时候，需要把PC的值先给保留下来，只有把PC的值保存下来，那么在中断结束之后，才可以恢复PC以前的值，这个工作可以交给所谓的中断隐指令来执行。</p><p>中断隐指令并不是一条具体的指令，而是CPU检测到中断信号之后，会自动来执行的一系列动作。下面来看一下中断隐指令会做些什么。</p><p>首先第一点，会保存原程序PC的值，就是要把K+1这个值给保存下来，以便处理完中断以后可以恢复到以前的程序继续往后执行。</p><p>第二点，中断隐指令还需要让PC指向中断服务程序的第一条指令，即修改PC的值，这些动作都是CPU在检测到中断信号之后，自动执行的一系列动作。</p><p>接下来把中断隐指令所需要做的事情再给细化一下，就是CPU检测到某一个中断信号之后会做以下一系列的事情：</p><img src="https://pic.imgdb.cn/item/66a7875dd9c307b7e92753b6.png" alt="计算机组成原理（七）——输入输出系统——中断隐指令.png"><p>第一步，首先会关中断，因为接下来保存程序断点是很重要的一件事情，必须保证能一气呵成，所以执行了关中断以后就可以保存断点，也就是把PC的值给保存下来，那这里就产生了第一个问题，PC的值应该保存到什么地方？</p><p>通常来说，PC的值可以放到堆栈里面，就是操作系统会有一个内核堆栈区，把PC的值放到内核堆栈里，这是比较常见的处理方式。而堆栈是主存的某一片区域，所以除了用主存里的堆栈保存以外，也可以用其它的一些特定的存储单元来存储。总之，只要能保证PC的值可以存的进去，还能取得回来就可以。</p><p>当程序运行的断点保存完了以后，就可以把PC的值指向中断服务程序的第一条指令，也就是引出中断服务程序。这里产生了第二个问题，如何确定某一个中断信号所对应的中断服务程序的起始地址呢？</p><p>这个问题可以用两种方式来解决，同样的分为硬件和软件两种思路，接下来重点探讨硬件实现思路，即硬件向量法。</p><img src="https://pic.imgdb.cn/item/66a787a7d9c307b7e9278567.png" alt="计算机组成原理（七）——输入输出系统——硬件向量法.png"><p>硬件向量法的做法是这样的，首先可以给每个中断请求信号进行一个编号，比如上图的12H、13H、14H等，可以看到在主存里面与这些中断请求号对应的主存单元里，保存了一个JMP无条件转移指令，这个无条件转移指令指明了当前这个中断请求所对应的中断服务程序的入口地址。我们经常把指向中断服务程序起始地址的地址信息称为中断向量。</p><p>来说一下硬件向量法的整体工作过程，之前说过，可以用硬件排队器来实现中断判优，中断判优会导致只有一个中断信号所对应的输出线会输出1，然后其它的输出线都是0。那么可以把之前排队器的输出作为中断向量地址形成部件电路的输入，然后经过中断向量地址形成部件电路的处理以后，会把所对应的某一个信号映射为某一个向量地址。如上图左，比如说排队器输出结果只有第二个是1，那么经过中断向量地址形成部件以后，输出的结果是16进制的13H，这个向量地址指向了当前这个中断请求信号所对应的中断向量的存储地址。接下来再根据这个中断向量就可以找到与这个中断请求信号相对应的中断处理程序。这就是用硬件来确定某一个中断请求信号所对应的中断服务程序的一个方法。这里需要注意区分向量地址和中断向量这两个概念。</p><p>这里补充一点，中断向量地址形成部件输出的向量地址还有一个名字叫做中断类型号。</p><p>现在思考一个问题，既然13H这个中断类型号所对应的服务程序入口地址是300这个地址，那么为什么不让硬件电路直接输出300这个地址信息？事实上，这种方案也可以实现，但是中断服务程序有可能需要被修改，比如打印机所对应的中断服务程序只占了200<del>299这些地址，但如果它变长了直接占了200</del>399，那这样的话显示器所对应的地址只能从400开始往后存放，所以一旦修改了中断服务程序，就意味着要再来修改这个硬件电路，这显然不科学。</p><p>到这里，就已经找到了中断处理程序的入口地址，并且让PC的值指向了它的第一条指令，接下来就应该执行这个中断服务程序，那么这些中断服务程序又需要做什么事情呢？</p><img src="https://pic.imgdb.cn/item/66a787dfd9c307b7e927ab11.png" alt="计算机组成原理（七）——输入输出系统——中断服务程序.png"><p>首先有一些事情是公共的，必须做的事情。第一步是保护现场，就是要保护之前运行的程序的一些CPU环境，这样才能保证之前运行的程序在中断处理完了以后，能够接着之前得到的中间结果继续往后运算。通常来说，要保存的现场环境就是各种各样的寄存器的值，可以把这些寄存器的值压到系统堆栈里，也可以使用特定的存储单元保存。</p><p>接下来第二步就是中断服务，这部分是中断服务的主体部分，这部分要做的事情千差万别，需要根据具体的中断信号执行对应的中断服务。</p><p>第三步就需要恢复现场，在中断服务结束以后，需要把之前运行的程序的环境给复位，也就是要从之前压入的堆栈栈顶弹出各种寄存器的值。</p><p>第四步是中断返回，通过中断返回指令回到原程序断点处，即从堆栈栈顶弹出PC之前的值K+1，然后赋值给PC。</p><p>最后，用一个流程图对中断处理的过程进行一个小结，如下图右：</p><img src="https://pic.imgdb.cn/item/66a788afd9c307b7e9283e66.png" alt="计算机组成原理（七）——输入输出系统——总结中断处理过程.png"><h2 id="6-多重中断"><a href="#6-多重中断" class="headerlink" title="6. 多重中断"></a>6. 多重中断</h2><img src="https://pic.imgdb.cn/item/66a78900d9c307b7e92880ec.png" alt="计算机组成原理（七）——输入输出系统——多重中断.png"><p>所谓多重中断指的就是在执行某一个中断服务程序时，这个中断服务程序的执行还有可能再被中断，所以又开始了更深层次的套娃。</p><p>为了实现多重中断，可以看一下之前提出的上图右的方案需要进行什么样的改进。之前说中断隐指令处需要先关中断，然后在最后整个中断服务程序结束之后，才开中断，这种方式就意味着中间整个过程是不可以再被中断的。</p><p>因此要想实现多重中断，当中断隐指令处理完一系列动作之后，中断服务程序在保存了之前那个程序的运行现场以及保存了屏蔽字之后，需要执行一个开中断指令，如下图：</p><img src="https://pic.imgdb.cn/item/66a7893ed9c307b7e928afab.png" alt="计算机组成原理（七）——输入输出系统——单重中断与多重中断.png"><p>在保存了之前那个程序的运行现场以及保存了屏蔽字之后插入一个开中断指令，就意味着接下来执行中断服务程序的过程当中，有可能再次被中断，所以就可以实现多重中断。</p><p>现在思考一个问题，为什么要把开中断指令放在保护现场的后面呢？</p><p>中断服务程序在保存以前的主程序的运行现场的时候，这个事情的背后也是在执行一系列的指令，也就是要把主程序所对应的各种寄存器的值压入栈里这样的一些指令。如果把开中断这条指令安排在保护现场的前边，就意味着主程序的现场可能只保留了一半，然后又被新的中断程序给中断掉了。这就有可能导致主程序以前的运行现场丢失，所以只有保护完以前那个主程序的现场以后，才可以打开中断，保护现场这个动作必须是一气呵成的。恢复现场的动作也是一样的，必须保证一气呵成，所以要在恢复现场之前，要先关中断。</p><p>支持多重中断的系统相比于单重中断的系统来说，区别就是增加了额外增加了一组开关中断指令。除了这两条指令外，还可以看到一个东西叫屏蔽字。接下来看一下屏蔽字是什么？</p><p>屏蔽字的全称叫做中断屏蔽字，它用于屏蔽某些中断。一个系统里可能出现各种各样的中断请求信号，比如此时上图的中断服务程序3，它在处理DMA控制器发来的中断请求，按照多重中断的性质，在处理DMA中断请求的时候，中间如果再来一个，比如说来自于键盘的中断请求信号，就得进入更深一级的中断处理，但这显然是不科学的，因为中断请求信号是有优先级的，应该优先搞定高速的设备发来的中断信号，然后再响应低速的设备发来的中断信号。所以当CPU在处理某一个中断信号的时候，就需要一个屏蔽字，来指明接下来哪些中断请求应该被屏蔽，这就是中断屏蔽字的作用。</p><img src="https://pic.imgdb.cn/item/66a7899ed9c307b7e928f663.png" alt="计算机组成原理（七）——输入输出系统——中断屏蔽技术1.png"><p>如上图左，是上一节说的排队器实现中断信号的判优，就是会优先响应优先级更高的一些中断请求的信号，那在这个排队器的基础上进行一个改造，就可以得到一个具备中断屏蔽功能的硬件电路，如上图右。</p><p>但是注意，它们的作用是有区别的，左边的硬件排队器是收到多个中断请求时，只响应其中的一个，是固定优先级的，即各个中断请求信号之间的优先级顺序是固定不变的。而上图右这种增加了屏蔽功能之后，就可以更灵活，更动态的来调节各种中断之间的一个优先级。每个中断源都会有一个与之相对应的中断屏蔽字，这个中断屏蔽字会由很多个比特来组成。中断屏蔽字指明了当CPU在处理这个中断源发来的中断请求的时候，应该屏蔽掉其它的哪些中断源的中断请求。</p><p>举个例子，假设硬件排队器的最右边是一个键盘的中断请求信号，最左边是优先级最高的DMA控制器的中断请求信号，所以基于上图左的硬件排队器，当二者同时发出中断请求的时候，CPU一定是优先响应DMA控制器。另外，当CPU在处理键盘发来的中断请求的时候，如果紧接着就接收到了DMA发来的中断请求，那么键盘所对应的中断处理程序又会被DMA再次的中断。</p><p>如果想要避免这个问题，只需要给键盘这个中断源设置一个与之对应的中断屏蔽字，如下图右，所有的比特位都设为1，当比特位设为1的时候，就意味着与这个比特位相对应的中断源不可以把当前这个中断处理程序给打断。所以左边的1 2 3三个中断源的优先级都比键盘的中断源优先级更高，但是如果给键盘设置了一个屏蔽字，四个全1的话，那么可以看下，MASK头上有个横，意思就是先取反。那么最后经过取反、与非门处理以后的信号就如下图右所示，可以看到输出0，这就意味着与键盘相对应的中断服务程序，不可以再被中断。</p><img src="https://pic.imgdb.cn/item/66a78a9dd9c307b7e929b3df.png" alt="计算机组成原理（七）——输入输出系统——中断屏蔽技术2.png"><p>一般来说，如果给某一个比特位设置为1，那就意味着需要屏蔽与这个比特位对应的那个中断源发来的中断请求信号，另外刚才说过，每个中断源对应一个屏蔽字，用这样的方式可以很灵活地实现多重中断。显然一个中断源的优先级要搞得很高很高，就可以给这个中断源设置更多的1。还需要注意的是，每一个屏蔽字当中至少需要有一个1，也就是至少需要屏蔽自身的中断。</p><p>接下来看下这部分在考题里会如何进行考察（习题讲解8分25秒~12分50秒：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=85&vd_source=7fb4b255ed876969a742738d7b84f461">7.3_3_多重中断</a>）：</p><img src="https://pic.imgdb.cn/item/66a78acbd9c307b7e929d57d.png" alt="计算机组成原理（七）——输入输出系统——中断屏蔽技术3.png"><p>接下来对中断系统这部分的内容进行小结：</p><img src="https://pic.imgdb.cn/item/66a78b00d9c307b7e929fc9b.png" alt="计算机组成原理（七）——输入输出系统——中断系统小结.png"><h2 id="7-程序中断方式"><a href="#7-程序中断方式" class="headerlink" title="7. 程序中断方式"></a>7. 程序中断方式</h2><p>本节研究一下，引入了中断系统之后，如何控制IO设备的读写工作。下面直接根据下图进行解释。</p><img src="https://pic.imgdb.cn/item/66a78b59d9c307b7e92a3f29.png" alt="计算机组成原理（七）——输入输出系统——程序中断方式.png"><p>首先CPU是正在运行某一个程序，这个程序有可能需要使用到外部设备，比如说要从外部设备输入一个字符的数据。那么首先需要通过IO指令，向IO设备发出启动输入相关的命令，然后接下来外部设备就可以去准备CPU想要的数据和信息。</p><p>在外部设备准备数据的过程当中，CPU可以继续执行之前的那个程序。当IO设备完成了工作之后，它会给CPU发送一个中断请求信号，假设CPU之前运行的那条指令地址是K，在K这条指令运行周期的末尾检测到了中断请求信号，接下来就要对中断请求信号进行处理。当CPU处理完中断请求以后，就会返回到K+1这条指令。</p><p>这里复习一下中断处理的过程，首先需要用中断隐指令完成一系列的操作，即关中断、保存PC值和引出中断服务程序。接下来CPU就可以转向执行中断服务程序。在中断服务程序当中，首先需要保护以前的这个程序的运行现场，保护好现场以后就开始对中断信号进行处理。在这个过程中，CPU取走了外部设备准备好的第一个数据，接下来CPU可以继续给外部设备发送IO指令，让它接着输入第二个数据。接下来CPU就可以恢复之前程序的运行现场。在外部设备准备下一个数据的时候，CPU可以继续的往后执行后续的指令，直到外设准备好下一个数据，再次给CPU发送中断请求信号。然后再重复刚才的过程。</p><p>引入了中断机制以后，CPU就可以和设备并行的工作。</p><p>下面看一下这部分会如何考察，题目讲解跳转4分20秒~11分20秒：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=86&vd_source=7fb4b255ed876969a742738d7b84f461">7.3_4_程序中断方式</a>。</p><img src="https://pic.imgdb.cn/item/66a78b90d9c307b7e92a7572.png" alt="计算机组成原理（七）——输入输出系统——程序中断方式例题.png"><p>下面是本节内容的小结：</p><img src="https://pic.imgdb.cn/item/66a78bb2d9c307b7e92a95cc.png" alt="计算机组成原理（七）——输入输出系统——程序中断方式小结回顾.png"><h2 id="8-DMA方式"><a href="#8-DMA方式" class="headerlink" title="8. DMA方式"></a>8. DMA方式</h2><img src="https://pic.imgdb.cn/item/66a78bdcd9c307b7e92ab357.png" alt="计算机组成原理（七）——输入输出系统——三种IO控制方式.png"><p>对于程序中断方式来说，每一次IO设备准备好一个字的数据，CPU就需要运行一次中断服务程序，把这个字的数据转存到主存当中，所以对于那些速度很快的IO设备来说，采用这种中断方式，就会使得CPU执行中断服务程序的时间开销会很大，效率会很低，所以提出了DMA方式。</p><p>采用DMA这种控制方式，需要有一个专门的DMA控制器，DMA控制器也是一种IO控制器(也就是IO接口) ，但是这种IO接口可以控制数据传输的过程。</p><p>下面就来研究一下DMA控制器：</p><img src="https://pic.imgdb.cn/item/66a78c07d9c307b7e92ad133.png" alt="计算机组成原理（七）——输入输出系统——DMA控制器1.png"><p>首先需要明确的是DMA控制器通常是用来控制某一些块设备，就是以块为单位进行读写的设备，比如磁盘就是一种很典型的块设备，所以上图以磁盘为例。</p><p>假设现在CPU想要读入一个磁盘的一整块数据，那么如果采用DMA控制方式，就意味着CPU可以向DMA控制器指明这一次要执行的是输入操作还是输出操作。</p><p>假设这次执行的是输入操作，指明方向是从IO设备输入数据到主存当中，接下来还要指明要传输多少个数据，比如说可以以字或字节为单位。接下来由于数据的输入是要把整块的数据从磁盘给读到主存里，所以CPU需要给DMA控制器指明这个数据输入到主存里面，应该存放到主存的什么地址。除此以外，还需要指明要输入的数据在磁盘里的位置。</p><p>DMA控制器现在已经知道了要输入的数据在哪，输入之后应该存放在什么位置，接下来假设这次要输入的一整块数据只有5个字，那么DMA控制器就需要进行一个计数，就是要计算当前已经传了多少个数字，接下来还需要再传几个字。由于要传输5个字，所以上图里的要传几个字处要填上5，然后再分别指明主存读写地址和外存读写地址。</p><p>接下来磁盘的数据是一个字一个字丢给DMA控制器的，所以DMA控制器里还需要有一个数据缓冲寄存器，用来接收磁盘传过来的一个字的数据，每收到一个字之后，DMA控制器就可以根据它里面保存的主存读写地址，把这一整个字的内容通过系统总线传给主存。第一个字传输完成以后，DMA控制器的计数器就会减一，同时主存和外存的读写地址都会后移一位。接下来的工作过程同理，直到DMA控制器的计数器减到0以后，就意味着整块数据的传输就结束了。</p><p>接下来把DMA控制器一个字一个字传送的过程中，发生的一些事情给细化一下：</p><p>首先DMA控制器需要接收磁盘发来的DMA控制请求，所谓DMA请求就是磁盘给它传了一个字之后，就会给它一个DMA请求。当DMA控制器收到DMA请求以后，由于需要把这一个字的数据通过系统总线写入到主存，所以需要先跟CPU发出总线请求。CPU对DMA控制器的总线使用请求给出一个响应，把总线的使用权分配给DMA控制器之后，DMA控制器就可以接管这个系统总线的控制权，然后就进入DMA周期，所谓DMA周期，在本例里指的就是要把这一个字的内容通过系统总线写到主存里面，这样的一个动作就要一个DMA周期。注意，这部分的操作是在把数据传送给主存之前发生的一些事情，接下来才是正式的进入到DMA操作的周期。</p><p>通过总线传递数据的过程是这样的，首先DMA控制器里面记录了当前要写入主存的地址信息和要读入的一整个字的大小信息，当把字写入主存以后，主存的地址会自动加上一个字的大小。另外除了修改主存读写地址之外，传送完字以后，计数器会减1。接下来DMA控制器会往主存写入一个数据，DMA控制器会通过系统总线给主存发出写的命令，所以DMA控制器需要能够控制外设和主存之间的传送方向。除了读写的命令之外，DMA控制器还会根据它里面记录的地址信息，把地址打到系统总线的地址总线上，再把一整个字的数据打到数据总线上，这样就可以对主存执行写操作，就可以完成数据的传送。这就是数据传送过程当中，DMA控制器会做的事情。</p><p>通过上面的方式，DMA控制器就可以一个字一个字的把一整块的数据陆续地传送完成，等这一整块的数据都传送完成之后，还需要向CPU报告工作的完成，这个报告的方式就是通过一个中断信号来执行的。</p><p>上图为了方便理解，只在DMA控制器里画出了一些比较重要的寄存器，接下来再把DMA控制器的内部结构进行一个细化，如下图：</p><img src="https://pic.imgdb.cn/item/66a78c4ad9c307b7e92b07b6.png" alt="计算机组成原理（七）——输入输出系统——DMA控制器2.png"><p>接下来看下DMA控制器里面东西有什么作用：</p><p>首先看控制&#x2F;状态逻辑，这个是一些时序电路，用来完成一系列控制动作。</p><p>接下来看DMA请求触发器，触发器的作用就是保存二进制的0和1，如果设备输入完一整个字的数据之后，会把DMA请求触发器改为1，表示已经完成一个字的输入，当DMA请求触发器改为1之后，控制逻辑相关的电路就可以收到高电平的信号，于是控制电路就可以知道接下来应该把输入的数据放到主存里，这就是DMA请求触发器的作用。</p><p>接下来看主存地址计数器，这个地方用来存放主存的读写地址。</p><p>再看传送长度计数器，用来记录传送数据的长度，当计数溢出时，数据即传送完毕，自动发中断请求信号。</p><p>下面看数据缓冲寄存器，这个前面已经接触过，用来暂存每次传送的数据。</p><p>最后再看中断机构，当一个数据块传送完毕后触发中断机构，向CPU提出中断请求。</p><p>现在注意这样的一个问题：DMA控制器和主存的数据交换是通过系统总线进行的，所以当DMA控制器正在通过系统总线传送数据的过程，这个过程当中，如果CPU也想使用系统总线，也想访问主存，那CPU需要暂停等待，直到DMA的数据传送结束之后，才会把总线的使用权让回给CPU。</p><p>接下来结合流程图看一下DMA的传送过程：</p><img src="https://pic.imgdb.cn/item/66a78c84d9c307b7e92b3589.png" alt="计算机组成原理（七）——输入输出系统——DMA传送过程.png"><p>  首先预处理阶段，CPU会向DMA控制器指明接下来要读或者写的数据应该存放在主存的什么位置，设备的地址是什么，要传送多少个数据，然后就可以启动IO设备。</p><p>接下来会由DMA控制器控制着数据的传送过程，而对于CPU来说，它可以继续执行之前的程序。如果此时要输入一个数据，设备首先会把数据冲入到DR寄存器里，同时向DMA触发器发出一个高电平信号，让其变为1。当控制逻辑检测到DMA请求，就会像CPU申请总线的控制权。如果此时系统总线可以让给DMA控制器使用的话，CPU就会给它一个反馈信号。现在DMA控制器就获得了总线的控制权，就可以通过控制线、地址线和数据线这些给主存发出读或者写命令，由于上图给的是数据输入的例子，所以应该是给主存发送一个写的命令，同时把数据缓冲寄存器里的信息打到数据线上，然后把主存的地址信息打到地址线上，这样就完成了一个字的数据传输。数据传输完以后，需要让主存的地址自动的后移，同时也需要修改长度计数器，这就是一个字的传输。传输完多个字以后，长度计数器就会发生溢出，溢出信号就会传送给中断机构，中断机构检测到溢出信号以后，会向CPU发出中断请求，接下CPU再对DMA的中断信号进行一个处理。</p><p>这里需要注意一点，DMA请求和DMA中断请求是不一样的东西，发送DMA请求时意味着要和主存传送一个字的数据，而发送DMA中断请求的时候，意味着一整块的数据传输已经完成。</p><p>数据传输完成之后，CPU收到中断请求就会进行后处理，也就是运行相应的中断服务程序，然后做DMA结束的处理。做完这些之后，CPU继续去执行主程序。</p><p>下面把刚才分析的过程用流程图总结一下，如下图：</p><img src="https://pic.imgdb.cn/item/66a78ca8d9c307b7e92b5053.png" alt="计算机组成原理（七）——输入输出系统——DMA传送过程流程.png"><p>现在思考这样的一个问题，当DMA控制器在传送数据的过程中，需要不断的占用系统总线，如果说系统总线是被CPU管理的，那由CPU来决定到底要不要把系统总线的使用权分配给DMA控制器就可以了，也就是说只要CPU把系统总线的控制权分配给DMA控制器，那么DMA控制器就可以正常的访问主存，因为系统总线分配给DMA控制权就意味着CPU暂时不能访问主存(CPU和主存之间的交互也需要通过系统总线进行)。所以对于之前的结构图来说，到底要让谁使用主存，这个问题完全是由CPU来控制的，但是现在换一种总线的连接方式，就是之前提出的三总线连接方式，如下图左上：</p><img src="https://pic.imgdb.cn/item/66a78cd9d9c307b7e92b7964.png" alt="计算机组成原理（七）——输入输出系统——DMA方式特点.png"><p>可以看到，主存和DMA接口之间会专门用一个DMA总线来进行交互，然后CPU和主存之间会专门用一个主存总线来交互，在这种情况下，DMA控制器想要访问主存，只需要通过DMA总线即可，而DMA总线的使用权总是归DMA接口所有，已经不再是CPU说了算。</p><p>所以采用三总线结构，就意味着有可能会出现CPU也想访问主存，然后DMA控制器也想访问主存的情况。如果主存不是双端口的主存，同一时刻只能支持一个访问请求，那么对这个主存的访问请求应该先满足CPU还是先满足DMA控制器呢，这就成了一个问题，可以通过下图的三种方案来解决CPU与DMA的访存冲突：</p><img src="https://pic.imgdb.cn/item/66a78d0cd9c307b7e92ba456.png" alt="计算机组成原理（七）——输入输出系统——DMA传送方式.png"><p>首先第一种方式，停止CPU访问主存，就是DMA控制器传送一整块的数据的时候，整个传送的过程当中，主存的使用权会完全分配给DMA控制器，这也就意味着DMA控制器传送一整块的数据过程当中，CPU就没办法从主存里边取走指令，这样就会导致CPU整个运行完全停滞。所以这种方式简单粗暴，相应的控制方式也很简单，但不能发挥CPU对主存的利用率，同时也会使CPU的工作进度必须停滞，这就和引入DMA控制器的初衷相互违背了。</p><p>接下来看第二种方式，DMA与CPU交替访存，看上图第二个就很好理解这种方式，主存的工作时间会被分为两个阶段，第一段给DMA使用，第二段给CPU使用。采用这种方式就不需要进行总线的使用权申请，因为时间片的划分是规定死的，所以控制起来也很简单，不过这种方式控制电路逻辑要比第一种复杂，并且这种简单的传送方式未必能够很好地利用主存的读写性能。比如说CPU对主存的访问可能是很频繁的，每一个给CPU分配的主存访问时间，CPU都会使用到，而对于DMA控制器来说，由于它需要等待外部设备输入一个字，输入完一个字之后才会去进行一次访存，所以对于DMA控制器来说，给它分配的这些保存时间可能用不到，所以这种方式对主存的利用率也不太好。</p><p>接下来看第三种方式，周期挪用，这里的周期指的是主存的存取周期，在这种方式下主存的工作时间的分配变得更加自由。由于DMA和CPU都有可能访存，因此可能会出现这样的三种情况，第一种当DMA想访存主存时，CPU不访问主存；第二种当DMA想访存主存时，CPU正在访问主存；第三种当DMA想访存主存时，CPU也要访问主存。</p><p>当DMA想访存主存时，CPU不访问主存时，DMA直接访存就可以。</p><p>当DMA想访存主存时，CPU正在访问主存，此时CPU的存取周期还没有结束，那么DMA控制器就需要等待CPU的这次存取结束之后，再去访问主存。</p><p>当DMA想访存主存时，CPU也要访问主存，这种情况下会优先让DMA控制器进行访存，原因是如果不及时把DMA控制器里的数据缓冲寄存器里的数据写到主存里，那么外部设备继续往里面冲入数据，就有可能导致数据的丢失。</p><p>上面这三种方案就是用来解决DMA和CPU的缓冲冲突。</p><p>下面结合之前的学习再把DMA控制器的特点进行一个总结，如下图右，这里很简单就不过多叙述：</p><img src="https://pic.imgdb.cn/item/66a78cd9d9c307b7e92b7964.png" alt="计算机组成原理（七）——输入输出系统——DMA方式特点.png"><p>最后把DMA方式与中断方式进行一个对比：</p><img src="https://pic.imgdb.cn/item/66a78d4ad9c307b7e92bd39e.png" alt="计算机组成原理（七）——输入输出系统——DMA方式与中断方式.png"><p>下面对本节内容进行小结：</p><img src="https://pic.imgdb.cn/item/66a78d72d9c307b7e92bf392.png" alt="计算机组成原理（七）——输入输出系统——DMA方式小结回顾.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（六）——总线</title>
      <link href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BA%BF/"/>
      <url>/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（六）——总线"><a href="#计算机组成原理（六）——总线" class="headerlink" title="计算机组成原理（六）——总线"></a>计算机组成原理（六）——总线</h1><h2 id="1-总线的概述"><a href="#1-总线的概述" class="headerlink" title="1. 总线的概述"></a>1. 总线的概述</h2><img src="https://pic.imgdb.cn/item/66a75d05d9c307b7e904f7af.png" alt="计算机组成原理（六）——总线——总线概述.png"><p>在之前的学习过程中，虽然没有对总线进行详细的学习，但是对总线已经有了一定的接触，在之前会画这样的一个图，如上面，CPU可以通过地址总线给主存或给打印机、硬盘这些发送地址信息，所以在上图可以看到，在CPU和地址总线之间有一根连线，硬盘和地址总线之间有一根连线，主存和地址总线之间也有一根连线。</p><p>除了地址总线之外，之间还经常遇到数据总线，CPU可以通过数据总线和主存、打印机、硬盘之类的其它的一些硬件部件进行数据的传输，并且之前说过数据总线有可能并行的传递32bit或更多bit的数据。</p><p>最后，之前还经常接触的还有一个叫控制总线，就是CPU可以通过控制总线给其它的硬件部件发送一些控制信号。</p><p>接下来解释一下，为什么一个数据总线可以并行的传递32bit或更多bit的数据。原因是每个总线里面可能会包含很多根信号线。比如说，把数据总线拆解一下，如下图：</p><img src="https://pic.imgdb.cn/item/66a75d40d9c307b7e9052a51.png" alt="计算机组成原理（六）——总线——总线的物理实现.png"><p>数据总线的内部可能如上图所示的样子，一个数据总线里边有可能会包含多跟信号线，上图画了4根，当然如果想并行的传递32bit，那数据总线内部就可以包含32根信号线。</p><p>比如CPU想给主存发送4bit数据0101，那就意味着CPU只需要给数据总线的四根线上分别加上高低电平信号就可以，而0101这四个数据可以被主存接收，也可以被硬盘接受，还可以被打印机接收，因为这些高低电平信号只要加到上面的4根线上，那么由于所有的硬件部件都是连在数据总线上，所以所有的硬件部件都可以通过数据总线来接收CPU要发给他们的信号。</p><p>所以虽然平时通常说一根总线，虽然说的是一根，但是这个总线内部有可能是包含了多根信号线的，那到底要包含几根，这个主要看具体的需求。</p><p>但是仔细想一下，刚才是说CPU往总线上面加了四个高低电平信号，那么这四根线就会带有0101的数据信息。现在假设SSD固态硬盘也想往数据总线上传送数据，比如SSD传送1111，这个时候就会导致每一条信号线上面的信号会有冲突。所以对于这样的一根数据总线来说，同一时刻只能有一个部件发送数据，但是可有多个部件接受数据。</p><p>下面看一下这章的总览：</p><img src="https://pic.imgdb.cn/item/66a75d83d9c307b7e9056a9c.png" alt="计算机组成原理（六）——总线——本章总览.png"><p>接下来首先看一下总线的定义： </p><img src="https://pic.imgdb.cn/item/66a75db8d9c307b7e9059b85.png" alt="计算机组成原理（六）——总线——总线的定义.png"><p>总线是一组能为多个部件分时共享的公共信息传送线路，上图中给出的图是总线与各个部件的连接图，图中上半部分是CPU的运算部件和控制单元，图中下半部分是输入输出设备和主存，CPU和这些设备之间会通过一组系统总线来进行数据的交互以及控制信号的收方，所有的硬件部件都是通过系统总线来进行相互的控制和数据的传送。</p><p>早期计算机由于外部设备非常少，因此大多采用分散连接方式，但是这种方式不易实现随时增减外部设备。为了更好地解决l&#x2F;O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。</p><p>总线有两个很明显的特点，一个是分时，一个是共享。分时和共享的意思参考下图：</p><img src="https://pic.imgdb.cn/item/66a75de3d9c307b7e905c647.png" alt="计算机组成原理（六）——总线——总线的特点.png"><p>当在设计一个总线的时候，需要关注到如下图的特性：</p><img src="https://pic.imgdb.cn/item/66a75e19d9c307b7e905f985.png" alt="计算机组成原理（六）——总线——总线的特性.png"><p>接下来重点关注总线的分类：</p><img src="https://pic.imgdb.cn/item/66a75e7ed9c307b7e9065095.png" alt="计算机组成原理（六）——总线——总线的分类.png"><p>总线的分类可以根据不同的维度进行分类，分类的方式如上图。</p><p>下面先介绍一下按数据传输格式的分类：</p><img src="https://pic.imgdb.cn/item/66a75e92d9c307b7e90660d6.png" alt="计算机组成原理（六）——总线——串行总线与并行总线.png"><p>总线按数据传输格式可以分为串行总线和并行总线。</p><p>首先解释一下什么是串行总线什么是并行总线。假设设备A要给设备B发送4bit数据1011，如果采用串行总线就意味着A只能一个比特一个比特的发送这四位数据，B接收也是一个比特一个比特接收。如果采用并行总线就意味着A能并行的发送这四位数据，B接收时也能并行的接收。显然CPU和主存之间用于传送数据的数据总线就是一种并行总线。</p><p>由于串行总线每次只需要传递一个比特的数据，因此只需要用一根传输线就可以实现串行总线，所以串行总线实现起来成本比较低。由于串行总线成本低，而且只有一根抗干扰能力强，所以串行总线广泛用于长距离传输。但串行总线缺点也很明显，在数据发送和接收的时候要进行拆卸和装配(通常来说发送一组有意义的二进制信息至少是以一个字节为单位，但由于每次只能传递一个比特，因此就存在把一个完整的信息包拆卸和装配这样的一个过程)，另外还要考虑串行-并行转换的问题。</p><p>接下来再看并行总线的优点，并行总线的逻辑时序比较简单，电路实现起来比较容易。但缺点也很明显，信号线数量多，占用更多的布线空间；远距离传输成本高昂。</p><p>另一方面由于并行总线工作频率较高时，并行的信号线之间会产生严重干扰，可能会导致二进制信息跳变，所以并行总线无法持续提升工作频率。因此，在实际传输的速度上，并行总线不一定比串行总线快。</p><p>接下来看一下按总线功能分类：</p><img src="https://pic.imgdb.cn/item/66a75ee4d9c307b7e906a600.png" alt="计算机组成原理（六）——总线——按总线的功能分类.png"><p>根据总线功能可以分为片内总线、系统总线和通信总线。</p><p>先来看片内总线，片内总线就是芯片内部的总线。它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。</p><p>系统总线是计算机系统内各功能部件（CPU、主存、IO接口）之间相互连接的总线。</p><p>系统总线又可以根据其传输信息的内容不同，进一步划分为：数据总线、地址总线和控制总线。</p><p>这里需要重点探讨，数据总线、地址总线和控制总线的数据传输方向的问题，如下图：</p><img src="https://pic.imgdb.cn/item/66a75f10d9c307b7e906cc8a.png" alt="计算机组成原理（六）——总线——系统总线.png"><p>首先看一下数据总线，数据总线传输各功能部件之间的数据信息，包括指令和操作数。数据总线包含数据线的位数(根数)与机器字长、存储字长有关。同时，通过之前的学习不难理解，<strong>数据总线传输数据的方向是双向的</strong>。</p><p>接下来看地址总线，地址总线传输地址信息，包括主存单元或I&#x2F;O端口的地址。地址总线包含数据线的位数(根数)与主存地址空间大小及设备数量有关。<strong>地址总线传递信息是单向的</strong>，一定是由CPU发送地址信号，来指明它想要读或者写的这个设备或者主存地址是哪一个。</p><p>接下来看控制总线，控制总线传输传输控制信息，控制总线内部也会包含多根控制线，一根控制线传输一个信号。控制总线里面包含的一根一根的控制线，对于单根控制线来说，控制信号的传输方向肯定都是单向的，有的控制线是由CPU发出给其它的设备；而有的控制线是CPU用来接收其它硬件设备给它返回的控制信号的。所以对于单根控制线来说，信号的传输方向是单向的，然而对于整个控制总线来说，它的传输方向既有可能是CPU向其它设备传输，也有可能是其它设备向CPU反馈。</p><p>这里补充一点，第五章里说过数据通路的概念，要注意数据通路表示的是数据流经的路径，而数据总线是承载的媒介。</p><p>接下来说第三种通信总线，通信总线是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备)之间信息传送的总线，通信总线也称为外部总线。</p><p>接下来介绍几种系统总线的结构，单总线结构、双总线结构和三总线结构：</p><img src="https://pic.imgdb.cn/item/66a75f53d9c307b7e9070225.png" alt="计算机组成原理（六）——总线——单总线结构.png"><p>首先看单总线结构，即在计算机内部只设置一组系统总线，然后CPU、主存和各种IO设备之间都是连接在这一组系统总线上的，所有功能部件都是通过这一组系统总线来进行数据的传输。</p><p>注意，单总线并不是指只有一根信号线，这根总线里还包含了地址总线、数据总线和控制总线。</p><p>显然，这种总线结构优点是结构简单，成本低，易于接入新的设备。缺点就是带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。</p><p>单总线结构中CPU和主存是属于比较快速的设备，但是其它的外部设备属于慢速设备，因此虽然系统总线可以支持很快的速度传输，但是当用快速的系统总线来让慢速的设备传输数据的时候，就意味着快速的系统总线的性能是被浪费的，所以所有的慢速设备都接在同一根快速的系统总线上是不合理的，</p><p>接下来看双总线结构是如何解决这个问题的：</p><img src="https://pic.imgdb.cn/item/66a75f7bd9c307b7e9071ef5.png" alt="计算机组成原理（六）——总线——双总线结构.png"><p>双总线结构会让CPU、主存和通道统一的连到一个主存总线上。这里先说一下通道的概念，通道可以看成是阉割版的小CPU，但是这个功能部件是专门用于管理各种各样的IO设备的，所以从上图可以看到通道和下面的IO总线之间有一个双向箭头，所有的IO设备不管是快还是慢，都会通过通道来和CPU进行间接的交互，而通道对信息的处理速度很快，所以把通道和CPU直接通过主存总线进行连接。</p><p>通过通道就可以保证快速的主存总线的性能可以被发挥出来，而下面的IO总线由于各种IO设备读写速度较慢，所以下面的IO总线设计时性能就可以设计的慢一些。</p><p>另一方面，能对l&#x2F;O设备进行统一的管理，而通道要管理这些IO设备，它也需要运行管理相关的程序代码，而通道要运行的程序也是被存放在主存里面的，所以主存和通道间也可以通过快速的主存总线来进行数据的交互。</p><p>另外再补充一点，主存总线可以支持突发(猝发)传送，即送出一个地址，可以收到多个地址连续的数据。正常来说，CPU每指明一个地址，可以从主存当中读出一个字的信息，但是由于主存当中保存的信息很多时候都是需要被连续的访问的，因此会有这样的一个需求，CPU指明一个地址后，如果能从主存当中连续的读出多个字的数据，那这样的话系统的效率肯定就能更高。这也就是突发传送方式的意义。</p><p>双总线结构的优点是将较低速的l&#x2F;O设备从单总线上分离出来，实现存储器总线和IO总线分离。缺点是需要增加通道等硬件设备。</p><p>接下来看三总线结构：</p><img src="https://pic.imgdb.cn/item/66a75fa6d9c307b7e9073c2d.png" alt="计算机组成原理（六）——总线——三总线结构.png"><p>三总线结构如上图，可以看到有三个总线，主存总线用于连接主存和CPU这两个高速部件之间的交互。主存和某一些快速的IO设备之间会用DMA总线来连接。快速的IO设备可以通过DMA总线将数据传递给主存，然后CPU从主存里获取数据，这么做的好处就是CPU不需要通过慢速的IO总线和设备进行数据交互，而是可以先把数据从快速的设备放到主存里，然后CPU从主存里获取数据，这样可以缓和CPU和快速的IO设备之间的速度矛盾。</p><p>三总线结构使得某一些高速的IO设备的性能得到提升，因为这些高速的IO设备可以通过更快的DMA总线和主存之间进行数据交互。另外由于这些慢速的IO设备和CPU是直接连接的，所以它们可以更快的响应CPU发出的命令，因此系统的吞吐量得到提升。而这种总线结构的缺点是系统工作效率较低，这是因为三个总线同一时刻只能有一个总线在工作。</p><p>接下来再拓展一种四总线结构：</p><img src="https://pic.imgdb.cn/item/66a75fd7d9c307b7e9075c75.png" alt="计算机组成原理（六）——总线——四总线结构.png"><p>如上图，可以看到有一个CPU总线用于连接CPU和cache。然后有一个系统总线用于连接主存。还有高速总线用于连接快速的设备。最后还有一个扩充总线，用于外部设备的扩充。</p><p>在四总线结构中，不同的总线的速度是各不相同的，显然CPU总线是最快的，其次是系统总线和高速总线，由于不同的总线之间有速度差异，因此需要增加一个中间设备桥接器，用于连接不同的总线。桥接器具有数据缓冲、转换和控制功能。</p><p>另一点，在这种四总线结构中，越靠近CPU的总线速度是越快的。</p><p>另外，每级总线的设计遵循总线标准（总线设计标准的内容408不考，有兴趣自己研究）。</p><p>四总线结构在考试中通常不考，但这种结构才是现代计算机最常用的一种结构。</p><p>下面对本节内容进行小结：</p><img src="https://pic.imgdb.cn/item/66a76003d9c307b7e9077aaa.png" alt="计算机组成原理（六）——总线——总线概述小结.png"><h2 id="2-总线的性能指标"><a href="#2-总线的性能指标" class="headerlink" title="2. 总线的性能指标"></a>2. 总线的性能指标</h2><p>考察方式：总线的性能指标一般考察选择题或大题第一小问。</p><img src="https://pic.imgdb.cn/item/66a7604cd9c307b7e907aeca.png" alt="计算机组成原理（六）——总线——总线的性能指标1.png"><p>首先看第一个性能指标——总线的传输周期，也叫总线周期。</p><p>总线周期指利用总线来传输一组数据所需要的时间，通常一个总线周期会被分为申请阶段、寻址阶段、传输阶段和结束阶段这四个阶段。</p><p>申请阶段主要负责总线仲裁(总线仲裁内容408不考察，有兴趣可以去了解)，即决定是否把总线分配给某一个设备使用。寻址阶段主设备要指明从设备的读写的地址。第三个阶段，主设备在指明地址以后，会通过总线向从设备里写入数据或读出数据。数据传输完成以后，最后会进入一个结束阶段，就是要释放总线的使用权，把总线让给其它设备使用。</p><p>总线周期包含这样的四个阶段，经过一个总线周期以后，就可以完成一组数据的传送。一个总线周期通常由若干个总线时钟周期构成。</p><p>接下来看第二个性能指标——总线的时钟周期。</p><p>对于早期的计算机来说，总线的时钟周期的时钟信号，是由CPU发出的，所以总线的时钟周期通常就是机器的时钟周期。但是现在的计算机中，总线时钟周期也有可能由桥接器提供。这一点可以参考上一节的四总线结构，里面就有桥接器。</p><p>这里要说明一点，总线周期与总线时钟周期的关系比较魔幻，大多数情况下，一个总线周期包含多个总线时钟周期。但有的时候，一个总线周期就是一个总线时钟周期；还有的时候，一个总线时钟周期可包含多个总线周期。所以做题时要注意审题，明确总线时钟周期和总线周期的关系。</p><p>第三个总线的工作频率和第四个总线的时钟频率很简单，参考上图的介绍即可，这里不再过多叙述。</p><img src="https://pic.imgdb.cn/item/66a76080d9c307b7e907d5ef.png" alt="计算机组成原理（六）——总线——总线的性能指标2.png"><p>接下来看第五个性能指标——总线的宽度，这个很好理解，总线宽度就是总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位(bit)总线。注意，总线宽度一般是数据总线的位数，而没有包含地址总线和控制总线的宽度。</p><p>接下来看第六个性能指标——总线的带宽，总线带宽可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节&#x2F;秒（B&#x2F;s）表示。总线带宽的计算公式如上图。</p><p>注意，总线带宽是指总线本身所能达到的最高传输速率。而题目中如果让计算实际的有效教据传输率时，要用实际传输的数据量除以耗时。</p><p>有效传输速率和总线带宽是有区别的，下面用一道例题感受一下：</p><img src="https://pic.imgdb.cn/item/66a7648fd9c307b7e90ae8df.png" alt="计算机组成原理（六）——总线——总线的性能指标带宽及例题.png"><p>提到了总线带宽，下面再来看一下上一节有关串行总线和并行总线的遗留问题：</p><img src="https://pic.imgdb.cn/item/66a764d3d9c307b7e90b2579.png" alt="计算机组成原理（六）——总线——串行总线与并行总线速度比较.png"><p>表面上，并行总线的总线宽度大于串行总线的总线宽度，所以会认为并行总线的总线带宽大于串行总线的总线带宽。但实际上总线带宽还受总线工作频率的影响，所以工作频率相同时，串行总线传输速度比并行总线慢。但并行总线的工作频率无法持续提高，而串行总线可以通过不断提高工作频率来提高传输速度，最终超过并行总线。</p><p>接下来看第七个性能指标——总线复用：</p><img src="https://pic.imgdb.cn/item/66a76507d9c307b7e90b55b7.png" alt="计算机组成原理（六）——总线——总线性能指标3.png"><p>总线复用是指一种信号线在不同的时间传输不同的信息。可以使用较少的线传输更多的信息，从而节省了空间和成本。之前画的图，地址总线和数据总线是独立的两组线，但是也可以采取上图的方式，用同一组线来分时的传输地址信息和数据信息，这样就可以用更少的线来传输更多的数据，从而节省总线的布线空间和硬件的成本。</p><p>基于总线复用技术，如果CPU要往主存当中写入某一个数据，那CPU要先通过总线发出地址信息，主存接收到地址信息以后，CPU要再发出数据的信息，同样通过总线传递给主存，主存根据刚才接收到的地址信息，把接受到的数据写入刚刚地址。所以采用总线复用技术，显然当要传递地址信息和数据信息的时候，至少都需要两个总线周期，需要进行两次数据传送。所以总线复用虽然节约了成本，但也会使速度有所下降。</p><p>最后看第八个性能指标——信号线数。信号线数就是地址总线、数据总线和控制总线3种总线数的总和称为信号线数。这个指标很简单，不过多叙述。</p><p>下面对本节内容进行一个汇总小结：</p><img src="https://pic.imgdb.cn/item/66a7656dd9c307b7e90ba30d.png" alt="计算机组成原理（六）——总线——总线性能指标汇总.png"><h2 id="3-总线的操作和定时"><a href="#3-总线的操作和定时" class="headerlink" title="3. 总线的操作和定时"></a>3. 总线的操作和定时</h2><p>本节研究总线的操作和定时，即占用总线的一对设备如何进行数据传输。</p><img src="https://pic.imgdb.cn/item/66a765b5d9c307b7e90bd618.png" alt="计算机组成原理（六）——总线——总线传输四个阶段.png"><p>之前说过，总线周期可以分为四个阶段，如上图，首先要经过申请分配阶段，某一个主设备要想使用总线，那么他需要向总线控制部件发出请求，申请总线控制权。然后接下来总线控制器按照一定的优先级，把总线的控制器分配给某一个主设备，即进行总线仲裁，经过请求和仲裁这两个阶段，就完成了申请和分配这个阶段所需要做的事情。</p><p>当主设备获得总线控制权以后，就可以开始用地址信息来指明它想要读或者写的从设备是哪一个，因为每一个设备都会有自己的地址编号，所以主设备可以用地址来指明它想要配合工作的从设备是哪一个。除了地址信息外，还需要发出相关的命令（比如是进行读操作还是写操作），指定的从设备接收到相关请求后，就会启动，这就是第二个阶段寻址阶段所要做的事情。</p><p>接下来第三个阶段，传输阶段，这个阶段要进行具体的数据交换。</p><p>接下来第四个阶段，主模块传输完数据以后，需要把总线的控制权让出来，所以要把地址信息之类的相关的电信号，从总线上擦除。这就是一个总线周期大致上要经历的的四个阶段，这一小节要说的总线定时指的就是主模块与从模块在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时。事实上，总线定时的问题就是要制定某一种协议或规则让数据的发送方和接收方都能按照统一的规则来进行数据交互。</p><p>接下来介绍四种总线定时的方案，分别是同步通信、异步通信、半同步通信和分离式通信。</p><p>首先同步通信这种方式会由总线控制器提供一个统一的时钟信号，用来控制数据传送。异步通信方式相当于没有提供一个统一的节奏，而是让主设备和从设备在获得总线的使用权以后，让他们用应答的方式来相互协商决定工作的节奏，这种定时方式不会有一个统一的节拍。接下来半同步通信是同步和异步通信的结合。最后的分离式通信又可以更进一步的挖掘总线每瞬间的潜力。</p><p>接下来详细探究一下这四种通信方式，首先看一下同步定时方式：</p><img src="https://pic.imgdb.cn/item/66a765fcd9c307b7e90c0cb5.png" alt="计算机组成原理（六）——总线——读命令同步定时方式.png"><p>同步通信方式，总线控制器采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。假设此时CPU是主设备，CPU获得了总线的控制权，然后CPU作为主设备可以主动的选择某一个输入设备作为从设备，想要从从设备读入某一个数据，那么要进行读操作，所以可以这样安排总线的传输周期。</p><p>假设一个总线周期里包含了四个时钟周期T1、T2、T3、T4，那么CPU获得总线的控制权以后，第一个周期的上升沿处，CPU会发出地址信号，用来指明它想要读的从设备的地址。</p><p>接下来T2节拍，会向从设备发出读命令，从上图可以看到，读命令的电平信号是向下画的，也就是说在这个例子里，默认低电平有效。所以在T2这个周期内，从设备首先可以根据地址信息来判断这个主设备要操作的对象是不是自己，然后根据读命令可以知道这个主设备想从自己这里读出数据，所以T2时钟周期内，从设备需要准备好主设备想要的数据。</p><p>接下来T3时钟周期的上升沿到来的时候，从设备就会把自己准备好的数据给放到数据总线上，主设备就可以从数据总线上获得自己想要的数据。</p><p>接下来T4时钟周期内，主设备会撤销读命令，然后再紧接着撤销地址信号，释放总线的控制权。</p><p>所以经过这样的一个总线传输周期，每一个节拍内，主设备和从设备会完成对应的操作，接下来就可以进入下一个总线周期。上面就是用同步定时方式完成一次读操作的例子。</p><p>可以看到，从设备在接收到地址信息和读命令之后，T2这个时钟周期内，从设备需要准备好想要读的数据，然后在T3的上升沿到达的时候，就把这个数据放到数据总线上。显然，如果说从设备的速度比较慢，跟不上节奏的话，那么就意味着在T3周期内，从设备有可能给不出数据，这样的话同步定时方式就会出现问题。因为同步定时方式意味着这个统一的时钟信号是固定的，每一个总线的传输周期只会给四个时钟信号，所以如果从设备跟不上这么快的节奏，那么他们俩的这种数据通信就会出现问题，所以这就是同步通信方式的一个局限性。</p><p>下面再把同步通信方式的特点进行一个总结：（如果有不懂的地方可以跳转视频8分钟~10分钟40秒：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=78&vd_source=7fb4b255ed876969a742738d7b84f461">6.3_总线操作和定时</a>）</p><img src="https://pic.imgdb.cn/item/66a7662cd9c307b7e90c3068.png" alt="计算机组成原理（六）——总线——同步定时方式.png"><p>接下来看异步通信方式：</p><img src="https://pic.imgdb.cn/item/66a766c6d9c307b7e90c9976.png" alt="计算机组成原理（六）——总线——异步定时方式.png"><p>采用异步通信方式，就意味着系统不会提供一个统一的时钟信号，主设备需要提出交换信息的请求信号，从设备会通过IO接口接收到这个请求信号，然后根据请求信号的具体信息，从设备会发出回答信号。</p><p>对于这种异步通信方式，并不会有一个统一的时钟部件来统一动作，这个时候主设备和从设备又是如何配合工作的呢？这种情况下可以根据“请求”和“回答”信号的撤销是否互锁，把异步定时进一步细分为不互锁方式、半互锁方式和全互锁方式。</p><p>接下来依次看一下这三种方式：</p><img src="https://pic.imgdb.cn/item/66a766fed9c307b7e90cc726.png" alt="计算机组成原理（六）——总线——异步定时方式3种类型.png"><p>首先看不互锁方式，主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答”信号。双方不存在互锁关系。</p><p>接下来看半互锁方式，主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。</p><p>最后看全互锁方式，主设备发出“请求”信号后，必须待从设备“回答”后，才撤销“请求”信号；从设备发出“回答”信号，必须待获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系。</p><p>通过对三种方式的了解，很明显可以看到，不互锁方式速度最快，但可靠性最差；全互锁方式速度最慢，但可靠性最好。</p><img src="https://pic.imgdb.cn/item/66a76727d9c307b7e90ce5bd.png" alt="计算机组成原理（六）——总线——异步定时方式优缺点.png"><p>通过对三种异步定时方式的了解可以发现，异步定时方式的优点是总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。缺点是比同步控制方式稍复杂一些，速度比同步定时方式慢。</p><p>接下来看半同步通信：</p><img src="https://pic.imgdb.cn/item/66a7676bd9c307b7e90d1a73.png" alt="计算机组成原理（六）——总线——半同步通信.png"><p>半同步通信就是同步与异步的结合，看上图，比起同步控制方式来说，半同步这种通信方式会增加一个反馈的信号wait。</p><p>首先主设备在T1时间内发出地址信号，然后再T2节拍前沿发出读命令，如果按照之前同步定时方式，在T2这个节拍再往后的一个节拍，从设备需要准备好自己的数据，但是有的从设备跟不上这种节奏，所以当从设备跟不上节奏的时候，就会通过控制线路，给总线的控制器进行一个反馈，让总线控制器等自己几个节拍，所以后面跟的TW这两个节拍就是总线控制器在等待从设备准备数据，经过这样的两个节拍以后，从设备准备好数据，接下来到T3这个节拍内，从设备就可以把自己准备好的数据，通过数据总线发送给主设备。然后最后T4这个节拍主设备会撤销读命令还有地址信息，这样就完成了总线的传输工作。</p><p>可以看到，之前介绍的同步定时方式，每一个总线的传输周期都是定长的，但是这种半同步的通信方式结合了异步通信方式的优点，增加了一个等待的反馈信号，这样的话总线控制器就可以根据反馈信号来动态的调节这个传输周期里面应该包含的时钟周期数。</p><p>所以这种半同步通信方式也是有一个统一的时钟节拍，但是由于可以动态的调整每一个传输周期内包含的时钟节拍数，因此它也能够支持速度差异比较大的主设备和从设备之间的数据交互。</p><p>接下来看最后一种分离通信：</p><img src="https://pic.imgdb.cn/item/66a767acd9c307b7e90d4a69.png" alt="计算机组成原理（六）——总线——分离式通信.png"><p>首先对于刚刚提到的三种通信方式来说，都有一些共同点，他们都会经过主设备发送地址和命令、从设备准备数据、从设备向主设备发送数据这三个阶段，但这三个阶段只有第一个和第三个会使用总线，而第二个从设备准备数据的阶段，主设备和从设备即使不使用总线，也会占据总线，所以前面提到的三种总线定时方式可以优化的点就在第二个阶段。</p><p>当慢速的从设备在准备数据的时候，总线在这段时间是没有被使用的，然而这段时间内，主从设备依然占据总线控制权，所以分离式通信的思想就是会把总线的传输周期切分为两个独立的子周期，第一个子周期就是主设备申请占用总线，并且发出地址命令之类的请求信息，当请求信号发出以后，主设备会立即放弃总线的控制权，把总线让给其它设备使用。从设备接收到请求信号以后，就可以开始准备主设备想要的数据，等从设备准备好数据之后，它又会主动的申请占用总线，当从设备获得总线控制权以后，再把主设备想要的数据给送到总线上。</p><p>所以分离式的通信可以充分的利用从设备准备数据的这段时间，这段时间把总线的使用权分配给其它设备使用，这样可以让总线的数据传输效率变得更高，</p><p>之前说过，所谓的主设备指的是可以主动地申请总线控制权的那些设备，可以把它称为主设备，但是如果采用这种分离式通信，显然也需要让从设备也能够主动地申请总线的控制权。</p><p>另外，这种分离式的通信同样也会给一个统一的时钟信号，采用同步通信方式，主设备在规定的节拍内发出请求信号，但是主设备不需要等待从设备的回应，规定的节拍内发出请求，然后规定的节拍内释放总线的控制权。而且在各个模块准备数据的时候是不需要占用总线的，所以这种分离式通信可以让总线的利用率提高，它可以充分的挖掘出总线的数据传输能力。</p><p>接下来对这部分进行总结：</p><img src="https://pic.imgdb.cn/item/66a767d6d9c307b7e90d6a62.png" alt="计算机组成原理（六）——总线——总线操作和定时小结.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（五）——输入/输出（I/O）管理</title>
      <link href="/2024/06/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86/"/>
      <url>/2024/06/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%88IO%EF%BC%89%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（五）——输入-输出（I-O）管理"><a href="#操作系统（五）——输入-输出（I-O）管理" class="headerlink" title="操作系统（五）——输入&#x2F;输出（I&#x2F;O）管理"></a>操作系统（五）——输入&#x2F;输出（I&#x2F;O）管理</h1><h2 id="1-I-O设备的概念和分类"><a href="#1-I-O设备的概念和分类" class="headerlink" title="1. I&#x2F;O设备的概念和分类"></a>1. I&#x2F;O设备的概念和分类</h2><img src="https://pic.imgdb.cn/item/6669bad4d9c307b7e98969f9.png" alt="操作系统（五）——IO管理——知识总览.png"><p>通过之前的学习可以知道，操作系统作为系统资源的管理者，既需要对上层的软件进行管理，也需要对下层的硬件进行管理。在之前的学习里，已经学习了操作系统对处理机还有存储器这些硬件进行管理。但是这些硬件其实是在计算机的主机内部的。本章要探讨的所谓的设备管理，指的是操作系统对计算机主机外部硬件设备的管理。</p><p>接下来了解一下I&#x2F;O设备的基本概念和分类。</p><img src="https://pic.imgdb.cn/item/6669ba0cd9c307b7e9877675.png" alt="操作系统（五）——IO管理——什么是IO设备1.png"><p>I&#x2F;O设备又可以称为外部设备，属于计算机中的硬件部件。所谓的I&#x2F;O指的就是输入和输出。l&#x2F;O设备可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备。</p><p>因此输入的过程就是把设备准备好的数据读入计算机当中，而输出的过程就是把计算机准备好的数据写出到输出设备上。所以UNIX系统会把这些外部设备抽象为一种特殊的文件，这样的话用户就可以用读文件或者写文件的方式，来对外部设备进行操作。</p><p>像下图的write操作就是向外部设备写出数据，也就是数据输出的过程。read操作就是从外部设备读入数据，也就是数据输入的过程。</p><img src="https://pic.imgdb.cn/item/6669bbacd9c307b7e98bbb28.png" alt="操作系统（五）——IO管理——什么是IO设备2.png"><p>接下来看一下IO设备有哪些分类：</p><p>按使用特性分类：</p><img src="https://pic.imgdb.cn/item/6669bd0bd9c307b7e98fbac1.png" alt="操作系统（五）——IO管理——IO设备分类1.png"><p>按传输速率分类：</p><img src="https://pic.imgdb.cn/item/6669bdd7d9c307b7e9924ca9.png" alt="操作系统（五）——IO管理——IO设备分类2.png"><p>按信息交换的单位分类：</p><img src="https://pic.imgdb.cn/item/6669bdf9d9c307b7e992cdae.png" alt="操作系统（五）——IO管理——IO设备分类3.png"><p>最后对这部分进行一个小结：</p><img src="https://pic.imgdb.cn/item/6669be28d9c307b7e9935321.png" alt="操作系统（五）——IO管理——IO设备分类4.png"><h2 id="2-I-O控制器"><a href="#2-I-O控制器" class="headerlink" title="2. I&#x2F;O控制器"></a>2. I&#x2F;O控制器</h2><p>I&#x2F;O设备由机械部件和电子部件(I&#x2F;O控制器、设备控制器)组成。</p><img src="https://pic.imgdb.cn/item/666b03a0d9c307b7e92bbe6d.png" alt="操作系统（五）——IO管理——IO机械部件.png"><p>我们平时使用的鼠标、键盘还有显示器，这些我们看得见摸得着的机械部分就是机械部件，这些机械部件主要用来执行具体的IO操作。比如说显示屏就是用来显示输出数据。</p><p>而电子部件一般来说就是印刷电路板。当我们的设备连上电脑以后，CPU是没办法直接控制这些IO设备的机械部件，必须通过电子部件来间接的控制这些机械部件。</p><p>因此电子部件(I&#x2F;O控制器)就是一个CPU和IO设备的机械部件之间的一个中介。I&#x2F;O控制器其实就是用于实现CPU对I&#x2F;O设备的控制的。</p><p>I&#x2F;O控制器的功能如下图：</p><img src="https://pic.imgdb.cn/item/666b03c9d9c307b7e92c1ac4.png" alt="操作系统（五）——IO管理——IO电子部件.png"><p><strong>I&#x2F;O控制器首先要能接收和识别CPU发出的命令</strong>，除了命令本身外，CPU还会告诉I&#x2F;O控制器执行这个命令的一些相关参数。因此I&#x2F;O控制器中会有相应的控制寄存器来存放命令和参数。</p><p>其次，<strong>I&#x2F;O控制器还要能向CPU报告设备的状态</strong>，比如一个设备此时是忙碌还是空闲。CPU作为系统资源的管理者，当然也需要知道各个设备的相应状态。因此I&#x2F;O控制器中会有相应的状态寄存器，用于记录I&#x2F;O设备的当前状态。如：1表示空闲，0表示忙碌。CPU可以读取这个寄存器当中的内容，来判断设备此时的状态。</p><p>接着，<strong>I&#x2F;O控制器还需要实现数据交换的功能</strong>。I&#x2F;O控制器是CPU和I&#x2F;O设备机械部件的中介，所以需要作为数据交换的中间媒介。因此，l&#x2F;O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</p><p>最后，<strong>I&#x2F;O控制器需要实现地址识别的功能</strong>。I&#x2F;O控制器当中会设置各种各样的寄存器，并且每一组寄存器可能会有多个，为了识别这些寄存器，所以需要像给内存编址一样给个寄存器编上一个相应的地址。CPU在往这些寄存器当中读或者写数据的时候，就是通过这些寄存器对应的地址来进行操作的。I&#x2F;O控制器需要通过CPU提供的地址来判断，此时CPU想要操作的到底是哪一个寄存器。</p><p>下面看一下I&#x2F;O控制器由哪些部分组成：</p><img src="https://pic.imgdb.cn/item/666b0d0fd9c307b7e9424b83.png" alt="操作系统（五）——IO管理——IO控制器组成1.png"><p>一般来说，I&#x2F;O控制器可以分为三个部分，第一个部分是CPU与控制器的接口，第二个部分叫做I&#x2F;O逻辑，第三个部分是控制器与设备的接口。</p><p>I&#x2F;O控制器作为CPU和机械部件之间的中介，如上图，CPU与控制器的接口负责I&#x2F;O控制器与CPU连接。控制器与设备的接口负责I&#x2F;O控制器与设备的机械部件连接。而I&#x2F;O控制器在连接CPU和设备的时候，需要做一些中间处理，这些处理就在I&#x2F;O逻辑部分完成。</p><p>因此，I&#x2F;O逻辑会负责接收和识别CPU的各种命令（如地址译码），在接收和识别了CPU的命令之后，I&#x2F;O逻辑需要把它翻译成具体的设备能够明白的命令，然后通过控制器与设备之间的接口，发送给具体的设备，让设备执行相应的操作。</p><p>在上图可以发现，一个I&#x2F;O控制器可能会有多个控制器与设备之间的接口，也就是说一个I&#x2F;O控制器有可能会负责控制多个具体的I&#x2F;O设备。此时CPU为了区别要操作的是哪一个设备，同样需要给这些设备进行编号，CPU在发出I&#x2F;O命令的时候，也需要指明自己需要操作的是哪个设备。</p><p>来看一下具体过程，如上图，CPU首先会通过一个叫做控制线的线路，向I&#x2F;O控制器发出一个具体的指令。同时，CPU还会在地址线上说明自己要操作的是哪一个设备。如果说，此时是要输出一个数据，CPU会通过数据总线把自己要输出的数据放到I&#x2F;O控制器的数据寄存器当中，之后I&#x2F;O逻辑就可以从数据寄存器当中取得CPU想要输出的数据。类似的，CPU此时发出的这个I&#x2F;O指令可能会有一些相应的参数，这些参数会放到控制寄存器当中，I&#x2F;O逻辑就可以从控制寄存器当中取得相应的参数。另外为了实现对各个设备的管理，CPU还会从状态寄存器当中读出各个设备的状态，因此I&#x2F;O逻辑会往状态寄存器当中写入相应的数据，来告诉CPU各个设备的状态到底是什么样的。这就是CPU与控制器的接口所需要完成的一些事情。</p><p>现在看一下控制器与设备的接口需要做哪些事情，如果输出一个数据，首先就是由CPU通过数据总线把数据写入到数据寄存器当中，之后I&#x2F;O逻辑就可以从数据寄存器当中取得CPU想要输出的数据，然后通过控制器与设备的接口把数据输出到外部设备上。类似的，如果要输入一个数据，这些数据可以通过控制器与设备的接口输入，然后I&#x2F;O逻辑就可以把这些数据放到数据寄存器当中，之后CPU从数据寄存器当中取走数据。这就完成了数据输入的过程。那除了传送数据，设备还需要及时向I&#x2F;O控制器反馈自己的状态，同样的，设备通过控制器与设备的接口像I&#x2F;O控制器报告此时自己的状态，然后I&#x2F;O控制器的I&#x2F;O逻辑又会把这个设备的状态写入到对应的状态寄存器里。另外，制器与设备的接口中还会有一个用于实现设备控制的电路，I&#x2F;O逻辑会根据CPU发出的命令和相应的参数，然后对对应的设备发出一些控制命令。</p><p>这地方有两个小细节需要注意一下，如下图：</p><img src="https://pic.imgdb.cn/item/666b0408d9c307b7e92ca364.png" alt="操作系统（五）——IO管理——IO控制器组成.png"><p>对于上图所说的两个注意点，这里要补充一下知识，一般来说给寄存器编址有两种方式，第一种方式就是让他们占用内存地址的一部分，这种方式称为内存映像I&#x2F;O。另一种方式就是会采用I&#x2F;O专用的地址，也就是寄存器独立编制。</p><p>下面看一下这两种方式的区别：</p><img src="https://pic.imgdb.cn/item/666b0447d9c307b7e92d2928.png" alt="操作系统（五）——IO管理——内存映像和寄存器独立编址.png"><p>如果采用内存映像I&#x2F;O，如上图左，假设内存共有N个地址，编号分别是0到N-1。如果系统中有一个设备控制器0，它有三个对应的寄存器，这些寄存器就会顺着内存地址继续往下编制，寄存器0的地址是N，寄存器1的地址是N+1，寄存器2的地址是N+2，然后依次类推。如果还有别的设备控制器，那依次往下编制。也就是说内存映像I&#x2F;O，控制器中的寄存器与内存地址统一编址。</p><p>如果采用寄存器独立编址的话，内存编号仍是分别是0到N-1，如果有一个设备控制器有三个寄存器，这些寄存器又会从0开始进行编号，如上图右，相应的，如果还有别的寄存器也会从0开始编号。不过在有的系统当中，也有可能是各个设备控制器当中的寄存器用连续编号的方式。这些细节部分可以忽略，只需要知道寄存器独立编制，控制器中的寄存器与内存地址不统一编址。</p><p>采用寄存器独立编址有一个很明显的缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号。而采用内存映像I&#x2F;O，就不需要设置专门的指令来支持对这些寄存器的操作，即可以采用对内存进行操作的指令来对控制器进行操作。</p><p>下面对这小结进行一个总结：</p><img src="https://pic.imgdb.cn/item/666b048cd9c307b7e92dc289.png" alt="操作系统（五）——IO管理——IO控制器小结.png"><h2 id="3-I-O控制方式"><a href="#3-I-O控制方式" class="headerlink" title="3. I&#x2F;O控制方式"></a>3. I&#x2F;O控制方式</h2><p>随着计算机的发展，I&#x2F;O控制器也是在不停的发展的，相应的，I&#x2F;O控制器对设备的控制方式也出现了不同的变化，本节要掌握下图的四种I&#x2F;O控制方式。</p><img src="https://pic.imgdb.cn/item/667bccb8d9c307b7e950fc27.png" alt="操作系统（五）——IO管理——IO控制方式.png"><p>注意，在学习这几个I&#x2F;O控制方式时，要注意研究上图提出的几个问题。</p><h3 id="3-1-程序直接控制方式"><a href="#3-1-程序直接控制方式" class="headerlink" title="3.1 程序直接控制方式"></a>3.1 程序直接控制方式</h3><p>下面来分析一下，采用程序直接控制方式，完成一次读写操作的流程是什么样的，这里以读操作为例：</p><img src="https://pic.imgdb.cn/item/667bcda5d9c307b7e952adcc.png" alt="操作系统（五）——IO管理——程序直接控制方式1.png"><p>如上图，在2.I&#x2F;O控制器里我们知道，一个I&#x2F;O控制器有如上图右的结构组成。</p><p>如果要进行读操作，CPU会首先通过控制线向I&#x2F;O控制器发出一条读指令，然后I&#x2F;O控制器会根据CPU的要求来启动相应的设备，并且会把这个设备对应的状态设置为未就绪，或者忙碌的状态，假设状态寄存器为1表示这个设备忙碌。</p><p>接下来这个设备就会开始准备计算机想要读入的数据。但是由于设备的速度要比CPU慢很多，所以在设备还没有完成I&#x2F;O之前，CPU会一直不断的轮询检查这个设备的状态，也就是检查状态寄存器中的数据，如果数字为1就表明这个设备在忙碌，还没有准备好想要读入的数据。</p><img src="https://pic.imgdb.cn/item/667bd18ed9c307b7e95937f7.png" alt="操作系统（五）——IO管理——程序直接控制方式2.png"><p>再接下来，如果设备准备好了输入的数据，那么这个设备就会给I&#x2F;O控制器传送这一次要输入的数据，并且报告自己的状态已经变成了已就绪的状态。</p><p>然后，I&#x2F;O逻辑会把这个设备传送来的数据放入数据寄存器当中，并且会把状态寄存器改为0，即已就绪的状态。在这个过程中，CPU也是在不停的轮询检查的，当它发现状态寄存器变为了0，CPU就可以从数据寄存器当中，取出此次要输入的数据。</p><p>在取出此次要输入数据的过程中，CPU首先会把这个数据读到CPU自己的寄存器当中。然后再把CPU寄存器当中的内容再放到内存当中。所以数据输入的过程，本来是要从设备输入到内存，但这个过程中必须先经过CPU的寄存器，然后再由寄存器转存到内存当中，这样就完成了一次读操作。</p><p>如果之后还要继续读数据，CPU就会发送下一条读指令，然后继续循环上面的过程。</p><p>采用程序直接控制方式的流程图如下图右：</p><img src="https://pic.imgdb.cn/item/667bd1e4d9c307b7e959e367.png" alt="操作系统（五）——IO管理——程序直接控制方式3.png"> <p>这里说一下不易理解的点，在每个步骤后面都会有一个指向性信息，比如第一个步骤，给I&#x2F;O模块发出读命令的后面就有一个CPU-&gt;I&#x2F;O，其意思是读命令是CPU向I&#x2F;O控制器发出的，其余的几个步骤后面的指向性信息同理。</p><p>另外，这里还有一个不易理解的点，为什么数据读入CPU寄存器以后，还需要往存储器当中写入数据。这里可以结合上图的C语言代码来理解，如C语言代码里的scanf，就是从键盘这种I&#x2F;O设备里读入一个输入字符，并且赋值给其中某一个变量。而程序里定义的变量a,b,c,d等是存放在存储器也就是内存中的，所以这些数据从键盘读入以后，最终是要被放到存储器也就是内存中的，因此当CPU获得从键盘输入的数据以后，还需要把这些数据写入到相应的存储器的单元里。同理，printf输出数据时，也是把内存当中存储的变量的数据经过CPU输出到输出设备上。</p><p>接下来分析一下开篇提到的另外的几个问题：</p><img src="https://pic.imgdb.cn/item/667bdc10d9c307b7e96be7a7.png" alt="操作系统（五）——IO管理——程序直接控制方式4.png"><p>首先看一下CPU的干预频率，在使用程序直接控制方式的时候，CPU需要不断轮询检查I&#x2F;O操作是否已经完成，所以CPU干预的频率是很频繁的，不仅在I&#x2F;O操作开始之前和完成之后需要CPU的介入，在等待I&#x2F;O完成的过程中，CPU也需要不断的轮询检查。这也是程序直接控制方式的最大一个缺点。</p><p>下一个要关注的问题是程序的控制单位，从上面的分析中可以发现，每次读入或写出的数据量是一个字。</p><p>下一个要注意的是数据的流向，所谓数据流向就是上面分析的，在读入数据时，数据流向是从I&#x2F;O设备-&gt;CPU-&gt;内存。在输出数据时，数据流向是从内存-&gt;CPU-&gt;I&#x2F;O设备。所以每个字的读和写都需要CPU的介入和帮助。也就是说CPU需要花费大量时间来辅助I&#x2F;O完成。</p><p>最后要看一下程序直接控制方式的主要缺点和优点：</p><p>优点：实现简单，可以用软件的方式就可以实现。由于轮询的过程就是在执行一系列循环检查的指令，所以这种方式才称为“程序直接控制方式”。</p><p>缺点：CPU和I&#x2F;O设备只能串行工作，在CPU发出一条命令以后，并不能去做别的事情，需要一直不断的循环检查I&#x2F;O是否已完成，所以CPU长期处于“忙等”状态，CPU利用率低。相应的，当CPU在进行一些别的计算工作时，I&#x2F;O设备也是空闲的，所以I&#x2F;O设备的利用率也是低的。为了应对这种问题，人们提出了中断驱动方式。</p><h3 id="3-2-中断驱动方式"><a href="#3-2-中断驱动方式" class="headerlink" title="3.2 中断驱动方式"></a>3.2 中断驱动方式</h3><p>与程序直接控制方式相比，中断驱动方式主要是引入了中断机构，可以让CPU在发出I&#x2F;O指令之后，继续做别的事情，即切换到别的进程。中断驱动的流程图如下。</p><img src="https://pic.imgdb.cn/item/667bf980d9c307b7e99e861b.png" alt="操作系统（五）——IO管理——中断驱动控制方式.png"><p>由于I&#x2F;O设备速度很慢，而CPU又是一种速度很快的硬件机构，所以当CPU发出I&#x2F;O指令之后，可以把此时需要等待I&#x2F;O的进程先阻塞，然后CPU去做其它的事情，当I&#x2F;O完成之后，控制器会向CPU发出一个中断信号，CPU检测到中断信号以后，就会根据中断信号类型来执行相应的中断处理程序。在CPU处理中断的过程当中，会从I&#x2F;O控制器中读出一个字的数据传送到CPU寄存器，并且再写入主存。接下来CPU就可以恢复之前被阻塞的进程继续往下执行，当然也可以选择不恢复，让其在就绪队列里继续等待，然后先执行别的进程。</p><p>这里要注意两点：①CPU会在每个指令周期的末尾检查中断；②中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能，而且中断每次只能读入一个字的数据，所以如果要读入大量的数据，显然会发生大量的中断，这样也会导致系统的性能降低。</p><p>接下来分析一下开篇提到的另外的几个问题在中断方式里的情况：</p><img src="https://pic.imgdb.cn/item/667bfc22d9c307b7e9a30997.png" alt="操作系统（五）——IO管理——中断驱动控制方式1.png"><p>相比于之前的程序控制方式来说，采用中断方式的CPU干预的频率就降低了许多，CPU只需要在每次的I&#x2F;O操作开始之前发出一条指令，然后就可以做其它的事情；当I&#x2F;O完成之后，CPU也需要介入来处理相应的中断，而由于等待I&#x2F;O的过程中，CPU可以切换到别的进程，所以在引入了中断以后，才实现了CPU和I&#x2F;O设备并行工作的特点。</p><p>另外需要知道的是，每发出一个读&#x2F;写指令，就会读入或写出1个字大小的数据。</p><p>中断驱动方式的数据流向与前面的程序直接控制方式是相同的，在读入数据时，数据流向是从I&#x2F;O设备-&gt;CPU-&gt;内存。在输出数据时，数据流向是从内存-&gt;CPU-&gt;I&#x2F;O设备。</p><p>中断驱动方式的优点就是解决了程序直接控制方式的最大缺点，引入了中断技术之后，可以让CPU和I&#x2F;O设备并行的工作，然后CPU不需要再不停地轮询来检查I&#x2F;O是否完成。这样CPU和I&#x2F;O设备的利用率都得到了明显的提升。</p><p>而这种方式也存在很明显的缺点，就是每次只能传送一个字，所以当要传送大量数据时，就会发送很多次中断，而每次中断处理都会付出一定时间代价。所以中断如果发生太频繁，就会消耗较多的CPU时间。</p><p>另外，采用这种方式的时候，在读入数据或者写出数据的时候，都必须先经过CPU，但是通过之前的分析也可以知道，读入数据就是把I&#x2F;O设备准备好的数据放到内存里，而写出数据则是把内存准备好的数据写出到I&#x2F;O设备，所以为了把中间必须经过CPU中转的步骤省略掉，人们又提出了一种新的I&#x2F;O控制方式叫做DMA方式。</p><h3 id="3-3-DMA方式"><a href="#3-3-DMA方式" class="headerlink" title="3.3 DMA方式"></a>3.3 DMA方式</h3><img src="https://pic.imgdb.cn/item/667bfecad9c307b7e9a7ce21.png" alt="操作系统（五）——IO管理——DMA方式.png"><p>DMA方式又叫直接存储器存取，这种方式主要用于对于块设备的I&#x2F;O控制，相比于中断驱动方式，DMA的数据传送单位由”字”变成了”块”，每次会读入或写出一个块。</p><p>另外DMA的数据流向不再需要经过CPU，而是可以在DMA控制器的控制下，直接从设备放入内存或者从内存写出到设备。</p><p>而且，使用DMA方式，CPU对I&#x2F;O操作的干预频率也进一步降低，仅仅在传送一个或多个数据块的开始和结束时，才会需要CPU进行干预。</p><p>DMA方式的大致流程如上图左下，首先CPU会给I&#x2F;O模块发出一个读或者写一个块的命令，之后CPU就可以转头做其它的事情。接下来DMA控制器会根据CPU发出的命令参数，完成CPU指定的一系列读写工作，当CPU指定的这些块读完或者写完之后，又会由DMA控制器向CPU发出一个中断信号，让CPU介入处理这个中断。</p><p>在上面一直提到的DMA控制器也是一种I&#x2F;O控制器，只不过存在一些小区别，DMA控制器的组成如下图：</p><img src="https://pic.imgdb.cn/item/667c00c7d9c307b7e9ab5610.png" alt="操作系统（五）——IO管理——DMA方式1.png"><p>DMA控制器同样由三部分组成，第一部分是主机与控制器的接口，第二部分是I&#x2F;O控制逻辑，第三部分是块设备和控制器接口。</p><p>为了实现DMA控制器和CPU之间的通信，还会再DMA控制器里设置一系列寄存器，如上图，然后CPU可以通过系统总线来读或者写DMA控制器当中某些寄存器的内容，用这种方式达到控制I&#x2F;O设备的一个目的。</p><p>这里说明一下，上图中的寄存器以及其作用都已经给出，这里就不再详细叙述。但是要知道，和之前说的I&#x2F;O控制器一样，这些寄存器也有可能有多个，上图只列出几个主要的，并没有列全。</p><p>在控制器和块设备之间也有一个相应的接口，通过这个接口可以实现控制器对于这些块设备的通信控制的过程。</p><p>系统总线还会把DMA控制器和内存连接在一起，所以DMA控制器和内存之间可以直接进行数据的读写，不再需要经过CPU。比如说CPU在刚开始可以指明这次要读的数据是存放在磁盘的什么位置，读入的数据要存放在内存的什么位置，这个信息是存放在DMA控制器的MAR里的，并且还会说明此次要读入数据的数据量，数据量存放在DC里。接下来DMA控制器就会跟据CPU提供的这一系列的参数，从磁盘的相应位置，读入数据，然后写到内存里，这个过程就不再需要CPU的干预，只有DMA控制器完成了整个CPU指定的这一系列动作以后，才会向CPU发出一个中断信号，然后CPU再进行后续的处理。</p><p>这里要注意，DMA控制器并不是每次直接读入一整块的数据，然后把一整块放到内存当中，其实DMA控制器在读入数据的过程当中，也是一个字一个字的读入，然后每次读入的一个字都是先存放在DR，也就是数据寄存器当中，再从DR写入到内存当中。通过这种一个字一个字的方式，最终就可以完成一地址块数据读入的工作。</p><p>采用DMA方式完成一次读写操作的流程就是上面所说，接下来继续研究DMA方式：</p><img src="https://pic.imgdb.cn/item/667c0b8dd9c307b7e9c08f65.png" alt="操作系统（五）——IO管理——DMA方式2.png"><p>首先还是再看DMA的CPU的干预频率，在采用DMA方式以后，CPU的干预频率就进一步降低，仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。在开始之前，CPU需要发出相应的I&#x2F;O指令，并且指明相应的参数；在结束之后，CPU需要处理中断，然后进行后续的一系列处理。</p><p>另外，DMA方式的数据传送单位也从一个字变成了一个块，CPU每发出一个读指令或者写指令之后，DMA控制器就会完成对一个块或者多个块的读和写的操作，但需要注意的是，这个地方指的多个块，只能是读写连续的多个块，并且这些块在读入内存以后也必须是连续存放的。也就是说，如果想要读入多个离散的块或者想把读入的块离散的存放在内存的不同位置，那么采用DMA方式同样是需要CPU发出多条I&#x2F;O指令。</p><p>采用DMA方式以后，数据的流向就不再需要经过CPU，它可以直接从I&#x2F;O设备读入，然后再DMA控制器的控制下，直接把数据放入到内存，在输出时刚好相反。</p><p>DMA方式的优点就是进一步提升了数据传输的效率，数据传输以块为单位，CPU介入频率进一步降低，这样的话，CPU就可以有更多的时间去进行别的处理，另外数据传输的过程也不再需要经过CPU，所以数据传送的效率也进一步增加。总而言之，CPU和I&#x2F;O设备的并行性得到提升，资源利用率也得到了进一步的提升。</p><p>DMA方式的缺点就是上面刚刚说到的，CPU每发出一条l&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块。如果想要读入多个离散的块或者想把读入的块离散的存放在内存的不同位置，那么采用DMA方式同样是需要CPU发出多条I&#x2F;O指令。为了解决这个问题，人们又提出了通道控制方式。</p><h3 id="3-4-通道控制方式"><a href="#3-4-通道控制方式" class="headerlink" title="3.4 通道控制方式"></a>3.4 通道控制方式</h3><img src="https://pic.imgdb.cn/item/667c0e97d9c307b7e9c680f4.png" alt="操作系统（五）——IO管理——通道控制方式1.png"><p>通道是一种硬件，可以理解为是”弱鸡版的CPU”，通道可以识别并执行一系列的通道指令。</p><p>首先，看一下通道的工作原理，如上图，CPU、内存、通道通过系统总线连接到一起。CPU会先向通道这个硬件发出I&#x2F;O指令，并且指明此次要执行的通道程序(即通道指令的序列)是存放在内存的什么位置的，同时CPU还要指明此次要执行操作的设备是哪一个，在把这些信息告诉通道以后，CPU就可以切换到其它进程执行。</p><p>接下来通道会根据CPU的指示，去找到此次要执行的通道程序存放在内存当中的哪个位置，这个通道程序可以理解为任务清单(就是一些利通道指令的集合)。在通道程序的通道指令当中，会向通道指明此次要读入和写出的数据是多少，读写的数据要放到或存在于内存当中的什么位置等一系列信息，这些都是通道在执行这个程序的过程当中就可以知道的事情。所以采用这种方式，就相等于CPU只是告诉通道现在去执行一个任务，任务清单已经放到内存里，但具体任务的内容要做什么并不是由CPU直接告诉通道，而是由通道去读取内存当中的通道程序，然后一步一步执行的。</p><p>当通道执行完一系列任务之后，就会向CPU发出一个中断信号，CPU接收到中断信号以后，对中断进行处理，然后再继续执行接下来的一系列程序。</p><p>上面就是通道控制方式当中，完成一次I&#x2F;O所需要经历的一系列步骤。现在要思考一个问题，为什么说通道是“弱鸡版的CPU”？</p><img src="https://pic.imgdb.cn/item/667c11a2d9c307b7e9cde135.png" alt="操作系统（五）——IO管理——通道控制方式2.png"><p>说通道是“弱鸡版的CPU”是因为与CPU相比，通道可以执行的指令很单一，并且通道也没有自己的内存，通道程序是放在主机内存中的，也就是说通道与CPU共享内存，因此可以把通道理解为是弱鸡版的CPU。</p><p>引入了通道以后，CPU的干预频率就进一步降低，CPU可以一次扔给通道一堆事情，这些事情会写在通道程序里，所以通道可以根据通道程序的指示一步一步完成I&#x2F;O操作，然后当它完成了一系列的数据块读写以后，才需要对CPU发出中断信号，因此CPU的干预频率是极低的。</p><p>在通道控制方式中，每次读写可以完成对一组数据块的读写操作。</p><p>与DMA类似，采用通道控制方式之后，可以在通道的控制下，让数据直接从I&#x2F;O设备读入内存，或者直接把内存中的数据直接输出到I&#x2F;O设备当中。</p><p>通道方式的主要缺点就是实现复杂，需要专门的通道硬件支持。</p><p>但通道方式的优点也很明显，就是CPU、通道、l&#x2F;O设备可并行工作，资源利用率很高。</p><h3 id="3-5-I-O控制方式小结"><a href="#3-5-I-O控制方式小结" class="headerlink" title="3.5 I&#x2F;O控制方式小结"></a>3.5 I&#x2F;O控制方式小结</h3><img src="https://pic.imgdb.cn/item/667c1353d9c307b7e9d194f1.png" alt="操作系统（五）——IO管理——IO控制方式小结.png"><h2 id="4-I-O软件层次结构"><a href="#4-I-O软件层次结构" class="headerlink" title="4. I&#x2F;O软件层次结构"></a>4. I&#x2F;O软件层次结构</h2><p>I&#x2F;O软件层次从上至下，依次可以分为用户层软件、设备独立性软件、设备驱动程序、中断处理程序这样的四层，如下图：</p><img src="https://pic.imgdb.cn/item/667c24eed9c307b7e9f775a8.png" alt="操作系统（五）——IO管理——IO软件层次结构知识总览.png"><p>从上图还可以看到，在I&#x2F;O软件的下层是I&#x2F;O的硬件设备，而I&#x2F;O设备的硬件又是由机械部分和电子部分组成，而I&#x2F;O硬件的组成和原理在I&#x2F;O控制器部分已经说过，这部分重点关注软件层面要实现的功能。</p><p>另外，I&#x2F;O软件层次里的下面三层，即设备独立性软件、设备驱动程序、中断处理程序属于操作系统内核部分，所以这三层也可以被称为I&#x2F;O核心子系统或简称I&#x2F;O系统。上面的用户层软件是在操作系统内核之外的，也就是可以在用户态下实现一系列的功能。</p><p>从上面的示意图中还可以看到，在这些层次结构当中，越靠近上层的越接近用户，越靠近下层的越接近硬件。而各个层次都会使用它们下面一层软件所提供的功能，并且向它上层的软件提供一些服务。像这种，每一层会利用其下层提供的服务，实现某些功能，并屏蔽实现的具体细节，向高层提供更简单易用的接口，这种思想就是封装思想。</p><p>当用户发出一个I&#x2F;O请求的时候，这个I&#x2F;O请求会从上至下，经过各个层次进行处理，最后被扔给I&#x2F;O硬件，来执行实际的I&#x2F;O操作。当I&#x2F;O硬件做完这次I&#x2F;O操作，发出I&#x2F;O应答的时候，又会由这些层次从下往上依次进行处理，最后返回给用户。</p><p>接下来按照从上至下的顺序，依次分析一下各个层次所需要实现的功能。</p><h3 id="4-1-用户层软件"><a href="#4-1-用户层软件" class="headerlink" title="4.1 用户层软件"></a>4.1 用户层软件</h3><img src="https://pic.imgdb.cn/item/667c287dd9c307b7e9fed153.png" alt="操作系统（五）——IO管理——用户层软件.png"><p>用户层作为最接近用户的一个层次，需要向用户提供一些简单易用的交互的接口。一般来说，用户层软件会向用户提供一些与I&#x2F;O操作相关的库函数，让用户调用这些库函数来对设备进行操作。比如C语言里的printf，就是在显示屏这个I&#x2F;O设备上打印输出。</p><p>既然需要使用I&#x2F;O设备进行输出操作，所以用户层软件需要请求操作系统提供服务，因为只有操作系统才有对硬件操作的权利，因此用户层软件会使用设备独立性软件这一层向上提供的系统调用接口，来请求操作系统内核的服务。比如printf(“hello world”)这样一句代码，在用户层软件处理完了以后，会把它翻译成等价的write系统调用，当然在进行write调用时，也会填入相应的参数，比如打印输出的内容。</p><p>这里注意一下，<strong>设备独立性软件向上层提供了系统调用的接口，而设备独立性软件是用来处理系统调用的一个层次</strong>。所以有的题目中也会<strong>把设备独立性软件这一层称为系统调用处理层</strong>。像我们熟悉的Windows操作系统就会向外提供一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此windows系统在用户层上封装了一系列更方便的库函数接口供用户使用( Windows API)。</p><h3 id="4-2-设备独立性软件"><a href="#4-2-设备独立性软件" class="headerlink" title="4.2 设备独立性软件"></a>4.2 设备独立性软件</h3><p>设备独立性软件，又被称为设备无关性软件，而与设备的硬件特性无关的功能几乎都在这一层实现。下面看一下这层要实现哪些功能、</p><img src="https://pic.imgdb.cn/item/667c28e2d9c307b7e9ffa131.png" alt="操作系统（五）——IO管理——设备独立性软件功能一.png"><p>像在4.1用户层软件里所说，这一层要实现的第一个功能就是要向上层提供一个统一的调用接口。</p><img src="https://pic.imgdb.cn/item/667c291cd9c307b7e9001340.png" alt="操作系统（五）——IO管理——设备独立性软件功能二.png"><p>第二个要实现的功能是设备的保护。对设备的保护原理类似于对文件的保护，在很多操作系统当中，设备会被看做是一种特殊的文件，而不同的用户对各个文件的访问权限是不一样的。既然设备被看作是一种特殊的文件，相应的不同的用户对设备这种特殊的文件的访问权限肯定也是不一样的，因此操作系统需要提供设备保护的功能。</p><img src="https://pic.imgdb.cn/item/667c2943d9c307b7e90061d5.png" alt="操作系统（五）——IO管理——设备独立性软件功能三.png"><p>第三个要实现的功能是差错处理，就是对设备产生的一些错误进行处理。注意，因为差错的类型是有很多的，所以这个地方有印象即可，不需要了解差错处理的细节。</p><img src="https://pic.imgdb.cn/item/667c2961d9c307b7e9009b52.png" alt="操作系统（五）——IO管理——设备独立性软件功能四.png"><p>第四个要实现的功能是设备的分配与回收，因为很多设备是一种临界资源，不可以同时分配给多个进程使用，所以操作系统需要对设备这种资源进行分配与回收的管理。</p><img src="https://pic.imgdb.cn/item/667c2987d9c307b7e900f309.png" alt="操作系统（五）——IO管理——设备独立性软件功能五.png"><p>第五个要实现的功能是数据缓冲区管理，数据缓冲区是用来屏蔽各个设备之间数据交换单位大小，还有传输速度的差异。至于具体实现的细节会在后面进行介绍。</p><img src="https://pic.imgdb.cn/item/667c29acd9c307b7e901373f.png" alt="操作系统（五）——IO管理——设备独立性软件功能六.png"><p>第六个要实现的功能是建立逻辑设备名到物理设备名的映射关系，并且根据设备的类型来选择调用相应的驱动程序。</p><p>这里说一下逻辑设备名和物理设备名，所谓逻辑设备名就是用户在请求使用一个设备的时候，所提供的名字，也就是用户所看到的设备名。比如说平时在打印店打印的时候，因为打印店里的电脑都会连上很多台打印机，所以在进行打印时，会被让选择哪一台进行打印，在选择时会看到打印机1、打印机2等，这些用户看到的设备名就是逻辑上的设备名。操作系统对这些设备进行管理在背后还会有一个叫做物理设备名的东西。</p><p>所以当我们选择某一个逻辑设备的时候，操作系统需要知道这个逻辑设备具体对应的到底是哪一个物理设备。一般来说，这个映射关系是通过一个叫做<strong>逻辑设备表</strong>的东西来实现的，并且在这个逻辑设备表中，还会记录每一个逻辑设备对应的设备驱动程序的入口地址，如下图。</p><img src="https://pic.imgdb.cn/item/667c29d9d9c307b7e901a6b2.png" alt="操作系统（五）——IO管理——设备独立性软件功能六补充.png"><p>在上图中可以看到，逻辑设备名还带有类似于文件路径的东西，这就是刚刚所说的，很多操作系统会把设备当做是一种特殊的文件，所以这个文件当然也会有一个存储的路径，每一个表项记录了逻辑设备名到物理设备名的映射关系，并且还记录了这个设备它所对应的驱动程序的入口地址在什么地方。</p><p>一般来说会用两种方式来管理逻辑设备表。第一种方式是整个系统只设置一张逻辑设备表，但是由于各个用户在使用设备时，使用的都是逻辑设备名，而操作系统又是根据逻辑设备名来查找逻辑设备表的表项的，所以如果不同的用户使用相同的逻辑设备名，就有可能导致这个逻辑设备到物理设备映射紊乱的问题，所以其实整个系统只设置一张逻辑设备表这种方式，只适用于单用户的操作系统。</p><p>第二种方式是为每一个用户设置一张逻辑设备表，采用这种方式不同用户所使用的逻辑设备名可以是重复的，并且相同的逻辑设备名，可以被映射到不同的物理设备上去。</p><p>上面还说到另一个问题，就是不同类型的I&#x2F;O设备需要有不同的驱动程序，这是为什么呢？下面看一下设备驱动程序的概念。</p><h3 id="4-3-设备驱动程序"><a href="#4-3-设备驱动程序" class="headerlink" title="4.3 设备驱动程序"></a>4.3 设备驱动程序</h3><p>我们在网上搜索打印机会发现有各种品牌的各式各样的打印机，不同品牌的打印机外形不同，并且内部的电子部件（I&#x2F;O控制器）也有可能是不同的结构，比如假设下图是佳能打印机内部结构。</p><img src="https://pic.imgdb.cn/item/667cc1f8d9c307b7e9bd60ee.png" alt="操作系统（五）——IO管理——佳能打印机内部结构.png"><p>可以看到佳能打印机内部总共有两个数据寄存器，它的状态寄存器当中0代表空闲，1代表忙碌。</p><p>但是换成惠普打印机，其内部结构可能又是另一种样子，如下图：</p><img src="https://pic.imgdb.cn/item/667cc25ad9c307b7e9bdefde.png" alt="操作系统（五）——IO管理——惠普打印机内部结构.png"><p>可以看到惠普打印机内部只有一个数据寄存器，它的状态寄存器当中1代表空闲，0代表忙碌，与佳能打印机刚好相反。</p><p>我们将这两个例子总结到下图：</p><img src="https://pic.imgdb.cn/item/667cc2b4d9c307b7e9be6c7c.png" alt="操作系统（五）——IO管理——驱动程序.png"><p>通过例子可以发现，不同型号的设备内部的电子部件有可能是完全不一样的，各个设备内部的硬件特性只有设计者才知道。所以操作系统要通过这些设备的控制器来控制这些设备的具体运行的话，那操作系统肯定需要了解这些设备内部的硬件细节。不过这些IO设备多种多样，所以操作系统不可能了解所有的设备的内部细节，因此这些设备在出厂的时候，一般来说厂家会提供一个与设备对应的驱动程序，然后当要控制某个设备的时候，CPU只需要执行这个设备相对应的驱动程序就可以完成对这个设备控制器的控制。</p><p>所以在生活中可以发现，当给计算机插上一个新的机械键盘或鼠标时，在这些设备第一次被插上电脑时，电脑的右下角会有一个正在安装驱动程序的小弹窗，这个自动安装的驱动程序就是由厂家提供的，为了让操作系统实现对新的设备硬件进行具体控制的一个程序。所以设备独立性软件不可以直接操作硬件，必须调用厂家提供的设备驱动程序，由这个设备驱动程序来完成对硬件的具体控制。</p><p>各个类型的驱动程序一般来说在系统中会以一个独立进程的方式运行存在。所以再看一下刚刚的逻辑设备表，如下图，为什么不同的设备要对应不同的驱动程序呢，就是因为各种设备内部的硬件特性是不一样的，因此必须执行与它对应的特定的驱动程序，才可以正常的完成对这个设备硬件的控制。比如要使用打印机1，那么操作系统就会查询下图的设备记录表，找到设备对应的驱动程序的入口，然后找到对应的驱动程序。</p><img src="https://pic.imgdb.cn/item/667cc425d9c307b7e9c05dd8.png" alt="操作系统（五）——IO管理——设备驱动程序.png"><h3 id="4-4-中断处理程序"><a href="#4-4-中断处理程序" class="headerlink" title="4.4 中断处理程序"></a>4.4 中断处理程序</h3><img src="https://pic.imgdb.cn/item/667cc6cbd9c307b7e9c3dfe9.png" alt="操作系统（五）——IO管理——中断处理程序.png"><p>当硬件设备完成I&#x2F;O操作以后，它会发出一个中断信号，作为I&#x2F;O应答，系统会根据这个中断信号的类型来找到与这个中断信号对应的中断处理程序，然后执行这个程序，进行中断处理。</p><p>中断程序对中断的处理流程如上图。首先，中断处理程序会从I&#x2F;O控制器（设备控制器）当中读出设备的状态，来判断这一次的I&#x2F;O是否是正常的结束。如果此次是正常的结束，接下来中断处理程序会从设备控制器的数据寄存器当中读出一个字的数据，并且经由CPU放到内存缓冲区当中，这就完成了一个字的读入。如果此次I&#x2F;O是非正常结束，系统会根据异常的原因做出相应的处理。这就是中断处理程序所需要做的事情。</p><p>当中断处理程序把这一次要输入的数据放到内存之后，接下来会交由设备驱动程序对这些数据进行进一步的处理。等设备驱动程序处理完了以后，又会再交由上一层的设备独立性软件进行再进一步的处理，最后一层一层往上，然后一直返回给用户。所以如果要输入一个数据的话，对这个数据的处理应该是从下往上依次层层处理的。</p><p>经过分析可以发现，除了设备驱动程序会直接和硬件打交道以为，中断处理程序也需要直接和硬件打交道。但是再往上的设备独立性软件和用户层软件就不会直接和硬件打交道了。</p><h3 id="4-5-I-O软件层次小结"><a href="#4-5-I-O软件层次小结" class="headerlink" title="4.5 I&#x2F;O软件层次小结"></a>4.5 I&#x2F;O软件层次小结</h3><img src="https://pic.imgdb.cn/item/667cc974d9c307b7e9c82c78.png" alt="操作系统（五）——IO管理——IO软件层次小结.png"><img src="https://pic.imgdb.cn/item/667cc9aad9c307b7e9c870f3.png" alt="操作系统（五）——IO管理——IO软件层次小结1.png"><h2 id="5-输入输出应用程序接口和驱动程序接口"><a href="#5-输入输出应用程序接口和驱动程序接口" class="headerlink" title="5. 输入输出应用程序接口和驱动程序接口"></a>5. 输入输出应用程序接口和驱动程序接口</h2><img src="https://pic.imgdb.cn/item/667ce3c7d9c307b7e9f0e26d.png" alt="操作系统（五）——IO管理——输入输出应用程序接口知识总览.png"><p>本节要掌握输入&#x2F;输出应用程序接口和设备驱动程序接口。其中输入&#x2F;输出应用程序接口又分为字符设备接口、块设备接口和网络设备接口。另外还需要认识什么是阻塞I&#x2F;O，什么是非阻塞I&#x2F;O。</p><p>下面首先看一下什么是输入&#x2F;输出应用程序接口，结合下图理解。</p><img src="https://pic.imgdb.cn/item/667ce850d9c307b7e9f7592f.png" alt="操作系统（五）——IO管理——输入输出应用程序接口.png"><p>I&#x2F;O软件分为多个层次，上层的用户应用程序需要通过系统调用的方式来请求使用底层的某一种I&#x2F;O设备，而I&#x2F;O设备的种类特性非常的多样化，所以上层的应用程序很难通过一个统一的系统调用接口来操作所以类型的I&#x2F;O设备。比如像块设备（如磁盘）就是有寻址的概念，同时块设备支持多个字节的读写，因此当我们自己写程序时，要用系统调用的方式从块设备中读入数据，那么read调用就要先指明要操作的是哪个块设备，另外还可以指明此次要读入几个字节，同时还可以指明要从哪个地方开始读。</p><p>上面是块设备的读入方法，但这种读入方法显然不适用于字符设备，因此字符设备不可寻址。比如键盘就是最典型的输入型字符设备，键盘是没有地址的概念。所以在用系统调用从键盘中读入一个字符的时候，不可能指明从哪个地址读入。</p><p>因此可以看到，由于底层的设备多种多样，对于各种设备的I&#x2F;O读写，所需要提供的参数也各不相同，因此很显然用户层的应用程序无法用一个统一的系统调用接口来完成所以类型设备的I&#x2F;O。</p><p>所以设备独立软件这一层，需要对上一层的应用程序提供若干种类型的程序接口，上层应用程序如果访问的是字符设备或者块设备和网络设备，那么它所调用的系统调用接口是各不相同的。</p><p>下面来分别看一下这三种设备的接口有什么特性：</p><img src="https://pic.imgdb.cn/item/667cecebd9c307b7e9feb6d4.png" alt="操作系统（五）——IO管理——三种设备接口.png"><p>用户层的软件如果要使用一个字符型设备，要对字符型设备进行读或者写，那么可以采用get和put这两个系统调用，get是从指定的字符设备当中读出一个字符，put是往指定的字符设备当中写入一个字符，数据的读写是以字符为单位的。</p><p>块设备的系统调用接口是read和write系统调用，块设备有地址的概念，可以用seek系统调用来指定读写指针要放到磁盘的哪个地址。放到这个地址以后就可以使用read或write往读写指针所指的位置后面读写若干位的字符。</p><p>接下来详细说一下可能不是很熟悉的网络设备接口。电脑里会有网卡，这个网卡就是所谓的网络控制器，用于收发网络数据包。显然，电脑上的网络控制器可能会收到很多很多的数据包，而不同的数据包应该丢给不同的应用程序，这时候就要区分这个数据包是给哪个应用程序的。</p><p>为了区分网卡接收到的数据包是给哪个应用程序的，网络设备接口(网络套接字接口)，会向上层的应用程序提供socket系统调用，这个系统调用的作用是可以创建一个网络套接字，另外在创建时还需要指明连接的网络协议是什么协议，比如TCP或UDP。</p><p>有了网络套接字以后就可以使用bind系统调用，把套接字绑定到本地的某一个端口上，再结合本机的IP地址，这个端口号就可以映射到计算机当中的某一个应用程序上。</p><p>在网络设备接口里，设备独立性软件还提供了connect的系统调用，这个系统调用可以把套接字连接到远程的某一个主机上，当网络套接字初始化完毕以后，就可以使用read或write对网络套接字进行数据的读写。</p><p>接下来根据图示来理解一下进程是如何使用网络设备接口来实现网络通信的：</p><img src="https://pic.imgdb.cn/item/667cf13ad9c307b7e905bd73.png" alt="操作系统（五）——IO管理——网络设备接口1.png"><p>如上图，有两台主机，它们之间使用网络进行连接，每一台主机上可能会同时运行多个进程，比如主机1就同时运行了P1和P2两个进程。另外每一台主机都会有一个网络控制器，也就是网卡，用于实现网络数据包的收发。同时每一台主机都会有各自的IP地址，每个进程都会有自己的进程用户空间，同时操作系统内核也会有操作系统内核的空间。</p><p>现在P3这个进程要使用网络通信，它可以先使用socket系统调用来创建一个网络套接字(套接字简单理解就是申请一片内核空间用于接收和发送数据)。socket系统调用会给用户进程返回一个描述符(可以理解为就是指向套接字的指针)。有了套接字对象之后，还需要把套接字绑定到本地的某一个端口，比如上图是绑定到6666这个端口，这样主机2的套接字就可以等待着被连接。</p><p>同理，主机1也可以进行相同的操作，P1进程也通过socket系统调用，来申请创建一个套接字对象，并通过bind系统调用绑定到本地端口211。</p><p>现在两个主机都有了各自的套接字，同时也确定了各自的一个数据收发端口号，接下来一步要做的事情就是使用connect系统调用，把本机的套接字连接到另一台机器的套接字上。比如说可以让主机1的P1进程使用connect系统调用，指明要把fd指向的套接字(P1刚刚申请的套接字)，连接到主机2的6666端口处，这个系统调用就会使得这两个套接字之间建立起一个连接，接下来两个主机就可以通过套接字进行通信。</p><p>比如P1现在想给P3发送一个数据包，如下图：</p><img src="https://pic.imgdb.cn/item/667cf826d9c307b7e9121f53.png" alt="操作系统（五）——IO管理——网络设备接口2.png"><p>P1首先在自己的用户区准备好这个数据，然后使用write系统调用指明要想fd指向的套接字当中写入数据。</p><p>设备独立性软件接收到write系统调用以后，就会把用户进程准备好的数据给复制到内核区，也就是套接字对应的缓冲区当中。这一步设备独立性软件这一层来完成的事情。</p><p>现在数据已经放到内核缓冲区里，接下来设备独立性软件这一层会调用网络控制器的驱动程序来处理这片数据，这个驱动程序会负责把准备好的数据给输出到网络设备上。</p><p>接下来网络控制器就可以把数据包给发送到网络上。数据包会顺着网线发送到主机2的网络控制器处。</p><p>主机2的网络控制器接收到一个数据包以后会向主机发出一个中断信号。主机2的中断处理程序发现中断信号是来自于网络控制器，因此中断处理程序接下来会调用网络控制器的驱动程序，让驱动程序来把网络控制器里收到的数据给它搬到内核的缓冲区里。因为早就知道这个数据应该发送到6666这个端口处，所以数据会被复制到6666这个端口所对应的内核缓冲区里。</p><p>现在数据已经一路发到主机2里，接下来P3这个进程要接收一个网络数据包，只需要使用read系统调用指明要从fd所指的这个套接字对象当中读出一个数据包。这个系统调用的结果就是，设备独立性软件会从缓冲区里把数据给复制到用户进程的用户去当中，这样用户进程P3就可以使用它收到的这一块数据。</p><p>接下来看一下阻塞I&#x2F;O和非阻塞I&#x2F;O的概念：</p><img src="https://pic.imgdb.cn/item/667cfab5d9c307b7e916b581.png" alt="操作系统（五）——IO管理——阻塞IO和非阻塞IO.png"><p>阻塞I&#x2F;O就是应用程序发出I&#x2F;O系统调用，进程需转为阻塞态等待。比如从键盘使用get读入一个字符，那么只要键盘的输入动作没有完成，这个进程就得一直等下去。</p><p>非阻塞l&#x2F;O就是应用程序发出I&#x2F;O系统调用，系统调用可迅速返回，进程无需阻塞等待。比如write系统调用往磁盘写数据，这个系统调用可以很快的被处理完，然后迅速的返回到用户进程让其继续往下执行。</p><p>接下来看一下设备驱动程序接口：</p><img src="https://pic.imgdb.cn/item/667cfb89d9c307b7e9183b79.png" alt="操作系统（五）——IO管理——设备驱动程序接口1.png"><p>同样从层次结构出发，设备独立性软件需要根据实际操作的设备不同去调用不一样的设备驱动程序。因此，若各公司开发的设备驱动程序接口不统一，则操作系统很难调用设备驱动程序。</p><p>所以操作系统会统一一个标准，要求设备的厂商在制作这个驱动程序的时候，按照规定好的统一标准来开发驱动程序，如下图。</p><img src="https://pic.imgdb.cn/item/667cfc4fd9c307b7e919a6c5.png" alt="操作系统（五）——IO管理——设备驱动程序接口2.png"><p>而由于不同的操作系统，对设备驱动程序接口的标准各不相同，所以设备厂商还必须根据各操作系统的接口要求，开发相应的设备驱动程序，设备才能被使用。</p><h2 id="6-I-O核心子系统"><a href="#6-I-O核心子系统" class="headerlink" title="6. I&#x2F;O核心子系统"></a>6. I&#x2F;O核心子系统</h2><img src="https://pic.imgdb.cn/item/667d0fbcd9c307b7e93f517d.png" alt="操作系统（五）——IO管理——IO核心子系统知识总览.png"><p>通过前面的学习可以知道，I&#x2F;O软件层次里的下面三层，即设备独立性软件、设备驱动程序、中断处理程序属于操作系统内核部分，所以这三层也可以被称为I&#x2F;O核心子系统或简称I&#x2F;O系统。因此，I&#x2F;O核心子系统要实现的功能其实就是中间三层要实现的功能，而这三层要实现的功能可以参考上面一节。</p><p>在考研中，我们需要重点理解和掌握的功能是：I&#x2F;O调度、设备保护、假脱机技术( SPOOLing技术）、设备分配与回收、缓冲区管理（即缓冲与高速缓存)。</p><p>下面看一下这些功能分别要在哪些层次实现：</p><img src="https://pic.imgdb.cn/item/667d10add9c307b7e940eef0.png" alt="操作系统（五）——IO管理——功能层次划分.png"><p>在上一节已经强调过，所以和硬件直接相关的肯定是设备驱动程序和中断处理程序需要负责的，但在刚刚提到的功能中，都没有与硬件直接相关的。</p><p>其中假脱机技术一般在用户层实现。而I&#x2F;O调到、设备保护、设备分配与回收和缓冲区管理这几个功能是在设备独立性软件这一层实现。一般来说，假脱机技术都需要使用到磁盘这种设备的设备独立性软件这一层的服务，所以假脱机技术一般来说都是在用户层软件这一层实现。</p><p>本部分先主要介绍两个很熟悉的功能的实现，一个是I&#x2F;O调度，一个是设备保护。</p><p>下面首先看一下I&#x2F;O调度：</p><img src="https://pic.imgdb.cn/item/667d11cdd9c307b7e942f4e7.png" alt="操作系统（五）——IO管理——IO调度.png"><p>I&#x2F;O调度就是用某种算法确定一个好的顺序来处理各个I&#x2F;O请求。比如在第四章里学的磁盘调度，就是用某一种算法，来确定应该先满足哪些磁盘的访问请求。由于磁盘也是一种I&#x2F;O设备，所以磁盘调度也是一种I&#x2F;O调度的问题。</p><p>而I&#x2F;O调度的算法如上图提到，这些算法我们在前面已经学过，这里不再介绍。</p><p>接下来再看一下设备的保护：</p><img src="https://pic.imgdb.cn/item/667d1298d9c307b7e94448a3.png" alt="操作系统（五）——IO管理——设备保护.png"><p>设备的保护在上一节已经提及过，因为在UNIX系统中，设备会被看做是一种特殊的文件，因此其实系统也会为各个设备建立一个相应的FCB(文件控制块)，不同的用户对不同的文件是有不同的访问权限的，所以把设备看做是一种特殊的文件，当一个用户想要访问某个设备的时候，系统也会根据设备对应的FCB来判断一下这个用户是否有相应的访问权限。这样就实现了所谓的设备保护的功能，但它其实上也是文件保护那一块所需要做的事情(这个知识点可以参考第四章文件保护的知识)。 </p><h2 id="7-假脱机技术"><a href="#7-假脱机技术" class="headerlink" title="7. 假脱机技术"></a>7. 假脱机技术</h2><p>本节假脱机技术知识总览：</p><img src="https://pic.imgdb.cn/item/667d1406d9c307b7e946e6ee.png" alt="操作系统（五）——IO管理——假脱机技术知识总览.png"><p>首先看一下什么是假脱机技术：</p><img src="https://pic.imgdb.cn/item/667d1433d9c307b7e9473b32.png" alt="操作系统（五）——IO管理——什么是假脱机技术1.png"><p>在手工操作阶段，主机直接从I&#x2F;O设备获得数据，由于设备速度慢，主机速度很快。人机速度矛盾明显，主机要浪费很多时间来等待设备。</p><p>所以在批处理阶段，人们引入了脱机技术，刚开始的脱机技术是使用磁带实现的，如下图。</p><img src="https://pic.imgdb.cn/item/667d14add9c307b7e9480059.png" alt="操作系统（五）——IO管理——什么是假脱机技术2.png"><p>引入了脱机技术以后，程序员可以先用纸带机把自己的程序数据输入到磁带当中，磁带速度要比纸带机要快，而这个输入的过程是一台专门的外围控制机来实现的。</p><p>由于程序的数据首先被输入到更快速的磁带当中，而之后CPU可以直接从磁带中读取想要的输入数据，因此这就很大的缓解了这种速度矛盾。 也就是说引入了脱机输入技术以后，在数据输入的时候速度就快了很多。</p><p>在数据输出时同理，主机会先把数据输出到一个很快速的磁带上，之后又会由一个外围控制机控制着把磁带当中的数据依次的给输出到慢速的纸带机上。同样的由于磁带的速度的比纸带的速度快很多，因此CPU在输出时就可以节省很多等待输出完成的时间，这样就大大的提升了CPU的利用率。</p><p>脱机技术中的脱机，就是指脱离主机的控制进行输入&#x2F;输出操作，而在上面的介绍中也明白了在脱机技术中，输入输出是由外围控制机来实现的。显然CPU输入输出的过程并不需要主机或CPU的干预和控制，这样CPU就可以有更多的时间去处理别的计算内容。</p><p>引入脱机技术后，除了缓解了CPU与慢速I&#x2F;O设备的速度矛盾。还有另一好处就是，在输入时，即使CPU在忙碌，也可以在外围控制机的控制下提前将数据输入到磁带；而在输出时，即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带。</p><p>基于脱机技术的思想，人们又发明了假脱机技术，又叫SPOOLing技术，假脱机技术当中的脱机是用软件的方式来模拟实现的。SPOOLing系统的组成如下图：</p><img src="https://pic.imgdb.cn/item/667d1a54d9c307b7e952046f.png" alt="操作系统（五）——IO管理——假脱机系统组成1.png"> <p>SPOOLing系统一般来说由上图的部分组成，系统会在磁盘上开辟出两个存储区域，一个是叫输入井，一个是叫输出井。</p><p>“输入井”用于模拟脱机输入时的磁带，用于收容I&#x2F;O设备输入的数据。</p><p>“输出井”用于模拟脱机输出时的磁带，用于收容用户进程输出的数据。</p><p>除了磁带之外，外围控制机也是实现脱机技术当中一个很重要的部件。外围控制机在假脱机技术里就睡由一个输入进程和一个输出进程来实现的。</p><img src="https://pic.imgdb.cn/item/667d1e16d9c307b7e959528d.png" alt="操作系统（五）——IO管理——假脱机系统组成2.png"><p>“输入进程”模拟脱机输入时的外围控制机，“输出进程”模拟脱机输出时的外围控制机。</p><p>显然输入进程和输出进程肯定需要和用户进程并发的执行，才可以完成模拟脱机输入和脱机输出的过程。因此SPOOLing技术肯定是需要有多道程序技术的支持的。</p><p>另外还需要注意，在内存当中还会开辟输入缓冲区和输出缓冲区：</p><img src="https://pic.imgdb.cn/item/667d1f4ad9c307b7e95b57f1.png" alt="操作系统（五）——IO管理——假脱机系统组成3.png"><p>输入缓冲区和输出缓冲区的作用就是在模拟脱机输入和脱机输出的时候，作为一个数据的中转站。</p><p>输入进程在实现模拟脱机输入的时候，其实是先接收了输入设备的数据，然后把这些数据先放到输入缓冲区里，之后再把输入缓冲区当中的数据放到磁盘的输入井当中</p><p>而进行数据输出时，在输出进程的控制下，输出缓冲区用于暂存从输出井送来的数据，之后再传送到输出设备上。</p><p>接下来看一个具体的假脱机技术的应用——共享打印机的实现：</p><img src="https://pic.imgdb.cn/item/667d2067d9c307b7e95d6503.png" alt="操作系统（五）——IO管理——共享打印机原理分析.png"><p>在前面的学习中提到过两个概念，一个是独占式设备，一个是共享设备，这两个概念的解释在上图已经给出。</p><p>打印机是一种独占式设备，在一段时间内只能为一个用户进程提供服务，如果打印机设备同时处理多个进程的请求的话，就有可能导致各个进程的打印输出结果相互串行。所以对于打印机这个独占式设备来说，如果一个进程正在使用这个打印机，那另一个进程在请求使用打印机的时候必然是需要阻塞等待的。</p><p>但是打印机虽然是独占式设备，但可以使用SPOOLing技术改造成共享设备。如下图。</p><img src="https://pic.imgdb.cn/item/667d21ecd9c307b7e9601cd3.png" alt="操作系统（五）——IO管理——共享打印机原理分析1.png"><p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：</p><p>第一件事：在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的而非内存里)，并将要打印的数据送入其中。</p><p>第二件事：为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的)，再将该表挂到假脱机文件队列上。</p><p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。</p><img src="https://pic.imgdb.cn/item/667d2207d9c307b7e960537a.png" alt="操作系统（五）——IO管理——共享打印机原理分析2.png"><p>在采用了假脱机技术以后，虽然系统中只有一台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备)，使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p><p>因此，SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。</p><p>下面对这部分进行小结：</p><img src="https://pic.imgdb.cn/item/667d222bd9c307b7e9608ed1.png" alt="操作系统（五）——IO管理——假脱机技术小结.png"><h2 id="8-设备的分配与回收"><a href="#8-设备的分配与回收" class="headerlink" title="8. 设备的分配与回收"></a>8. 设备的分配与回收</h2><p>本节设备的分配与回收知识点总览：</p><img src="https://pic.imgdb.cn/item/667d248dd9c307b7e964c5e0.png" alt="操作系统（五）——IO管理——设备分配与回收知识总览.png"><p>首先看一下设备分配时应该考虑的因素：</p><img src="https://pic.imgdb.cn/item/667d4c72d9c307b7e9ab148a.png" alt="操作系统（五）——IO管理——设备的固有属性.png"><p>设备分配时要考虑设备的固有属性、设备的分配算法还有设备分配中的安全性。</p><p>从设备的固有属性角度看，设备的固有属性可分为三种：独占设备、共享设备、虚拟设备。</p><p>独占设备就是一个时段只能分配给一个进程的设备，如打印机。</p><p>共享设备就是可以同时分配个多个进程使用的设备，比如磁盘，但是所谓的这种共享，是宏观上山的共享，微观上各个进程可能是交替的使用设备。</p><p>虚拟设备就是采用SPOOLing技术把独占设备改造成的虚拟的共享设备，可同时分配给多个进程使用。</p><p>从设备分配算法角度看，可以有很多我们很熟悉的算法进行设备分配，比如先来先服务、优先级高者优先，短任务优先等，这里不再具体赘述。</p><p>从设备分配的安全性角度看，可以有如下图的两种分配方式：</p><img src="https://pic.imgdb.cn/item/667d4f03d9c307b7e9af6684.png" alt="操作系统（五）——IO管理——设备分配的安全性.png"><p>注意，如果使用不安全分配方式，一个进程可以同时使用多个设备，但是有可能会发生死锁，所以可以结合第二章死锁的知识，使用银行家算法来避免系统进入不安全状态，即死锁避免。</p><p>接下来看一下两种设备分配方式——静态分配和动态分配：</p><img src="https://pic.imgdb.cn/item/667d5042d9c307b7e9b195de.png" alt="操作系统（五）——IO管理——静态分配和动态分配.png"><p>这两种分配方式在第二章死锁的部分也已经讲过，这里也不过多赘述。</p><p>下面看一下设备分配管理中需要用到哪些数据结构。在了解这些数据结构之前，先看一下设备、控制器、通道之间的关系，如下图：</p><img src="https://pic.imgdb.cn/item/667d5094d9c307b7e9b223c4.png" alt="操作系统（五）——IO管理——设备分配管理中的数据结构1.png"><p>一个通道可控制多个设备控制器，每个设备控制器又可以控制多个设备，所以可以把它们之间的关系理解为一个树的形状。</p><p>从另一个角度来说，每个设备肯定会有一个它所从属的控制器，而每个控制器也肯定会有一个它所从属的通道。这里要注意，一个系统中可能会有多个通道。</p><p>由于控制一个设备肯定需要找到这个设备的控制器，而要控制一个控制器肯定也需要找到控制器所从属的通道。所以设备分配管理中的数据结构需要表示出这种从属的关系。</p><p>下面看一下系统中需要配置的第一种数据结构——设备控制表：</p><img src="https://pic.imgdb.cn/item/667d51fed9c307b7e9b4c3c8.png" alt="操作系统（五）——IO管理——设备控制表.png"><p>系统会为每一个设备配置一张设备控制表，用于记录设备的使用情况。</p><p>一个设备控制表当中可能会有如上图所示的一些常用的字段。其中指向控制器表的指针就是上面所说的用于找到一个设备所从属的控制器到底是那一个。</p><p>接下来看一下第二种数据结构——控制器控制表：</p><img src="https://pic.imgdb.cn/item/667d538fd9c307b7e9b7940a.png" alt="操作系统（五）——IO管理——控制器控制表.png"><p>每一个设备控制器都会对应一张控制器控制表，操作系统会根据控制器控制表的信息对控制器进行操作和管理。</p><p>控制器控制表当中也可能会有如上图所示的一些常用的字段。其中指向通道表的指针用于找到一个控制器所从属的通道到底是那一个。</p><p>接下来看一下第三种数据结构—通道控制表：</p><img src="https://pic.imgdb.cn/item/667d5445d9c307b7e9b9a2e2.png"><p>每个通道都会对应一张通道控制表，操作系统根据通道控制表对通道进行操作和管理。</p><p>与之前的两个数据结构类似，通道控制表当中也可能会有如上图所示的一些常用的字段。其中操作系统可以通过与通道连接的控制器表首址找到该通道控制的所有控制器的相关信息。</p><p>第四个需要设置的系统数据结构叫做系统设备表：</p><img src="https://pic.imgdb.cn/item/667d5551d9c307b7e9bc0107.png" alt="操作系统（五）——IO管理——系统设备表.png"><p>系统设备表当中记录了系统中全部设备的情况，每一个设备会对应一个表目，每个表目中又会记录这个表目所对应的设备的设备类型，比如说是打印机还是扫描仪等。还会记录这个设备的标识符。除此以外，这个表目中还会包含这个设备的控制表。最后还记录了设备的驱动程序的入口。</p><p>由于系统设备表当中记录了系统中全部设备的情况，所以用户用设备名请求某一个设备的时候，操作系统是可以从系统控制表当中来找到用户指定的设备到底是哪一个。</p><p>接下来分析一下设备分配的具体步骤：</p><img src="https://pic.imgdb.cn/item/667d5689d9c307b7e9be7c59.png" alt="操作系统（五）——IO管理——设备分配步骤一.png"><p>第一步操作系统会根据进程请求的物理设备名查找系统设备表。操作系统用某种方式来查找系统设备表的时候，就会把各个表目当中记录的设备标识符和用户提供的物理设备名进行比对，然后找到这两个参数相匹配的一个表项，之后就可以这个设备对应的设备控制表。</p><img src="https://pic.imgdb.cn/item/667d5769d9c307b7e9c067d8.png" alt="操作系统（五）——IO管理——设备分配步骤二.png"><p>第二步，在找到设备控制表以后，会根据设备控制表中记录的信息来判断此时这个设备是否空闲，如果设备空闲的话，就可以把这个设备分配给进程，如果设备忙碌的话，就需要把进程挂到这个设备对应的等待队列中，一直到这个设备空闲，并且把设备分配给该进程以后，才会把这个进程重新唤醒。除了分配设备之外，还需要把这个设备对应的控制器也分配给这个进程，所以系统还会根据指向控制器表的指针找到这个设备对应的控制器控制表。</p><img src="https://pic.imgdb.cn/item/667d586ad9c307b7e9c26bf7.png" alt="操作系统（五）——IO管理——设备分配步骤三.png"><p>第三步，在找到控制器控制表以后，与前面类似，会根据控制器控制表中记录的信息来判断此时这个控制器是否空闲，如果控制器空闲的话，就可以把这个控制器分配给进程，如果控制器忙碌的话，就需要把进程挂到这个控制器对应的等待队列中，一直到这个控制器空闲，并且把控制器分配给该进程以后，才会把这个进程重新唤醒。除了分配控制器之外，还需要把这个控制器对应的通道也分配给这个进程，所以系统还会根据指向通道表的指针找到这个控制器对应的通道控制表。</p><img src="https://pic.imgdb.cn/item/667d5911d9c307b7e9c3a922.png" alt="操作系统（五）——IO管理——设备分配步骤四.png"><p>第四步，在找到通道控制表以后，同理，会根通道控制表中记录的信息来判断此时这个通道是否空闲，如果通道空闲的话，就可以把这个通道分配给进程，如果通道忙碌的话，就需要把进程挂到这个通道对应的等待队列中，一直到这个通道空闲，并且把通道分配给该进程以后，才会把这个进程重新唤醒。</p><p>只有设备、控制器、通道三者都分配成功时，这次的设备分配才算成功，之后便可启动I&#x2F;O设备进行数据传送。</p><p>现在思考一下，这个设备分配过程有什么缺点呢？</p><img src="https://pic.imgdb.cn/item/667d59d9d9c307b7e9c520bc.png" alt="操作系统（五）——IO管理——设备分配步骤改进1.png"><p>如上图，首先第一个缺点就是用户编程时需要使用物理设备名，这种方式对用户编程来说是很不方便的。第二个缺点就是用户编程使用的是物理设备名，如果更换设备，则设备名也会更换，此时用户程序就无法运行。第三个缺点是若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待。比如一台电脑连了三台打印机，如果进程请求使用的是第一台打印机，那么虽然第二台和第三台打印机此时有可能是空闲的，只要第一台打印机此时是忙碌的，那这个进程依然需要阻塞等待，但显然其实可以把这个进程的打印任务把它分配给第二台或第三台打印机进行。因此采用这种方式也会导致设备的利用率不高的问题。</p><p>解决上述缺点的办法就是建立逻辑设备名与物流设备名的映射机制，这样用户编程时只需要提供逻辑设备名，然后由操作系统完成逻辑设备名到物理设备名的转换。</p><img src="https://pic.imgdb.cn/item/667d5b85d9c307b7e9c852f8.png" alt="操作系统（五）——IO管理——设备分配步骤改进2.png"><p>引入逻辑设备名与物流设备名的映射机制之后，进程在请求使用某种设备的时候只需要提供逻辑设备名，所谓的逻辑设备名就是指明它所要使用的设备类型。</p><p>比如说进程想要使用打印机这种设备，那由于系统设备表当中有一个字段记录了设备的类型，因此操作系统可以根据用户提供的逻辑设备名来依次查找系统设备表，然后找到一个指定类型的，并且空闲的设备，把它分配给进程。只有这个类型的设备全部处于忙碌状态的时候，才需要把这个进程给阻塞。</p><p>把这个设备分配给进程以后，操作系统还需要在逻辑设备表LUT当中，新增一个表项。</p><p>之后的操作就会之前一样，可以根据设备控制表找到相应的控制器控制表，然后把控制器分配给设备。然后根据控制器控制表找到相应的通道控制表，然后把通道分配给设备。</p><p>只有进程第一次通过逻辑设备名申请使用一个设备的时候，操作系统才会来查询这个系统控制表，如果之后进程再次以相同的设备名来请求使用设备的话，那操作系统首先做的事，是会在逻辑设备表当中查找这个逻辑设备对应的物理设备，然后找到相应的表项以后，就可以找到设备对应的驱动程序。</p><img src="https://pic.imgdb.cn/item/667d5ba0d9c307b7e9c88391.png" alt="操作系统（五）——IO管理——设备分配步骤改进3.png"><p>有这样的两种方式设置逻辑设备表：</p><p>第一种就是整个系统中只有一张逻辑设备表，这样的话各个用户所用的逻辑设备名不允许重复，所以这种方式只适合用于单用户操作系统。</p><p>第二种就是每个用户设置一张逻辑设备表，这样的话不同用户的逻辑设备名可以重复，可以适用于多用户操作系统。</p><p>下面对本节进行一个小结：</p><img src="https://pic.imgdb.cn/item/667d5bc6d9c307b7e9c8db2d.png" alt="操作系统（五）——IO管理——设备分配与回收小结.png"><h2 id="9-缓冲区管理"><a href="#9-缓冲区管理" class="headerlink" title="9. 缓冲区管理"></a>9. 缓冲区管理</h2><p>缓冲区管理知识点总览：</p><img src="https://pic.imgdb.cn/item/667d6b64d9c307b7e9ea18bb.png" alt="操作系统（五）——IO管理——缓冲区管理知识总览.png"><p>首先看一下，什么是缓冲区，缓冲区有什么作用：</p><img src="https://pic.imgdb.cn/item/667d6b90d9c307b7e9ea7150.png" alt="操作系统（五）——IO管理——什么是缓冲区.png"><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p><p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合，如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本。</p><p>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区。</p><p>所以本节介绍的缓冲区主要还是围绕内存作为缓冲区这种类型。</p><p>下面看一下缓冲区有什么作用：</p><img src="https://pic.imgdb.cn/item/667d6ca3d9c307b7e9ecb736.png" alt="操作系统（五）——IO管理——缓冲区的作用.png"><p>在内存中可以开辟一小片区域作为缓冲区，如果要输出数据的话，CPU产生的这些数据首先会被放到内存的缓冲区当中，不过CPU速度很快，所以它很快就可以把这个缓冲区给充满。等缓冲区放满了以后，CPU就可以去做别的事情。之后I&#x2F;O设备就可以慢慢的从缓冲区当中取走数据。在数据输入时也是类似的，I&#x2F;O设备可以慢慢的把数据放到缓冲区当中，当缓冲区满了以后，CPU再很快速的从缓冲区当中取走数据，所以采用这种方式的话很明显可以缓和CPU和I&#x2F;O设备之间的速度不匹配的矛盾。</p><p>如果说没有采用缓冲区这种策略的话，I&#x2F;O设备每输入或者每输出一定单位的数据之后，就需要对CPU发出一个中断信号，请求CPU介入处理。假设I&#x2F;O设备是一种字符型设备，那每输入完一个字符或者每输出一个字符，I&#x2F;O设备都会打断CPU，向CPU发出中断信号。而对中断的处理是需要付出一定时间代价的，因此CPU频繁的处理这些中断，显然会降低系统的性能。而如果采用缓冲区这种策略，只有缓冲区的数据被全部取走或者输入的数据充满了缓冲区以后，CPU才需要来介入处理中断，因此采用这种方式可以减少CPU的中断频率，放宽CPU对中断响应时间的限制。</p><p>缓冲区还有一个作用就是解决数据粒度不匹配的问题。比如说此时在CPU上运行的输出进程，每次可以申请一整块的数据，但I&#x2F;O设备每次只能输出一个字符。如果没有采用缓冲区策略的话，输出进程只能一个字符一个字符的给I&#x2F;O设备来传送数据。如果采用缓冲区策略的话，输出进程可以直接把一整块的数据放到缓冲区里，让I&#x2F;O设备从缓冲区里一个字符一个字符的往外取。输入时同理。</p><p>另外，采用缓冲区以后，很显然是可以提供CPU和I&#x2F;O设备之间的并行性的。</p><p>接下来介绍几种缓冲区管理的策略。</p><p>首先看一下单缓冲：</p><img src="https://pic.imgdb.cn/item/667d6f73d9c307b7e9f29e08.png" alt="操作系统（五）——IO管理——单缓冲.png"><p>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p><p>注意，缓冲区有一个特点，当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p><p>那么看一下对一个数据块的处理需要经历哪些步骤：</p><p>首先系统在主存中，为用户进程分配了一块大小的缓冲区，那么这个块设备会产生一块大小的数据把它输入到缓冲区当中，这个过程假设所耗费的时间为T。</p><p>之后这块数据需要传送到用户进程的工作区当中，才可以被用户进程所处理（在考研当中，默认用户进程的工作区也是刚好可以放得下一块数据）。这个过程假设所耗费的时间为M。</p><p>再之后，用户进程就可以开始对这一块数据进行处理，假设对一块数据进行计算处理所需要的时间为C这么多。当它处理完以后，这个用户进程的工作区就可以被腾空了。</p><p>在考研中经常考察的题型是，<strong>会让计算每处理一块数据平均需要多长的时间</strong>。这里说一个技巧，<strong>可以假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间</strong>。</p><p><strong>而在“单缓冲”题型中，可以假设初始状态为工作区满，缓冲区空</strong>。所以对于单缓冲，要分析下一次达到工作区满，缓冲区空这样的一个状态需要花多少时间。这个时间长度就是处理一个数据块平均所需要消耗的时间。</p><p>下面看单缓冲区的第一种情况，假设输入时间T大于处理时间C：</p><img src="https://pic.imgdb.cn/item/667d723ad9c307b7e9f9a560.png" alt="操作系统（五）——IO管理——单缓冲处理一个数据块所需时间.png"><p>根据假设条件，刚开始工作区是满的，缓冲区是空的。所以刚开始CPU就可以处理工作区中的这一块数据，这个处理过程需要花费C这么长的时间。另外由于刚开始缓冲区为空，所以块设备可以往其中冲入一块数据，这个时间总共耗费了T这么久。</p><p>由于T&gt;C，因此CPU处理完数据后，并不能紧接着将下一块数据传送到工作区，必须等待缓冲区中冲满数据并且把数据传送到工作区以后，才可以进行下一块数据的处理。</p><p>显然在T这个时间点缓冲区充满，可以紧接着将这一块数据传送到工作区当中，这个过程又要花费M这么长的时间。</p><p>此时经历了T+M这么的时间以后，就再次回到了刚刚假设的初始状态，也就是缓冲区满，工作区空。接下来的数据处理无非就是重复刚刚分析的过程，因此通过刚刚的分析可以发现，平均每处理一块数据的用时是T+M这么多。</p><p>下面看第二种情况，假设输入时间T小于处理时间C：</p><img src="https://pic.imgdb.cn/item/667d7464d9c307b7e9fe29ee.png" alt="操作系统（五）——IO管理——单缓冲处理一个数据块所需时间1.png"><p>刚开始同第一种情况一样，刚开始工作区是满的，缓冲区是空的。所以刚开始CPU就可以处理工作区中的这一块数据，这个处理过程需要花费C这么长的时间。另外由于刚开始缓冲区为空，所以块设备可以往其中冲入一块数据，这个时间总共耗费了T这么久。</p><p>由于这次T&lt;C，因此缓冲区中冲满数据后，暂时不能继续冲入下一块数据，必须等待CPU处理结束后，才能将数据从缓冲区传送到工作区。</p><p>显然也是在C这个时间点CPU处理结束，可以紧接着将这一块数据传送到工作区当中，这个过程又要花费M这么长的时间。</p><p>此时经历了C+M这么的时间以后，就再次回到了刚刚假设的初始状态，也就是缓冲区满，工作区空。接下来的数据处理同样是重复刚刚分析的过程，因此通过刚刚的分析可以发现，平均每处理一块数据的用时是C+M这么多。</p><p>通过分析上面两种情况，可以总结如下图的结论：</p><img src="https://pic.imgdb.cn/item/667d7bb6d9c307b7e90d749e.png" alt="操作系统（五）——IO管理——单缓冲处理一个数据块所需时间2.png"><p><strong><font color=red>结论：采用单缓冲策略，处理一块数据平均耗时Max(C，T)+M。</font></strong></p><p>接下来看一下双缓冲策略：</p><img src="https://pic.imgdb.cn/item/667d7cadd9c307b7e90f6b58.png" alt="操作系统（五）——IO管理——双缓冲策略.png"><p>假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块)。</p><p>类似的，双缓冲问题也经常<strong>会让计算每处理一块数据平均需要多长的时间</strong>。</p><p>在双缓冲题目中，假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空。</p><p><strong>先看第一种情况，如上图，假设T&gt;C+M：</strong></p><p>根据假设的初始状态，缓冲区1中此时是有一块数据的，缓冲区2和工作区是空的。所以在0这个时刻，可以把缓冲区1中的数据传送到工作区当中，这个过程耗时是M这么多。而接下来CPU就可以处理工作区当中的数据，耗时为C。</p><p>另一方面，在刚开始缓冲区2是空的，所以刚开始块设备可以往缓冲区2中输入数据，充满缓冲区2总共耗时T。</p><p>由于T&gt;C+M，所以虽然在C+M这个时刻，CPU已经把工作区中的数据给处理完了，工作区已经空了。但是由于缓冲区2此时这个时刻还没有充满，所以暂时不能把缓冲区2的数据传送到工作区当中，必须等到T这个时刻，缓冲区2才可以被充满，所以到T这个时刻就回到了假设的初始状态。</p><p>因此，当T&gt;C+M的时候，处理一块数据平均用时为T。</p><p><strong>下面看第二种情况，假设T&lt;C+M：</strong></p><img src="https://pic.imgdb.cn/item/667d7fb5d9c307b7e916ea6b.png" alt="操作系统（五）——IO管理——双缓冲处理一个数据块所需时间.png"><p>刚开始缓冲区2是空的，所以刚开始设备可以往缓冲区2中冲入数据，耗时为T。另一方面，由于刚开始，缓冲区1当中是充满数据的，所以一开始就可以把缓冲区1的数据传送到工作区当中。到M这个时刻工作区会充满，然后CPU就可以开始处理数据，耗时C这么长。</p><p>处理完工作区中的数据以后，缓冲区2中也已经充满了下一块的数据，因此接下来可以紧接着把缓冲区2当中的数据传送到工作区当中，接着继续处理工作区中的这一块数据。</p><p>接着回头看数据输入的这个过程，在T这个时刻，缓冲区2已经被充满，设备开始空闲。并且，由于缓冲区1当中的数据在M这个时刻就已经被取空了，因此当缓冲区2的数据被充满以后，设备就可以紧接着往缓冲区1中冲入数据，这个耗时也是T这么多。</p><p>假设2T&lt;2M+C，则I&#x2F;O设备将缓冲区1冲满时，缓冲区2的数据尚未取空，因此I&#x2F;O设备暂时不能冲入数据，只有缓冲区2当中的数据被取空以后，这个设备才可以继续往缓冲区2当中写入下一块的数据。</p><p>经过分析可以发现，如果采用双缓冲结构，并且T&lt;C+M，那么很难找到一个和刚开始的初始状态一模一样的一个状态。所以对于这种情况，上面假设的先假定一个初始状态，然后分析下次到达相同状态需要多少时间这种方法就不太好使用了。</p><p>但是通过甘特图的方式往下分析可以发现，每经过M+C这么长的时间，就会有一块数据被处理完毕，因此，当T&lt;C+M就意味着设备输入数据块的速度要比处理机处理数据块的速度更快。每处理一个数据块平均耗时C+M。</p><p>经过上面的两种情况的分析，可以知道采用双缓冲策略，处理一个数据块的平均耗时为Max(T,C+M)。</p><p>下面看一下单缓冲和双缓冲在通信时的区别：</p><img src="https://pic.imgdb.cn/item/667d8417d9c307b7e91fea36.png" alt="操作系统（五）——IO管理——单缓冲和双缓冲在通信时的区别1.png"><p>单缓冲和双缓冲策略不仅可以在主机和设备之间的数据传送当中使用，在两台主机通信时，也可以采用这种缓冲策略，用于数据的发送和接收。</p><p>如上图，如果说为两台通信的主机配置单缓冲区的话，A主机想要发送的数据，要先放入A主机缓冲区中，等缓冲区满时就可以将数据发送到B缓冲区中。之后，B主机将缓冲区中的数据全部取走后，才能向A主机发送数据。</p><p>显然，若两个相互通信的机器只设置单缓冲区，则在任一时刻只能实现数据的单向传输。</p><img src="https://pic.imgdb.cn/item/667d857ad9c307b7e922d343.png" alt="操作系统（五）——IO管理——单缓冲和双缓冲在通信时的区别2.png"><p>为了实现同一时刻双向传输，可以给两台机器配置双缓冲区，其中一个缓冲区用来暂存即将发送的数据，而另一个缓冲区用来接收输入的数据。所以如果采用双缓冲结构，那么这两台主机可以同时往自己的发送缓冲区当中冲入自己想要发送出去的数据，接下来可以同时往对方的接收缓冲区当中冲入数据。这样就实现了同一时刻双向传输的功能。</p><p>接下来看另一种缓冲区——循环缓冲区：</p><img src="https://pic.imgdb.cn/item/667d85a2d9c307b7e92329b0.png" alt="操作系统（五）——IO管理——循环缓冲区.png"><p>很多时候只有两个缓冲区依然不能满足进程的实际需要，所以操作系统可以给一个进程分配多个大小相等的缓冲区，让这些缓冲区连成一个循环的队列。</p><p>在上图中，橙色表示已经被充满数据的缓冲区，而绿色表示的是此时为空的缓冲区。系统会保持两个指针用于缓冲区的管理。其中，in指针，指向下一个可以冲入数据的空缓冲区；out指针，指向下一个可以取出数据的满缓冲区。当out指针指向的缓冲区数据被取空以后，out指针就会指向下一个满缓冲区。类似地，如果in指针所指向的缓冲区被充满以后，in指针也需要指向下一个为空的缓冲区。</p><p>在考研中，一般来说只有单缓冲和双缓冲需要分析处理一个数据平均所需要的消耗时间，循环缓冲只需要了解大致的原理就可以了。</p><p>接下来看一下缓冲池的概念：</p><img src="https://pic.imgdb.cn/item/667d860bd9c307b7e9240a81.png" alt="操作系统（五）——IO管理——缓冲池.png"><p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为:空缓冲队列、装满输入数据的缓冲队列（输入队列)、装满输出数据的缓冲队列(输出队列）。</p><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输数据的工作缓冲区(hin)、用于提取输入数据的工作缓冲区(sin)、用于收容输出数据的工作缓冲区(hout)、用于提取输出数据的工作缓冲区(sout)。</p><p>如果一个输入进程要请求输入一块数据，那么系统会从空缓冲队列的队头当中，取下一块空的缓冲区，把它作为**用于收容输入数据的缓冲区(hin)**，当这块缓冲区被充满以后，就会被挂到输入队列的队尾上。</p><p>如果计算进程想要取得一块之前已经输入的数据，那么操作系统会从输入队列的队头取下一个缓冲区，把它作为**提取输入的工作缓冲区(sin)**，接下来这块缓冲区当中的数据会被传送到计算进程的工作区当中，所以这块缓冲区中的数据就被取空了，当它取空之后，这个缓冲区又会被挂回到空缓冲队列的队尾。</p><p>如果此时计算进程已经准备好了数据，想要把这些数据冲入到缓冲区，那么系统会从空缓冲队列的队头取下一个空闲的缓冲区，把这个缓冲区作为**收容这个进程想要输出数据的工作缓冲区(hout)**，因此接下来这个缓冲区慢慢的会被充满，由于这块缓冲区的数据接下来是要输出到I&#x2F;O设备上的，所以这块数据会被挂到输出队列的队尾。</p><p>如果某个输出进程请求输出一块数据，那么操作系统会从输出队列中取得一块冲满输出数据的缓冲区作为**提取输出数据的工作缓冲区(sout)**。缓冲区读空后挂到空缓冲区队列。</p><p>下面对本节进行一个小结：</p><img src="https://pic.imgdb.cn/item/667d862cd9c307b7e9245053.png" alt="操作系统（五）——IO管理——缓冲区管理小结.png"><h2 id="10-磁盘的结构"><a href="#10-磁盘的结构" class="headerlink" title="10. 磁盘的结构"></a>10. 磁盘的结构</h2><p>磁盘的结构知识总览：</p><img src="https://pic.imgdb.cn/item/667e14fbd9c307b7e9c83ec8.png" alt="操作系统（五）——IO管理——磁盘的结构小结.png"><p>首先看一下磁盘、磁道、扇区的概念：</p><img src="https://pic.imgdb.cn/item/667e1566d9c307b7e9c8d0d2.png" alt="操作系统（五）——IO管理——磁盘、磁道、扇区的概念.png"><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据。磁盘的结果如上图右。</p><p>磁盘的盘面被划分成一个个磁道。如上图左的一个“圈”就是一个磁道。注意，在实际的磁盘中磁道数量会有很多，这里图中因为画不下，所以只画了几道。</p><p>而一个磁道又可以被划分成一个个扇区，每个扇区就是一个“磁盘块”。而且各个扇区存放的数据量相同，如1KB，即每个扇区的大小是1KB这么多。注意，不同磁道的扇区大小也是相同的，所以，由于最内侧磁道上的扇区面积最小，因此数据密度最大。</p><p>在上图的磁盘结构中还会发现，在磁盘的中间会有一个马达，这个马达转动时就可以带动磁盘的转动。</p><p>另外，为了方便查找，可以给扇区进行编号。</p><p>接下来看一下怎么从磁盘当中读写数据：</p><img src="https://pic.imgdb.cn/item/667e174bd9c307b7e9cb4360.png" alt="操作系统（五）——IO管理——磁盘的读写.png"><p>首先，需要把“磁头”移动到想要读&#x2F;写的扇区所在的磁道。磁头会由磁头臂带动，磁盘会由中间马达带动转起来，让目标扇区从磁头下面划过，这样才能完成对扇区的读&#x2F;写工作。</p><p>如上图左，就是将磁头移动到橙色磁道，并让电机旋转带动磁盘旋转进行橙色磁道数据读取的示意图。</p><p>注意，上图左只给了一个盘片，但事实上磁盘当中会有很多个这样的盘片，如下图：</p><img src="https://pic.imgdb.cn/item/667e1853d9c307b7e9cca01a.png" alt="操作系统（五）——IO管理——盘面和柱面.png"><p>相应的，每个盘面上都会有一个磁头，然后这些磁头都会由磁头臂统一的带动着往里或往外移动。</p><p>我们可以对这些盘面进行编号，每个盘面都会对应一个用于读取磁盘数据的磁头。</p><p>另外，在有的磁盘当中，一个盘片有可能会对应两个盘面，也就是盘片的正面和背面。</p><p>还有一点需要注意的是所有的磁头都是连在同磁臂上的，因此所有磁头只能共进退。</p><p>还要知道，磁盘盘面中相对位置相同的磁道组成柱面。</p><p>所以对于磁盘的物理地址，我们结合上面的定义，就可以用下图的三元组来表示：</p><img src="https://pic.imgdb.cn/item/667e19bbd9c307b7e9cf4f86.png" alt="操作系统（五）——IO管理——磁盘的物理地址.png"><p>可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”。其中柱面号用来定位盘面中某一个磁道，盘面号用来选择到底是哪一个盘面中的磁道，而扇区号用来选择在这个磁道中到底是哪一个扇区。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号)的地址形式。</p><p>所以如果要读取某一个文件在某一个盘块中的数据的话，那么磁盘会根据这个地址来找到磁盘块对应的位置，具体步骤如下：</p><p>①根据“柱面号”移动磁臂，让磁头指向指定柱面；</p><p>②激活指定盘面对应的磁头；</p><p>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</p><p>接下来看一下，磁盘有哪些分类：</p><p>按照磁头是否可以移动划分，有下图两种：</p><img src="https://pic.imgdb.cn/item/667e1cead9c307b7e9d3e870.png" alt="操作系统（五）——IO管理——磁盘的分类.png"><p>按照盘片是否可以更换也有下图两种分类：</p><img src="https://pic.imgdb.cn/item/667e1d1cd9c307b7e9d42cfa.png" alt="操作系统（五）——IO管理——磁盘的分类1.png"><p>最后对本部分进行小结：</p><img src="https://pic.imgdb.cn/item/667e1d5fd9c307b7e9d483fa.png" alt="操作系统（五）——IO管理——磁盘的结构总结.png"><h2 id="11-磁盘调度算法"><a href="#11-磁盘调度算法" class="headerlink" title="11. 磁盘调度算法"></a>11. 磁盘调度算法</h2><p>本节知识点总览：</p><img src="https://pic.imgdb.cn/item/667e1da8d9c307b7e9d4f44e.png" alt="操作系统（五）——IO管理——磁盘的调度算法知识总览.png"><p>本节首先要掌握一次磁盘读&#x2F;写操作需要多久的时间，应该怎么计算，计算时会从寻道时间、延迟时间和传输时间三个部分入手。而磁盘调度算法的不同会影响寻道时间的长短，所以选择一个合适的调度算法对磁盘整体的性能是有很大影响的。这里要重点掌握上图列出的四种算法。</p><p>首先看一下一次磁盘的读或写操作需要多久的时间。</p><img src="https://pic.imgdb.cn/item/667e1fded9c307b7e9d8238c.png" alt="操作系统（五）——IO管理——一次磁盘读写所需时间.png"><p>磁盘的读写操作需要时间包含三部分，分别是寻道时间、延迟时间、传输时间。上图给出了这三个部分的详细计算已经介绍，这里就不再对其计算过程进行重复。</p><p>从上图的公式中可以看到，延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间。所以操作系统唯一可以影响的时间就是寻道时间，根据不同的磁盘调度算法，寻道时间会有很大差异。</p><p>接下来就看一下各种磁盘调度算法：</p><p>首先看一下先来先服务算法：</p><img src="https://pic.imgdb.cn/item/667e4295d9c307b7e91245a6.png" alt="操作系统（五）——IO管理——先来先服务算法.png"><p>所谓先来先服务算法就是根据进程请求访问磁盘的先后顺序进行调度。</p><p>这里根据上图给出的例子，可以看到，按照先来先服务的规则，按照请求到达的顺序，磁头需要依次移动到55、58、39、18、90、160、150、38、184号磁道，磁头总共移动了498个磁道。响应一个请求平均需要移动55.3个磁道。</p><p>所以先来先服务算法的优点就是公平；如果请求访问的磁道比较集中的话，算法性能还可以。缺点是如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，会有很多时间浪费在寻道上。</p><p>接下来看第二种磁盘调度算法——最短寻找时间优先：</p><img src="https://pic.imgdb.cn/item/667e43fad9c307b7e9156a15.png" alt="操作系统（五）——IO管理——最短寻找时间优先算法.png"><p>最短寻找时间优先算法会优先处理的磁道是与当前磁头最近的磁道。这样可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。(其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优。)</p><p>根据上图还是之前的例子，可以看到，按照最短寻找时间优先的规则，磁头需要依次移动到90、58、55、39、38、18、150、160、184号磁道，磁头总共移动了248个磁道。响应一个请求平均需要移动27.5个磁道。</p><p>最短寻找时间优先算法的优点是性能较好，平均寻道时间短。缺点是可能产生“饥饿”现象。比如本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。</p><p>产生饥饿的原因在于：磁头在一个小区域内来回来去地移动。为了解决饥饿的问题，人们又提出了扫描算法。</p><p>接下来看第三种磁盘调度算法——扫描算法：</p><img src="https://pic.imgdb.cn/item/667e4619d9c307b7e9188272.png" alt="操作系统（五）——IO管理——扫描算法.png"><p>SSTF算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，<strong>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法(SCAN)的思想</strong>。由于磁头移动的方式很像电梯，因此也叫电梯算法。</p><p>如上图例子，假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道，此时磁头就会从100的位置一直增大，直到移动到200号磁道，才会开始回来往磁道号变小的方向移动。</p><p>在磁头访问磁道的过程中，磁头总共移动了282个磁道，平均响应一个请求需要移动31.3个磁道。</p><p>这种扫描算法的优点是性能较好，平均寻道时间较短，不会产生饥饿现象。但缺点也很明显有两点：①只有到达最边上的磁道时才能改变磁头移动方向，如上例，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了，但是该算法依然会向右移动到最大磁道处才返回。②SCAN算法对于各个位置磁道的响应频率不平均。比如假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，磁头往返之后很快又可以再次响应184号磁道的请求。</p><p>下面就来看一下对于扫描算法的这两个缺点的改进：</p><img src="https://pic.imgdb.cn/item/667e463fd9c307b7e918bb82.png" alt="操作系统（五）——IO管理——LOOK调度算法.png"><p>首先看扫描算法的第一个缺点，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。为了解决这个问题，人们提出了LOOK调度算法。</p><p>LOOK调度算法规定，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。(边移动边观察，因此叫LOOK。)</p><p>如上图还是同一个例子，只不过此次磁头往磁道号增大的方向移动不需要移动到200了，当移动到184号磁道时，此时在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。</p><p>在这个过程中，磁头总共移动了(184-100)+(184-18)&#x3D; 250个磁道，响应一个请求平均需要移动250&#x2F;9&#x3D; 27.5个磁道（平均寻找长度)。</p><p>经过改进可以看到，比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。</p><p>下面看对扫描算法的第二个缺点的改进：</p><img src="https://pic.imgdb.cn/item/667e469dd9c307b7e91941c1.png" alt="操作系统（五）——IO管理——循环扫描算法.png"><p>SCAN算法对于各个位置磁道的响应频率不平均，为了解决这个问题，于是循环扫描(C-SCAN)算法就出现了。</p><p>循环扫描(C-SCAN)算法规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p><p>如上图，还是同一个例子，假设C-SCAN算法只有在向右移动时才会处理磁道访问请求，而且根据C-SCAN算法的规定，磁头只有到了最边上的磁道才能改变磁头移动方向。磁头返回途中不处理任何请求。</p><p>在这个过程中，磁头总共移动了(200-100)+(200-0)+(9o-0)&#x3D; 390个磁道，响应一个请求平均需要移动390&#x2F;9 &#x3D;43.3个磁道（平均寻找长度)。</p><p>所以C-SCAN比起SCAN来，对于各个位置磁道的响应频率很平均。但是缺点也一样，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，C-SCAN平均寻道时间更长。</p><p>为了应对这个问题，人们效仿LOOK调度算法，提出了C-LOOK调度算法。</p><img src="https://pic.imgdb.cn/item/667e46d1d9c307b7e919978f.png" alt="操作系统（五）——IO管理——C-LOOK调度算法.png"><p>C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。</p><p>C-LOOK算法规定，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p>如上图，同样的例子，假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道。使用C-LOOK算法在磁头移动到184处时，在磁头移动方向上已经没有别的请求，这是就可以让磁头返回。而磁头只需要返回到最靠近边缘的、并且需要访问的磁道上即可，并不需要回到最左边边缘处。</p><p>在这个过程中，磁头总共移动了(184-100)+(184-18)+(90-18)&#x3D; 322个磁道，响应一个请求平均需要移动322&#x2F;9&#x3D; 35.8个磁道(平均寻找长度)。</p><p>很明显C-LOOK比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短。</p><p>下面看一下本部分小结：</p><img src="https://pic.imgdb.cn/item/667e4707d9c307b7e919eff1.png" alt="操作系统（五）——IO管理——磁盘调度算法小结.png"><p>这里注意一点，若题目中无特别说明，则默认题目中的SCAN算法就是LOOK算法，C-SCAN算法就是C-LOOK算法。</p><h2 id="12-减少磁盘延迟时间的方法"><a href="#12-减少磁盘延迟时间的方法" class="headerlink" title="12. 减少磁盘延迟时间的方法"></a>12. 减少磁盘延迟时间的方法</h2><img src="https://pic.imgdb.cn/item/667e4d7cd9c307b7e9243f8a.png" alt="操作系统（五）——IO管理——减少磁盘延迟时间引例.png"><p>我们意识到了一次读磁盘或者写磁盘的操作，需要寻道时间、延迟时间和传输时间这样三个部分组成。其中延迟时间指的是把目标扇区转到磁头下面所花的时间。如上图，比如说我们此时要读取橙色的这些区域的话，那么我们首先需要有一段延迟时间是用来转动磁盘的，让橙色区域放到这个磁头的下面。</p><p>假设现在要连续读取橙色区域的2、3、4扇区，磁头读取一块的内容（也就是一个扇区的内容）后，需要一小段时间处理，而盘片又在不停地旋转。因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断地读入3号扇区，必须等盘片继续旋转，3号扇区再次划过磁头，才能完成扇区读入。</p><p>所以，由于磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”。</p><p>面对上面的这个问题，我们可以采用交替编号的方式来处理：</p><img src="https://pic.imgdb.cn/item/667e4dedd9c307b7e924f343.png" alt="操作系统（五）——IO管理——交替编号.png"><p>所谓交替编号，就是让逻辑上相邻的扇区在物理上有一定的间隔。如上图，我们编好了0号扇区后，并不是在它后面紧接着就规定1号扇区，而是在间隔了一个扇区后，才把下一个扇区编为1号扇区。然后依次类推。</p><p>假设现在这个磁头指向0号扇区位置，如果接下来要读入的是2号、3号和4号扇区，那由于首先要读入的是2号扇区，所以需要先转动磁盘让2号扇区放到磁头下面，接下来在这个磁盘继续转动的过程中就可以把2号扇区的数据给堵住了。在读完了2号扇区之后，磁头需要有一小段时间做中间的准备，在这段时间内，磁头是不能读入任何数据的，但是由于采用了交替编号的策略，所以在3号扇区划过磁头前，这个磁头就做好了下一次读取数据的准备。因此，这个磁盘继续旋转，3号扇区从磁头下面划过，磁头也可以顺利的把3号扇区里的数据给读进来。</p><p>从上面这个过程中可以看到，采用交替编号这样的策略，可以使读取连续的逻辑扇区所需要的延迟时间更小。</p><p>接下来探讨一个磁盘地址结构的问题：</p><img src="https://pic.imgdb.cn/item/667e5717d9c307b7e9350079.png" alt="操作系统（五）——IO管理——磁盘地址结构设计.png"><p>通过之前的学习可以知道，磁盘的物理地址是按(柱面号，盘面号、扇区号)这种顺序的一个三元组，现在思考一下，为什么不是(盘面号，柱面号，扇区号)这种顺序的一个三元组呢？也就是说，为什么柱面号一定要在前，盘面号一定要在后？这里来分析一下这个问题。</p><p>用上图的磁盘为例，假设这个磁盘有8个柱面&#x2F;磁道（假设最内侧柱面&#x2F;磁道号为0 )，4个盘面，8个扇区。则可用3个二进制位表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。</p><p>若物理地址结构是（盘面号，柱面号，扇区号)，且假设现在需要连续读取物理地址(00, 000,000) ~ (00,001,111）的扇区。</p><p>首先(00,000,000) ~ ( 00, 000,111 )这些扇区就是0号盘面0号柱面的8个扇区，根据之前的分析可以知道，在转了一圈之后，这个磁头可以依次读入0123这几个扇区的数据。再转第二圈后，这个磁头可以依次读入4567这几个扇区的数据，也就是说(00,000,000) ~ ( 00, 000,111 )这个物理地址范围内的数据只需要转两圈就可以读完。之后再读取物理地址相邻的区域(00,001,000) ~ ( 00,001,111)，即0号盘面1号柱面的8个扇区，这时由于柱面号变了，所以需要启动磁头臂，将磁头移动到下一个磁道。</p><p>通过之前的学习可以知道，启动磁头臂还有移动磁头是一种物理上的移动，它所需要花费的时间是比较高的，这是盘面号在柱面号之前的情况，下面看一下盘面号在柱面号之后的情况。</p><img src="https://pic.imgdb.cn/item/667e5747d9c307b7e93545cf.png" alt="操作系统（五）——IO管理——磁盘地址结构设计1.png"><p>若物理地址结构是(柱面号，盘面号，扇区号)，假设此时需要读取的取物理地址依然是(000,00,000) ~ (000,01,111)的扇区。</p><p>同样的，首先要读取(00,000,000) ~ ( 00, 000,111 )即0号盘面0号柱面的8个扇区，根据上面的分析可以知道，这部分需要转两圈才可以读完。</p><p>接下来还要读取(00,001,000) ~ ( 00,001,111)范围内的数据，但是这里采用的是(柱面号，盘面号，扇区号)即柱面号在前，盘面号在后的物理地址结构，所以(00,001,000) ~ ( 00,001,111)对应的是0号柱面1号盘面的8个扇区。而由于柱面号&#x2F;磁道号相同，只是盘面号不同，因此不需要移动磁头臂，只需要激活相邻盘面的磁头即可。并不需要像之前一样要启动磁头臂，然后来回移动磁头。</p><img src="https://pic.imgdb.cn/item/667e5769d9c307b7e9357bcf.png" alt="操作系统（五）——IO管理——磁盘地址结构设计2.png"><p>因此磁盘的物理地址是(柱面号，盘面号，扇区号)而不是(盘面号，柱面号，扇区号)的原因，就是读取地址连续的磁盘块时，采用(柱面号，盘面号，扇区号)的地址结构可以减少磁头移动消耗的时间。</p><p>理解了上面的问题之后，接下来再看第二种减少延迟时间的方法——错位命名：</p><img src="https://pic.imgdb.cn/item/667e57bbd9c307b7e935f798.png" alt="操作系统（五）——IO管理——错位命名1.png"><p>先来看一下，不采用错位命名方式在读取编号连续的扇区会发生什么情况。</p><p>假设0号盘面和1号盘面在它们相对位置相同的这些扇区的编号都是相同的，也就是0号盘面的0号扇区下面，对应的刚好是1号盘面的0号扇区，然后0号盘面的4号扇区下面对应的也是1号盘面的4号扇区，这些扇区号是一一对应的，两个盘面对应的磁头也是指向一个相对位置相同的地方。</p><p>现在假设这个0号盘面的橙色区域对应的扇区编号的物理地址为(000,00,111)，由于磁盘的地址结构是(柱面号，盘面号，扇区号)，所以与这个扇区序号相邻的下一个扇区的编号应该是(000,01,000)，也就是1号盘面的0号扇区，即上图右的橙色区域。</p><p>由于所有盘面都是一起连轴转的，因此读取完磁盘块(000,00,111)之后，需要短暂的时间处理，而盘面又在不停地转动，因此当（000,01,000)第一次划过1号盘面的磁头下方时，并不能读取数据，只能再等该扇区再次划过磁头。</p><p>为了解决上述问题，可以使用错位命名的方式来命名，如下图：</p><img src="https://pic.imgdb.cn/item/667e57f2d9c307b7e93647ca.png" alt="操作系统（五）——IO管理——错位命名2.png"><p>错位命名就是就将相邻盘面中的偏下方的盘面的扇区编号向后移动一位，以达到与上方盘面错开编号的目的，如上图的0号盘面和1号盘面就是错位命名，可以看到，0号盘面在1号盘面正上方，0号盘面的0号扇区它的正下方对应的是1号盘面的7号扇区，然后0号盘面的4号扇区下面对应的也是1号盘面的0号扇区，也就是说这些盘面的扇区编号是错开的，这就是为什么叫错位命名。</p><p>还是使用上面的例子作分析，由于采用错位命名法，因此读取完磁盘块( 000,00,111)之后，还有一段时间可以用于处理，当(000,01,000)第一次划过1号盘面的磁头下方时，就可以直接读取数据，从而减少了延迟时间。</p><p>下面对本节进行一个小结：</p><img src="https://pic.imgdb.cn/item/667e581cd9c307b7e93689b3.png" alt="操作系统（五）——IO管理——减少磁盘延迟时间小结.png"><h2 id="13-磁盘的管理"><a href="#13-磁盘的管理" class="headerlink" title="13. 磁盘的管理"></a>13. 磁盘的管理</h2><p>本节知识点总览：</p><img src="https://pic.imgdb.cn/item/667e584fd9c307b7e936df56.png" alt="操作系统（五）——IO管理——磁盘的管理知识总览.png"><p>首先看一下什么是磁盘初始化：</p><img src="https://pic.imgdb.cn/item/667e59aad9c307b7e93912c6.png" alt="操作系统（五）——IO管理——磁盘的初始化.png"><p>磁盘刚被制造出来时，只被划分成了一个一个的磁道，在磁盘正式出厂之前，还需要进行一个低级格式化的过程，这个过程就是一个划分扇区的过程。一个扇区通常可分为头、数据区域、尾三个部分组成。每个扇区的数据区域所能存放的数据数量都是相同的，比如512B，所以前面说的一个扇区可以存放的数据大小，其实指的是数据区域可以存放的大小。</p><p>另外，在文件的物理结构的部分说过一种链式结构，也就是把文件的那些数据块用链接的方式把它们连起来，那前一个数据块指向下一个数据块的指针就可以保存在尾部这个部分。也就是说链接部分并不需要占用数据区域，这样的话可以方便操作系统的管理。</p><p>除此以外，管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)。</p><p>在正式使用磁盘之前，还需要对磁盘进行逻辑上的分区，每个分区由若干个相邻的柱面组成，这里所谓的分区就是我们平时熟悉的C盘、D盘等。</p><p>在划分了分区以后，需要进行逻辑格式化。逻辑格式化所做的事情就是创建文件系统，包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表)。</p><p>上面是磁盘初始化时要做的事情，接下来看一下什么是磁盘的引导块：</p><img src="https://pic.imgdb.cn/item/667e59e5d9c307b7e9397628.png" alt="操作系统（五）——IO管理——磁盘的引导块.png"><p>在磁盘完成了物理格式化、磁盘分区和逻辑格式化以后，就可以把操作系统相关的数据写到磁盘中，也就是安装操作系统的一个过程。</p><p>计算机开机时需要进行一系列初始化的工作（包括初始化CPU、内存等），这些初始化工作是通过执行初始化程序（自举程序）完成的。一般来说，初始化程序是存放在ROM（只读存储器）中的，而ROM中的数据在出厂时就写入了(一般来说，ROM在出厂时就直接集成在了电脑主板上)，并且以后不能再修改。</p><p>也就是说，计算机开机时，首先会读取ROM当中的程序，并且执行这些程序完成初始化的工作。但是思考一下，把初始化程序程序（自举程序）放在ROM中存在什么问题？</p><p>假设自举程序需要更新的话就会很不方便，因为ROM当中的数据是无法更改的，但是由于自举程序本身又比较复杂，所以不太可能保证自举程序相关的数据永远不改变。对于这个问题，应该如何解决呢？</p><img src="https://pic.imgdb.cn/item/667e5a18d9c307b7e939ca59.png" alt="操作系统（五）——IO管理——磁盘的引导块1.png"><p>那现在的操作系统一般是只在ROM当中存放很小的一个自举装入程序，而完整的自举程序放在磁盘的启动块(即引导块&#x2F;启动分区)上，启动块位于磁盘的固定位置。比如上图指向C盘的几个盘块，这几个盘块就可以称为启动分区或者叫引导块。</p><p>当计算机开机的时候，首先会先执行ROM当中的自举装入程序，在执行自举装入程序的过程中，CPU就可以知道接下来需要执行的自举程序是存放在硬盘当中的哪个位置。通过自举装入程序的引导，CPU就可以从磁盘中读取完整的自举程序，这样的话就可以完成初始化。</p><p>自举装入程序的复杂度不高，所以其实是可以保证自举装入程序是不会出错的，不需要更改的。而自举程序需要更改的话，就把自举程序放在磁盘的固定位置，这样的话当自举程序需要更新的时候，就只需要重新把这些引导块当中的数据，把它重新更新一下就可以。所以这种方案带来的好处就是自举程序更新会变得很方便。</p><p>一般来说，拥有启动分区(启动块、引导块)的磁盘称为启动磁盘或系统磁盘。</p><p>接下来再看一下对磁盘的坏块应该进行什么样的管理：</p><img src="https://pic.imgdb.cn/item/667e5a5bd9c307b7e93a3798.png" alt="操作系统（五）——IO管理——坏块的管理.png"><p>所谓的坏块就是指那些坏了、无法正常使用的扇区。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。</p><p>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在FAT表(文件分配表)上标明。被标记为坏块的块，之后不再分配给任何一个文件。由于操作系统在对存储空间进行管理时肯定需要读取文件分配表的内容，而哪些块是坏块是记录在文件分配表当中的，因此采用这种方式的话，坏块对这个操作系统是不透明的。</p><p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表，并在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。另外，磁盘控制器会保留一些“备用扇区”，用于替换坏块。比如操作系统想使用一个本来已经坏掉的块，那么在硬件层次，磁盘控制器这个硬件部件就会用其中的某一个好的备用块来替换这个坏块，但是这个过程对操作系统是透明的，操作系统是不可知的。这种方案也称为扇区备用。</p><p>上面就是对磁盘坏块管理的两种方法。下面对本节进行一个小结：</p><img src="https://pic.imgdb.cn/item/667e5a8cd9c307b7e93a8877.png" alt="操作系统（五）——IO管理——磁盘的管理小结.png"><h2 id="14-固态硬盘SSD"><a href="#14-固态硬盘SSD" class="headerlink" title="14. 固态硬盘SSD"></a>14. 固态硬盘SSD</h2>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（五）——中央处理器</title>
      <link href="/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/2024/06/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（五）——中央处理器"><a href="#计算机组成原理（五）——中央处理器" class="headerlink" title="计算机组成原理（五）——中央处理器"></a>计算机组成原理（五）——中央处理器</h1><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h2><img src="https://pic.imgdb.cn/item/6666f9a05e6d1bfa0557f168.png" alt="计算机组成原理（五）——中央处理器——知识总览.png"><p>上图给出了本章知识总览，本章的学习也是从上图所示的五个部分入手，在学习过程中可结合上图进行学习。</p><h2 id="1-CPU的功能与结构"><a href="#1-CPU的功能与结构" class="headerlink" title="1. CPU的功能与结构"></a>1. CPU的功能与结构</h2><img src="https://pic.imgdb.cn/item/666867d8d9c307b7e940051c.png" alt="计算机组成原理（五）——中央处理器——CPU的功能.png"><p>CPU由运算器和控制器两大部件组成。</p><p>CPU首先要完成的最重要的一个功能是<strong>指令控制</strong>，就是要完成取指令、分析指令和执行指令的操作，CPU需要能自动的完成程序的顺序执行。</p><p>CPU在执行指令的过程中，需要控制各个部件，一步一步的来完成工作，因此CPU的第二个功能就是需要实现<strong>操作控制</strong>。一条指令的执行，往往需要多个细分的操作才能够完成，因此CPU需要提供一些列的操作信号，每一种操作信号会对应着一种微操作。通过多种操作信号的组合，就可以完成指令所需要的一个一个的微操作。CPU需要根据具体的指令来决定，应该发出哪些操作信号。另外这些操作信号会被送到相应的部件（比如某一个寄存器），这些更细小的硬件部件，接收到相应的操作信号之后，就可以按照要求来进行相应的动作。</p><p>CPU的第三个功能是<strong>时间控制</strong>。一条指令执行的过程当中，各个操作是有先后顺序的，而每一个具体的微操作会对应一个操作信号，所以这些操作信号应该按照时间先后顺序来逐一发出。</p><p>CPU的第四个功能是<strong>数据加工</strong>。所谓数据加工就是进行算术和逻辑运算。</p><p>CPU的第五个功能是<strong>中断处理</strong>。所谓中断处理就是对计算机运行过程中出现的异常情况和特殊请求进行处理。正常情况下，CPU是从头到尾依次顺序的执行某一个程序的指令，但是由于计算机内部会有一些突发的状况需要处理，因此就引入了中断机构，当CPU检测到某一种特殊的中断信号之后，会转而执行处理这个中断对应的一系列指令代码，当中断处理完以后，再回去执行之前执行的一系列指令。（中断处理的内容可以结合操作系统第一章进行学习）</p><p>接下来，站在运算器和控制器的角度，再把这些功能进行一个分类：</p><img src="https://pic.imgdb.cn/item/66686827d9c307b7e9406fec.png" alt="计算机组成原理（五）——中央处理器——运算器和控制器的功能.png"><p>显然，运算器主要实现的就是对数据的加工。</p><p>控制器主要负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令。</p><p>在取指令时，CPU应该自动的形成下一条应该执行的指令的地址（即之前说过的PC自动加1的功能）。</p><p>另外每一条指令执行结束之后，控制器也该自动的发出下一条指令的取指令命令。</p><p>当取得一条指令后，要分析这条指令，也就是要把指令的操作码进行一个译码，来分析这条指令到底想要完成什么样的操作。另外在分析指令的过程中，也需要产生操作数的有效地址（即根据数据寻址方式找到操作数的实际存放地址）。</p><p>每一条指令的执行背后都需要进行若干个微操作，而每个不同的微操作，都需要由一个控制信号来控制。因此执行指令的过程就是形成操作信号控制序列的一个过程，然后逐一的发出这些操作信号，从而控制着运算器、存储器、IO设备还有各种寄存器之间进行数据交换或者完成某一个相应的操作。</p><p>在现代计算机当中，每执行完一条指令之后，CPU都会检查是否有中断信号需要处理。在这个阶段，控制器完成对总线还有输入输出设备的处理，对中断信号做出应该有的响应，比如鼠标的点击操作就是一个中断信号，控制器要对鼠标的点击操作进行中断处理。除了外部设备可能导致中断的发生以外，内部指令的执行，也有可能会出现一些异常的情况，比如说一条指令是实现除法操作，但是给出的除数等于0，那对于除法除以0这种异常情况的处理也是由控制器在中断处理这个阶段来负责搞定的。</p><p>接下来详细的探讨一下运算器和控制器应该怎么组成，需要有哪些部件：</p><p>运算器的核心就是ALU算数逻辑单元，ALU是一个组合逻辑电路，可以实现算术运算和逻辑运算。我们需要提供两个操作数a和b，然后经过ALU电路处理之后，可以输出运算结果。</p><p>很多情况下，我们会把需要参与运算的一些数据，提前存放到某一些通用寄存器当中。所以运算器内部还需要提供一些通用寄存器组，如下图，就给出了四个通用寄存器。</p><img src="https://pic.imgdb.cn/item/6668715ed9c307b7e94b9a0b.png" alt="计算机组成原理（五）——中央处理器——通用寄存器组.png"><p>对于x86架构来说，通用寄存器的命名规则通常是AX、BX、CX、DX、SP等。而上图的AH、AL、BH、BL等，指的是AX、BX等通用寄存器的高位和低位。如AH指的就是AX这个通用寄存器的高位（高字节部分），AL指的就是AX这个通用寄存器的低位（低字节部分）。这就是x86架构的CPU对寄存器的一个命名的规则，只是名字不一样，本质上与这里用R0，R1，R2，R3表示的寄存器没什么区别。</p><p>另一个值得注意的是这里有个SP，SP是堆栈寄存器，保存了堆栈指针，堆栈指针的作用在上一章寻址里的堆栈寻址部分有介绍过，这里就不再赘述了，如有遗忘，可以回去翻一下上一章有关堆栈寻址的内容。</p><p>有的教材把堆栈指针寄存器SP归为了通用寄存器，而有的教材当中会专门的把堆栈指针寄存器SP归为一类特殊的寄存器。</p><p>总之，为了实现算数运算和逻辑运算，运算器的内部一定需要提供一组通用寄存器。任何一个通用寄存器里保存的数据，都有空作为ALU的一个输入，比如R0里的数据可能作为ALU的A端口的输入，也可能作为ALU的B端口的输入。因此需要提供两组连线，分别把R0连到A端和B端。R1、R2、R3与R0类似，也要连线，如下图：</p><img src="https://pic.imgdb.cn/item/6668747cd9c307b7e9500ebd.png" alt="计算机组成原理（五）——中央处理器——专用数据通路.png"><p>注意，这里虽然给每个寄存器与ALU的连接都只简单的画了一条线，但事实上应该有很多条线。以R0为例，如果R0寄存器可以存放16bit数据，那么这16bit数据应该是通过16根线并行的把它送到A端口或B端口，只不过这里画16条线会显得很乱，因此用一条线简化表示。</p><p>由于每个寄存器和ALU之间都有一个单独的专门的数据通路，因此这种连线方式，我们把它称为专用数据通路的方式。</p><p>专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路。</p><p>从上图可以发现，ALU的输入端和所有的寄存器都进行了连接，所有的寄存器都在同时给ALU传送数据。而一次算数运算当中，应该只挑选其中的某一个寄存器作为左边的输入，然后挑选另一个寄存器作为右边的输入，不应该让所有寄存器都同时进行数据的输入，面对这种问题，可以使用多路选择器，如下图。</p><img src="https://pic.imgdb.cn/item/66686888d9c307b7e940e967.png" alt="计算机组成原理（五）——中央处理器——运算器的基本结构1.png"><p>多路选择器，英文缩写MUX，每个多路选择器都会有相应的控制信号，用来决定到底要把哪个输入信号进行输出。比如现在要执行的是一个加法指令，加法的两个操作数分别存在于R0和R1，在执行这条指令时，控制器会给左边的多路选择器输入一个信号00，表示让R0寄存器作为左边操作数；同时，控制器会给右边的多路选择器输入一个信号01，表示让R1寄存器作为右边操作数。所以加了多路选择器后，控制器就可以决定让哪个寄存器作为操作数输入。</p><p>上面是第一种解决方法，下面看第二种方法，使用三态门。如下图。</p><img src="https://pic.imgdb.cn/item/6668ff1cd9c307b7e9d906ba.png" alt="计算机组成原理（五）——中央处理器——三态门.png"><p>每一个三态门可以控制一条路是否可以输出，通常用如图所示的小三角来表示一个三态门。</p><p>每个三态门会有三个接口，第一个接口是输入接口，第二个接口是输出接口，第三个接口是使能接口。正常情况下，三态门是不导电的，即没有连通，但是当使能接口输入电信号以后，比如输入一个高电平时，三态门就可以导电。而如果控制信号是低电平的话，三态门就不会导通。</p><p>显然，采用专用数据通路方式，可以保证性能较高，基本上不存在数据冲突的现象。但是部件如果特别多的话，连线也会变得复杂，这就意味着制造成本和工艺难度的提升。所以专用数据通路方式，可以在某一些性能要求比较高的部件之间进行连线。</p><p>与之相对于的另一种数据通路设计方式叫CPU内部单总线方式，即可以在CPU内部设置一个总线，然后所有的寄存器都直接连接到这个内部总线上，可以把数据输出到内部总线，也可以从内部总线接收信号。</p><p>下图是内部单总线的方式：</p><img src="https://pic.imgdb.cn/item/666bb001d9c307b7e91ddc5a.png" alt="计算机组成原理（五）——中央处理器——运算器基本结构1.png"><p>显然使用这种内部单总线的方式，要比之前提到的专用数据通路结构简单，连线也要更简单，比较容易实现，但是数据传输过程存在较多的冲突现象，性能较低。</p><p>举个例子说明：</p><img src="https://pic.imgdb.cn/item/666bcebcd9c307b7e9516d3c.png" alt="计算机组成原理（五）——中央处理器——运算器基本结构2.png"><p>假设现在寄存器里的数据可以通过数据总线进行传输，这些数据有可能作为ALU的输入。比如现在进行加法指令(ADD)，对R0和R1的内容进行一个加法操作。那R0和R1的内容同时送到总线上，就会导致总线的冲突，ALU无法判断A和B到底应该是什么值。为了解决这个问题，可以在其中一端设置一个暂存寄存器，这样就可以先把R0的数据送到总线上，然后通过总线R0的数据会被放到暂存寄存器当中。接下来撤销R0的输出有效信号，即给R0out低电平，然后让R1导通，把R1的数据送到总线上，然后R1数据会通过上图右边线路输出到B端。这样就可以保证内部单总线的结构可以正常的工作。</p><p>所以采用这种连线方式，运算器内部需要提供暂存寄存器，用于暂时存储从主存或从某些寄存器读过来的数据。</p><p>接着看这个例子，通过ALU进行加法运算以后，得到结果会输出到总线，然后重新放到R0寄存器里。但ALU的输入端一定要等到信号稳定以后，输出端才有可能得到正确的结果，然而其中一个操作数R0，R0给到B端的输入信号不稳定之前，ALU就会产生一个输出信号，送到内部总线上，这就会和R0送到内部总线的信号发生冲突。所以在ALU的输出端也要加上一个暂存寄存器，然后还要在暂存寄存器的上方加一个三态门，等ALU的输出结果稳定以后，再让三态门导通，从而把运算结果送到内部总线上。然后再给R0的输入端接上使能信号，就可以把加法运算结果输入回R0。</p><p>为了方便某些复杂运算的实现，暂存寄存器还可以增加一些功能，比如改造成移位寄存器，或累加寄存器。不过也可以如下图一样专门设置一个累加寄存器，也就是ACC，用于存放每一次运算的中间结果。</p><img src="https://pic.imgdb.cn/item/666bcf60d9c307b7e9526dee.png" alt="计算机组成原理（五）——中央处理器——运算器基本结构3.png"><p>除了这些寄存器外，之前还提过一个重要的寄存器叫程序状态字寄存器(PSW)。我们在进行运算的时候，有的运算可能会发生溢出，或者运算结果为0，所以ALU每进行一次运算，这次运算结果的状态都会被记录在PSW这个寄存器当中，其中不同的二进制位有不同的含义，比如OP这个二进制位就表示刚才进行的运算是否发生溢出。总之，PSW中的这些位会参与并决定微操作的形成。</p><p>那除了上面这些各种寄存器外，运算器内部还要提供一个移位器，对运算结果进行移位运算，移位运算很重要，比如说在二进制乘法中，其实就是加法操作和移位操作交替执行。</p><p>最后运算器内部还需要提供一个计数器，用于控制乘法和除法运算的操作步数。因为二进制乘法和除法，本质上就是进行多次的加法和减法，至于到底执行了几次加几次减，这就需要通过计数器来记录。</p><p>上面的是运算器内部的基本结构，接下来看控制器的基本结构，如下图：</p><img src="https://pic.imgdb.cn/item/666c646bd9c307b7e9758d40.png" alt="计算机组成原理（五）——中央处理器——控制器结构.png"><p>控制器主要用于取指令、分析指令和执行指令，那为了记录下一条指令的存放地址，所以必须有一个程序计数器PC，并且PC有自动加一的功能。当然也有一些CPU的内部，PC加一这个功能是通过送给ALU实现的。</p><p>接下来，取出一条指令后，会把这个指令放到指令寄存器IR当中。一条指令分为操作码(OP)和地址码(Ad)两个逻辑部分，其中地址码有可能会有多个。指令的地址码指明了操作室的存放地址，所以地址码的信息需要输出到内部总线上。而操作码部分会送给控制单元CU。</p><p>那么首先这个操作码会送给指令译码器，然后译码器对应的某一个输出端会被选通，那么根据哪一条输出线被选通，可以判断当前执行的指令是一个什么样的指令。</p><p>译码器的输出信号会作为微操作发生器的一个输入信号，用来判断这条指令所对应的微操作序列是什么。</p><p>由于微操作序列执行有先后次序，因此还需要有一个时序系统产生时序信号。微操作发生器每接收到一个节拍信号，就会执行下一个微操作，发出下一个微操作所对应的操作信号。另外，除了指令的操作码之外，还需要根据PSW当中存放的标志信息，决定接下来微操作序列到底是什么样的。</p><p>总之，根据当前指令的操作码和PSW里边某些标志位，就可以确定接下来要进行的微操作到底是什么。另外，从上图里可以看到，微操作信号发生器发出的信号颜色有绿色有蓝色，这两个颜色和上图中的图示颜色相对应，意思是寄存器的输入信号输出信号是否有效，即信号的有效与否是通过微操作信号发生器发出的信号来进行控制的。</p><p>除了这些部件以外，还需要有存储器地址寄存器，即MAR。现在计算机中，MAR通常集成在CPU内部。而且从上图可以看到，MAR在控制器内部只有输入线，没有输出线。</p><p>MAR里保存的信息，指明了某一个主存的存储地址，可以通过通过这个地址信息访问主存、如果访问主存，就需要把这个地址信息，通过外部的地址总线传送给主存，然后主存根据总线上的地址信号去查找相应的存储单元，找到数据以后会把数据放到MDR当中。MDR也是被集成在CPU内部，主存需要通过外部的数据总线把找到的数据送到CPU的MDR中，这样就完成了对某一个主存地址的读操作。</p><p>这里在上图可以看到，MDR的两个控制信号分别叫MDRin和MDRinE，后面加了E的意思是从外部数据总线输入数据的通路是否有效，没加E的意思是从CPU内部数据总线输入数据的通路是否有效。这一点在做题时要注意。输出信号MDRout和MDRoutE同理。</p><p>现在把运算器和控制器的结构都连到CPU内部总线上，这样就形成了一个CPU的比较详细的结构图，如下图。</p><img src="https://pic.imgdb.cn/item/666c659fd9c307b7e9781675.png" alt="计算机组成原理（五）——中央处理器——控制器和运算器.png"><p>运算器主要由ALU和一系列寄存器组成。而控制器主要由一系列寄存器和控制单元CU组成。值得注意的是，CPU内部有的寄存器是用户可见的，有的寄存器是用户不可见的。用户可见的意思是说，程序员可以通过汇编语言，来改变某一些寄存器内部的值。上图中用橙色标出的寄存器是用户可见的，灰色的则是不可见的。</p><p>逻辑上CPU可以分为ALU、寄存器、CU还有中断系统这四大部分，如下图：</p><img src="https://pic.imgdb.cn/item/666c6628d9c307b7e9795d07.png" alt="计算机组成原理（五）——中央处理器——逻辑划分.png"><p>这一章重点探讨的是CU控制单元。</p><p>下面对本节进行小结：</p><img src="https://pic.imgdb.cn/item/666c66c7d9c307b7e97ad834.png" alt="计算机组成原理（五）——中央处理器——CPU功能与结构小结.png"><h2 id="2-指令周期的数据流"><a href="#2-指令周期的数据流" class="headerlink" title="2. 指令周期的数据流"></a>2. 指令周期的数据流</h2><img src="https://pic.imgdb.cn/item/666edd00d9c307b7e987b116.png" alt="计算机组成原理（五）——中央处理器——指令周期.png"><p>所谓指令周期，就是CPU从主存中取出并执行一条指令所需要的全部时间，每一条指令的完整执行时间就是一个指令周期。</p><p><strong>一个指令周期可以被划分为取指周期和执行周期两部分</strong>，如上图。其中取指周期会根据PC所指向的位置取出当前要执行的指令，并且PC自动加一指向下一条应该执行的指令。另外，还会对指令进行译码，也就是分析指令的过程。</p><p>注意，上图把分析指令归为取指周期内，但有的地方会把分析指令单独的拆分成一个阶段。这里这么做的原因是取指令这个操作会涉及到访存，访存是很慢的，而当把这条指令取到IR指令寄存器之后，对这条指令的分析是CPU内部一个很快速的运算，因此分析指令这个过程速度是很快很快的，比起访存来说，只需要花很短的时间就可以完成指令的译码。这就是为什么这里把分析指令划分在取指周期内的原因。</p><p>分析指令结束以后，就可以执行指令。执行指令的过程同样有可能需要访存，当然也有可能不需要访存，所以不同的指令所需要的执行时间有可能区别很大。当一个指令执行结束以后，就可以取下一条指令，也就是进入下一个取指周期。</p><p>通常来说，<strong>一个指令周期常常由若干个机器周期（CPU周期）表示</strong>。像上图图示，取指周期会消耗掉一个机器周期，执行阶段又会消耗掉一个机器周期。而一个机器又会包含若干个时钟周期。时钟周期也称为节拍、T周期或CPU时钟周期，它是CPU操作的最基本单位。</p><p>机器周期、时钟周期和指令周期的关系如下图：</p><img src="https://pic.imgdb.cn/item/666eebd6d9c307b7e9a8f041.png" alt="计算机组成原理（五）——中央处理器——指令周期关系.png"><p>上图里的CLK指的是时钟脉冲，一个方波代表一个时钟周期，在购买CPU时会看到一个很重要的指标叫CPU的主频，如果CPU的主频是3.0GHz，就代表CPU每秒钟可以发出3.0G次的时钟周期。</p><p>另外，根据上面的叙述可以发现，取指令的过程其实需要分为几个微操作，如果说取指令的过程需要四个微操作，即四个步骤，如上图，那就意味着取指令需要消耗四个时钟周期，所以可以看到上图T0~T3，通过这四个时钟周期分别执行四个微操作之后，才完成了取指令这个动作。</p><p>取出指令以后，有可能需要对这个指令里边所包含的形式地址进行一个转换，把形式地址转换为有效地址，这个转换过程也有可能需要消耗若干个时钟周期，上图的例子同样是消耗了四个周期。</p><p>确定了操作数的存放地址以后，接下来就可以执行这条指令，也就是去主存当中取出操作数，并且执行相应的运算，所以执行指令又需要分为若干个微操作，上图例子同样假定执行指令需要四个时钟周期。</p><p>从上图中可以看出，所谓机器周期指的是我们完成了某一步子工作所需要的时间，一个机器周期需要由多个时钟周期组成。<strong>如果说完成每一步子工作所需要的时钟周期都是相同的，这就意味着所有的机器周期的长度也是相同的，所以这种CPU就是定长机器周期的CPU</strong>。</p><p>当然，对于取指令和执行指令所需要的时间也许是各不相同的，可能取指令需要进行访存，但是执行指令不需要进行访存，如果是这样的话，执行指令所消耗的机器周期就有可能比取指令所需要的节拍数要更少。<strong>因此这一类的CPU就是不定长的机器周期的CPU</strong>。</p><p>另外，从上图的两个机器周期示例图里也能看到，<strong><font color=red>不同的指令执行所需要的时间，也就是指令周期的长度，有可能是不一样的</font></strong>。比如有可能一条指令给的是形式地址，这时需要地址转换的周期，而有的给的是直接地址，这时候就不需要进行转换。对于不同的指令执行所需要的时间有可能是不一样的这句话的理解，我们也可以参考下图的具体例子结合理解。</p><img src="https://pic.imgdb.cn/item/666eec7cd9c307b7e9aa6cb0.png" alt="计算机组成原理（五）——中央处理器——指令周期不同.png"><p>这里可以看到，有的指令在取指结束后，就可以直接执行。而有的指令在取指结束后，还需要把形式地址转换为有效地址，也就是需要增加间址周期，然后才可以执行。所以不同的指令的执行过程是不一样的，下面把指令周期的整个流程给捋一遍。</p><p>如下图，是指令周期的整个流程：</p><img src="https://pic.imgdb.cn/item/666ef48fd9c307b7e9bc7dff.png" alt="计算机组成原理（五）——中央处理器——指令周期流程.png"><p>首先需要从主存当中取出这条指令，这段时间称为取指周期。</p><p>取出指令后，需要进行指令的分析，如果这个指令当中包含的地址码部分采用间接寻址，那我们就需要经过间址周期，来把形式地址转换成操作数的有效地址。</p><p>有了操作数的有效地址之后，就可以执行这条指令，也就是进入执行周期。</p><p>指令执行结束后，会例行的检查是否有中断信号需要处理，如果此时有中断信号需要处理，那么就会进入中断周期，否则这条指令的整个指令周期就到此为止。就会进入下一条指令的指令周期。</p><p>上面就是整个指令周期的处理流程，显然，取指阶段、间址阶段、执行阶段和中断阶段，这几个阶段CPU所需要做的事情一定是不一样的，那CPU是如何区分当前到底处于哪个阶段呢？为了解决这个问题，可以设置四个触发器，如下图。</p><img src="https://pic.imgdb.cn/item/666efa75d9c307b7e9c97ae2.png" alt="计算机组成原理（五）——中央处理器——触发器.png"><p>注：触发器的知识可以参考第三章。</p><p>一个触发器可以存放一个二进制比特位0或者1，所以可设置如上图的四个触发器，分别用来表示当前到底处于指令执行的哪个阶段。比如当前如果处于取值周期，那么控制单元会把FE触发器的值设置为1，其余的设置为0；如果处于间址周期，那么控制单元会把IND触发器的值设置为1，其余的设置为0；如果处于执行周期，那么控制单元会把EX触发器的值设置为1，其余的设置为0；如果处于中断周期，那么控制单元会把INT触发器的值设置为1，其余的设置为0。</p><p>CPU执行一条指令的不同阶段需要做不一样的事情，通过这些触发器就可以判断当前处于哪个阶段。</p><p>另外，这四个阶段的工作都有可能需要进行访存操作，只不过访存目的不一样。取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。</p><p>接下来探讨一下，在这四个阶段，分别要做什么事情：</p><img src="https://pic.imgdb.cn/item/666efccfd9c307b7e9ce7088.png" alt="计算机组成原理（五）——中央处理器——取指周期.png"><p>如上图，在取指阶段，首先PC这个寄存器指明了接下来要执行的指令在主存当中的存放地址，因此第一步需要把PC当中保存的地址信息，先给送到MAR当中。</p><p>接下来CU控制单元通过控制总线，向主存储器发出读信号。注意，上图使用**<font color=red>1-&gt;R</font>**的方式来表示发出读信号，至于为什么使用这样的记录方法，是因为在第三章里我们学过，主存储器到底是是要进行读操作还是写操作，关于这个控制可以留两个接口，其中一个接口R表示要进行读，另一个接口W表示要进行写，如果给R接口输送一个高电平信号，就意味着主存此时要进行读操作。</p><p>CU通过控制总线向主存发出了读信号之后，MAR指明了当前要取出的指令存放在什么地址，这个地址信息会通过地址总线送给主存。此时我们读出这个地址相应的数据，就意味着读出了接下来要执行的这条指令。这条指令会通过数据总线送到MDR当中。</p><p>这里注意一下上图的把指令通过数据总线送到MDR当中的表示方式：**<font color=red>M(MAR)-&gt;MDR</font><strong>。正常我们知道，</strong>不加括号表示数据直接在寄存器中 ，加了括号表示间址，需要到主存中访问数据**，而这个加了括号前面还有一个M是什么意思呢？这里的M指的是memory，即主存。这个记录方式的意思是把主存当中MAR所指向的数据放到MDR当中。有的教材也会记成MEN(MAR)-&gt;MDR。注意这里的书写方式，做题时会遇到。</p><p>现在我们需要的指令已经放到了MDR当中，我们还需要把MDR当中的内容送到IR指令寄存器当中，这样就完成了取指操作。</p><p>另外，还需要注意，每取出一条指令，都会让PC的值自动加一，所以最后CU会发出一个控制信号让PC的值自动加一，形成下一条指令的地址。</p><img src="https://pic.imgdb.cn/item/666efcfed9c307b7e9cede3d.png" alt="计算机组成原理（五）——中央处理器——间址周期.png"><p>当完成取指以后，接下来应该执行指令，但有的指令的地址码可能采用了间接寻址的方式，因此有的指令有可能需要进入到间址周期。</p><p>顾名思义，我们需要通过指令当中所包含的形式地址来完成一次间接寻址。目前这个指令的地址码只是指明了有效地址的一个存放地址，所以我们需要根据这个指令的地址码信息，先从主存当中读出这个有效地址，这样才能在执行指令的时候，根据有效地址得到最终的操作数。</p><p>具体的数据流向就是把当前的这条指令的一个地址码信息送到MAR当中。注意，这里把指令地址码的信息送到MAR当中，使用的是<strong>Ad(IR)-&gt;MAR</strong>，这里的Ad是地址码的意思，我们知道指令由操作数和地址码组成，所以如果想用的是操作数，应该写成OP(IR)。</p><p>注意，把指令的地址码信息送到MAR当中，除了上面的把IR指令寄存器当中包含的地址信息送到MAR中外，也可以把MDR当中的地址信息送到MAR中。因为在间址周期前，经过了取指周期，而在取指令的过程中，我们是先把指令从主存放到MDR当中，然后再把MDR的数据给复制一份到IR当中，所以此时MDR里边所存储的也应该是当前执行的指令的一个信息，因此也可以直接从MDR当中读取出这条指令的一个地址信息。</p><p>接下来CU发出读信号，通过控制总线来告诉主存接下来要进行读操作。接下来根据MAR所指明的地址，就可以读出相应的数据，然后通过数据总线放到MDR当中。此时读出的这个数据应该是有效地址，到这步就意味着我们已经找到了接下来这个操作数存放的有效地址。</p><p>当我们找到了接下来这个操作数存放的有效地址以后，在接下来执行指令的时候，就可以根据MDR里存储的信息，来判断我们的操作数到底是存放在哪一个有效地址当中，也就是说可以直接把MDR的数据送到MAR，用来指明操作数的地址。当然也有的CPU是把此时得到的这个有效地址拼接到指令的地址当中，即拼接到IR寄存器里。因为原本指令里包含的是一个形式地址，所以我们得到有效地址以后，可以把这个有效地址拼接上去，把以前的形式地址给覆盖掉，这样接下来执行这条指令的时候，可以把这个地址码当做直接地址来进行访问。根据有效地址，接下来可以执行指令。</p><img src="https://pic.imgdb.cn/item/666efd2dd9c307b7e9cf4265.png" alt="计算机组成原理（五）——中央处理器——执行周期.png"><p>在执行指令阶段，不同的指令所需要做的事情千差万别，因此在这个阶段没有一个统一的数据流行，本节暂时不探讨，之后会对不同的指令进行分开讨论。</p><p>执行周期完以后，就会进入中断周期。</p><img src="https://pic.imgdb.cn/item/666efdf3d9c307b7e9d20a9a.png" alt="计算机组成原理（五）——中央处理器——中断周期.png"><p>注意，这里如果没有操作系统基础的话，直接看中断有点难以理解其中过程，而计组里的中断部分会在第七章，也就是最后一章才能学到，所以这部分我推荐去看一下原视频讲解，因为其中会掺杂一部分中断的知识点，原视频跳转链接：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=63&vd_source=7fb4b255ed876969a742738d7b84f461">指令周期数据流——王道</a>(大概从22分钟到28分30秒处)。</p><p>到此，我们就对指令周期的各个阶段所需要做的事情有了更进一步的了解。可以知道的是，一个指令周期通常要包括几个时间段（执行步骤)，每个步骤完成指令的一部分功能，经过若干的步骤之后，才可以完成这条指令的全部功能。</p><p>那么当我们希望能够连续执行多条指令的时候，这个指令的执行方案有哪些呢&#x2F;</p><img src="https://pic.imgdb.cn/item/666efe59d9c307b7e9d30f80.png" alt="计算机组成原理（五）——中央处理器——指令执行的方案.png"><p><strong>第一种方案：单指令周期。</strong></p><p>虽然不同的指令，需要的操作步数可能不相同，但如果采用单指令周期方案，我们会规定所有的指令的指令周期都是相同的。</p><p>本来有的指令只需要很短的时间就可以完成，而有的指令需要很长的时间才可以完成，但如果在单指令周期方案下，就意味着对任何一条指令，它的指令周期，都会被延长为和最慢的那条指令相同。这也意味着，某一些执行很快的指令，可能有很长的时间是浪费掉的。</p><p>但这么做的好处是，当我们设计指令执行的控制电路的时候，我们只需要根据节拍数就可以确定一条指令的执行是否结束，所以这种方式可以使得控制电路设计起来更方便一些。</p><p>另一点需要注意的是，如果采用这种方式，各个指令之间是串行执行的，即一条指令执行结束以后，紧接着才执行下一条指令。</p><p>到此，可以发现，这种指令的执行方案是比较低效的，为了解决这个问题我们可以采用第二种方案——多指令周期。</p><p><strong>第二种方案：多指令周期。</strong></p><p>多指令周期就是说我们可以允许不同的指令，执行的指令周期的长度不同。这样的话执行快的指令只需要很短的一个指令周期就可以执行结束，当它执行结束后，就可以紧接着执行下一条指令。所以如果采用这种指令执行方案，就要比第一种方案效率高得多。</p><p>如果采用这种方案，指令之间也是串行执行。而不同的指令所需要的时钟周期数也是各不相同的，因此这就导致我们需要设计更复杂的控制电路，硬件的设计成本会增加。</p><p><strong>第三种方案：流水线方案。</strong></p><p>流水线方案，就是在每一个时钟周期启动一条指令尽量让多条指令同时运行，但各自处在不同的执行步骤中。采用流水线方案就可以使得指令之间并行的执行，流水线的内容会在本章最后一部分详细探讨，这里先简单介绍一下。</p><p>我们可以看到不同的指令，它的执行是分为不一样的阶段的，那么一条指令在不同的执行阶段，有可能需要用到的硬件部件是不一样的，比如第一个阶段需要用到PC计数器和IR寄存器，而第二个阶段用到MAR和MDR。</p><p>总之，如果说各个阶段用到的硬件部件不一样，就意味着，当第一条指令执行了第一个阶段之后，第一个阶段所需要用到的硬件部件暂时就用不到了，这些部件就可以让给其他的指令来使用。因此当这条指令完成了第一阶段工作之后，就可以接着启动第二条指令，让第二条指令完成它的第一阶段工作，同时上一条指令进入第二阶段工作。当第二条指令完成其第一阶段工作后，就可以把第一阶段用到部件让给第三条指令使用，让第三条指令进行第一阶段工作，具体过程可以参考上图右下角红笔画的示意图。</p><p>上述便是指令流水线的概念，即在指令执行的不同阶段，所需要用到的资源是不一样的，那么就可以设计指令流水线，使得总体来看指令之间可以并行的执行，从而使CPU内部这些不同的部件利用率达到最高。</p><p>下面对本节进行一个小结：</p><img src="https://pic.imgdb.cn/item/666efe99d9c307b7e9d391be.png" alt="计算机组成原理（五）——中央处理器——指令周期的数据流小结.png"><h2 id="3-数据通路的功能"><a href="#3-数据通路的功能" class="headerlink" title="3. 数据通路的功能"></a>3. 数据通路的功能</h2><h3 id="3-1-知识回顾"><a href="#3-1-知识回顾" class="headerlink" title="3.1 知识回顾"></a>3.1 知识回顾</h3><img src="https://pic.imgdb.cn/item/66711f1ad9c307b7e9d8f15a.png" alt="计算机组成原理（五）——中央处理器——指令周期的数据流.png"><p>通过之前的学习可以知道，一条指令的执行，整个指令周期会被划分为不同的阶段，在不同的阶段，有可能数据的流向是不一样的。</p><p>有的时候需要实现寄存器之间的数据流动，有的时候需要实现主存与寄存器之间的数据流通，还有的时候需要实现寄存器与算术逻辑单元之间的数据交换。无论执行什么样的指令，在指令执行的整个过程当中，数据的流动都逃不过这三种。所以，接下来会探讨这三种类型的数据流动应该如何实现，如何发出控制信号。</p><p>而在之前的部分里，也提过数据通路的概念，如下图：</p><img src="https://pic.imgdb.cn/item/66712068d9c307b7e9db89b1.png" alt="计算机组成原理（五）——中央处理器——数据通路.png"><p>数据通路指的就是数据在各个功能部件之间传送的一个路径，我们需要确定信息从哪儿开始，中间经过哪些部件，最后又传到了哪个地方。只要确定了数据流动的方向，就可以依次的发出不一样的控制信号，来控制这些数据的流动。</p><p>控制信号是由控制部件产生的，对于各种类型的寄存器来说，总共有两种控制信号，第一种控制信号是控制数据的输入，而第二种控制信号是控制数据是否可以从寄存器流出。无论是控制输入信号还是输出信号，这些控制信号都是由控制器发出的。</p><p><strong>另外，数据通路的基本结构有三种：</strong></p><ol><li><strong>CPU内部单总线方式。</strong></li><li><strong>CPU内部多总线方式。</strong></li><li><strong>专用数据通路方式。</strong></li></ol><p>上图中，采用的就是CPU内部单总线的方式，所有的寄存器之间交换数据都是通过一个CPU内部总线来完成的。这种单总线的方式也意味着，在同一时刻，只允许两个部件之间进行数据交换，它们对总线的使用是独占式的。当两个部件之间进行数据交换时，就不允许另外两个部件之间进行数据交换。而为了解决这个问题，在有的CPU当中会涉及多个总线。</p><p>CPU内部有多个总线，就是CPU内部多总线方式。如果有的CPU内部有三个总线，就意味着同时可以支持三组部件的数据交换。</p><p>除了用总线的方式作为公共的信息通路之外，也有的CPU内部会采用专用数据通路方式，也就是只要两个寄存器之间需要有数据流动，那么就会单独的在这两个寄存器之间专门的建立一个数据通路。</p><p>下面先着重看一下基于单总线的方式，如何实现信息的流动。</p><h3 id="3-2-单总线结构"><a href="#3-2-单总线结构" class="headerlink" title="3.2 单总线结构"></a>3.2 单总线结构</h3><p>在3.1里说过，数据流动大致上分为三类，第一类是寄存器与寄存器之间的流动，第二类是寄存器与主存之间的流动，第三类是寄存器与ALU之间的流动。所以接下来依次探讨这三种情况。</p><p>在此之前，先回顾一下内部总线和系统总线的概念，如下图。</p><img src="https://pic.imgdb.cn/item/667128a8d9c307b7e9ecd348.png" alt="计算机组成原理（五）——中央处理器——寄存器之间数据传送.png"><p>接下来首先探讨寄存器与寄存器之间的数据传送如何实现。假设要把PC内容送至MAR，因此应该先让PC的流出控制信号有效，即让PCout为高电平，此时PC的数据会被送到总线上。接下来想让这些二进制数据输入到MAR当中，因此还需要让MAR的输入信号MARin有效，这样二进制数据就可以通过总线进入MAR寄存器中。</p><p>这里需要注意，在描述数据流动的时候，需要标明哪些控制信号是有效的，如上图，在描述数据流行(PC)-&gt;Bus的时候，也注明了PCout有效。</p><p>另外，有的教材也可能会把这两个步骤合二为一。而且之前强调，如果要把PC里的内容传送到MAR，通常需要在PC外面打一个括号，表示取出PC内容，然后传递给MAR。但是有的教材当中描述的时候，PC可能没有加括号。所以在做题时要看题目要求要不要加括号，当然这类题目一般看重的是描述清楚数据的流行，至于PC有没有加括号不是很重要，当然题目要求加的话，还是需要加的。这里关于加括号，想说一下我的理解，结合前面说过的，<strong>不加括号表示数据直接在寄存器中 ，加了括号表示间址，需要到主存中访问数据</strong>，个人认为，这些寄存器里存储的都是地址，而指令执行的时候，需要通过这些寄存器里的地址去主存里找到指令，比如PC里存储的是指令在主存里存储的位置，需要通过这个位置去找到位于该位置的指令，所以PC外面加上括号的意思是，把PC指向的地址上的指令给取出，当然也可以认为是通过间址找到的指令。</p><p>下面看一下寄存器与主存之间的数据传送：</p><img src="https://pic.imgdb.cn/item/66712ffdd9c307b7e9fb0f3d.png" alt="计算机组成原理（五）——中央处理器——寄存器与主存的数据传送.png"><p>比如CPU要从主存读取指令，第一步程序计数器PC指明了要读取的指令存放在什么地址，所以刚开始需要让PC的内容放到MAR当中，也就是上面寄存器之间数据传输的例子。</p><p>在准备完成之后，应该撤销刚才的两个控制信号PCout和MARin，此时总线空闲出来。接下来由于要对主存进行读操作，因此CPU需要对主存发出读信号，这个信号的发出是通过控制总线来进行的，当然上图并没有画出控制总线。</p><p>现在主存已经知道自己要进行读操作，而且应该读的地址是存放在MAR当中的，此时CU控制器使能MAR地址线输出端，让MAR中的地址信息通过地址线送到主存。注意，这里由于位置不够，所以没有画出，但大家心里要知道MAR通过地址线输出数据到主存，而且地址线的开启与否也是被CU控制的。</p><p>接下来主存跟据MAR所指示的地址读出相应的数据，然后把读出的数据送到MDR中，这个数据传送到MDR是通过数据总线进行的。注意，这里也有一个控制信号来控制MDR从数据总线接收数据，一般会把这个控制信号命名为MDRinE，上图直接写MDRin是有点小问题的，因为根据图示，MDRin是把数据从CPU内部总线输送到MDR，当然这里想表达的意思还是从数据总线把数据输入到MDR，这点要注意一下。</p><p>现在要的指令已经被放到MDR当中，接下来需要把这条指令给放到IR寄存器里。所以，需要接通MDR的输出通路和IR的输入通路，即控制MDRout和IRin有效。到此，就完成了读取一条指令的操作。</p><p>接下来看最后一种，当执行某一种算术或逻辑运算时，数据有可能需要流行ALU，此时这种指令的执行又会是什么样的呢？</p><img src="https://pic.imgdb.cn/item/667133ced9c307b7e9025150.png" alt="计算机组成原理（五）——中央处理器——寄存器与ALU的数据传送.png"> <p>比如执行加法指令，其中参与加法运算的一个操作数已经被存放在ACC中，而另一个操作数会由这条加法指令直接指明这个操作数的存放地址。</p><p>所以执行这条加法指令，首先需要根据指令的地址码部分，来读取出参与加法的另一个操作数。具体的做法就是把这条指令的地址码部分通过内部总线传送到MAR当中，要实现这个微操作，需要保证IR的输出控制信号是有效的，另外MAR的输入控制信号也是有效的。当然，还有一种方式，之前说过在取指令时是把指令先取到MDR中，然后再从MDR复制一份到IR中，所以取指结束后，MDR当中也存放了这条指令的完整信息，因此也可以从MDR直接把指令的地址码送到MAR中，所以也可以让MDR的输出信号有效，MAR的输入信号有效。</p><p>现在，指明了一个操作数的存放地址，接下来需要CU向主存发出一个读命令，主存收到地址信息同时又收到读信号，就可以把相应的存储单元里的数据通过外部的数据总线送到MDR当中，此时需要保证MDR的输入信号是有效的。</p><p>到这里已经取出了加法所需要的操作数，接下来需要先把这个操作数放到暂存寄存器y中。在之前，我们说过ALU算术逻辑单元的两个输入信号必须是同时有效的，而内部总线同一时刻只能传送一个输入信号，因此就只能先把其中的一个加数放到暂存寄存器y当中，然后另一个被加数是存放在ACC里的。接下来只需要让ACC的输出通路接通，同时让ALU的输入通路接通，这样的话另一个被加数就可以通过内部总线传送给ALU，此时ALU接收到了加数与被加数的电信号，CU还需要给ALU发送一个控制信号，告诉ALU要进行一个加法操作，接下来ALU对这两个数执行加法运算，运算结果会被输出到暂存寄存器Z中。待输出数据稳定以后，就可以撤销刚刚的控制信号，让内部总线恢复空闲。最后还需要把加法结果重新存回ACC里，此时CU还要发出控制信号，使暂存寄存器Z中结果传输到ACC中。这样就完成了一条加法指令。</p><p>需要注意的是，如果采用单总线结构，ALU算术逻辑单元的两个输入信号必须同时有效，而CPU内部总线，同一时刻只能传送一个输入信号，此时需要暂存寄存器先存储一个被加数才可以。而如果采用多个内部总线，我们就可以不设置这个暂存寄存器，而是通过另一个内部总线直接把要进行运算的操作数送给ALU。</p><p>到这里，我们也可以体会到单总线结构与多总线结构的区别，单总线的设计方式可以使硬件的设计成本更低，多总线的设计方式成本更高，但是可以使得数据的传输更有效率。考试时多遇到单总线的情况。</p><p>到目前为止，已经探讨了数据传送的过程当中，CU控制单元需要发出的一些控制信号，通过发出不一样的控制信号，就可以让微操作一步一步的执行下去，而每一个微操作的执行至少需要消耗一个时钟周期。每一个时钟周期内，CU都会发出一组相应的控制信号来完成其中的某一个微操作，到下一个时钟周期，CU又发出第二个控制信号来完成第二个微操作。所以指令的执行，本质上就是通过这样的一个一个的微操作，一组一组的控制信号来完成的。</p><p>接下来看一道例题：</p><img src="https://pic.imgdb.cn/item/66714555d9c307b7e926bc5c.png" alt="计算机组成原理（五）——中央处理器——单总线例题.png"><p>例题讲解跳转：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=64&vd_source=7fb4b255ed876969a742738d7b84f461">单总线结构数据通路</a>，大约18分30秒到27分40秒处。</p><p>下面对本节进行小结：</p><img src="https://pic.imgdb.cn/item/667145c7d9c307b7e927b206.png" alt="计算机组成原理（五）——中央处理器——单总线小结.png"><h3 id="3-3-专用通路结构"><a href="#3-3-专用通路结构" class="headerlink" title="3.3 专用通路结构"></a>3.3 专用通路结构</h3><p>前面说了单总线的结构，如果采用单总线就意味着同一时刻只允许两个部件之间进行数据的流通，如果说多个部件之间想同时交换数据，显然单总线结构是不支持的。但事实上，指令执行的过程中，有的部件之间的数据交换逻辑上是可以同时进行的，如果能让多个部件之间同时进行数据的流动，那么显然指令执行的速度也可以进一步得到提升。基于这样的需求，可以建立多总线，用多个总线来同时传输多组数据。另外还有一种方法，就是建立专用的数据通路，在任何两个需要进行数据流动的部件之间，都建立起一个专用的数据通路，如下图。</p><img src="https://pic.imgdb.cn/item/66714613d9c307b7e92845ec.png" alt="计算机组成原理（五）——中央处理器——专用数据通路方式.png"><p>上图就是专用数据通路结构，其原理与单总线一样，图中的C2、C5之类的东西就是控制信号，当控制信号有效时，就意味着它所控制的这条数据通路可以进行数据流通传送。</p><p>下面基于这样的一种专用数据通路的方式来探讨一下，如果想取出一条指令，那么需要发出哪些控制信号：</p><img src="https://pic.imgdb.cn/item/667147ead9c307b7e92bebfe.png" alt="计算机组成原理（五）——中央处理器——专用数据通路方式取指.png"><p>首先，指令的存放地址肯定是PC当中的，所以应该让PC的值先传到MAR当中，因此就需要给出C0的控制信号。</p><p>接下来，这个指令的存放地址还应该通过外部的地址总线传送给主存，所以应该接通C1的信号。</p><p>主存接收到地址信息，还应该给主存发送一个读控制信号，表示此时想读出指令的数据。</p><p>现在，主存收到了地址，也收到了读信号。此时主存需要通过外部的数据总线，把这个数据传送给MDR，因此应该给C2这个信号有效。</p><p>接下来，这条指令执行之前，还要把它送给IR指令寄存器，所以接下来应该让C3这个控制信号有效。这样就大致完成了取指令的工作。</p><p>另外要注意，每取出一条指令后，都要让PC+1，由于上图没有告诉PC+1的信号是哪一个，所以直接描述PC+1的过程即可。</p><p>接下来还需要把指令的操作码部分送给CU，进行指令译码。所以接下来要让C4的控制信号有效，把指令的操作码部分送给CU进行译码。注意，上图这里用来灰色字体标识，原因在于有的题目不会给你一个专门的控制信号来控制指令寄存器到CU的数据通路，如果题目中没有给出，那只需要写出Op(IR)-&gt;CU即可，不需要写C<sub>4</sub>有效。</p><p>这就是专用数据通路在取指周期所需要做的一系列事情。</p><p>接下来思考一下，如果说刚取出的指令是加法指令，然后这个加法指令指明了某一个地址，就是操作数在主存当中的存放地址，然后另一个加法的操作数已经提前放到了ACC中，那么接下来这条加法指令的执行过程应该是什么样的呢？、</p><p>很显然，刚刚已经把指令取出来了，现在只需要根据指令的操作数地址，去主存里取出操作数，然后传给ALU运算即可，步骤应该是这样的：Ad(MDR)-&gt;MAR，M(MAR)-&gt;MDR，MDR&#x2F;AC-&gt;ALU。注意一点，这个题目里没有给出IR寄存器通往MAR的路子，所以应该是从MDR里把地址读到MAR，这也说明要理解知识，不能死记硬背。</p><p>到这里可以发现，有了单总线结构的基础，对于专用数据通路理解起来会很简单，下面看一道例题：</p><img src="https://pic.imgdb.cn/item/66714e2fd9c307b7e9395d6a.png" alt="计算机组成原理（五）——中央处理器——专用数据通路方式例题.png"><p>例题讲解跳转链接：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=65&vd_source=7fb4b255ed876969a742738d7b84f461">专用数据通路方式结构</a>，大概从五分钟开始到结束。</p><h2 id="4-控制器的功能和工作原理"><a href="#4-控制器的功能和工作原理" class="headerlink" title="4. 控制器的功能和工作原理"></a>4. 控制器的功能和工作原理</h2><h3 id="4-1-硬布线控制器设计"><a href="#4-1-硬布线控制器设计" class="headerlink" title="4.1 硬布线控制器设计"></a>4.1 硬布线控制器设计</h3><img src="https://pic.imgdb.cn/item/66715ccad9c307b7e9576238.png" alt="计算机组成原理（五）——中央处理器——硬布线控制器设计知识回顾.png"><p>首先回顾一下知识， 通过之前的学习我们知道，我们用高级语言编写的代码会被翻译成与之等价的一系列机器语言的指令序列，而每一条指令的执行有可能会被分为四个机器周期。</p><p>第一个周期是取指周期，这个周期内完成了从主存取出指令。</p><p>第二个周期可能会进入间址周期，如果当前执行的指令里面的地址码采用了间接寻址，那么就需要用间址周期把其中包含的形式地址转变成有效地址。另外，有的指令的间接寻址可能会涉及到多级的间接寻址，也就是说有的指令的间址周期可能会重复多次。</p><p>间址周期结束后，我们就知道最终要操作的操作数存放的有效地址，接下来就可以进入执行周期。而不同的指令在执行周期所做的事情各不相同。在指令的主要功能执行完以后，还有可能进入中断周期，用于处理某些突发的中断信号。</p><p>另外，注意一下上图的FE、IND、EX、INT，这几个英文缩写是触发器的意思，触发器标志着当前进入哪一个指令周期，这一点别忘了。</p><p>之前我们说过，在一个机器周期内，我们需要通过若干个微操作序列，来完成一个机器周期内需要完成的一些事情，每一个机器周期又会由若干个时钟周期组成，每个时钟周期又可以称为一个节拍。</p><p>控制单元CU会在每一个节拍内发出一个微命令，用来完成对应的微操作。所谓的微命令，指的就是与这个微操作所对应的控制信号。比如CU此时发出了微命令1，使得PCout和MARin这两个控制信号有效，那么发出这个微命令就意味着接下来就可以完成它所对应的微操作1，即把PC里的内容传递给MAR。所以微命令这个概念和微操作是一一对应的。微操作更多的是在描述我们要做的一个细分的工作，这个工作要完成一个什么样的功能，而微命令指的是要完成这个细分的工作，所需要发出的一些有效的控制信号。所以每发出一条微命令，那就意味着会完成一个与之对应的微操作。</p><p>另外，在之前我们说过，有的微操作是有可能并行的进行的。比如在专用通路结构下，完全可以让多个寄存器之间的数据同时并行的流动，因此一个机器周期由若干个节拍组成，而每一个节拍里，可以并行的完成某一些互相不冲突的微操作。比如上图的取指周期，假如需要三个节拍，那么可以在第一个节拍内就完成两个微操作，也就是让CU同时发出两个微命令。</p><p>在上图中，我们还可以发现，在执行周期和中断周期的T0节拍内，什么操作也没有执行。也就是说这条指令的执行周期以及中断周期只需要两个节拍就可以完成工作，然而还是让它们凑成了三个节拍，也就是让所有的机器周期都相等，这也就意味着在上图的例子中，我们是假定了采用定长机器周期的策略。这样做的好处是可以使电路设计更简单。</p><p>接下来总结一下，在上图例子中，一些比较重要的特质：</p><p>第一个特质，在一个节拍内，可以并行的完成多个相容的微操作。</p><p>第二个特质，同一个微操作可能在不同指令的不同阶段被使用。</p><p>第三个特质，不同指令的执行周期所需节拍数各不相同。为了简化设计，可以选择定长的机器周期，周期长短以可能出现的最大节拍数为准。一般来说，由于访存比较慢，因此涉及到访存的指令的执行，它所需要的节拍数有可能就是最大的节拍数，所以通常会以访存所需节拍数作为参考，来确定一个定长的机器周期。</p><p>第四个特质，如果说在一个机器周期内，实际所需要的节拍数要比它真正所包含的节拍数要更小的话，那通常来说可以把相关的微操作安排在机器周期的末尾几个节拍来进行。这里可以参考上图的执行周期和中断周期。</p><p>回顾完以上知识以后，我们就可以开始设计CU。通过之前的学习可以知道，对任何一条指令来说，它们在取指周期、间址周期、中断周期所做的微操作都是一样的，只有在执行周期内做的微操作序列可能会出现一些差别。但是只要能知道指令的操作码，能够判断这条指令的具体类型，那么也能够确定这条指令的执行周期内，每一个节拍所需要完成哪些微操作。</p><p>因此，只要能确定指令的操作码，并且再根据触发器信息判断处于哪一个机器周期，另外结合上节拍信号(即处于第几个节拍)，最后结合上机器的状态条件(比如PSW里记录的溢出信息等)，就可以确定现在所处的节拍下，CU应该发出哪些微指令。</p><p>接下来看一下如何结合这些信息发出微指令：</p><img src="https://pic.imgdb.cn/item/66717826d9c307b7e9916310.png" alt="计算机组成原理（五）——中央处理器——硬布线控制器.png"><p>首先可以看到，<strong>控制器的核心部件就是CU控制单元，如果控制单元采用硬布线方式设计，那么这种控制器就是硬布线控制器。</strong></p><p>按照上面所说，我们要想知道当前这个节拍下，控制单元CU应该发出什么样的微命令，那么首先要参考的是指令的操作码。所以，要先把IR寄存器的n位操作码送给操作码译码器，译码器的知识在第三章已经说过，如果输出n位操作码，那n位操作码可能会对应2<sup>n</sup>种状态，比如此时输入译码器n位全为0，那么就会使译码器的0号输出线输出高电平。CU根据译码器哪个输出线有效，来判断现在执行的是什么指令。</p><p>接下来，CU知道执行什么指令以后，还需要知道执行到指令的哪个周期。这时候会把四个触发器的二进制值送给CU，CU根据二进制值判断处于哪个周期。有一点需要注意，确定周期的触发器是集成在CU内部的，上图画在外面是为了演示用。</p><p>接下来，CU需要判断出处于该周期下的第几个节拍，所以还需要给CU输入一个节拍信号。节拍信号是通过节拍发生器来给出的，如上图左，时钟部件会有规律的发出脉冲信号，每一个脉冲信号就是一个时钟周期。节拍发生器接收到时钟部件发来的脉冲信号以后，都会选择让其中的某一根输出线导通，比如第一个脉冲让T0输出，第二个脉冲让T1输出。这样CU就可以根据节拍发生器的哪根线输出信号，来判断处于哪一个节拍。</p><p>补充一点，如果采用定长周期，这说明每一个机器周期采用的节拍数都是相等的，对于上图来说，相当于每个机器周期都会包含m+1个节拍(从T<sub>0</sub>到T<sub>m</sub>)，这些节拍信号是循环发出的，如果此时已经到达了当前机器周期的最后一个节拍，发出这个信号以后，接下来如果再接收到下一个脉冲信号，那么下一个节拍信号又会回到T<sub>0</sub>，这也意味着进入了下一个周期。</p><p>最后，还需要给CU输入机器的状态条件，我们把所有的状态条件统称为标志，这些标志来自于执行单元的反馈信息。</p><p>到此，CU就可以结合这些信息来决定当前这个节拍下应该发出什么样的微命令。所以CU的输出就对应一系列的微命令，如上图，每一条输出线就对应一个微命令，也就是对应一个微操作。比如我们想让C1输出对应上(PC)-&gt;MAR，那么只需要把C1这根输出线接到PCout和MARin上即可，所以接下来要考虑的是什么情况下，控制单元CU应该发出C1这条微操作命令。</p><p>对于上面这个问题，我们之前强调过很多次，所有的指令在取指周期内，第一步需要做的事情一定是先把PC程序计数器的值放到MAR当中。因此，无论什么指令，如果此时处于取指阶段，并且处于取指阶段第一个节拍，这时就要完成(PC)-&gt;MAR这个微操作0，所以，我们可以得到如上图左上的表达式，并根据表达式设计出C1的电路。</p><p>我们可以在CU内部设计一个与门，并且与门的输入分别接到T0和FE上，与门的输出接到C1上，当FE和T0都是1时，C1就会输出。</p><p>注意一点，逻辑表达式都是电路的数学化描述，所以只要写出了逻辑表达式，就意味着同时也确定了这个微命令它所对应的一个电路应该怎么接。</p><p>上面(PC)-&gt;MAR这个微操作的逻辑表达式很简单，因为这个操作只会在取指阶段第一个节拍内进行，现在思考一下，如果是M(MAR)-&gt;MDR这个微操作的逻辑表达式该是什么样的呢，又如何去设计电路呢。下图直接给出答案。</p><img src="https://pic.imgdb.cn/item/66718019d9c307b7e9a3afdc.png" alt="计算机组成原理（五）——中央处理器——MAR到MDR逻辑表达式.png"><p>可以看到这个微命令的逻辑表达式很复杂，对应的电路同样也很负载，这里简单说一下，在逻辑表达式里点表示与，加表示或，从这个表达式里很明显可以看出，在取指(FE)、间址(IND)、执行(EX) 这三个阶段可能会产生M(MAR)-&gt;MDR的操作。这里以取指阶段为例，取指阶段是在第一个2个节拍内产生该操作，所以上述表达式关于取指阶段的逻辑表达式就用FE&amp;T1来表示，剩下的间址和执行同理。这些可能会产生该操作的表达式间用+号连接起来，表示或，即只要这些部分有一个输出为1，就意味着此时要执行M(MAR)-&gt;MDR的操作。根据分析写出表达式以后，就可以设计出对应的电路。</p><p>接下来需要探讨的就是如何根据一个微操作分析出对应的逻辑表达式。并设计出对应的电路。</p><img src="https://pic.imgdb.cn/item/66718475d9c307b7e9adbc00.png" alt="计算机组成原理（五）——中央处理器——硬布线控制器的电路设计.png"><p>上面是设计过程，可以看到设计过程是很复杂的，不过考研是不考具体设计的，但是弄清楚具体的设计过程是有助于真正理解控制器工作原理的，所以这部分了解一下即可。</p><p>还是M(MAR)-&gt;MDR这个例子，我们先根据第一步，分析出每个阶段的微操作序列：</p><img src="https://pic.imgdb.cn/item/667185ded9c307b7e9b21606.png" alt="计算机组成原理（五）——中央处理器——分析每个阶段微操作.png"><p>如果我们能列出所有指令的微操作序列，就可以知道在什么情况下需要使用这个微操作。不过上图我们只列举了取指周期、间址周期和执行周期这三个周期内的微操作序列，而中断周期的微操作序列这里没有分析，但原理都是类似的。总之，本质的目的就是想要找到某一个微操作在哪些时候会被用到。(这里主要想说明这个过程，所以举了几个例子，并没全部进行列举，下面的步骤也都是根据我们列举的这几个例子执行的，但实际上是要把所有的指令微操作序列都列出来才可以。)</p><p>根据上面分析的每个阶段的微操作序列，可以知道在什么样的指令，什么样的机器周期下，什么样的机器状态条件下，会有M(MAR)-&gt;MDR这个微操作。现在还差节拍信息需要确定。所以，我们需要进行第三步的安排微操作时序。</p><p>但进行微操作时序安排之前，我们要先进行第二步，选择CPU的控制方式，这里假设选择定长机器周期，一个机器周期内安排三个节拍的控制方式。</p><p>下面对上面列举各个周期的微操作序列进行微操作时序安排，在进行安排前，先看一下安排微操作时序的原则：</p><img src="https://pic.imgdb.cn/item/667189fad9c307b7e9bc4daf.png" alt="计算机组成原理（五）——中央处理器——安排微操作时序的原则.png"><p>接下来以取指周期为例进行微操作时序安排：</p><img src="https://pic.imgdb.cn/item/66718dbfd9c307b7e9c58c0e.png" alt="计算机组成原理（五）——中央处理器——取指周期的时序安排.png"><p>上面是取指周期的微操作，接下来根据三个原则，把右边的微操作序列安排到T0,T1,T2这三个时序内。</p><p>首先，可以看到第二个微操作的对象是主存，而第一个微操作的对象是两个寄存器，所以这两个寄存器显然可以安排到同一个节拍完成。第三个微操作和第一个微操作有先后依赖关系，所以要保证微操作3在微操作1之后。同理，微操作4一定在微操作3之后。而微操作5一定在微操作4之后。再看第六个微操作，让PC值加1，而对于这个微操作来说，只要把PC的值放到MAR后，就可以让PC值加1，所以微操作6只需要在微操作1之后就可以，当然不一定是最后面，这里我们可以把它放到3的后面。</p><p>经过处理后的微操作序列如下图，接下来安排微操作时序：</p><img src="https://pic.imgdb.cn/item/6671946bd9c307b7e9d5b64f.png" alt="计算机组成原理（五）——中央处理器——取指周期的时序安排1.png"><p>第一个和第二个微操作这两个微操作的被控对象不同，所以都可以在T0这个时序内完成。接下来微操作3和微操作6也没有前后依赖关系，所以可以把它们安排在T1这个节拍内完成。最后由于微操作4和5执行的时间很短，所以虽然他们之间有前后依赖的关系，但是同样可以安排在一个节拍内完成，所以把它们安排进最后一个节拍T2。</p><p>这里解释一下，为什么可以把4和5安排在一个节拍内。原因在于MDR、IR和ID都是CPU内部的部件，CPU内部的寄存器各个部件之间的数据流动是很快的，所以CU可以并行的发出这两个微操作所对应的微命令，让这两个微操作同时进行，这也就意味着数据可以快速的从MDR先流行IR，然后再流向ID(指令译码器)，可以迅速连惯得完成。</p><p>这里可能会有疑问，既然4,5可以放到一起，3和4能不能放到一起？答案是不行的，因为M(MAR)-&gt;MDR会从主存读取数据，而从主存取得一个数据的用时是比较长的，因此必须使用一个时钟周期才能保证微操作的完成，所以不能把3和4安排进同一个节拍内。</p><p>同理，我们也可以对间址周期、执行周期进行时序安排，这里方法一样，就不再重复，直接展示安排的结果：</p><p>间址周期：</p><img src="https://pic.imgdb.cn/item/6671969bd9c307b7e9da83ba.png" alt="计算机组成原理（五）——中央处理器——间址周期的时序安排.png"><p>执行周期：</p><img src="https://pic.imgdb.cn/item/66719701d9c307b7e9db5c87.png" alt="计算机组成原理（五）——中央处理器——执行周期的时序安排.png"><p>到此，我们就完成了前三步，接下来要进入第四步，确定每个微操作命令的逻辑表达式，并实现电路设计。而第四步又可以继续细分为如下图的三步骤：</p><img src="https://pic.imgdb.cn/item/6671983dd9c307b7e9de233f.png" alt="计算机组成原理（五）——中央处理器——电路设计步骤.png"><p>首先，我们根据第一步列出操作时间表，如下图：</p><img src="https://pic.imgdb.cn/item/667198a5d9c307b7e9df1118.png" alt="计算机组成原理（五）——中央处理器——取指阶段操作时间表.png"><p>在这个图里，如果某个指令在取指周期的某个节拍内会执行对应的微操作命令信息，就会填上1，否则就是0。而基本上所有的指令在取指阶段的操作都一样，所以大部分都是1，唯一不同的地方在于最后两行。</p><p>最后两行表示在取指周期结束后是进入间址周期还是执行周期，这里使用I来表示条件寄存器，根据I的值来判断有没有间址周期，而我们表里指令列的顺序就是按照上面非访存指令和访存指令的顺序来列举的，所以显然非访存指令一定会直接进入执行阶段，所以上面五条非访存指令在是否进入间址阶段的位置不用写1。而访存指令需要进行访存操作，所以地址码可能会采用间接寻址，这时就会进入间址阶段，所以填1。当然这些指令也可能不采用间址寻址，所以可以直接进入执行阶段，所以其执行阶段也要填1。</p><p>同理，可以列出间址阶段操作时间表：</p><img src="https://pic.imgdb.cn/item/66719adfd9c307b7e9e4120f.png" alt="计算机组成原理（五）——中央处理器——间址阶段操作时间表.png"><p>执行阶段的操作时间表：</p><img src="https://pic.imgdb.cn/item/66719b12d9c307b7e9e48f21.png" alt="计算机组成原理（五）——中央处理器——执行阶段操作时间表.png"><p>这里只列举了7种，并没有列举完，而中断阶段的操作时间表类似，这里也就不列举了。</p><p>到这里，我们就完成了列出操作时间表的操作，接下来要写出微操作命令的最简表达式：</p><img src="https://pic.imgdb.cn/item/66719b9fd9c307b7e9e60685.png" alt="计算机组成原理（五）——中央处理器——列出逻辑表达式.png"><p>把操作时间表结合，找到出现M(MAR)-&gt;MDR的地方，然后就可以列举出上图下的逻辑表达式，并把其化简。</p><p>得到逻辑表达式以后，就可以转换成电路：</p><img src="https://pic.imgdb.cn/item/66719c0fd9c307b7e9e76cbf.png" alt="计算机组成原理（五）——中央处理器——列出逻辑表达式设计电路.png"><p>这里再次强调，逻辑表达式只是电路的一个数学化描述，所以对于电路设计人员来说，只要得到了逻辑表达式，就相当于已经得到了最终的电路。</p><img src="https://pic.imgdb.cn/item/66719ca0d9c307b7e9e8fc34.png" alt="计算机组成原理（五）——中央处理器——硬布线设计小结.png"><p>最后，从设计步骤可以感受到硬布线设计的特点：</p><p>第一个特点，指令越多，硬布线的设计和实现就越复杂，因此这种方式常用于RISC(精简指令集系统)，因为RISC支持的指令条数不会太多。而对CISC(复杂指令集系统)，如果单纯的用硬布线方式设计，显然设计起来会非常复杂和困难，所以复杂指令集系统通常会采用微程序控制器。</p><p>第二个特点，对应一个硬布线控制器，如果需要扩充一个新指令，这就意味着硬布线控制器的设计需要大改，所以扩充指令是比较困难的。</p><p>第三个特点，硬布线控制器由于使用纯硬件实现控制，因此执行速度很快。</p><h3 id="4-2-微程序控制器的基本原理"><a href="#4-2-微程序控制器的基本原理" class="headerlink" title="4.2 微程序控制器的基本原理"></a>4.2 微程序控制器的基本原理</h3><img src="https://pic.imgdb.cn/item/667ecda6d9c307b7e91a2a88.png" alt="计算机组成原理（五）——中央处理器——硬布线控制器设计思路回顾.png"><p>硬布线控制器的微操作控制信号是否需要发出，是由组合逻辑电路根据当前指令的操作码以及机器状态和时序系统产生的一些信息来及时的产生，速度非常快。</p><p>而硬布线控制器的设计过程中，需要确定每一个微操作信号，在哪些情况下需要发生，那么要把需要发出这些微操作控制信号的条件，用一个逻辑表达式把它表达出来，然后再把逻辑表达式实现为与之对应的一个硬件电路，这就是用纯硬件思想来实现的控制器。</p><p>下面看一下如何用软件的思想来实现微程序控制器：</p><img src="https://pic.imgdb.cn/item/667ecfd6d9c307b7e91e0f29.png" alt="计算机组成原理（五）——中央处理器——微程序控制器的设计思路.png"><p>首先说一下设计思路，用高级语言写的代码，会被翻译成与之对等的一系列机器指令。在每一条指令执行的过程当中，这条指令的执行又会被细分为一个一个的微操作，即由一些微操作序列来完成一条指令的具体功能。</p><p>到这里可以看到，微操作序列之于指令，就类似于指令序列之于程序。所以不难想到，可以模仿指令序列执行的处理方式，用同样的思想来处理微操作序列，这就是微程序的概念。</p><p>如上图，可以把一个时序之内，可以同时进行的微操作，用一个微指令来指明，比如说微指令a的执行会导致微操作一和二的完成。而在这一条指令执行过程中的产生的微操作序列就构成了一个微程序。**<font color=red>所以，每一条指令对应一个微程序。</font>**</p><p>另外，对于不同的机器指令来说，不同的机器指令所需要完成的这些微操作序列是不一样的，因此不同的指令所对应的微指令序列也不一样。所以之前几章一直说的指令是对程序执行步骤的描述，而这里说的微指令是对指令执行步骤的描述。因此，CPU在执行一条指令的时候，其实就是要执行这条机器指令所对应的微程序。</p><p>借鉴之前提到过的存储程序的思想，可以在CPU出厂之前，把所有的机器指令所对应的微程序，都存放到控制器里边的一个特殊的存储器当中，然后CPU可以根据当前要执行的这个机器指令的类型，去找到与这条机器指令所对应的微程序，然后来一条一条的执行这个微程序当中所包含的微指令序列。所以微程序控制器的设计思想和CPU执行指令、取指令的思想都是一致的。因此前面说微程序控制器引入了软件的思想，就是会用一些微指令来描述一条机器指令的执行过程。</p><p>这里要强调几个容易混淆的概念：</p><ol><li>微命令和微操作是一一对应的，微操作是强调要做什么，而微命令是强调要完成这个微操作需要发出哪一个控制信号。</li><li>一条微指令的执行，可能会包含多个微命令。</li><li>微程序和机器指令也是一一对应的。一条机器指令会对应一个微程序，一个微程序又会由多个微指令的序列来组成，所以也可以说机器指令是对微指令功能的一个封装。</li></ol><p>在微程序控制器当中，有可能出现多种微指令，每一种微指令会对应相应的一系列微操作，因此每一条微指令需要有一个操作控制的字段。如上图最下面的微指令基本格式，操作控制字段由若干比特组成，用来表示当前这条微指令所对应的微操作是哪几个。</p><p>另外，一条微指令还需要有一个顺序控制的字段，同样的这个信息也由几个比特组成，比如用mbit表示接下来要执行的一条微指令存放在什么地址。</p><p>需要注意，微指令序列也是存储在控制器内部的一个特殊的存储器当中的，所以每一条微指令都会对应一个存储的地址。</p><p>接下来看一下，一个微程序控制器需要有的一些基本的结构：</p><img src="https://pic.imgdb.cn/item/667ed246d9c307b7e9235b01.png" alt="计算机组成原理（五）——中央处理器——微程序控制器的基本结构.png"><p>在CU控制单元内部，首先要有一个控制存储器，英文缩写是CM，用于存放各指令对应的微程序，每一种机器指令会对应一段微程序，而一段微程序会由一系列微指令序列组成，这些微指令序列在控制存储器里会顺序的存放。另外需要注意，控制存储器是用只读存储器ROM构成，这是因为ROM读取速度很快（比RAM快），而且ROM是一种非易失性的存储芯片，这就意味着CPU断电之后，ROM当中的存储的微程序不会丢失。所以每一条机器指令所对应的微程序应该由CPU的厂商设计，并且需要在CPU出厂之前，把ROM里的微程序数据全部写好。</p><p>控制存储器用于存放微指令，而为了指明接下来要执行的微指令存放在什么地址，所以要引入一个微地址寄存器CMAR。CMAR也叫μPC，因为CPU内部，PC寄存器适用于指明接下来要执行的指令地址，只不过从主存取出指令，需要先把PC的值放到MAR，然后再根据MAR的值去主存当中找出对应指令。而在CU内部，CMAR就相当于MAR和PC的功能结合体。</p><p>之前说过，MAR给出的地址信息需要通过一个译码器的处理，才可以选中主存的某一个存储单元，所以对于CU内部的CMAR来说，也需要把地址信息送给一个地址译码器，然后通过地址译码器把地址转换成CM当中对应的存储单元的存取控制信号。</p><p>接下来继续回忆一下，从主存当中取出一条指令，会先把这条指令送给MDR数据寄存器，然后再送给IR指令寄存器，所以对于CU内部同样类似，从CM当中取出一条微指令需要先放到CMDR中，CMDR也叫μIR，用于存放从CM中取出的微指令。注意，CMDR的位数同微指令字长相等。</p><p>除了上述这些，在CU中还要引入微地址形成部件，用于产生初始微地址和后继微地址，以保证微指令的连续执行。这里解释一下，外部的一条机器指令被取到IR寄存器当中，然后不同的机器指令所对应的微指令序列(即微程序)不同，因此<strong>需要根据当前机器指令的操作码来确定它所对应的微程序的起始地址是什么</strong>，所以这就是微地址形成部件的一个作用。</p><p>最后还要引入一个逻辑电路叫做顺序逻辑，顾名思义就是用于控制微指令的执行顺序的，因为微指令序列不一定是一条一条顺序的往下执行，如果说有中断发生的时候，V指令执行序列的次序就需要进行调整，所以这就是顺序逻辑的作用。</p><p>当CPU取得一条指令之后，执行这条指令的过程就是先把操作码送给微地址形成部件，用来确定这条指令所对应的微指令序列的一个起始地址。接下来根据顺序逻辑的标志这一类信息来确定接下来要执行的微指令的存放地址，把微指令地址放到CMAR中，然后经过地址译码器的译码以后，就可以选择CMAR所指向的那条微指令，然后取出这条微指令放到CMDR中。而一条微指令会包含两个部分信息，第一个部分信息用来描述这条微指令所对应的控制信号，第二个部分用来描述接下来要执行的一条微指令的地址(下地址)。在执行完这条微指令以后，需要把下地址信息送给顺序逻辑，仍然顺序逻辑再结合上某一些机器标志的信息，再来决定下一条应该执行的微指令的存放地址，然后再把下一条微指令的地址送给CMAR，这就是微指令序列一条一条往下执行的原理。而现在要执行的微指令被放到CMDR中，硬件电路需要根据微指令的控制码部分，向CPU内部的其它部件或者系统总线来发出一些控制信号。</p><p>接下来思考一个问题：所有指令的取指周期、间址周期、中断周期所对应的微指令序列都一样，所以是否可以共享使用？基于这个考虑，在控存里面存储的微指令序列，通常来说取指周期、间址周期和中断周期所对应的微程序段只有一份，而执行周期各个指令对应的微指令序列不一样，所以执行周期会存储多个不同指令功能的微指令序列，如下图：</p><img src="https://pic.imgdb.cn/item/667ed915d9c307b7e92fb701.png" alt="计算机组成原理（五）——中央处理器——微程序控制器的工作原理.png"><p>为了更好的理解，接下来结合上图，模拟一个取数指令执行的过程：对于取数指令LDA X，就是把X所指向的主存里面的数据放到ACC里面。在这条指令的取值周期内，会执行0号、1号、2号这三个地址上的微指令。在执行2号地址所存储的微指令之后，就意味着已经完成了取指周期内所需要做的所有事情，接下来要执行的一条微指令，被存放在地址为3的地方，也就是间址周期的第一条微指令。但是这条机器指令，它的地址码有可能不需要进行间接寻址，因此接下来要执行的微指令，不一定就是3号地址所存储的这一条，<strong>所以在指令的地址码部分，会有一些标志位用来指明这个地址码到底是采用直接寻址还是间接寻址，这个寻址特征位可以送给顺序逻辑，顺序逻辑根据指令地址码的寻址特征位判断是否要跳过间址周期。</strong></p><p>LDA指令在执行完取值周期以后，经过顺序逻辑处理，会知道接下来要执行的不是间指周期，而应该直接跳到执行周期。所以根据这条指令的操作码，然后再通过微地址形成部件的处理之后，微地址形成部件会告诉顺序逻辑，LDA这条指令的执行周期所对应的微指令序列的首地址是13，所以顺序逻辑会把13这个地址信息放到CMAR当中，接下来就会执行LDA指令对应的执行周期的微程序。在15这个微指令执行完以后，下一条要执行的指令就变成了0，这意味着当前指令结束以后，如果没有中断周期的话，就进入到下一条指令的取指阶段。但是，如果此时顺序逻辑检测到一个中断信号，那么接下来执行的微指令就不是0，而是要执行中断周期内的微指令序列。</p><p>上面就是取数指令的执行过程，下面再来补充一点边角知识：</p><img src="https://pic.imgdb.cn/item/667eda08d9c307b7e9316c08.png" alt="计算机组成原理（五）——中央处理器——微程序控制器的工作原理补充.png"><p>由于所有指令的取指周期、间址周期和中断周期所需要做的事情是一样的，所以取指周期所对应的微程序段通常是公用的，在控存里只需要存一份就可以了，所以如果一个题目说某指令系统中有n条机器指令，那么这n条机器指令所对应的执行周期的微程序段都不一样，因此就需要设计n个微程序来分别描述这n条机器指令的执行周期，另外还需要加上一个公用的取指周期的微程序，所以在这个系统的控存中微程序的个数至少是n+1个，这里没有把间址周期和中断周期算进去的原因是，一些早期的CPU、物联网设备的CPU可以不提供间接寻址和中断功能，因此这类CPU可以不包含间址周期、中断周期的微程序段。</p><p>另外还要强调一点，在有的选择题当中，并不会认为取指周期的微程序和执行周期的微程序是两个微程序。物理上，取指周期、执行周期看起来像是两个微程序，但逻辑上应该把它们看作一个整体。因此，“一条指令对应一个微程序”的说法也是正确的。所以，上面的说法某指令系统中有n条机器指令，那么在这个系统的控存中微程序的个数至少是n+1个如果不想产生歧义，就应该改成微程序段的个数至少是n+1个。但是也可以说微程序的个数只有n个。</p><p>下面对本节进行一个小结：</p><img src="https://pic.imgdb.cn/item/667edad1d9c307b7e932c8e9.png" alt="计算机组成原理（五）——中央处理器——微程序控制器小结.png"><h3 id="4-3-微指令的设计"><a href="#4-3-微指令的设计" class="headerlink" title="4.3 微指令的设计"></a>4.3 微指令的设计</h3><img src="https://pic.imgdb.cn/item/66801411d9c307b7e9c265b6.png" alt="计算机组成原理（五）——中央处理器——微程序控制器回顾.png"><p>在前面已经了解了微程序控制器的工作原理和工作流程，但是还没有探讨如何根据一条微指令来发出相应的控制信号，这就是接下来要探讨的主要问题，即微指令的具体格式应该怎么设计？如何根据微指令发出相应的微命令？</p><p>接下来看第一个问题：微指令的具体格式应该怎么设计？</p><img src="https://pic.imgdb.cn/item/66801545d9c307b7e9c50b1f.png" alt="计算机组成原理（五）——中央处理器——微指令的格式.png"><p>微指令的格式可以分为如上图的三种类型，其定义以及优缺点上图也给出，这部分比较简单，就不过多叙述。除此以外，这里还要再补充两个基本概念：</p><ol><li>相容性微命令：如果多个微命令可以并行的完成，那么这些微命令就是相容性的微命令。</li><li>互斥性微命令：如果多个微命令不可以并行的完成，那么这些微命令就是互斥性的微命令。</li></ol><p>接下来重点探讨，水平型的微指令格式，如何设计它的操作控制字段，即探讨如何用若干个比特的二进制信息来表示一系列的控制信号，又或者说微指令的编码方式是什么：</p><img src="https://pic.imgdb.cn/item/6680167dd9c307b7e9c782e9.png" alt="计算机组成原理（五）——中央处理器——微指令的编码方式1.png"><p>微指令的编码方式又称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。 </p><p>接下来看第一种编码方式——直接编码方式，如上图，这种编码方式就是操作控制的这些比特位，每一个比特位会对应一个具体的微操作。举个例子，如果规定某一位为1，则表示该位所代表的控制信号有效，假设如上图操作字段最左边的一位，规定其代表的微操作是(PC)-&gt;MAR，最右边的一位，规定其代表的微操作是1-&gt;R，如果此时有一个微指令想要同时完成这两个微操作，那么只需要让这个微指令的控制字段的第一位和最后一位为1，然后其它全部为0就可以。</p><p>接下来看第二种编码方式——字段直接编码方式，如下图：</p><img src="https://pic.imgdb.cn/item/668018ded9c307b7e9cc33e3.png" alt="计算机组成原理（五）——中央处理器——微指令的编码方式2.png"><p>字段直接编码方式就是将指令的控制字段分成若干“段”，每段经译码后发出控制信号。这里解释一下什么是分段，有些微操作可以并行的完成，而有些微操作不可以并行的完成，所以，可以对所有微操作进行分类，从属于同一个分类的微操作都是互斥的，而相容的会分在不同的段内。</p><p>另外，在实际应用中，每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。而且，一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。</p><p>字段直接编码方式与直接编码方式相比，其微指令总体长度可以变得更短，下面看一道例题来进一步感受一下，指令长度是如何变短的，如下图下：</p><img src="https://pic.imgdb.cn/item/66801960d9c307b7e9cd3191.png" alt="计算机组成原理（五）——中央处理器——字段直接编码方式例题.png"><p>字段直接编码方式的优点就是可以缩短微指令字长，但缺点是要通过译码电路后再发出微命令，因此比直接编码方式慢。</p><p>接下来再看一下第三种编码方式——字段间接编码：</p><img src="https://pic.imgdb.cn/item/66801a6fd9c307b7e9cf3d3f.png" alt="计算机组成原理（五）——中央处理器——微指令的编码方式3.png"><p>字段间接编码方式就是一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。如上图下，字段2经过译码器译码以后，并不是直接发出这个字段所对应的控制信号，而是会把这个译码器的输出信号送给下一级的译码器，然后下一级的译码器再进行一次处理以后，才发出最终的控制信号。</p><p>字段间接编码方式的优点是可以进一步缩短微指令字长，但缺点是削弱了微指令的并行控制能力，故通常作为字段直接编码方式的一种辅助手段。</p><p>接下来探讨一下微指令的下地址部分，也就是探讨如下确定下一条微指令的存放地址：</p><img src="https://pic.imgdb.cn/item/66801b63d9c307b7e9d117e0.png" alt="计算机组成原理（五）——中央处理器——微指令的地址形成方式.png"><p>第一种确定方式就是直接根据微指令的下地址字段直接找到，这种方式又称为断定方式。</p><p>第二种方式根据机器指令的操作码来确定接下来要执行的微指令的存放地址。</p><p>第三种方式是增量计数法，类似于PC+1，对于微指令系统如果想要顺序的执行一系列微指令序列，那么只需要在当前这条微指令执行结束以后，把地址信息加1即可。</p><p>第四种方式是分支转移，有些指令是转移指令，如JMP指令，这种转移类指令会指明转移方式，满足某种条件下才会进行转移，微指令的转移地址会在微指令的后面部分给出。</p><p>第五种是通过测试网络来决定下一条微指令的存放地址，如下图：</p><img src="https://pic.imgdb.cn/item/6697f115d9c307b7e9b98230.png" alt="计算机组成原理（五）——中央处理器——测试网络.png"><p>这其实就是前面说的顺序逻辑，顺序逻辑会接收一下标志信息，然后根据标志信息再结合当前执行的微指令的某些比特的信息，来决定接下来应该执行的微指令的存放地址。所以这里的测试网络就是指其内部的处理电路。</p><p>第六种方式是由硬件产生微程序入口地址，比如之前说的每一条指令的取指周期所对应的微指令序列都是公用的，而取指周期的第一条微指令作为开始，其地址可以用专门的硬件存放。另一方面，如果一个指令的进行需要进入到中断周期，那么同样的，也会用一个专门的硬件记录中断周期所对应的微程序的首地址。</p><p>接下来根据一道例题看一下这部分的考察方式：</p><img src="https://pic.imgdb.cn/item/66801cc5d9c307b7e9d3483f.png" alt="计算机组成原理（五）——中央处理器——微指令的地址形成方式例题.png"><p>接下来对本节进行一个小结：</p><img src="https://pic.imgdb.cn/item/66801cf3d9c307b7e9d39066.png" alt="计算机组成原理（五）——中央处理器——微指令的设计小结.png"><h3 id="4-4-微程序控制单元的设计"><a href="#4-4-微程序控制单元的设计" class="headerlink" title="4.4 微程序控制单元的设计"></a>4.4 微程序控制单元的设计</h3><img src="https://pic.imgdb.cn/item/66801d3bd9c307b7e9d41ee0.png" alt="计算机组成原理（五）——中央处理器——微程序控制单元设计.png"><p>微程序控制单元的设计步骤和硬布线控制器很类似，特别是第一步和第二步，只有第三步和第四步有区别。</p><p>首先第一步，同样需要分析出所有的指令在每一个阶段的微操作序列，如上图，以指令的取指周期内所需要做的微操作序列为例。在硬布线控制器设计一节，已经分析了取值周期内所需要做的6个微操作，其中的某一些微操作可以安排在同一个节拍内并行的完成。对于微程序控制器也一样，同样需要完成这样的一系列操作，如上图右，但最后一步会有一点区别，对应硬布线控制器来说，是把指令的操作码部分送给了指令译码器ID，然后指令译码器会发出与操作码相对应的那一根线的选通信号；而对于微程序控制器，是要把指令操作码送给微地址形成部件，然后由微地址形成部件来指明这条指令在接下来的执行周期，所对应的微程序的起始地址。</p><p>与硬布线控制器类似，微程序控制器设计时，对于一些相容的微操作，可以把它安排在同一个微指令内，让它们同时并行的完成，所以上图右的这些微操作，可以用三个微指令完成。</p><p>所以在取指阶段，要做的就是先执行微指令a，再执行微指令b，c如下图：</p><img src="https://pic.imgdb.cn/item/66801d8fd9c307b7e9d50642.png" alt="计算机组成原理（五）——中央处理器——微程序控制单元设计1.png"><p>根据取指阶段列出的具体的微操作，就可以确定每一条微指令所对应的操作码部分应该怎么样安排，所以只要能够整理出每一条微指令所包含的微操作，就已经完成了微指令的编码。</p><p>但是为了支持取指阶段微指令序列的执行，还需要考虑怎么读出这三条微指令，即微指令的存放地址如何确定，这一点在前面已经探讨过。对于取指周期的第一条微指令来说，会固定的把它存放在比如说0号单元里面，所以第一条要执行的微指令是由硬件自动的给出的。而接下来要执行的微指令的存放地址，会被包含在当前执行的这条微指令的下地址字段。所以在执行完微指令a之后，还需要穿插一个微操作，Ad(CMDR)-&gt;CMAR，就是要把当前执行的微指令的下地址信息送给CMAR，这个微操作的执行也需要消耗一个节拍，所以对应微程序控制器来说，每执行完一条微指令之后，都一定需要再用一个节拍来加上这个微操作，用这样的方式指明下一条微指令的存放地址。</p><p>另一方面，还需要考虑如何转入到下一个机器周期，假设一个指令系统中取指周期过了之后，会直接进入到执行周期，由于不同的指令在执行阶段的微程序各不相同，所以在取指阶段的微指令执行结束之后，还需要根据当前执行指令的操作码，来确定这个指令所对应的执行阶段的微程序的一个起始地址。因此，把这个指令的操作码送给微地址形成部件以后，还需要消耗一个节拍把微地址形成部件指明的地址信息送到CMAR中。</p><p>把上面考虑到的两个问题给补进去，如下图：</p><img src="https://pic.imgdb.cn/item/66801dd7d9c307b7e9d57b17.png" alt="计算机组成原理（五）——中央处理器——微程序控制单元设计2.png"><p>指令a执行完以后，需要消耗一个节拍，把指令a的下地址放到CMAR中，然后指令b执行结束后，同样需要消耗一个节拍，把指令b的下地址放到CMAR中，微指令c执行结束后，还需要再加一个节拍，把微地址形成部件所指明的当前这条指令它的执行周期所对应的微程序首地址放到CMAR当中。</p><p>很显然，采用微程序控制器完成指令周期的工作，总共需要消耗5个节拍，而硬布线控制器只需要消耗3个节拍，所以微程序控制器的执行速度要比硬布线慢的多。</p><p>补充一点，在上面t4节拍内执行了微指令c，这个微指令把从主存中读出的指令数据从MDR送到IR，同时又把指令的操作码部分送给了微地址形成部件，这两个微操作被放在用一个节拍内。但是有的教材里会用另外一种处理方式，就是在t4节拍内，先把指令的数据从MDR送到IR，然后t5时钟周期节拍内，会把指令的操作码送给微地址形成部件，然后同时再把微程序的首地址放入到CMAR中。这两种安排都是可以的，只需要保证在同一个节拍内，这些微操作可以并行的进行就可以了。如下图。</p><img src="https://pic.imgdb.cn/item/66801e00d9c307b7e9d5b639.png" alt="计算机组成原理（五）——中央处理器——微程序控制单元设计3.png"><p>下面接着回到刚开始说的设计步骤：</p><img src="https://pic.imgdb.cn/item/66801e6dd9c307b7e9d65af3.png" alt="计算机组成原理（五）——中央处理器——微程序控制单元设计4.png"><p>第一步分析每一条指令在每一个阶段的微操作序列，这个以取指周期为例，已经进行了分析。</p><p>第二个阶段，需要对机器指令的微操作命令及节拍进行安排，要写出每个周期内所需要的微操作，就是要在第一步得到的微操作序列的基础上，把可以并行进行的微操作，安排在同一个节拍内进行。到这一步为止，和硬布线控制器的设计方法都是重合的。</p><p>接下来就开始出现区别，在采用微程序控制器需要加入几个特有的微操作，第一个在取指周期内除了最后一条微指令之外，其它的每一条微指令结束之后都需要根据当前执行的这条微指令的下地址信息，来指明接下来要执行的这条微指令的存放地址，所以每一条微指令的后面，都需要补上Ad(CMDR)-&gt;CMAR。另外在取指周期的最后一条微指令执行结束之后，还需要用OP(IR)-&gt;微地址形成部件-&gt;CMAR来指明，当前执行的这条机器指令，它所对应的执行周期的微程序首地址。这就是在微程序的取指周期内，需要添加的两个特有的微操作。</p><p>在考试中，一般为了简化问题，通常取指周期结束之后，会直接进入到执行周期，而执行周期的第一条微地址指令，是在取指周期的末尾指明的。在执行周期内，每条微指令结束之后，也都需要通过执行的这条微指令来指明接下来要执行的微指令的存放地址。</p><p>而执行周期结束之后，若没有中断信号，则下地址会重新指回到取指周期的第一条微指令的存放地址，所以在执行周期内，每个微指令完成之后，都根据当前这条微指令的下地址信息，找到下一个应该执行的微指令，用这种方式就可以自然而然的进入下一条机器指令的执行周期。所以在指令的执行周期内，同样的列出微操作序列，然后把可以同时并行的进行的微操作把它们进行分组，每一组微操作就会对应一个微指令，而每一个微指令执行结束之后，都需要再添加上Ad(CMDR)-&gt;CMAR这样的一个特有的微操作，这个微操作同样会消耗一个节拍。用这样的方式就可以确定微程序控制器每一步应该做什么事情。</p><p>接下来第三步，需要确定微指令的格式：</p><img src="https://pic.imgdb.cn/item/66801ecfd9c307b7e9d70aca.png" alt="计算机组成原理（五）——中央处理器——微程序控制单元设计5.png"><p>微指令的格式在上一小节探讨过，微指令的格式分为微指令的操作码和下地址这样的两个部分。首先，需要根据微操作个数决定采用何种编码方式，以确定微指令的操作控制字段的位数。然后，根据CM中存储的微指令总数，确定微指令的顺序控制字段的位数。最后按操作控制字段位数和顺序控制字段位数就可确定微指令字长。</p><p>第四步，设计每一条微指令的码点：</p><img src="https://pic.imgdb.cn/item/66801f1dd9c307b7e9d7a517.png" alt="计算机组成原理（五）——中央处理器——微程序控制单元设计6.png"><p>比如说，如果采用直接编码的方式，也就是在微指令的控制码部分，每个比特位会对应一个特定的微操作，如果采用这样的编码方式的话，那么就可以根据每一条微指令所需要执行的微操作，来确定每一条微指令的控制码部分哪个地方为1，哪个地方为0。</p><p>接下来补充一个知识点——微程序的设计分类：</p><img src="https://pic.imgdb.cn/item/66801f52d9c307b7e9d82002.png" alt="计算机组成原理（五）——中央处理器——微程序设计分类.png"><p>微程序设计可以分为静态微程序设计和动态微程序设计两类。</p><p>静态微程序设计就是说微程序一旦写入了ROM，就不需要再改变。而动态则意味着，CPU出厂之后，还有可能会被改变微指令序列，所以为了实现动态微程序的设计，就应该使用可以擦除的ROM芯片，如EPRIOM。</p><p>除了这两种微程序设计，再补充一个更深层的设计——毫微程序设计。之前介绍的微程序是用微指令序列来解释一条机器指令的执行，而毫微程序是用毫微指令序列来解释每一条微指令的执行。</p><p>下面把硬布线控制器与微程序控制器做一个比较：</p><img src="https://pic.imgdb.cn/item/66801f93d9c307b7e9d8b0bf.png" alt="计算机组成原理（五）——中央处理器——硬布线与微程序的比较.png"><p>最后，对微程序控制器这部分内容进行一个简单的回顾：</p><img src="https://pic.imgdb.cn/item/66801fdcd9c307b7e9d94bd2.png" alt="计算机组成原理（五）——中央处理器——微程序控制器知识总结.png"><h2 id="5-指令流水线"><a href="#5-指令流水线" class="headerlink" title="5. 指令流水线"></a>5. 指令流水线</h2><h3 id="5-1-指令流水线的基本概念"><a href="#5-1-指令流水线的基本概念" class="headerlink" title="5.1 指令流水线的基本概念"></a>5.1 指令流水线的基本概念</h3><img src="https://pic.imgdb.cn/item/6680205fd9c307b7e9da5a7c.png" alt="计算机组成原理（五）——中央处理器——指令流水线定义1.png"><p>之前说过一条指令的执行过程可以分成多个阶段，不同计算机对阶段的划分不一样，最简单的一个划分方法是把它划分为三个阶段，第一个阶段进行取指的操作，第二个阶段分析指令，第三个阶段执行指令。</p><p>而一条指令在不同的阶段，所需要使用到的硬件部件是不一样的，比如取指阶段需要用的PC程序计数器，然后也需要访问主存储器，从主存里（有时候也可能是从cache里）读出这条指令，最后还需要把指令送到指令寄存器IR中。</p><p>在分析指令的阶段，需要把指令的操作码部分送给指令译码器ID，然后还需要根据指令中包含的形式地址，转换成最终操作数的有效地址，最后再根据有效地址取出操作数。</p><p>在执行阶段，需要根据指令的操作码字段来完成指令规定的功能，在这个阶段很多时候需要用到ALU算术逻辑单元，最后还需要把运算的结果写回到通用寄存器或者主存里。</p><p>可以看到，在取指、分析、执行这三个机器周期内，每个阶段会用到的硬件有可能是不一样的，当然也可能出现各个阶段所使用的硬件部件有重复的情况。</p><p>为了方便分析，可以假设取指、分析和执行这三个阶段所需要的时间都是相同的，都为t，那么按照之前介绍的这种指令执行方式，也就是顺序执行的方式，就意味着只有一条指令完成了取指、分析和执行这三个阶段的工作之后，下一条指令的取指分析和执行才会紧接着往后，所以按照之前介绍的这种指令执行方式，有n条指令的情况下，总共的耗时就应该是3nt。传统的冯诺依曼机就是采用这种执行方式，这种顺序执行方式又称为串行执行方式。</p><p>顺序执行方式的优点是控制简单，硬件代价小。而缺点是执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。</p><p>为了处理顺序执行方式的缺点，提供各功能部件的利用率，所以引入了指令流水线。</p><img src="https://pic.imgdb.cn/item/668021efd9c307b7e9de4bbe.png" alt="计算机组成原理（五）——中央处理器——指令流水线定义2.png"><p>首先看一次重叠执行方式，即第二条指令的第一个阶段和上一条指令的最后一个阶段会在时间上有重叠，采用这种方式，总耗时就变成了(1+2n)t，比顺序执行方式减少了1&#x2F;3的耗时。而CPU要支持这样的执行方式，显然需要在顺序执行方式的CPU基础上，再增加一些硬件部件。所以一次重叠执行方式的优点是程序的执行时间缩短了1&#x2F;3,各功能部件的利用率明显提高。而缺点是需要付出硬件上较大开销的代价，控制过程也比顺序执行复杂了。</p><p>接下来看两次重叠执行方式，如上图下，总耗时变成了(2+n)t，可以看到，与顺序执行方式相比，指令的执行时间缩短近2&#x2F;3。但是注意，上面画出的二次重叠执行方式是一种理想的指令执行方式，即在正常情况下，处理机中同时有3条指令在执行，但是实际过程中，有可能会遇到一些特殊情况导致指令的执行阶段需要延后。</p><p>另外，这里只是把指令的执行过程分为三个阶段，如果说把指令的执行过程分为四个或者五个阶段，并且如果能够实现在各个阶段所使用到的硬件部件都相互独立，就意味着在同一时刻可以支持四条指令、五条指令正在执行。考试中最常见的是把指令执行过程分为五个阶段的这种方式，这部分会在之后的5.3里专门介绍。</p><p>接下来看流水线的表示方法：</p><img src="https://pic.imgdb.cn/item/6680222cd9c307b7e9deb6ad.png" alt="计算机组成原理（五）——中央处理器——流水线的表示方式.png"><p>之前画的指令执行过程的图就是指令执行过程图，如上图上，横坐标表示时间，纵坐标表示指令序列，每个纵坐标对应一条指令的执行，<strong>这种画图方式主要用于分析指令执行过程以及影响流水线的因素。</strong></p><p>接下来介绍另一种描述指令执行过程的图——时空图，如上图下。对于时空图来说，横坐标表示时间，纵坐标表示不同的执行阶段。注意上图的时空图把一条指令的执行过程分为了四个阶段，这也是一种划分方式，而且每一个执行阶段都默认他们所需要消耗的时间都是相同的，并且各个阶段所需要使用到的硬件部件都是相互独立的。<strong>这种时空图主要会用来分析流水线的性能。</strong></p><p>关于如何度量CPU指令流水线的性能，这一点是接下来要探讨的具体问题，大体上可以用<strong>吞吐率、加速比和效率</strong>三个指标来评价一个指令流水线的性能。</p><p>下面依次看一下，首先看吞吐率：</p><img src="https://pic.imgdb.cn/item/6680229ad9c307b7e9dfb7df.png" alt="计算机组成原理（五）——中央处理器——流水线的性能指标——吞吐率.png"><p>吞吐率是指在单位时间内流水线所完成的任务数量，或是输出结果的数量。对于指令流水线来说，大多数情况下，我们探讨的吞吐率就是指单位时间内，可以完成多少条指令。</p><p>举个例子，假设有n个任务，要计算指令流水线的吞吐率，首先要确定总共完成了多少条指令，然后还需要确定完成这些指令总共花了多少时间。所以对于刚刚提出的最理想执行情况来说，可以先画出执行n条指令的时空图，如上图左下。那么第一条指令的执行总共有k个阶段，总共耗时就应该是k△t这么多，然后从k△t这个时刻往后开始，每隔△t的时间就会有一条指令执行结束，所以后续的n-1条指令只需要再花费(n-1)△t的时间来执行即可，因此n条指令的执行时间就应该是T<sub>k</sub>&#x3D;(k+n-1)△t。这样的话，流水线的吞吐率TP只需要用指令的条数除以T<sub>k</sub>即可得到，TP的表达公式如上图右，而从这个式子不难看出，当指令的条数很多的时候，TP就近似等于1&#x2F;△t，所以理想情况下，所能获得最大的吞吐率就是TP&#x3D;1&#x2F;△t。</p><p>注意，一条指令的执行分为k个阶段，每个阶段耗时△t，一般取△t &#x3D;一个时钟周期，这里解释一下为什么取△t &#x3D;一个时钟周期。按照之前的学习，一条指令的执行被分为多个阶段，每个阶段理论上是对应一个机器周期，而一个机器周期可能包含多个时钟周期，所以按照之前的认知，这个地方提出的一个指令的阶段应该是包含多个节拍才对，不过理论上最理想的情况是一个机器周期只包含一个时钟周期，所以这里既然探讨的是最理想的情况，那么△t就取一个时钟周期。</p><p>另外，这里再补充两个概念，一个叫装入时间，另一个叫做排空时间，根据上图所画，很容易理解。装入时间就是指第一条指令从取指一直到结束所需要的这段时间，而排空时间指的是最后的这一条指令从取指一直到结束所需要的这段时间。</p><p>接下来介绍第二个性能指标——加速比：</p><img src="https://pic.imgdb.cn/item/668022c3d9c307b7e9e01f34.png" alt="计算机组成原理（五）——中央处理器——流水线的性能指标——加速比.png"><p>加速比就是完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。</p><p>同样举个例子，设T<sub>0</sub>表示不使用流水线时的执行时间，即顺序执行所用的时间；T<sub>k</sub>表示使用流水线时的执行时间，则计算流水线加速比(S)的基本公式为S&#x3D; T<sub>0</sub>&#x2F;T<sub>K</sub>。</p><p>接下来继续刚才的假设，如果说不使用流水线的话，那么每一条指令的执行被分为k个阶段，而每个阶段需要△t这么长的时间，因此n条指令执行完成就需要nk△t这么长的时间，而刚才又得出了引入流水线后的一个总的消耗时间T<sub>k</sub>&#x3D;(k+n-1)△t，那么S&#x3D;nk△t&#x2F;(k+n-1)△t&#x3D;kn&#x2F;(k+n-1)。如果说n趋近于无穷时，加速比就可以接近于k，所以理论上最理想的情况下，最大加速度比为k。</p><p>接下来看第三个指标——流水线的效率：</p><img src="https://pic.imgdb.cn/item/668022f6d9c307b7e9e08bc5.png" alt="计算机组成原理（五）——中央处理器——流水线的性能指标——效率.png"><p>流水线的效率指的就是流水线的设备利用率，所谓设备的利用率就是指硬件设备处于忙碌的时间占总的时间的一个比例。所谓的设备就是指之前提出的，在不同的阶段所需要使用到的这些硬件设备，所以说如果把指令的执行分为四个阶段，那么就意味着在这种情况下，总共是有四组设备。结合时空图来看，用红框框出来的部分就是设备处于忙碌的时间，而蓝色的框又反映了整体的一个时间，所以想要计算流水线的效率，就用红色框的部分比上蓝色框的部分就可以。计算的时候可以把时空图右半部分阶梯状的框图拼凑到左侧，用这样的方式可以让整个图变得比较规整，这时候再计算效率时，就可以使用拼凑后的图形，只需要计算出右半部分矩阵占整体的一个比例即可，计算流水线的效率公式上图已经给出，注意T<sub>k</sub>是指总体的一个时间消耗，而再乘一个k的意思就是乘矩形的高。</p><p>接下来思考一个问题，当n趋近于无穷时，矩形就会变得越来越大，然而设备的空闲时空区不变，所以当n趋近于无穷时，整个流水线的设备利用率可以接近于1，因此引入流水线技术之后，这些硬件部件的利用率得到了很大的提升。</p><p>下面对本节进行一个小结：</p><img src="https://pic.imgdb.cn/item/66802322d9c307b7e9e0eefe.png" alt="计算机组成原理（五）——中央处理器——指令流水线的基本概念小结.png"><h3 id="5-2-指令流水线的影响因素和分类"><a href="#5-2-指令流水线的影响因素和分类" class="headerlink" title="5.2 指令流水线的影响因素和分类"></a>5.2 指令流水线的影响因素和分类</h3><p>经过上一小节的介绍可以知道什么是指令流水线，但上一小节所建立的指令流水线的工作模式都是很完美的情况，一个阶段和另一个阶段都可以完美无瑕的衔接，然而有的时候，指令流水线的工作可能不会那么完美，那么有可能导致各个阶段没有那么完美的衔接因素有哪些呢，这就是这个小节要探讨的主要问题。</p><p>为了让问题的探讨没有那么抽象，所以首先引入一个经典的五段式的指令流水线，如下图：</p><img src="https://pic.imgdb.cn/item/66841a76d9c307b7e9818fbe.png" alt="计算机组成原理（五）——中央处理器——机器周期的设置.png"><p>所谓五段式指令流水线，一条指令的执行会被分成如上图的五个阶段。第一个阶段叫做IF，即取指令阶段。取出指令以后，接下来进入ID阶段，即指令译码阶段。下一个阶段是EX阶段，即指令执行阶段。第四个阶段是M阶段，即访存阶段。最后一个阶段是WB阶段，就是要把最后运算的结果写回到通用寄存器组。这种五段式流水线是考研中最常见的一种模式，因为这种五段式流水线是经典的MIPS架构所提出来的一种指令流水线，MIPS是世界上第一个精简指令集的指令系统。</p><p>注意，MIPS架构下，一条指令的执行会被划分成这样的五个阶段，但是有的指令有可能会跳过其中的某些阶段，然而为了方便指令流水线的安排，即便有的指令可能在实际运行时不需要中间的某个阶段的处理，仍然会被安排为这样的五个机器周期。所以在MIPS架构下，所有的指令一定都是五个机器周期，即分为这样的五个阶段，有的机器周期内有可能什么也不做，但依然会存在这个机器周期。</p><p>另一方面，之前说过，每一个机器周期，完成对应工作所需要的时间花销，有可能会不一样，所以为方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准。如上图的例子，五个阶段中最长的耗时为100ns，所以此处应将机器周期设置为100ns。</p><p>现在产生一个问题，想要让每个阶段耗时为100ns，那么像图里的第三个部分，就是执行阶段所要用到的硬件部件，它应该是在第200ns的时候，才把它所需要的数据给输入，但是由于前面的第二个阶段实际只需要80ns的时间就可以准备好这些数据，所以为了让第二个阶段流出的数据能够刚好赶在200ns的时候才让它流出，那么就需要在各个阶段中间给它们添加一些暂存的寄存器，用来暂存上一个阶段要给下一阶段输出的数据，只有到下一个阶段的执行周期时，才会把数据输出给下一阶段，这种用于缓冲的寄存器也叫锁存器。</p><p>下面来探讨一下上图的五个阶段的含义：</p><p>第一个阶段取指阶段，这个阶段要做的事情是根据PC所指向的位置，去Instruction Cache里找出当前要执行的这条指令，然后把取出的这条指令放到这个功能段的锁存器里面。注意一点，之前一直在说取指令是去主存里取指令，但是在大多数情况下，主存里当前需要使用到的指令还有数据这些信息，会在cache当中保存一个副本，并且基于局部性原理，cache的命中率一般都是很高的，所以上图在取指阶段画了一个cache的意思就是说，在大部分情况下，都可以从cache里直接找到现在想要的那条指令的数据，而不需要进行访存。</p><p>接下来先跳到第四个阶段，本来第四个阶段是要访问主存的，但是上图却画了一个data cache，原理与第一阶段是类似的，要访存主存，但是大部分情况下，都可以从cache里直接命中想要的数据。而由于第四个阶段访问的并不是指令，而是指令要操作的某一些具体的数据，因此这个地方写的是data cache，也就是CPU内部的cache会被分为两个独立的模块，一种cache是专门用来存储指令的，而另一种cache是专门用来存储变量的。把指令和数据分开存放，就意味着对这两个模块的访问是可以并行的进行的，因此指令和数据用两个独立的cache模块来存储，可以使得第一个和第四个阶段所需要使用的硬件部件可以并行的工作，这样可以更方便的来安排指令流水线。</p><p>注意，如果读写的数据没有在cache命中的话，指令流水线就会出现断流的情况，因为cache不命中就必须去访问主存，这种复杂的情况暂时可以先不考虑。</p><p>接下来看第二个阶段，第二个阶段是指令译码阶段，在这个阶段除了完成指令译码的工作以为，还会完成取数的操作，取数就是只要把这条指令所需要用到的操作数，从通用寄存器里面把它取出来，然后放到锁存器A和B里面，如上图。注意，这一点和之前学过的指令不一样，之前学习的指令，比如说加法指令，可以直接指明要访问的加数和被加数是来自于主存，<strong>但是在RISC精简指令集系统下，想要进行运算的操作数，一定是直接来自于通用寄存器的</strong>，不可能直接来自于主存，如果来自于主存，那么一定要先把数据放到通用寄存器里，然后再从通用寄存器当中取出那个数据。所以在指令译码的阶段，除了指令译码之外，还会从通用寄存器里取出当前这一条指令所需要用的操作数，放到A和B锁存器里。</p><p>接下来第三个阶段，执行阶段，执行阶段需要用ALU算术逻辑单元来处理前一个阶段取出的操作数，这里会发现，在第二个阶段除了A和B两个锁存器以外，还有一个锁存器叫Imm，即立即数存储器，这个锁存器是用来存储立即数的，因为有的指令当中可能会使用立即寻址，也就是指令的地址码部分就直接说明了一个立即数，那么在这种情况下，可以直接从指令当中取出接下来执行阶段所需要使用的立即数，然后把它放到Imm锁存器里，所以有的时候第三个阶段处理的数据有可能一个是立即数，另一个是来自于通用寄存器。那第三个执行阶段就是把刚才的两个操作数进行一个处理，处理之后会把输出的结果放到第三个阶段的锁存器里，然后再把这个运算结果有可能需要写回主存，当然这个运算结果也有可能不需要写回主存。有的时候一条指令的运算结果是直接写回寄存器，所以从上图可以看到，第三个阶段还有一条线会直接输出到第四个阶段的锁存器里，然后接下来再把这个数据通过第五个写回阶段，把运算的结果写回到某一个通用寄存器里，因此第五个阶段写回阶段的实际工作就是，有可能需要把之前的运算结果写回到某一个通用寄存器当中，当然也可能不需要写回，这需要结合具体的指令分类再来分析。</p><p>到此这个图的含义就介绍清楚，现在注意到第二个阶段，有可能对通用寄存器的某一个寄存器进行读操作，然后写回阶段有可能会把数据写回到某一个通用寄存器，所以第五个阶段有可能对通用寄存器进行写的操作，那这两个阶段对寄存的读和写，就有可能造成一些问题。所以接下来要探讨的就是**影响指令流水线的具体的因素，分为三个大类，第一类叫做结构相关(资源冲突)；第二类叫做数据相关(数据冲突)；第三类叫做控制相关(控制冲突)**。</p><p>接下来先探讨第一个分类——结构相关：</p><img src="https://pic.imgdb.cn/item/66841cbed9c307b7e986aa56.png" alt="计算机组成原理（五）——中央处理器——影响流水线的因素1.png"><p>结构相关指多条指令在同一时刻争用同一资源而形成的冲突称为结构相关，如上图，是刚刚提出的五段式指令流水线，看红色的部分，当Instr3这条指令执行到第一个阶段取指阶段时，需要使用到主存，然而最开头的load指令在这个时候也会使用到存储器这个部件，所以它们俩同时访问存储器就会造成资源冲突。</p><p>另一个方面看上图蓝色的部分，load指令的第五个阶段需要访问某一个通用寄存器写回，然后下面的Instr3这条指令的蓝色阶段同样有可能会对某一个寄存器进行读操作，如果他们俩访问的是同一个寄存器，就又会造成资源冲突。</p><p>对应这种资源冲突的问题该如何解决呢？</p><p>第一种方法就是让排在后面的指令暂停一个周期，然后再来尝试着执行。</p><p>第二种方法就是资源重复配置，如下图。</p><img src="https://pic.imgdb.cn/item/66841cfad9c307b7e9872246.png" alt="计算机组成原理（五）——中央处理器——影响流水线的因素2.png"><p>如果把指令和数据分别放到不同的cache当中或者两个不同的存储体当中，那么第一个阶段和第四个阶段所需要访问的数据一定是不相同的，第一个阶段是指令数据，而第四个阶段是变量之类的数据。所以如果采用这种方式，那么当第一条指令执行到访存的阶段时，下面的指令刚好到取指阶段，而取指阶段访问的cache和访存阶段访问的cache是两个独立的cache体，所以用这种方式就可以解决结构相关的问题。</p><p>这里可以发现，这部分的解决原理本质上和操作系统的互斥问题是一个路子，所以可以结合操作系统处理互斥问题的思想来理解。</p><p>第二个影响流水线的因素叫做数据相关：</p><img src="https://pic.imgdb.cn/item/66841d4fd9c307b7e987ddc9.png" alt="计算机组成原理（五）——中央处理器——影响流水线的因素3.png"><p>数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。本质上和操作系统里的同步问题类似。</p><p>同样结合上图的图示理解，假设第一条指令执行一个加法，把r2和r3这两个寄存器的值相加之后放回r1，然后第二条指令是执行一个减法，把r1里的内容和r3里的内容相减之后放到r4，然后第三条是逻辑与运算，将r1和r7与运算结果放到r6，第四条是或运算，将r1和r9或运算结果放到r8，最后是一条异或运算，将r1和r11异或运算结果放到r10。</p><p>下面分析一下，正常来说，按照期待的执行顺序，应该先等第一条指令确定了r1的内容，才应该执行第二条指令。同样的，下面的三、四、五三条指令在读出r1数据之前，也都需要先保证第一条指令已经把数据写回r1。</p><p>如果按照期待的完美的流水线来安排这些指令的运行的话，如上图所画，就可以发现，第一条指令在把数据写回r1是在最后一个阶段才执行的，但是第二、三、四条从r1里读出数据是在指令译码阶段，而它们译码阶段的执行都要比第一条指令的第五个写回阶段执行的早，这也就意味着第一条指令还没有把数据写回r1，第二、三、四这三条指令就已经从r1里读出数据了，这就是数据冲突的问题。</p><p>另外，这里还可以发现，最后一条指令同样需要使用r1，但是最后这条指令取出r1的时候，r1的数据已经被写回了，所以最后这条指令和第一条指令之间不存在数据冲突的问题。</p><p>下面看一下数据冲突问题的解决方法：</p><p>第一种处理方法就是把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。这种方法又可以进一步分为硬件阻塞(stall)和软件插入“NOP”两种方法。</p><img src="https://pic.imgdb.cn/item/66841d83d9c307b7e9885239.png" alt="计算机组成原理（五）——中央处理器——影响流水线的因素4.png"><p>首先看硬件阻塞，如果两条指令之间存在数据冲突，那么采用硬件阻塞的方式就意味着，会由硬件系统添加几个气泡(如上图的bubble)，把第二条指令的开始时间往后拖三个周期，这时候再执行第二条指令就与第一条指令没有数据冲突问题。</p><p>除此意外，还可以用软件插入NOP方法，如下图：</p><img src="https://pic.imgdb.cn/item/66841e7bd9c307b7e98a7dd0.png" alt="计算机组成原理（五）——中央处理器——影响流水线的因素5.png"><p>如果在生成机器指令时，编译器发现某两条指令有数据冲突，那么编译器会在这两条指令中间插入三条空指令，每一条空指令的执行也会经过五个完整的机器周期，那么拖了三个这样的指令时间以后，再来启动刚刚的指令，也可以保证不会出现数据冲突。</p><p>接下来说第二种解决方法——数据旁路技术，又叫做转发机制。还是看上图，第一条指令是把r2和r3的相加结果存放到r1里，然后第二条指令会取出r1的内容，然后以r1的内容作为其中一个操作数和r3进行减法操作。但是，r2和r3相加的结果，事实上在第三个执行阶段经过运算器处理以后，就已经有结果了，而第二条减法指令所需要用的其中一个操作数r1也不一定必须从寄存器里取，我们可以增加一个电路，直接从ALU的输出端接到ALU的输入端，也就是把r2和r3相加的结果作为下一条指令的其中一个输入端。这样的话，第二条指令所需要的数据就不需要等待，这就是数据旁路技术。</p><p>下图就是经过数据旁路技术处理后的示意图：</p><img src="https://pic.imgdb.cn/item/66841f20d9c307b7e98bdf9a.png" alt="计算机组成原理（五）——中央处理器——影响流水线的因素6.png"><p>接下来说第三种解决方法——编译优化：通过编译器调整指令顺序来解决数据相关。</p><p>还是结合上面的例子来解释，第一条指令的计算结果会被后面的几条指令所使用到，如果往后还有一系列的指令的执行不需要依赖前面的这几条指令的执行结果，那么就可以把这几条指令安排到第一条指令之后来执行，这样的话，当减法操作指令执行的时候，就已经过了产生数据冲突的周期，这就是编译优化的策略。</p><p>接下来看第三个影响指令流水线的因素——控制相关：</p><img src="https://pic.imgdb.cn/item/66a70ddcd9c307b7e9baf76b.png" alt="计算机组成原理（五）——中央处理器——影响流水线的因素7.png"><p>当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关。</p><p>还是结合上图理解，比如此时要执行的是一个条件转移指令，然后这条指令被存放在地址为12的位置，然后下一条顺序存储的指令存储在地址为16的位置，也就是说每条指令占4B。正常来说，指令的执行流会顺序的一条一条往下执行，但是如果条件转移指令的判断条件满足，那么有可能根据这条指令的指示跳转到某一个不一样的位置，比如说跳转到1000，如上图，那么按照之前安排的指令流水线，前面取进来的三条指令就不应该执行，但事实上它们已经在运行中了，这就是控制相关问题。</p><p>事实上，除了转移指令以外，回调指令和中断指令等，都会产生控制冲突。但接下里重点研究由转移指令导致的这种控制冲突应该如何解决。</p><p>第一种解决方法：转移指令分支预测，就是预测结果会不会满足。这里有两种预测方式：简单预测、动态预测。</p><p>简单预测就是无脑猜，永远都猜条件满足或不满足。而动态预测就是根据历史情况动态的调整猜测的策略。</p><p>第二种解决方法：预取转移成功和不成功两个控制流方向上的目标指令。由于条件转移指令有可能导致程序的执行流往两个方向进行，那么把两个方向所需要用到的指令都预取出来。显然，如果要预取两个控制流方向上的指令，那么可能会需要增加一些硬件部件，比如增加两个指令寄存器之类的。</p><p>第三种解决方法：加快和提前形成条件码。这个思想和第二章所学的把一位全加器进行串联一样，虽然每个全加器都会依赖于前面一个全加器产生的进位信息，但可以通过电路改造的方式，让进位信息提前的产生，然后提前传输给前一个全加器。</p><p>第四种解决方法：提高转移方向的猜准率。这是对第一种解决方法的优化，就是引入一些方法，来提高猜准的概率。</p><p>下面把刚才的内容汇总一下：</p><img src="https://pic.imgdb.cn/item/66841f95d9c307b7e98cecf1.png" alt="计算机组成原理（五）——中央处理器——影响流水线的因素8.png"><p>接下来探讨一下指令流水线的分类：</p><img src="https://pic.imgdb.cn/item/66841fe4d9c307b7e98d9cea.png" alt="计算机组成原理（五）——中央处理器——流水线分类1.png"><img src="https://pic.imgdb.cn/item/66842017d9c307b7e98e056c.png" alt="计算机组成原理（五）——中央处理器——流水线分类2.png"><p>分类的方法以及对应分类的含义如上面的两个图所示，这里就不过多介绍，如有不明白的，可以跳转视频(34分10秒~41分25秒)：<a href="https://www.bilibili.com/video/BV1ps4y1d73V/?p=71&spm_id_from=pageDriver&vd_source=7fb4b255ed876969a742738d7b84f461">5.6.2_指令流水线的影响因素和分类</a></p><p>接下来说一下指令流水线的多发技术：</p><img src="https://pic.imgdb.cn/item/66842058d9c307b7e98e9573.png" alt="计算机组成原理（五）——中央处理器——流水线的多发技术.png"><p>第一种叫超标量技术，如上图，如果采用这种技术，那么在一个时钟周期内，可以并行的发射出多条指令，所以叫多发技术。但需要保证同时执行的这几条指令，在同时工作的情况下，不会导致问题。显然如果同时运行三条指令，就意味着至少需要配置三个指令寄存器，也有可能需要配置三个ALU。因此要实现超标量技术，那么必须配置多个功能部件。</p><p>另外程序里面所包含的这些指令的执行顺序是不可以调整的，就是说经过编译器处理之后，形成的机器代码是怎么排列的，在执行时就是按什么顺序执行的，这个执行顺序是不可改变的。但是有的CPU会支持指令的乱序发射，那这一类的CPU就意味着即便给出的指令序列是1234这么排序的，但是对于这种CPU来说这个指令的顺序仍然是可以调整的。</p><p>回到超标量技术，由于指令的排列是由编译器来确定的，因此编译器在得到这个指令序列的时候，就需要考虑哪些指令可以并行着执行，因此采用超标量技术，那么编译的优化技术要求就会比较高。</p><p>接下来看第二种流水线的多发技术——超流水技术：</p><img src="https://pic.imgdb.cn/item/668420b2d9c307b7e98f5728.png" alt="计算机组成原理（五）——中央处理器——超流水技术.png"><p>超流水技术是会把一个时钟周期再进行分段，像上图就是把一个时钟周期再分成了3段，然后再一个时钟周期内的不同时间点，会发射出三条指令。那么采用这种技术就意味着，在一个时钟周期内，一个功能部件有可能会被使用到多次。所以超流水技术实际上是一个时分复用技术，就是把一个完整的时间段，细分为了三个更细小的时间段。而超标量流水线实际上是空分复用技术，由于增加了多组功能部件，所以可以支持同一时刻多个事情并行的运行。</p><p>所以对于超标量技术和超流水技术思想是有一定区别的，但效果差不多。同样的，对于超流水技术来说，也不能调整指令的执行顺序。而指令的执行顺序也是由编译器来决定的。因此如果要超流水技术效果更好的话，同样得靠编译程序的优化，来优化指令的执行序列。对于上面的例子来说，显然流水线的速度提升为了原来的三倍。</p><p>注意，这里说到的一个时钟周期更应该解释为一个机器周期，因为之前一直说指令完成取指、译码什么的每一个阶段，所需要的时间都是定义为一个机器周期，但是在5.1也说过，一个机器周期理论上最理想的情况下是只需要包含一个时钟周期就可以，所以这里才说一个时钟周期。</p><p>接下来看第二种流水线的多发技术——超长指令字技术：</p><img src="https://pic.imgdb.cn/item/668420d5d9c307b7e98fa6a1.png" alt="计算机组成原理（五）——中央处理器——超长指令字技术.png"><p>如上图可以看到，一条指令的执行经历了取指、译码、执行、写回这四个阶段，但是可以看到，在执行阶段，会有多个同时出现的黑框。出现这种情况的原因是，当编译程序发现某几条指令潜在并行性，会把多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。</p><p>显然多种操作想同时进行，就必须提供多个相互独立的处理部件。</p><p>下面对本节进行一个回顾小结：</p><img src="https://pic.imgdb.cn/item/66842126d9c307b7e9904683.png" alt="计算机组成原理（五）——中央处理器——指令流水线的影响因素.png"><h3 id="5-3-五段式指令流水线"><a href="#5-3-五段式指令流水线" class="headerlink" title="5.3 五段式指令流水线"></a>5.3 五段式指令流水线</h3><p>本部分补充一种考研中，经常会遇到的一种指令流水线类型，即经典的五段式指令流水线，如下图：</p><img src="https://pic.imgdb.cn/item/669d31add9c307b7e902b112.png" alt="计算机组成原理（五）——中央处理器——机器周期设置.png"><p>在5.2里已经接触过五段式指令流水线的概念，但是还有一个遗留问题，那就是之前学习过的指令是否都需要经过这样的五个功能段呢？本部分会介绍考试中常见的五个类型的指令，分别是运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令。通过详细分析这五个类型的指令，看一看如何根据五段式指令流水线的五个功能段来完成相应的工作。</p><img src="https://pic.imgdb.cn/item/669d31e3d9c307b7e902efb9.png" alt="计算机组成原理（五）——中央处理器——五段式指令流水线.png"><p>首先看运算类指令，如下图：</p><img src="https://pic.imgdb.cn/item/669d323cd9c307b7e9034783.png" alt="计算机组成原理（五）——中央处理器——运算类指令的执行过程.png"><p>这里给出了三个例子，加法指令当中，可以指定要相加的两个数，分别来自Rs和Rd这样的两个寄存器，实现的功能就是把Rs和Rd的内容相加，然后再存回Rd。</p><p>注意一点，Rs和Rd这样的命名规则是很常见的，Rs通常指的是原操作数的一个存放的寄存器，Rd指的是目的操作数，即操作数运算结束之后，应该放到什么位置。</p><p>另外，在加法指令中，也可以指定用某一个寄存器的值和某一个立即数进行相加，所以可以看到上图下的第二个加法指令，把源操作数用#966这个立即数的形式来表示。</p><p>下面再看一个算数左移指令，如上图下，这样的一条指令指明了寄存器Rd，这样一条指令所实现的功能就是把Rd寄存器里边存放的内容算数左移两位，然后再存回Rd寄存器。</p><p>下面来看一下，对于这种运算类的指令，如何把一条指令的工作，分在不同的阶段来执行。</p><p>首先，第一个阶段，取指阶段，根据PC从指令Cache取指令至IF段的锁存器。</p><p>接下来ID译码阶段，这一阶段要完成两个事情，第一就是要对指令的操作码进行译码；第二需要把当前的这条指令所需要用到的操作数取到ID段的锁存器里。ID段有三个锁存器，分别是A、B和Imm(立即数锁存器)。所以对于刚刚列举的三条运算类的指令来说，第一条加法指令是把两个寄存器里的内容进行相加，所以对于第一条指令来说，就是要把两个操作数分别的放到A和B这两个锁存器里。而第二条指令同样也是一个加法指令，但是其中一个操作数是一个立即数，因此第二条指令的ID功能段会把其中一个目的操作数放到A锁存器里，然后再把立即数指令里边指明的这个立即数放到Imm锁存器里。对于第三条指令也是类似的，只需要把这一次要进行左移运算的操作数，从通用寄存器组取到锁存器A就可以。所以对于运算类指令来说，在指令译码阶段，都需要把下一个阶段所需要用到的操作数放到ID段的几个锁存器里，至于放到哪个锁存器里，不同的指令会有不同的区别。</p><p>现在准备好了操作数就会进入第三个阶段，执行阶段，在这个阶段ALU算术逻辑单元会根据上一阶段得到的操作数信息进行运算，运算的结果会放到EX段的锁存器里。</p><p>接下来会进入第四个阶段，访存阶段，但是对于RISK精简指令集系统来说，所有的运算类指令运算的两个操作数，一定是直接来自于某一个寄存器或者是用立即数进行运算，然后运算得到的结果一定是存回某一个寄存器，而不能直接存回主存，因此对于精简指令集系统来说，在第四个访存阶段运算类指令是不需要做任何事情的，不需要吧结果写回主存，所以在访存这一个阶段什么也不用做，但是这个阶段的时间是必须要消耗的。</p><p>接下来进入第五个阶段，写回阶段，刚刚EX段运算的结果可以直接放到第四个阶段的锁存器里，然后第五个阶段就可以把这个锁存器里的内容给写回到某一个通用寄存器。</p><p>到这里可以看到，对于运算类的指令来说，访存这个阶段是不需要做任何事情的。接下来介绍一下RISC精简指令集系统下的很重要的两条指令LOAD取数指令和STORE存数指令。</p><img src="https://pic.imgdb.cn/item/669d32b2d9c307b7e903bfeb.png" alt="计算机组成原理（五）——中央处理器——Loda指令执行过程.png"><p>load指令会把内存中我们指明的这个数取出来，然后存放到Rd寄存器里，常见的load指令有如上图下的两种描述方式。第一种描述方式所表示的意思是说在Rs这个寄存器的值的基础上加上996，然后以这个相加的结果作为有效地址，去取出这个地址所对应的主存单元里所存放的数据，把它取到Rd寄存器当中。当然有的地方也会简写成上图最下面的形式，就是直接用mem表示此次要访问的主存地址，把这个地址所对应的内容取到Rd寄存器当中，当然这个主存地址通常也需要进行一次地址变换才可以得到。总之，这里想强调的是，在执行load指令的过程当中，也需要进行一个加法运算。</p><p>那如何安排load指令的执行呢？</p><p>首先第一个阶段都一样，根据PC从指令Cache取指令至IF段的锁存器。</p><p>然后第二个阶段ID指令译码阶段，除了指令译码外，还会把这条指令指明的Rs基址寄存器里的值，放到锁存器A里面。另外还会把指令当中指明的立即数996放到Imm锁存器里。</p><p>接下来进入第三个阶段，第三个阶段会把偏移量和基址进行一个相加，相加之后的结果放到EX段的锁存器里，这样就得到了有效地址EA。</p><p>接下来第四个阶段，需要根据刚才得出的有效地址，从数据cache中取出想要的数，把数取出之后，放到M这个功能段的锁存器里。</p><p>接下来第五个阶段，写回阶段，会把刚才取出的数写回到目的寄存器Rd里。</p><p>这就是load指令的执行过程，注意load指令也是必须经过运算这个阶段的，因为需要经过运算器的处理以后，才可以得到最终的一个有效地址。</p><p><strong>另外，在RISC处理器中，只有“取数LOAD”和“存数STORE”指令才能访问主存，其它所有的指令在执行过程中都不会直接访问主存，其它指令想要得到数据，一定是直接来自于某一个寄存器或者是指令当中直接包含的某一个立即数。</strong></p><p>接下来看存储指令STORE：</p><img src="https://pic.imgdb.cn/item/669d32eed9c307b7e903f4da.png" alt="计算机组成原理（五）——中央处理器——STORE指令执行过程.png"><p>存数指令STORE和取数指令LOAD很像，如上图下，Rs指明源操作数，即要把Rs所指明的寄存器里的内容存到主存当中，存放的目的地址就是Rd再加上996，同样的有的地方也会把存数指令简写为上图最下面的形式，直接用mem来指明最终要存放的地址单元。但是要知道是，要得到最终的存放的有效地址，也需要进行一次加法运算。所以接下来看一下如何安排STORE这条指令的执行。</p><p>首先第一个阶段都一样，根据PC从指令Cache取指令至IF段的锁存器。</p><p>第二个阶段译码阶段，除了指令译码发现这是一条STORE指令之外，同时也需要把基地址存到锁存器A里面，另外也需要把指令当中带有的偏移量放到Imm锁存器里。除此之外，STORE指令还指明了这一次要存放的是哪一个数，这个数本来是存放在Rs寄存器里的，所以还需要把Rs寄存器里的数先放到B这个锁存器里。所以基地址放到了A，偏移量放到了Imm，这一次要存的数放到了B。</p><p>接下来进入第三个阶段，这个阶段需要根据基地址和偏移量计算出此次存放的有效地址，另外还需要把这次要存的数，通过绿色的线子把它从锁存器B直接转移到store锁存器里面。</p><p>接下来第四个阶段就可以根据有效地址EA，写入想要存的数据。这里可以看到，对于STORE指令来说，只需要把想要存的数据存回data cache里就完成了，也就是说第五个阶段写回阶段，不需要做任何事情。这就是存数指令的一个过程。</p><p>接下来看条件转移指令：</p><img src="https://pic.imgdb.cn/item/669d333cd9c307b7e9044547.png" alt="计算机组成原理（五）——中央处理器——条件转移指令执行过程.png"><p>首先要说明一点，转移类指令，不论是条件转移还是无条件转移，通常来说这类的指令都是采用相对寻址，也就是说相对于PC偏移了多少。</p><p>这里看下上图下给出的两条条件转移的例子，第一条指令beq，当指明的两个寄存器里的数相等时，就满足了转移条件，至于转移到什么位置，这里用一个立即数给出了偏移量。当这两个数相等时，要转移到的地址就应该是当前这条指令加上指令字长，再加上偏移量乘以指令字长。而条件不满足时，那接下来要执行的程序就是顺序往后的下一条指令。通常来说，PC自动加1这个过程，是在取指结束之后就会自动完成。</p><p>第二条指令bne类似，但是它代表的是不相等的条件转移。</p><p>接下来分析条件转移指令在各个阶段需要完成什么样的工作：</p><p>首先第一个阶段都一样，根据PC从指令Cache取指令至IF段的锁存器。</p><p>第二个阶段，由于接下来要比较Rs和Rd所指向的两个操作数，因此需要把这两个操作数分别放到锁存器A和B当中，然后另外还需要把这个条件转移指令的偏移量这个立即数放到Imm锁存器里。</p><p>接下来进入第三个执行阶段，这个阶段会通过ALU的计算，得到A和B两个数的比较结果，然后把比较结果放到下一级的锁存器里。</p><p>接下来第四个阶段访存阶段，显然当想进行条件转移时，是不需要保存的，经过第三个阶段的处理之后，就能够知道这个条件到底满不满足。接下来就可以根据当前条件是否满足，来决定到底要让PC的值改变为什么。所以对于条件转移类指令来说，在访存这个阶段，不会进行访存，而是会修改PC的值，把PC的值修改为想要转移到的那个地方。</p><p>也就是说修改PC的值并不是放在第五个写回阶段，写回阶段通常来说都是修改通用寄存器里的值，而PC寄存器不属于通用寄存器，所以对于PC寄存器的修改，并不会放到写回阶段。所以对于条件转移类指令来说，最后这个写回阶段是什么也不用做的。</p><p>很多教材把写回PC的功能段称为“WrPC段”，其耗时比M段更短，所以可安排在M段时间内完成。</p><p>接下来看最后一个无条件转移指令：</p><img src="https://pic.imgdb.cn/item/669d33a4d9c307b7e904accf.png" alt="计算机组成原理（五）——中央处理器——无条件转移指令执行过程.png"><p>无条件转移指令很简单，就是jmp后面跟一个偏移量，这个偏移量通常用补码表示，可以为正也可以为负，同样的，无条件转移指令也采用相对寻址的方式。</p><p>对于无条件转移指令的功能描述是这样的，如上图下，给出的PC的值是指当前指令的存放地址，然后当前指令的地址再加上一个指令字长，相当于先给PC+1，即先指向下一条指令，然后相对于下一条指令的存储地址而言，进行一个偏移，而要偏移多少，jmp指令里给出的偏移量指的是应该向前或向后偏移多少条指令，因此还需要用偏移量乘指令字长，这个地方和条件转移是很类似的。</p><p>接下来看一下无条件转移指令的执行：</p><p>首先第一个阶段都一样，根据PC从指令Cache取指令至IF段的锁存器。</p><p>第二个阶段，需要把偏移量放到Imm锁存器里。</p><p>第三个阶段，由于对无条件转移指令来说，由于不需要判断任何条件，因此第三个阶段用不到ALU，而是会直接根据偏移量，把目标的PC值直接写回到PC寄存器里。所以对于无条件转移指令来说，刚刚提到的写回PC的这个功能段又会被安排在EX这个阶段来执行，所以接下来的访存和写回阶段不需要做任何事情。</p><p>“WrPC段”耗时比EX段更短，可安排在EX段时间内完成。WrPC段越早完成，就越能避免控制冲突。当然，也有的地方会在WB段时间内才修改PC的值。</p><p>下面对用一道真题对本节内容进行一个总结：</p><img src="https://pic.imgdb.cn/item/669d341cd9c307b7e905251a.png" alt="计算机组成原理（五）——中央处理器——五段式指令流水线例题.png"><h2 id="6-多处理器系统"><a href="#6-多处理器系统" class="headerlink" title="6. 多处理器系统"></a>6. 多处理器系统</h2><h3 id="6-1-多处理器系统的基本概念"><a href="#6-1-多处理器系统的基本概念" class="headerlink" title="6.1 多处理器系统的基本概念"></a>6.1 多处理器系统的基本概念</h3><p>本节是新考点，只要掌握基本概念即可，所以背就好，这里给张重点思维导图，可以结合视频学习记忆：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=73&vd_source=7fb4b255ed876969a742738d7b84f461">5.7_1_多处理器系统的基本概念</a></p><img src="https://pic.imgdb.cn/item/66a7385bd9c307b7e9dfe1d4.png" alt="计算机组成原理（五）——中央处理器——多处理器的基本概念.png"><h3 id="6-2-硬件多线程的基本概念"><a href="#6-2-硬件多线程的基本概念" class="headerlink" title="6.2 硬件多线程的基本概念"></a>6.2 硬件多线程的基本概念</h3><img src="https://pic.imgdb.cn/item/669d3470d9c307b7e9057570.png" alt="计算机组成原理（五）——中央处理器——硬件多线程.png"><p>下面是本节考点汇总，本部分都是基本概念，因此只要背住即可，考试一般也只考选择题，如果有不理解的地方可以跳转视频去听一下讲解，一共8分钟：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=74&vd_source=7fb4b255ed876969a742738d7b84f461">5.7_2硬件多线程的基本概念_</a></p><img src="https://pic.imgdb.cn/item/669d34afd9c307b7e905b28f.png" alt="计算机组成原理（五）——中央处理器——三种硬件多线程考点.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（四）——文件管理</title>
      <link href="/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2024/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（四）——文件管理"><a href="#操作系统（四）——文件管理" class="headerlink" title="操作系统（四）——文件管理"></a>操作系统（四）——文件管理</h1><h2 id="1-文件管理基础"><a href="#1-文件管理基础" class="headerlink" title="1. 文件管理基础"></a>1. 文件管理基础</h2><img src="https://pic.imgdb.cn/item/665f2a765e6d1bfa05a098ed.png" alt="操作系统（四）——文件管理——初始文件管理.png"><p>在之前的学习中，我们知道操作系统作为系统资源的管理者，也需要对文件进行管理。</p><p>文件也属于一种系统资源，所谓文件就是一组有意义的信息&#x2F;数据的集合。</p><p>而各种各样的文件，所呈现出的特性也是不一样的，比如图片文件和文字文件。所以不同的文件有不同的属性，而因为文件的属性不同，所以在使用文件时也会有各种各样的差别。<strong>所以第一个需要讨论的问题就是计算机存放了各种各样的文件，一个文件有哪些属性？</strong></p><p><strong>第二个问题，文件是一组有意义的信息&#x2F;数据的集合，那这些信息在内部是怎么被组织起来的（即文件内部组织形式的问题）？</strong></p><p>在系统当中有很多的文件，但是这些文件由于有组织的被存放在一起，所以平时使用时会很方便。<strong>所以第三个问题，文件之间是怎样组织起来的？</strong></p><p>从下往上看，OS的上层应该是应用程序和用户，所以OS应该为其上层提供一些简单易用的接口，用来方便操作各种文件。<strong>所以第四个问题，OS应该为上层提供哪些功能？</strong></p><p>从上往下看，OS的下面是硬件，所以OS也需要对硬件进行管理，而文件一般被存放在外存（磁盘）中，而外存作为计算机的一种硬件，肯定也需要OS对其进行管理。<strong>所以第五个问题，文件的数据应该怎么被存放在外存上？</strong></p><p>以上五个问题，将是我们这一章学习和研究的重点，希望通过上面的介绍，可以对本章有所初步认知。</p><p>接下来我们看一下，文件应该有哪些属性？</p><img src="https://pic.imgdb.cn/item/665f2d5e5e6d1bfa05a458ce.png" alt="操作系统（四）——文件管理——文件的属性.png"><p>这里要注意区分文件名和标识符的概念，文件名是由用户创建的，而标识符是由操作系统定义的。</p><p>接下来看文件内部数据应该怎么样组织起来？</p><img src="https://pic.imgdb.cn/item/665f2db75e6d1bfa05a4ba50.png" alt="操作系统（四）——文件管理——文件内部数据的组织1.png"><p>我们平常使用电脑的过程中也会使用各种各样的文件。</p><p>有的文件比如说像txt这样的文件，它是一种看起来没有很明显结构特性的文件，这样的文件是由一些二进制或字符流组成，这就是所谓的<strong>无结构文件</strong>，又称“流式文件”。</p><p>另外，在用户看来，还有一些文件表现出很强的结构特性，比如Excel表，这就是所谓的<strong>有结构文件</strong>。所以对于这种有结构文件来说，它是由一条一条的记录组成，而每一条记录又是由一组相关的数据项组成，比如上图右的例子。<strong>数据项是文件系统当中最基本的数据单位。</strong></p><p>因此，文件可以分为无结构文件和有结构文件两大类，如下图：</p><img src="https://pic.imgdb.cn/item/665f2dd75e6d1bfa05a4db10.png" alt="操作系统（四）——文件管理——文件内部数据的组织2.png"><p>有结构文件中，各个记录间应该如何组织的问题――应该顺序存放？还是用索引表来表示记录间的顺序？这是“文件的逻辑结构“要重点探讨的问题。该部分只是对本章做个概述，目的是让大家有个全局观，所以这个问题在这里先不介绍，在之后的部分会进行讲解。</p><p>接下来看文件之间应该怎么样组织起来：</p><img src="https://pic.imgdb.cn/item/665f2e3f5e6d1bfa05a54170.png" alt="操作系统（四）——文件管理——文件间的组织.png"><p>我们在打开电脑的某个盘时，里面会出现很多文件夹，打开某个文件夹，还会出现更多的文件夹。所以我们平时使用windows系统的组织形式，看起来像是一个树状结构，如上图。</p><p>一个根目录下可以有各种文件目录，也可以有一些普通的文件，而各个目录下还可以创建更深一层的目录。这里所谓的“目录”，就是我们熟悉的文件夹。</p><p>我们普通用户可以自己创建一层一层的目录，各层目录中存放相应的文件。系统中的各个文件就通过一层一层的目录合理有序的组织起来了。</p><p>我们平时看见的目录或者说文件夹其实也是一种特殊的有结构文件（这个有结构文件也是由一些记录组成)，而文件目录是怎么样实现的也是之后会重点探讨的问题。</p><p>总之，文件通过目录的功能，一层一层的组织起来，这样很方便用户的使用。</p><p>接下来考虑一下，OS应该为其上层提供哪些功能：</p><img src="https://pic.imgdb.cn/item/665f2e715e6d1bfa05a57475.png"><p>从生活经验出发，比如说我们可以在一个文件目录下新建一个txt文件，点了新建文件之后，在背后其实是使用了操作系统提供的一个文件创建功能。如上图左，在我们点击新建按钮以后，这个图形化进程其实是在背后调用操作系统向上提供的create系统调用来完成创建这个工作。在我们创建了文件以后，这个文件数据就已经在外存当中。</p><p>我们可以双击打开这个txt文件，为了操作这个文件的数据，需要把文件的数据从外存读到内存，因为只有读到内存以后，才能让CPU处理，所以这里就使用到了一个读文件的功能。在我们双击这个txt文件之后，操作系统先是默认的打开了txt对应的应用程序（即记事本），这个应用程序又调用了操作系统向上提供的read的系统调用来实现读文件的功能。通过读文件的功能，就可以把这个文件的数据放入内存，然后呈现在用户面前。</p><p>当我们把这个txt文件编辑结束以后，我们可以保存文件，在我们点击了文件保存的按钮以后，记事本这个应用程序在背后调用了操作系统向上提供的write系统调用，实现了所谓的写文件功能，这个功能就是负责把文件数据从内存再写回外存。因为我们平时编辑这个文件的时候，只改了文件在内存当中的副本的数据，所以为了保存这个文件的内容，我们必须再使用写文件的功能，将文件数据保存到外存中。</p><p>既然我们可以创建一个文件，当然也可以删除一个文件，如上图，在我们点了删除按钮以后，这个图形化的交互进程在背后调用了操作系统提供的delete系统调用，这样就可以把文件数据从外存当中删除。</p><p>除了这些肉眼可见的功能以为，OS还需要提供打开文件和关闭文件这两个基本的功能，如下图：</p><img src="https://pic.imgdb.cn/item/665f2e915e6d1bfa05a59811.png" alt="操作系统（四）——文件管理——OS向上提供的功能2.png"><p>这里的打开文件和关闭文件功能与我们平时所谓的双击和点击所谓的软件右上角的关闭窗口的“x”是不一样的东西。至于具体打开文件和关闭文件时需要做什么，在之后的内容里会进行探讨。</p><p>但是需要注意，在读&#x2F;写文件前，需要使用open系统调用打开文件；在读&#x2F;写文件后，需要使用close系统调用关闭文件。</p><p>另外，很多对文件的复杂操作，可以用这些基本的功能来进行复合，比如:“复制文件”：先创建一个新的空文件，再把源文件读入内存，再将内存中的数据写到新文件中。而OS在处理这些系统调用的时候，在背后需要做哪些事，这也是之后会展开探讨的问题。</p><p>接下来看一下，既然文件是存放在外存当中的，而外存又属于一种硬件，从上往下看，操作系统是最接近硬件的层次，因此OS需要对硬件进行管理，相应的，这些文件数据应该怎么被放到外存这个硬件当中，当然也是也是操作系统应该关心和解决的问题。</p><img src="https://pic.imgdb.cn/item/665f2ec65e6d1bfa05a5d6a6.png" alt="操作系统（四）——文件管理——文件如何存放在外存.png"><p>首先需要知道的是，外存与内存一样，也会被分为一个一个的存储单元，每个存储单元可以放一定量的数据，并且每个存储单元对应一个物理地址。</p><p>同样类似于内存分为一个个“内存块”，外存会分为一个个“块&#x2F;磁盘块&#x2F;物理块”。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址(如上图例中，一块包含210个地址，即1KB）。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小，比如说在上例中，一个磁盘块占2<sup>10</sup>个字节，所以要表示2<sup>10</sup>个物理地址，总共就需要10个二进制位才可以表示，因此在上例中，块内地址位数应该是10。</p><p>注意，操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用1KB的磁盘块。</p><p>另外，外存中的数据读入内存时同样以块为单位进行数据交换。</p><p>通过这部分了解可以知道，外存被分为一个一个的磁盘块，如下图：</p><img src="https://pic.imgdb.cn/item/665f2f205e6d1bfa05a635af.png" alt="操作系统（四）——文件管理——文件如何存放在外存1.png"><p>当文件比较大时，文件数据是放在连续的几个磁盘块中，还是离散的分配在磁盘块里，这也是我们之后需要讨论的内容。</p><p>除了分配给文件的这些磁盘块应该怎么组织起来这个问题之外，操作系统还要关心怎么管理这些空闲的磁盘块，怎么对这些磁盘块进行分配与回收这些问题，这也是本章需要讨论的内容。</p><p>所以文件的物理结构，探讨的是文件这些数据在物理上应该是怎么样存放的问题；而文件的逻辑结构，指的是文件的各个记录在逻辑上应该是什么样的一种组织关系的问题。这些知识点会在接下来的内容里进行进一步学习。</p><p>而除了刚刚探讨的功能以外，操作系统还要实现文件共享和文件保护这两个比较重要的功能，如下图：</p><img src="https://pic.imgdb.cn/item/665f2f4c5e6d1bfa05a66291.png" alt="操作系统（四）——文件管理——其它由OS提供的文件管理功能.png"><p>文件共享就是指如何让多个用户可以共享使用一个文件。</p><p>文件保护是指怎么保证不同的用户对文件有不同的操作权限。</p><p>这两个问题在本章也会学习到。</p><p>接下来对上面所说的问题进行一个总结：</p><img src="https://pic.imgdb.cn/item/665f2f735e6d1bfa05a68cda.png" alt="操作系统（四）——文件管理——文件管理基础小结.png"><p>最后说一下，该部分文件管理基础主要是为了帮助建立一个全局观，能在正式学习本章前，对本章内容有一个初步的认识。另外，在本章学习完以后，也可以回来再过一遍该部分，这样可以帮助对本章在宏观上有进一步的掌控。</p><h2 id="2-文件的逻辑结构"><a href="#2-文件的逻辑结构" class="headerlink" title="2. 文件的逻辑结构"></a>2. 文件的逻辑结构</h2><h3 id="2-1-文件的逻辑结构知识总览"><a href="#2-1-文件的逻辑结构知识总览" class="headerlink" title="2.1 文件的逻辑结构知识总览"></a>2.1 文件的逻辑结构知识总览</h3><img src="https://pic.imgdb.cn/item/6661ca565e6d1bfa051ca67a.png" alt="操作系统（四）——文件管理——文件的逻辑结构知识总览.png"><p>所谓的“逻辑结构”，就是指在用户看来,文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。</p><p>在数据结构中我们已经接触过许多逻辑结构与物理结构的问题，如“线性表”就是一种逻辑结构，在用户角度看来，线性表就是一组有先后关系的元素序列。但是对于一种逻辑结构李硕，也可以用不同的物理结构实现。比如线性表就可以用顺序表或链表的方式实现。顺序表的各个元素在逻辑上相邻，在物理上也相邻；而链表的各个元素在物理上可以是不相邻的。因此，顺序表可以实现“随机访问”，而“链表”无法实现随机访问。</p><p>可见，算法的具体实现与逻辑结构、物理结构都有关。文件也一样，文件操作的具体实现与文件的逻辑结构、物理结构都有关。</p><p>文件可以分为无结构文件与有结构文件，本节需要重点关注的是有结构文件。</p><p>接下来先看一下无结构文件。</p><h3 id="2-2-无结构文件"><a href="#2-2-无结构文件" class="headerlink" title="2.2 无结构文件"></a>2.2 无结构文件</h3><img src="https://pic.imgdb.cn/item/6661cbb85e6d1bfa051e7173.png" alt="操作系统（四）——文件管理——无结构文件.png"><p>所谓无结构文件就是一系列的二进制流或字符流组成，又称为“流式文件“。比如windows系统里的.txt文件就是一种很典型的无结构文件。由于这种结构没有很明显的特性，所以也不必要讨论这种无结构的问题。所以重点关注有结构文件。</p><h3 id="2-3-有结构文件"><a href="#2-3-有结构文件" class="headerlink" title="2.3 有结构文件"></a>2.3 有结构文件</h3><h4 id="2-3-1-有结构文件概念"><a href="#2-3-1-有结构文件概念" class="headerlink" title="2.3.1 有结构文件概念"></a>2.3.1 有结构文件概念</h4><img src="https://pic.imgdb.cn/item/6661ccc15e6d1bfa051fd55f.png" alt="操作系统（四）——文件管理——有结构文件1.png"><p>有结构文件：由一组相似的记录组成，又称“记录式文件”。每条记录由若干个数据项组成。如：数据库表文件。</p><p>如上图的例子就是一张数据库表，记录了各个学生的信息，包括学号、姓名、性别、专业这四个数据项。一般来说每条记录可以有一个数据项作为关键字，像上面的例子中就可以用学号作为关键字，来充当识别不同记录的id。每个学生会对应一条记录，每条记录由若干个数据项组成。</p><p>另外，根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种。</p><img src="https://pic.imgdb.cn/item/6661ceb25e6d1bfa0522256c.png" alt="操作系统（四）——文件管理——有结构文件定长记录.png"><p>如上图是定长的例子，还是刚刚的例子，可以用32B表示学号，32B表示姓名，4B表示性别，60B表示专业。所以既然每一个数据项长度相同，那么每条记录的总长度也是相同的。并且在定长记录当中，每个数据项在记录中所处的位置也是相同的。</p><p>接下来看一下可变长的例子：</p><img src="https://pic.imgdb.cn/item/6661d21a5e6d1bfa05276a66.png" alt="操作系统（四）——文件管理——有结构文件可变长记录.png"><p>如上图，是可变长记录的例子，还是之前的学生信息表，但这次记录了一个特长数据项，由于每个同学的特长这一项长度是不确定的，有的很多，有的很少，有的甚至没有，所以像这些记录就是一种可变长记录。如果我们给每个学生的特长都分配一个很大的存储空间，显然会出现空间浪费的情况，所以在这个例子里，最好是让这个有结构文件的记录是可变长记录。</p><p>接下来讨论一下这些记录在逻辑上应该被怎么组织起来的问题，也就是有结构文件的逻辑结构问题。<strong>根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类：顺序文件、索引文件、索引顺序文件。</strong>接下来分别看一下这三种结构。</p><h4 id="2-3-2-顺序文件"><a href="#2-3-2-顺序文件" class="headerlink" title="2.3.2 顺序文件"></a>2.3.2 顺序文件</h4><img src="https://pic.imgdb.cn/item/6661d4fe5e6d1bfa052aa24c.png" alt="操作系统（四）——文件管理——顺序文件1.png"><p>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p><p>如果文件是顺序存储的话，那么在逻辑上相邻的记录吗，在物理上也是相邻的。而如果采用链式存储结构，逻辑上相邻的记录，物理上不一定相邻。</p><p>根据记录是否按关键字顺序排列，又可以把记录分为串结构和顺序结构。串结构，就是记录之间的顺序与关键字无关。顺序结构就是记录之间的顺序按关键字顺序排列。</p><p>显然，记录到底是定长的还是可变长的，这些记录是否按照关键字有序排列，另外这些记录在物理上到底是顺序存储还是链式存储，这些都会影响文件的操作功能。</p><p>现在重点讨论两个问题，假设已经知道文件的起始地址。第一个问题，能否快速找到第i个记录对应的地址?（即能否实现随机存取)。第二个问题，能否快速找到某个关键字对应的记录存放的位置?</p><img src="https://pic.imgdb.cn/item/6661d52b5e6d1bfa052acf36.png" alt="操作系统（四）——文件管理——顺序文件2.png"><p>若一个顺序文件在物理上采用链式存储，那么无论这个文件是定长还是可变长记录，也无论是串结构还是顺序结构，都无法实现随机存取。每次只能从第一个记录开始依次往后查找。</p><p>若采用顺序存储的物理结构，并且这个文件是可变长记录文件，则依然无法实现随机存取。如上图左下的记录，由于文件记录是可变长的，所以每个文件的记录长度不一样，需要在每个记录前，用一定的存储空间，来表示这个记录的长度。假设记录长度用1字节表示，第0条记录的逻辑地址就是0。第二条记录的起始地址，就应该是第一条记录的长度L0，加上记录长度1字节。接下来的每条记录的起始地址都应该是前面记录的长度和，由于每条记录的长度不固定，所以每条记录的起始地址并不会呈现一种规律性，所以无法实现随机存取。</p><p>若采用顺序存储的物理结构，并且这个文件是定长记录文件，则可以实现随机存取，如上图右下，第i个文件可以通过起始地址+i*记录长度。若该文件还是串结构，即记录的顺序和关键字的顺序是没有关系的，这就无法快速找到某个关键字对应的记录。若该文件是顺序结构，即记录的顺序和关键字的顺序是有关系的，这样的话就可以用像折半查找之类的方法来快速找到某一个关键字对应的记录。</p><p>到这里就可以回答前面的两个问题，关于能否快速找到第i个记录对应的地址？我们得出的结论是如果物理上采用链式存储，那肯定无法实现。若物理上采用顺序存储，可变长记录的物理是无法实现的，而定长记录的文件是可以实现的。如果在这个基础上，再能保证定长记录的文件是一种顺序结构，就可以实现快速检索某一个记录的功能。</p><p>注：一般来说，考试题目中所说的“顺序文件”指的是物理上顺序存储的顺序文件。之后的讲解中提到的顺序文件也默认如此。</p><h4 id="2-3-3-索引文件"><a href="#2-3-3-索引文件" class="headerlink" title="2.3.3 索引文件"></a>2.3.3 索引文件</h4><img src="https://pic.imgdb.cn/item/6661d5515e6d1bfa052afd9c.png" alt="操作系统（四）——文件管理——索引文件.png"><p>通过前面的学习，我们可以知道，如果一个顺序文件是可变长记录的话，要找到第i个记录，就必须先顺序的查找前面i-1个记录，但是实际生活中，又有很多场景必须使用可变长记录，那能不能解决可变长文件查找效率慢的问题，能否让可变长文件也实现随机访问的功能。基于这种需求，人们提出了索引文件这种逻辑结构。</p><p>每一个文件会建立一张索引表，并且每一个索引表表项，会对应文件的一条记录。文件中的这些记录在物理上可以离散地存放。但索引表的表项在物理上需要连续存放。另外每一个索引表的表项大小是相等的。因此索引表本身可以理解为**<font color=red>定长记录的顺序文件</font>**，所以索引表可以支持随机访问。</p><p>如果让关键字作为索引号的内容，并且让索引表当中的表项按照关键字顺序排列，那么就可以让索引文件支持折半查找，这样就可以大幅度提升索引文件的检索速度。</p><p>既然每个记录都有一个对应的索引项，那么在添加&#x2F;删除一个记录时，也要对应的增加删除一个索引项。</p><p>到这里，我们就可以知道索引文件这种逻辑结构，可以支持很快的检索速度，所以这种逻辑结构主要是用在对于信息处理的及时性要去比较高的场合。另外，除了用关键字作为索引号之外，还可以用别的不同数据项作为索引号，来为一个文件建立多个索引表。</p><h4 id="2-3-4-索引顺序文件"><a href="#2-3-4-索引顺序文件" class="headerlink" title="2.3.4 索引顺序文件"></a>2.3.4 索引顺序文件</h4><img src="https://pic.imgdb.cn/item/6661d57b5e6d1bfa052b2950.png" alt="操作系统（四）——文件管理——索引顺序文件1.png"><p>在索引文件中，每个记录都对应一个索引表项，因此可能记录很小，索引表项很大，这样就会导致空间利用率极低。为了解决这个问题，人们提出了索引顺序文件的概念。</p><p>索引顺序文件是索引文件和顺序文件思想的结合。与索引文件相似的，索引顺序文件中，同样会为文件建立一张索引表，但不同的是，并不是每个记录对应一个索引表项，而是**<font color=red>一组记录对应一个索引表项</font>**。如上图的学生记录例子，而从这个例子也可以发现，索引顺序文件的索引项是每组的第一个关键字，所以索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入。</p><p>可以看到，用这种策略确实可以让索引表“瘦身”，但是是否会出现不定长记录的顺序文件检索速度慢的问题呢？下面来分析一下。</p><img src="https://pic.imgdb.cn/item/6661d5a35e6d1bfa052b4fd1.png" alt="操作系统（四）——文件管理——索引顺序文件2.png"><p>假设若一个<strong>顺序文件</strong>有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构的顺序文件)，那我们要找到某个关键字对应的记录，<strong>平均须查找5000个记录</strong>。</p><p>采用<strong>索引顺序文件</strong>结构，可把10000个记录分为sqrt(10000)&#x3D; 100组，每组100个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为100，平均需要查50次)，找到分组后，再在分组中顺序查找记录（每个分组100个记录，因此平均需要查50次)。可见，采用索引顺序文件结构后，平均查找次数减少为<strong>50+50&#x3D; 100次</strong>。</p><p>同理，若文件共有10个记录，则可分为1000个分组，每个分组1000个记录。根据关键字检索一个记录平均需要查找500+500 &#x3D; 1000次。这个查找次数依然很多，如何解决呢？可以建立多级索引，如下图。</p><img src="https://pic.imgdb.cn/item/6661d5ca5e6d1bfa052b7903.png" alt="操作系统（四）——文件管理——多级索引顺序文件.png"><p>我们可以先为这个文件建立一张低级索引表，每一个索引表对应100个表项，每一个表项对应一个分组，每一个分组里有100个记录，不难算出会有100张低级索引表。我们可以为100张低级索引表再建立一张顶级索引表，这样就形成了两级索引顺序文件，顶级索引表里有100个表项，低级索引表里每一个索引表也有100个表项，每个分组里也有100个记录，按照这样分组，根据一个关键字检索一个记录，<strong>平均只需要查找50+50+50&#x3D;150次</strong>。</p><p>注意，要会计算平均查找次数。</p><h3 id="2-4-文件的逻辑结构小结"><a href="#2-4-文件的逻辑结构小结" class="headerlink" title="2.4 文件的逻辑结构小结"></a>2.4 文件的逻辑结构小结</h3><img src="https://pic.imgdb.cn/item/6661d6185e6d1bfa052bc495.png" alt="操作系统（四）——文件管理——文件的逻辑结构小结.png"><h2 id="3-文件的物理结构"><a href="#3-文件的物理结构" class="headerlink" title="3. 文件的物理结构"></a>3. 文件的物理结构</h2><h3 id="3-1-文件的物理结构基础"><a href="#3-1-文件的物理结构基础" class="headerlink" title="3.1 文件的物理结构基础"></a>3.1 文件的物理结构基础</h3><img src="https://pic.imgdb.cn/item/6662759d5e6d1bfa05ac77c7.png" alt="操作系统（四）——文件管理——OS对磁盘块进行管理.png"><p>在之前的学习中我们知道，操作系统作为最接近硬件的一个软件层次，需要对硬件进行管理，这其中也包括外存（磁盘）。操作系统对磁盘的管理主要有两点，一是对非空闲磁盘块进行管理，即文件的物理结构问题；二是对空闲磁盘块进行管理，即文件存储空间管理的问题。</p><p>这部分我们先看第一个问题——文件的物理结构：</p><img src="https://pic.imgdb.cn/item/6662767b5e6d1bfa05ad7987.png" alt="操作系统（四）——文件管理——文件物理结构.png"><p>文件的物理结构要探讨的就是文件的数据应该怎么样存放在外存中，总共会分成三种方式：连续分配，链接分配，索引分配。其中链接分配可以进一步分为隐式链接和显示链接。</p><p>在正式开始学习这三种分配方式前，先补充一个知识点——文件块、磁盘块。</p><img src="https://pic.imgdb.cn/item/6662776f5e6d1bfa05ae910b.png" alt="操作系统（四）——文件管理——文件块、磁盘块1.png"><p>类似于内存分页，磁盘中的存储单元也会被分为一个个大小相等的块，这些块也被称为磁盘块或物理块。相应的，系统也会为这些磁盘块进行编号。另外，在很多操作系统中，磁盘块的大小会设置的和内存块、内存页面大小相同，这么做是为了方便外存和内存之间数据交换。</p><img src="https://pic.imgdb.cn/item/66627d015e6d1bfa05b53c90.png" alt="操作系统（四）——文件管理——文件块、磁盘块2.png"><p>在内存管理中学过，进程的逻辑地址空间会被分为一个一个页面，这样可以方便操作系统对内存进行管理。相应的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为一个一个大小相等的文件“块”，因此，文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。</p><p>如上图左，假设这个系统当中，一个物理块的大小是1KB，则1MB大小的文件可以被分为1K个块，所以这个文件的逻辑块号应该是从0到1023。因此用户在操作自己的文件时，可以用（逻辑块号，块内地址）的形式定位到自己文件中的任何一个位置。</p><p>文件的数据被分为一个一个数据块以后，操作系统为文件分配存储空间也都是以块为单位的，而文件的块被放到磁盘的什么位置，对用户来说是不可知的。因此用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射。这也是文件的物理结构需要关注的核心问题，怎么把逻辑块号转化为物理块号。</p><h3 id="3-2-连续分配"><a href="#3-2-连续分配" class="headerlink" title="3.2 连续分配"></a>3.2 连续分配</h3><img src="https://pic.imgdb.cn/item/6663097f5e6d1bfa0552daf7.png" alt="操作系统（四）——文件管理——连续分配1.png"><p>连续分配方式要求每个文件在磁盘上占有一组连续的块。比如说一个文件aaa，它在逻辑上可以分为如图的三个块，如果采用连续分配方式，这些逻辑上相邻的块在物理上也必须相邻，如图，0号逻辑块放到4号物理块，1号逻辑块放到5号物理块，2号逻辑块放到6号物理块。</p><p>现在要考虑一个问题，如果采用这种分配方式，操作系统如何实现从逻辑块号到物理块号的映射和转变呢？</p><p>首先要明确的是，用户在操作自己的文件时，使用的是（逻辑块号，块内地址）这样的一个地址，其实块内地址是不需要转变的，因此操作系统只需要关系逻辑块号到物理块号的映射就可以了。</p><p>为了实现地址映射的功能，在文件的目录表当中必须记录两个文件的属性，第一是一个文件存放的起始块号，第二是文件的长度。比如aaa这个文件，起始块号是4，并且连续占用了三个块，因此长度是3。</p><p>有了上述提到的信息，操作系统就可以完成地址转换。假设用户给出要访问的逻辑块号，那么操作系统需要先找到这个用户想要访问的文件对应的目录项，也就是FCB。在FCB当中就可以知道文件存放的起始块号，再用起始块号加上用户提到逻辑块号就可以得到对应的物理块号。</p><p>另外，操作系统还需要验证用户提供的逻辑块号是否合法，是否已经超过了文件的实际长度。</p><p>通过分析可以发现，如果采用连续分配，那么只要用户给出了自己想要访问的逻辑块号，操作系统就可以直接根据逻辑块号算出它对应的物理块号到底是多少，因此我们说连续分配方式是支持顺序访问和直接访问（随机访问）。</p><p>接下来看一下连续分配方式的第二个优点：</p><img src="https://pic.imgdb.cn/item/666309a95e6d1bfa05530c9a.png" alt="操作系统（四）——文件管理——连续分配2.png"><p>首先我们要知道，磁盘（磁盘的内容可以参考计组第三章存储系统）这种硬件想要读取一个磁盘块的时候，需要把磁头放到磁盘块对应的位置，而访问不同的磁盘块是需要移动磁头的。并且两个磁盘块的距离越远，那么移动磁头所需要的时间就越长。</p><p>比如，现在要读上图三个连续的黄色块。那么首先要把磁头放到第一个块的位置，之后移动到第二个块的位置，再之后移动到第三个块的位置。所以由于这三个块在物理上是相邻的，也就是它们相距距离是最短的。因此这个移动的过程其实磁头的移动距离也是最短的。而假如我们此时想要读取的是紫色的这三个磁盘块的话，由于紫色的块不相邻，所以需要移动磁头的时间就会变长。</p><p>基于上述分析，我们可以知道，如果一个文件采用连续分配，我们在顺序读取这个文件的各个块时，所需要的读写时间是最短的，读写速度是最快的，因此整个过程所需要的磁头移动距离是最短的。</p><p>接下来看一下连续分配方式有哪些缺点：</p><img src="https://pic.imgdb.cn/item/66630fd35e6d1bfa055b1cfb.png" alt="操作系统（四）——文件管理——连续分配缺点.png"><p>假设在上图中，黄色的部分是一个文件A所占用的连续的三个块，绿色区域是空闲磁盘，橙色区域为其他文件已经占用的磁盘块。</p><p>若此时文件A想要扩展，也就是说想要再增加一个磁盘块的话，那由于连续分配要求为一个文件分配的是连续的块，而文件A后面的相邻的块此时已经被别的文件所占有。因此，如果要扩展文件A，那么我们不得不把文件a的数据整体的迁移到另外的有连续的四个块的区域当中，也就是如下图四个块的样子。</p><img src="https://pic.imgdb.cn/item/66630e9e5e6d1bfa05596e68.png" alt="操作系统（四）——文件管理——连续分配缺点1.png"><p>进行数据迁移的过程是要耗费很大的开销的，所以可以得出结论，物理上采用连续分配的文件不方便拓展。</p><p>接下来看另一种情况：</p><img src="https://pic.imgdb.cn/item/666310cf5e6d1bfa055c8a57.png" alt="操作系统（四）——文件管理——连续分配缺点2.png"><p>同样假设橙色区域为非空闲块，绿色区域为空闲磁盘块。如上图，此时有五个空闲磁盘块。若此时创建的新文件采用连续分配方式大小为3个块，由于整个磁盘当中并没有连续的三个空闲块，那么无法为其分配足够的存储空间。如果这个系统当中有很多文件大小都是大于一个块的大小，那这些离散的空闲块就很难被利用起来。</p><p>所以可以得出结论：物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片。这些磁盘碎片就有点类似于在内存管理当中讲过的外部碎片，处理这些碎片的方式也和处理外部碎片的思想是一样的，可以用紧凑的方式来解决。但是紧凑就意味着要移动大量的磁盘块内容，这个过程是需要花费很大的时间代价的。因此产生磁盘碎片这个问题，也是连续分配方式一个很明显的缺点。</p><p>下面对连续分配进行一个总结：</p><img src="https://pic.imgdb.cn/item/666312745e6d1bfa055faa89.png" alt="操作系统（四）——文件管理——连续分配总结.png"><h3 id="3-3-链接分配"><a href="#3-3-链接分配" class="headerlink" title="3.3 链接分配"></a>3.3 链接分配</h3><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块，然后用指针链接的方式把这些磁盘块给串联起来。链接方式又可进一步分为隐式链接和显式链接两种。</p><p>下面先看隐式链接这种方式： </p><img src="https://pic.imgdb.cn/item/66631a265e6d1bfa0568d782.png" alt="操作系统（四）——文件管理——隐式链接1.png"><p>如果采用隐式链接的方式，在文件的目录项也就是文件对应的FCB当中，需要记录这个文件的起始块号和结束块号。另外，各个块之间都会有一定的存储空间用来存储指向下一块的链接指针，当然，最后一个块是没有指向下一块的链接指针的，而这些指针对于用户来说是透明的。</p><p>那采用这种方式的话，怎么实现逻辑块号到物理块号的转变呢？</p><p>用户首先给出要访问的逻辑块号i，然后操作系统会根据文件名找的他对应的FCB这个目录项，找的这个文件的起始块号，于是操作系统可以先读入这个文件的起始块（即逻辑上的0号块），然后通过起始块的指针找到下一个块，依次类推。因此，如果说我们想要访问逻辑块号为i的这个逻辑块时，那操作系统首先需要先依次地读入0号到i减1号逻辑块，才可以找到i号块的存放位置。因此访问i号逻辑块，总共需要i+1次磁盘I&#x2F;O操作。</p><p>经过上述分析可以得出结论：采用隐式链接方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</p><p>下面思考另一个问题，采用隐式链接的方式，是否方便实现拓展文件呢？</p><img src="https://pic.imgdb.cn/item/66631a6e5e6d1bfa05693ae2.png" alt="操作系统（四）——文件管理——隐式链接2.png"><p>还是上面的例子，假设现在要对这个文件进行拓展，由于这个文件的块可以是离散分配的，因此只需要从磁盘中随便找出一个空闲块，把它挂到文件的链尾即可。比如说给文件新分配一个8号块，如图，直接把8号块挂到链尾，然后操作系统还会修改这个文件的FCB的结束块号。</p><p>因此，可以看到采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高。</p><p>经过刚刚的分析，可以把隐式链接的内容总结如下：</p><img src="https://pic.imgdb.cn/item/66631a8c5e6d1bfa05695f40.png" alt="操作系统（四）——文件管理——隐式链接3.png"><p>接下来看显示链接的分配方式：</p><img src="https://pic.imgdb.cn/item/66631ac95e6d1bfa0569adc1.png" alt="操作系统（四）——文件管理——显示链接1.png"><p>显示链接分配会把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表。</p><p>磁盘当中的各个块的先后顺序都是统一记录在文件分配表当中的，所以一个磁盘有多少个块，在文件分配表里就会有多少个相应的表项。</p><p>假设此时有一个新创建的文件，文件名是aaa，它依次占用了2、5、0、1四个磁盘块。那么在aaa这个文件的FCB当中需要存放aaa的起始块号，如上图左上。另外在文件分配表里，会显示的记录文件aaa的几个物理块的链接关系，如上图中的FAT，作为文件结尾的块，它的下一块指针一般会用-1表示结束。同理，若有一个文件bbb，文件分配表里也会记录其物理块的链接关系。</p><p>从这里就可以看到，一个磁盘仅设置一张FAT，每个文件的盘块先后顺序都是统一的放到一张FAT里。另外，开机时，会将FAT读入内存，并常驻内存。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。</p><p>接下来看一下，采用这种方式如何实现文件的逻辑块号到物理块号的转变。</p><img src="https://pic.imgdb.cn/item/66631aec5e6d1bfa0569db8a.png" alt="操作系统（四）——文件管理——显示链接2.png"><p>一个用户如果给出要访问的逻辑块号i，操作系统会找到该文件对应的目录项。然后从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。由于FAT是常驻内存的，所以查询FAT的过程并不需要进行读磁盘操作，即逻辑块号转换成物理块号的过程不需要读磁盘操作。</p><p>经过上面的分析，我们可以得出这样的结论，采用显式链接方式的文件，支持顺序访问，也支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的0~i-1号逻辑块，可以直接通过FAT表查找到i号逻辑块存放的地址)，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p><p>另外，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。</p><p>最后，我们对链接分配这一节做出下面的总结：</p><img src="https://pic.imgdb.cn/item/66631b095e6d1bfa0569fefa.png" alt="操作系统（四）——文件管理——链接分配总结.png"><h3 id="3-4-索引分配"><a href="#3-4-索引分配" class="headerlink" title="3.4 索引分配"></a>3.4 索引分配</h3><img src="https://pic.imgdb.cn/item/66631f985e6d1bfa057034d6.png" alt="操作系统（四）——文件管理——索引分配1.png"><p>与链接分配一样，<strong>索引分配也允许文件离散地分配在各个磁盘块中</strong>，系统会为每个文件建立一张<strong>索引表</strong>，<strong>索引表中记录了文件的各个逻辑块对应的物理块</strong>（这里可以发现索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系）。</p><p>索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p><p>直接看一个例子，如上图，假设文件aaa的数据依次存放在2、5、13、9这几个磁盘块里。如果采用索引分配的方式，系统会为其建立一张索引表，索引表里记录了逻辑块号与物理块号的映射关系。如果aaa的索引表存放在7号磁盘块里，那么7号磁盘块就是aaa的索引块。而2、5、13、9这几个磁盘块就是aaa的数据块。</p><p>采用索引分配方式的文件，需要在自己的目录项，也就是FCB当中记录自动索引块到底是哪一块。索引块当中存放索引表，所以系统可以根据其索引块找到索引表，进而找到各个逻辑块对应的物理块。</p><p>到这里可以发现，在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张。</p><p>另外，可以用固定的长度表示物理块号，如假设磁盘总容量为1TB&#x3D;2<sup>40</sup>B，磁盘块大小为1KB，则总共有2<sup>30</sup>个磁盘块，则可用4B表示磁盘块号。经过上述分析，索引表中的“逻辑块号”可以是隐含的，因为索引表的每个表项都是4B，所以只要知道索引表的起始地址，就可以根据逻辑块号直接计算出其对应的表项在什么位置。</p><p>接下来考虑一下，采用索引分配的方式，如何实现逻辑块号到物理块号的转变。</p><img src="https://pic.imgdb.cn/item/66631ff85e6d1bfa0570adb3.png" alt="操作系统（四）——文件管理——索引分配2.png"><p>假设用户给出要访问的逻辑块号i，操作系统需要先找到该文件对应的目录项（FCB)。然后从中找到文件的索引块号，再从索引块里读出文件的索引表内容。接下来只需要根据逻辑块号查询索引表即可得到某一个逻辑块号对应的物理块号是多少。</p><p>从分析可以知道，如果想访问逻辑块号为i的块，并不需要从头访问，可以直接找到i号块对应的物理块号。因此<strong>索引分配方式支持随机访问</strong>。另外，如果需要对文件进行拓展，只需要给文件分配一个空闲块，并增加一个索引表项即可，所以<strong>索引分配方式也很容易实现文件拓展</strong>。</p><p>但是索引分配的索引表也会占用一定的存储空间，这是索引分配的缺点。</p><p>接下来考虑下一个问题，假设每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放256个索引项。如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？一般来说有三种方案，分别是：链接方案、多层索引、混合索引。</p><img src="https://pic.imgdb.cn/item/666320235e6d1bfa0570e7c9.png" alt="操作系统（四）——文件管理——索引分配3.png"><p>下面对链接方案、多层索引、混合索引分别进行介绍。</p><p><strong>(1) 链接方案</strong></p><p>链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p><img src="https://pic.imgdb.cn/item/6663efa15e6d1bfa05344e39.png" alt="操作系统（四）——文件管理——链接方案.png"><p>还是刚才的条件，假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。若一个文件大小超过256个块，那么这个文件的索引项也肯定超过256个。因此可以把这个索引表拆分。为这个文件分配多个索引块，每个索引块中存放256个索引项，并且在每个索引块当中用一定的存储空间存储指向下一个索引块的指针。这样就可以把一个很长的索引表拆分成不同部分，并且使用链接的方式将它们链接起来，如图。</p><p>如果采用链接方案，文件的FCB当中只需要记录它的第一个索引块的块号，如文件aaa只需要要记录它的第一个索引块号7。假设现在要访问的是文件aaa的逻辑块号为256号的逻辑块，为了查到256号逻辑块对应的物理块号，就需要找到aaa对应的第二个索引块。而由于各个索引块间是用链接方式连接起来，所以为了找到第二个索引块号，操作系统需要先把第一个索引块读入内存，然后才能根据第一个索引块当中的指针找到第二个索引块块号，并且把第二个索引块读入内存。只有这样才能找到256这个逻辑块号对应的物理块号是多少。</p><p>现在思考一个问题，若一个文件大小为256*256KB &#x3D;65536KB&#x3D; 64MB。该文件共有256*256个块，也就对应256*256个索引项，也就需要256个索引块来存储，这些索引块用链接方案连起来。若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块(第256个索引块)，而各个索引块之间是用指针链接起来的，因此必须先顺序地读入前255个索引块，显然这样是很低效的，那如何解决这个问题呢？</p><p>为此，就提出了多层索引的概念。</p><p><strong>(2) 多层索引</strong></p><p>多层索引：建立多层索引（原理类似于多级页表)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p><img src="https://pic.imgdb.cn/item/6663efe55e6d1bfa05349196.png" alt="操作系统（四）——文件管理——多层索引.png"><p>还是链接方案的例子，文件的大小是256*256个索引块的话，那么这个文件可以为其建立两层索引，第一层索引块总共有256个索引项，第二层索引块，每一块也有256个索引项，然后每一个索引项再指向某一个数据块。而在文件的FCB当中，只需要记录顶级索引表的存放索引块号。</p><p>若某文件采用两层索引，则该文件的最大长度可以到256*256*1KB&#x3D; 65536 KB &#x3D; 64MB。这时因为，**<font color=red>若采用多层索引，则各层索引表大小不能超过一个磁盘块</font>**，也就是说，第一级的索引表最多只有256个索引项，第二个级的索引表最多也只有256个索引项，所以文件大小最多64MB。注意这点很重要，因为考试时经常会遇到让计算文件最大长度的题。</p><p>接下来思考一下，如果采用多级索引，如何实现逻辑块号到物理块号的转变？</p><p>假设用户此时访问的是1026号逻辑块，则1026&#x2F;256&#x3D;4，也就是说1026号索引块对应的索引项应该是4号二级索引表当中存放的，而4号二级索引表的存放位置，操作系统只需要从一级索引表当中找到4号索引项对应的物理块即可。在读入4号二级索引表后，用1026%256&#x3D;2，说明此时应该查询的是4号二级索引表当中的2号表项，找到2号表项以后，就可以找到1026号逻辑块对应的物理块是多少。</p><p>综上，如果采用二级索引表，访问目标数据块，操作系统需要进行3次磁盘I&#x2F;O操作。第一次读入一级索引表，第二次读入二级索引表，第三次读入数据块。类似的，如果采用三级索引结构，则要进行4次磁盘I&#x2F;O操作。所以，我们可以得到这样一条结论：**<font color=red>采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作</font>**。与之前链接方案相比，这个方案已经少了很多读磁盘操作。</p><p>现在思考一下，假设一个文件很小，只有1KB，但是这个文件如果在物理上采用两层索引结构的话，那么读入这个1KB文件依然需要3次读磁盘操作。为了解决这个问题，人们又提出了混合索引。</p><p><strong>(3) 混合索引</strong></p><p>混合索引：多种索引分配方式相结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引（指向两层索引表)。</p><img src="https://pic.imgdb.cn/item/6663f0275e6d1bfa0534d33f.png" alt="操作系统（四）——文件管理——混合索引.png"><p>如上图的例子，包含8个直接地址索引，所谓直接地址索引就是这些索引项直接指向数据块，所以8个索引项直接指向8个数据块。另外，这个例子里还包含一级和二级间接索引，所谓一级间接索引就是指向一层索引表，这个索引表表项会指向数据块。二级间接索引就是指向两层索引表，上一层索引表表项会指向下一层索引表，下一层索引表会指向数据块。</p><p>接下来分析一下，如上图的例子，如果要访问某一个逻辑块需要几次读磁盘操作。</p><p>若<strong>顶级索引表还没读入内存</strong>，访问0<del>7号逻辑块需要两次读磁盘，访问8</del>263号逻辑块需要三次读磁盘，访问264~65799号逻辑块需要四次读磁盘。</p><p>所以可以看到，采用混合索引的一个好处就是，对于小文件来说，只需要较少的读磁盘次数就可以访问目标数据块。</p><p>下面对索引分配这部分进行一个知识汇总：</p><img src="https://pic.imgdb.cn/item/6663f0545e6d1bfa0534ff4d.png" alt="操作系统（四）——文件管理——索引分配小结.png"><h3 id="3-5-文件的物理结构小结"><a href="#3-5-文件的物理结构小结" class="headerlink" title="3.5 文件的物理结构小结"></a>3.5 文件的物理结构小结</h3><img src="https://pic.imgdb.cn/item/6663f0815e6d1bfa05352906.png" alt="操作系统（四）——文件管理——文件的物理结构小结.png"><p>另外，这里要补充一个知识点辨析，我们在学习文件物理结构时，发现里面有一个链接分配和文件逻辑结构里的链式存储很像，但又不知道他们之间的具体区别在哪。同样，我们在学习文件物理结构时，还会发现里面有一个索引分配和文件逻辑结构里的索引文件很像，但也不知道他们之间的具体区别在哪。所以接下来对这两点做一个辨析。</p><p><strong>(1) 链式存储和链接分配</strong></p><p>我们在说逻辑结构时，说到顺序文件可以采用链式存储的方式。在说物理结构时，又讲到了链接分配的方式，这两个东西看起来很像，但实际上并不一样。</p><p>文件的逻辑结构里说到的链式存储，指的是我们在文件内部的记录的先后顺序，是用链接指针把它们连接起来的，是由我们创建文件的用户自己设计的。而在文件的物理结构里提到的链接分配，这个链接是由操作系统做的。操作系统会把我们给出的一个很大的文件拆分成一个一个逻辑块，然后在磁盘里存放这些逻辑块时，操作系统会用链接的方式来记录他们之间的先后顺序。</p><p>这里可以自己再思考一下，我的感觉就像是我们用vs写一个学生信息表，里面的学信信息间的关系属于链式存储，是由我们自己定义的。而整个文件的存储是链接分配，是有操作系统决定的。</p><p><strong>(2) 索引文件和索引分配</strong></p><p>文件的逻辑结构里说到的索引文件，这里的索引表是由用户自己建立的，其中主要记录各个关键字到记录存放的逻辑地址之间的映射关系。而在文件的物理结构里提到的索引分配，这里的索引表是由操作系统建立的，用于实现逻辑块号到物理块号之间的映射关系。所以索引文件这种逻辑结构和索引分配这种物理结构很容易混淆，但它们之间其实完全是两个维度的东西。</p><p>这里再补充一个逻辑结构与物理结构的比较：</p><img src="https://pic.imgdb.cn/item/6664059b5e6d1bfa054df79c.png" alt="操作系统（四）——文件管理——文件的逻辑结构与物理结构的比较.png"><h2 id="4-文件目录"><a href="#4-文件目录" class="headerlink" title="4. 文件目录"></a>4. 文件目录</h2><h3 id="4-1-文件目录知识总览"><a href="#4-1-文件目录知识总览" class="headerlink" title="4.1 文件目录知识总览"></a>4.1 文件目录知识总览</h3><img src="https://pic.imgdb.cn/item/666464845e6d1bfa05b7917e.png" alt="操作系统（四）——文件管理——文件目录知识总览1.png"><p>在我们平时生活过程中对文件目录的使用是很频繁的，比如在Windows操作系统里，我们随便打开一个磁盘，里面就有很多的文件夹和文件目录，打开某一个文件夹以后，里面还有更深一层的目录。</p><p>那像这种一层一层的目录对用户来说有什么好处呢？很显然，通过这样的目录结构，可以很方便的找到想要找的文件，可以使整个文件的组织结构更加清晰，易于查找。</p><p>那从操作系统角度看，这些目录结构如何实现呢？这就是本节需要重点探讨的问题。</p><img src="https://pic.imgdb.cn/item/666466295e6d1bfa05b9623d.png" alt="操作系统（四）——文件管理——文件目录知识总览2.png"><p>所谓的文件目录就是Windows操作系统的文件夹，要实现文件目录的功能需要一个很关键的数据结构————文件控制块。所以接下来先看一下文件控制块的知识。</p><h3 id="4-2-文件控制块"><a href="#4-2-文件控制块" class="headerlink" title="4.2 文件控制块"></a>4.2 文件控制块</h3><img src="https://pic.imgdb.cn/item/666466d15e6d1bfa05ba1e4a.png" alt="操作系统（四）——文件管理——文件控制块1.png"><p>如图，打开电脑中的D盘根目录，会发现这个根目录下有一系列的文件夹和一些普通文件。那么对于这个D盘根目录来说，它对应的目录文件就应该是上图右的样子，其实就是用一个目录表来表示这个目录下面存放了哪些东西。在D盘当中的每一个文件、文件夹都会对应这个目录表当中的一个表项，所以这些一条一条的目录项本身就是一条一条的记录。</p><p>综上，目录本身就是一种有结构文件，由一条一条记录组成，每条记录对应一个放在该目录下的文件。</p><p>在上图的目录表当中，还可以看到，其里面标识了文件的文件名、类型等。另外，这里还需要注意一个很重要的信息，在这个表项当中记录了这个文件在外存当中存放的物理地址，所以，假如我们双击打开“照片”的时候，操作系统会在这个目录表中找到关键字“照片”对应的目录项（也就是记录），然后根据这个目录项当中记录的文件存放位置，从外存中将“照片”目录的信息读入内存，于是，“照片”目录中的内容就可以显示出来了。</p><p>打开照片这个目录后，会发现里面同样有一些文件，如下图：</p><img src="https://pic.imgdb.cn/item/66646e565e6d1bfa05c2f54c.png" alt="操作系统（四）——文件管理——文件控制块2.png"><p>同样的，照片这个目录对应的目录文件也是由一个一个目录项组成，每个目录项对应其中一个目录文件。</p><p>其实目录文件当中的一条记录就是一个文件控制块(FCB)，所以其实这些FCB的有序集合就是文件目录，而一个FCB就是一个文件目录项，很显然每一个文件都会对应一个FCB。</p><p>另外，从上图FCB的例子里也可以看到。FCB中包含了文件的基本信息(文件名、物理地址、逻辑结构、物理结构等)，存取控制信息(是否可读&#x2F;可写、禁止访问的用户名单等)，使用信息(如文件的建立时间、修改时间等)。不过，在这些信息里最重要的还是<strong>文件名和文件存放的物理地址</strong>这两个信息。因为FCB存在的一个最重要的作用，是实现文件名和文件之间的映射，即使用户（用户程序）可以实现“按名存取”，所以FCB必须建立起文件名到文件实际存放的物理地址之间的映射关系。</p><p>除了上述提到的信息以外，之前说过的文件各种各样的属性也可以存放到文件对应的FCB控制块中。</p><p>接下来看一下，我们需要对文件目录进行哪些操作：</p><img src="https://pic.imgdb.cn/item/666530ab5e6d1bfa0568a0e9.png" alt="操作系统（四）——文件管理——文件控制块的操作.png"><p>在操作系统发展过程中，出现了各种各样的目录结构。所以，接下来研究文件目录结构的内容。</p><h3 id="4-3-文件目录结构"><a href="#4-3-文件目录结构" class="headerlink" title="4.3 文件目录结构"></a>4.3 文件目录结构</h3><p><strong>(1) 单级目录结构</strong></p><img src="https://pic.imgdb.cn/item/666531775e6d1bfa05695df4.png" alt="操作系统（四）——文件管理——单级目录结构.png"><p>在操作系统发展过程中，最早出现的目录结构是单级目录结构。早期的操作系统只会在这个系统里建立一张目录表，每个文件会占用一个目录表的目录项。</p><p>单级目录结构支持按名存取，但是不允许文件重名。这是因为，各个目录项的关键字是文件名，如果出现了重名文件，比如出现两个文件名都是“a”的文件，如果告诉操作系统要按文件名a来存取文件时，操作系统就无法判断是哪个文件。</p><p>所以，在单级目录里，创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</p><p>如果这个计算机有很多用户的话，那显然不同用户的文件名是很容易重复的，因此**<font color=red>单级目录结构不适用于多用户操作系统</font>**。为了解决这个问题，人们提出了两级目录结构。</p><p><strong>(2) 两级目录结构</strong></p><img src="https://pic.imgdb.cn/item/666531c15e6d1bfa05699551.png" alt="操作系统（四）——文件管理——两级目录结构.png"><p>在两级目录结构里，会把目录分为两级。第一级为主文件目录，第二级为用户文件目录。</p><p>主文件目录记录用户名及相应用户文件目录的存放位置。而用户文件目录由该用户的文件对应的FCB组成。</p><p>由于不同的用户文件是存放在不同的用户文件目录下，所以允许不同用户的文件重名。文件名虽然相同，但是对应的其实是不同的文件。</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制，比如说上图的User1想要访问User2的用户文件目录，操作系统可以验证一下User1和User2这两个名字是否匹配，发现不匹配，就可以拒绝让User1访问。</p><p>但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类。为此人们又提出了多级目录结构，又叫树形目录结构。</p><p><strong>(3) 多级目录结构</strong></p><img src="https://pic.imgdb.cn/item/666532065e6d1bfa0569d517.png"><p>多级目录结构也是现在操作系统很常用的一个目录结构。每个目录下面可以有更低一级的目录，同时在各个目录下面也可以有一些普通文件，并且不同目录下的文件可以重名，但是文件名虽然相同，对应的其实是不同的文件。</p><p>如果采用多级目录结构，用户(或用户进程）要访问某个文件时要用文件路径名标识文件，操作系统才可以根据这个文件的路径名来找到这个文件。文件路径名是个字符串。各级目录之间用“&#x2F;”隔开。从根目录出发的路径称为<strong>绝对路径</strong>。</p><p>如果采用绝对路径，那每有一级都要经历一次读操盘的操作，如上图的例子。很多时候，用户会连续访问同一目录内的多个文件，如果每次都从根目录开始查找，是很低效的。所以可以设置一个当前目录，当用户想要访问某个文件时，可以使用从当前目录出发的<strong>相对路径</strong>。</p><p>下图给出了引入相对路径的例子：</p><img src="https://pic.imgdb.cn/item/6665323d5e6d1bfa056a0392.png" alt="操作系统（四）——文件管理——多级目录结构2.png"><p>可见，引入“当前目录”和“相对路径”后，磁盘I&#x2F;O的次数减少了。这就提升了访问文件的效率。</p><img src="https://pic.imgdb.cn/item/6665327d5e6d1bfa056a3d7f.png" alt="操作系统（四）——文件管理——多级目录结构3.png"><p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，**<font color=red>树形结构不便于实现文件的共享</font>**。为此，提出了“无环图目录结构”。</p><p><strong>(4) 无环图目录结构</strong></p><p>无环图目录结构和树形结构比较相似，只是在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个<strong>有向无环图</strong>。可以更方便地实现多个用户间的文件共享。如下图</p><img src="https://pic.imgdb.cn/item/666542ed5e6d1bfa057cc324.png" alt="操作系统（四）——文件管理——无环图目录结构1.png"><p>从上图例子里可以发现，可以用不同的文件名指向同一个文件（文件共享），甚至可以指向同一个目录（目录也是一个特殊的文件）。</p><p>但是引入了共享文件以后，删除就不能向以前一样，只要用户让把一个文件删除，就把这个文件的实际数据删除。因为这个文件可能是被多个用户使用的，所以需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。</p><p>如上图，如果删除User1的demo，操作系统只会把User1对应的demo目录项删除，并让共享计数器减1，而文件的实际内容并不会直接被删除。如下图：</p><img src="https://pic.imgdb.cn/item/666544365e6d1bfa057e1471.png" alt="操作系统（四）——文件管理——无环图目录结构.png"><p>当一个文件的共享计数器变为0时，才会把文件的实际数据删除。</p><p>另外，需要注意，共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</p><h3 id="4-4-索引结点"><a href="#4-4-索引结点" class="headerlink" title="4.4 索引结点"></a>4.4 索引结点</h3><img src="https://pic.imgdb.cn/item/666545095e6d1bfa058046f2.png" alt="操作系统（四）——文件管理——索引结点.png"><p>索引结点是对FCB这种数据结构的改进。通过前面的学习可以知道，由一系列FCB控制块组成了一个一个的文件目录。但是操作系统实际查找各级目录的过程中，只需要使用文件名这个信息就可以，而其它冗余的信息暂时不要。只有文件匹配时，才会去关心这个文件存放的物理位置。所以可以考虑让目录表简化，从而提升目录表的搜索效率。</p><p>由于按照文件名搜索目录时，并不需要关心除了文件名之外的其它信息，因此可以把其它的信息放到另外一个地方，也就是索引结点当中。除了文件名之外，像文件的类型，文件的存放物理位置等等这些信息，都可以放到文件对应的索引结点当中。</p><p>每一个文件都会有一个唯一的索引结点，而采用了索引结点这个机制之后，目录当中只包含文件名和指向索引结点的指针这两个信息。这样的话，这个目录表所占用的存储空间就会小很多。</p><p>接下来看一下，采用这种方式怎么加快查找效率：</p><p>假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640&#x2F;16&#x3D; 40个盘块。因此按照某文件名检索该目录，平均需要查询320个目录项，**<font color=red>平均需要启动磁盘20次（每次磁盘l&#x2F;O读入一块）</font>**。</p><p>若使用索引结点机制，假设文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要读入320&#x2F;64 &#x3D;5个磁盘块。显然，**<font color=red>这将大大提升文件检索速度</font>**。</p><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。</p><p>存放<strong>在外存中</strong>的索引结点称为**<font color=red>“磁盘索引结点”</font><strong>，当索引结点放入</strong>内存<strong>后称为</strong><font color=red>“内存索引结点”</font><strong>。相比之下</strong>内存索引结点中需要增加一些信息**，比如:文件是否被修改、此时有几个进程正在访问该文件等。</p><h3 id="4-5-文件目录小结"><a href="#4-5-文件目录小结" class="headerlink" title="4.5 文件目录小结"></a>4.5 文件目录小结</h3><img src="https://pic.imgdb.cn/item/666548555e6d1bfa0583f5e8.png" alt="操作系统（四）——文件管理——文件目录小结.png"><h2 id="5-文件存储空间管理"><a href="#5-文件存储空间管理" class="headerlink" title="5. 文件存储空间管理"></a>5. 文件存储空间管理</h2><p>在之前学习了文件的物理结构，也就是对非空闲磁盘块的管理，这部分学习对文件存储空间的管理，即空闲磁盘块的管理。</p><p>下面是本节知识总览：</p><img src="https://pic.imgdb.cn/item/666553145e6d1bfa05907b38.png" alt="操作系统（四）——文件管理——文件存储空间管理.png"><p>首先看一下存储空间的划分与初始化。</p><h3 id="5-1-存储空间的划分与初始化"><a href="#5-1-存储空间的划分与初始化" class="headerlink" title="5.1 存储空间的划分与初始化"></a>5.1 存储空间的划分与初始化</h3><img src="https://pic.imgdb.cn/item/666554e65e6d1bfa0592773c.png" alt="操作系统（四）——文件管理——文件存储空间的划分与初始化.png"><p>在我们安装Windows系统时，有一个必经的步骤是为磁盘分区，也就是我们平时熟悉的C盘、D盘等。这些所谓的C盘、D盘就是文件卷或者叫逻辑卷、逻辑盘。我们的一些文件就是存放在这些文件卷里。</p><p>另外，在存储空间初始化过程当中，也需要把这些文件卷进一步划分，划分为目录区和文件区。其中目录区主要用于存放文件目录信息(FCB)、用于磁盘存储空间管理的信息。而文件区用于存放文件数据。所以这就是文件区与目录区的区别。</p><p>在有的系统支持超大型文件的操作系统当中，也可支持由多个物理磁盘组成一个文件卷。平时我们自己使用的电脑是把一个物理磁盘划分为多个逻辑磁盘，但是有的操作系统当中可以把多个物理磁盘合并成一个逻辑磁盘。</p><h3 id="5-2-文件存储空间的管理方法"><a href="#5-2-文件存储空间的管理方法" class="headerlink" title="5.2 文件存储空间的管理方法"></a>5.2 文件存储空间的管理方法</h3><h4 id="5-2-1-空闲表法"><a href="#5-2-1-空闲表法" class="headerlink" title="5.2.1 空闲表法"></a>5.2.1 空闲表法</h4><img src="https://pic.imgdb.cn/item/666555915e6d1bfa05933331.png" alt="操作系统（四）——文件管理——文件存储空间管理——空闲表法.png"><p>如上图左，是一个系统目前的情况，绿色的是空闲块，橙色的是非空闲块。如果使用空闲表法，此时磁盘对应的空闲表应该如上图右的样子。这个空闲表与第三章内存管理里的动态分区分配里学习过的空闲表十分类似，都记录了空闲区间的起始位置和空闲区间的长度。</p><p>举个例子，像第一个空闲区间是0,1这两个连续的空闲块，所以这个空闲区间对应的是第一个表项，第一个空闲盘块号是0，空闲盘块数是2。</p><p><strong><font color=blue>空闲表法一般来说适用于文件的物理结构是连续分配的场景。</font></strong></p><p>接下来探讨一下采用这种方法该如何分配磁盘块：这里和内存管理的动态分配很类似，为一个文件分配连续的存储空间，同样可采用动态分区分配的算法——首次适用、最佳适应、最坏适应等。这里可以参考第三章的动态分配分配算法内容，这里就不再重复一遍了，<strong>但是要注意，分配完以后，要更新空闲盘块表。</strong></p><p>同样，回收磁盘块时的操作也和第三章动态分区分配的回收一样，都要讨论四种情况，这里也参考第三章动态分区分配的回收方法，这里不再重复。但是也要注意，<strong>回收完以后要对空闲盘块表进行更新</strong>。</p><h4 id="5-2-2-空闲链表法"><a href="#5-2-2-空闲链表法" class="headerlink" title="5.2.2 空闲链表法"></a>5.2.2 空闲链表法</h4><img src="https://pic.imgdb.cn/item/666574e15e6d1bfa05b685e7.png" alt="操作系统（四）——文件管理——文件存储空间管理——空闲链表法.png"><p>空闲链表发又可以进一步划分为空闲盘块链和空闲盘区链。</p><p>它们的区别在于空闲盘块链是以盘块为单位组成一条空闲链，如上图左，每一个空闲盘块中存储着下一个空闲盘块的指针。</p><p>而空闲盘区链是以盘区为单位组成一条空闲链，所谓盘区就是一些连续的空闲盘块可以组成一个盘区，如上图右，每一个空闲盘区中第一个盘块内记录了盘区的长度和下一个空闲盘区的指针。</p><p>接下来看一下，采用这两种方式，对磁盘块的分配与回收有什么区别。</p><p>首先看一下空闲盘块链：</p><img src="https://pic.imgdb.cn/item/6665765c5e6d1bfa05b7d48b.png" alt="操作系统（四）——文件管理——文件存储空间管理——空闲盘块链的分配与回收.png"><p>如果采用空闲盘块链，首先系统会保存着链头、链尾的指针。</p><p>若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针，如上图，上图绿色为空闲盘块，橙色为被占用磁盘块。</p><p>回收的时候，回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</p><p>从分配与回收的过程可以看到，这种方式一般适用于离散分配的物理结构。</p><p>由于分配时要从链头摘下一个一个磁盘块，所以为文件分配多个盘块时可能要重复多次操作。</p><p>接下来看一下空闲盘区链：</p><img src="https://pic.imgdb.cn/item/666576955e6d1bfa05b8085c.png" alt="操作系统（四）——文件管理——文件存储空间管理——空闲盘区链的分配与回收.png"><p>与空闲盘块链相同，如果采用空闲盘区链，首先系统会保存着链头、链尾的指针。</p><p>在进行分配时，若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</p><p>回收时，若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p><p>从分配与回收的过程可以看到，这种方式既适用于离散分配，也适用于连续分配。并且比起空闲盘块链来说，它给一个文件分配多个盘块时，效率更高，因为盘块链只能从链当中一个一个把空闲磁盘块摘下来，而盘区链可以一次摘取一片空闲连续区间。</p><h4 id="5-2-3-位示图法"><a href="#5-2-3-位示图法" class="headerlink" title="5.2.3 位示图法"></a>5.2.3 位示图法</h4><img src="https://pic.imgdb.cn/item/666576e85e6d1bfa05b84fef.png" alt="操作系统（四）——文件管理——文件存储空间管理——位示图法.png"><p>位示图法：就是一个一个的二进制位，来分别对应各个盘块的是否已分配的信息。</p><p>如上图的例子，用“0”代表盘块空闲，用“1”代表盘块已分配。如果上图左的磁盘里，绿色表示空闲块，橙色表示不空闲块，那前4个块对应的就是0101，与上图右上的表开始的4个是对应的。这就是位示图法的原理，并不难理解。</p><p>一般来说，位示图的数据在系统当中存储时，都会存储成一系列连续的“字”。比如上图的例子，一个字的字长是16位，也就是一行16位，那每个字就由16个二进制位组成，因此可以用如图的字号和位号这样的二元组，来定位到其中的某一个二进制位。</p><p><strong>考试时经常考的就是如何通过字号和位号来推测出对应的盘块号，或者如何通过盘块号来逆推出对应的字号和位号，这类题目要重点掌握。另外做题时要注意题目条件中，盘块号、字号、位号到底是从0开始还是从1开始。</strong></p><p>如上图的例子，盘块号、字号、位号到底是从0开始，如果说用n表示字长，那字号i和位号j转换成对应盘块号b的公式就可以写成：<strong>b&#x3D;ni+j</strong>。从盘块号逆推字号：<strong>i&#x3D;b&#x2F;n</strong>。从盘块号逆推出位号：<strong>j&#x3D;b%n</strong>。（注意，这里几个公式是基于盘块号、字号、位号到底是从0开始的前提，考试时要能根据题目自己写出转换关系。）</p><p>接下来考虑一下，采用位示图法，怎么进行磁盘块的分配与回收：</p><img src="https://pic.imgdb.cn/item/6665770e5e6d1bfa05b878e8.png" alt="操作系统（四）——文件管理——文件存储空间管理——位示图法的分配与回收.png"><p>在进行分配时，若文件需要K个块，①顺序扫描位示图，找到K个相邻或不相邻的“O”；②根据字号、位号算出对应的盘块号，将相应盘块分配给文件；③将相应位设置为“1”。</p><p>回收时，①根据回收的盘块号计算出对应的字号、位号；②将相应二进制位设为“0”。</p><h4 id="5-2-4-成组链接法"><a href="#5-2-4-成组链接法" class="headerlink" title="5.2.4 成组链接法"></a>5.2.4 成组链接法</h4><img src="https://pic.imgdb.cn/item/6665a72b5e6d1bfa05eac069.png" alt="操作系统（四）——文件管理——文件存储空间管理——成组链接法.png"><p>之前说的空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。所以UNIX系统中采用了<strong>成组链接法</strong>对磁盘空闲块进行管理。</p><p><strong>文件卷的目录区</strong>中专门用一个磁盘块作为**<font color=red>“超级块”</font>**，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致。</p><p>接下来看一下超级块有什么作用：</p><img src="https://pic.imgdb.cn/item/6665a8055e6d1bfa05ebf237.png" alt="操作系统（四）——文件管理——文件存储空间管理——成组链接法1.png"><p>在超级块中记录了下一组空闲盘块的数量，比如上图例子，下一组总共有100个空闲盘块，另外超级块还需要记住这100个空闲盘块的盘块号。通过这些盘块号，就可以依次找到下一个分组的各个盘块。如上图，通过超级块可以找到第一个空闲盘块的分组，总共有100个，分别是201~300号。</p><p>300号磁盘块作为分组的第一个磁盘块，其中还需要记录下一组空闲盘块的信息，如上图，300号磁盘块里的100表示下一个空闲盘块的分组总共有100个空闲盘块。其中的数字，代表下一个空闲盘块的分组的各个磁盘号，通过这些盘块号，又可以找到再下一个分组的盘块分别是哪些。</p><p>同样与之前类似，由300号磁盘块得到的下一个分组里，400号磁盘块作为分组的第一个磁盘块，其中也需要记录下一分组的空闲盘块的数量和盘块号，通过这种方式就可以把整个系统当中所有的空闲盘块给一一连起来。</p><p>再倒数第二个分组的第一个盘块处，可以最后的位置设置一个-1，如上图，这就代表再下一个分组已经是最后一个分组。所以找到值为-1的节点，就证明之后已经没有更多的分组。</p><p>另外，需要注意的是，一个分组中的块号不需要连续，上图只是为了让大家更方便看出各个分组的数量才连续显示的。另外一个要注意的是，最后一个分组的盘块数是要比其它的分组要少的，原因就出在要用一个-1来表示结束。</p><p>接下来看一下，这种方法如何进行磁盘块的分配：</p><img src="https://pic.imgdb.cn/item/6665aece5e6d1bfa05f426d1.png" alt="操作系统（四）——文件管理——文件存储空间管理——成组链接法分配1.png"><p>假设此时某个文件需要分配1个空闲块，首先是需要检查第一个分组的盘块到底够不够这个文件的需求。由于超级块此时已经读入内存（超级块在系统启动时读入内存），所以在进行这个检查的时候，并不需要进行读磁盘的操作，只需要找到内存当中的超级块数据，并且检查一下下一组的空闲盘块数是否大于此时要求得到的空闲盘块数。</p><p>由于此时1&lt;100，说明第一个分组的空闲磁盘块数量是够分配的，接下来就会把这个分组当中的最后的磁盘块（即201号磁盘块）分配给这个文件。在该盘块分配出去以后，需要在超级块里把该块的数据删除，并且把下一分组的空闲盘块数减1，这样就完成了分配一个空闲块的任务。</p><p>下图是分配一个空闲块以后的结果：</p><img src="https://pic.imgdb.cn/item/6665af9b5e6d1bfa05f52384.png" alt="操作系统（四）——文件管理——文件存储空间管理——成组链接法分配2.png"><p>如果现在有一个文件需要分配100个分组该如何分配：</p><img src="https://pic.imgdb.cn/item/6665afe75e6d1bfa05f581cf.png" alt="操作系统（四）——文件管理——文件存储空间管理——成组链接法分配3.png"><p>如上图，首先依然检查第一个分组的块数是否足够。由100&#x3D;100可以确定是足够的。因此接下来会把第一个分组的磁盘块全部分配出去，但要注意的是300号磁盘块存储了再下一个分组的磁盘块信息，因此如果把300号磁盘块直接分配出去却不做任何处理的话，那和下一组的链接信息就断掉了。因此，在把300号磁盘块正式分配给文件之前，需要把300号磁盘块当中的数据复制到超级块里，这样就可以保证虽然这个分组已经全部分配给文件，但是下一个分组的链接信息依然保存在超级块当中。</p><p>如果文件需要更多的磁盘块，依然可以用同样的方式把这些分组一个一个的全部分配出去。但一定要注意，分组分配出去之前，要先把分组当中指向下一个分组的链接信息保存到超级块当中。所以超级块就充当一个链头的作用，在这个链头当中要永远保持指向下一个分组的链接信息。</p><p>接下来看一下怎么回收一个空闲磁盘块：</p><img src="https://pic.imgdb.cn/item/6665b1e65e6d1bfa05f85093.png" alt="操作系统（四）——文件管理——文件存储空间管理——成组链接法回收1.png"><p>假设每个分组的磁盘块上限是100块，而第一个分组此时只有99块，如上图。此时要回收一个空闲块，由于第一个分组没有满，所以可以把这个空闲块插入到第一个分组当中。比如说回收的是201号块，那么就可以把201号块插入到分组当中，并且把超级块当中的下一组空闲盘块数从99+1变成100，如下图。</p><img src="https://pic.imgdb.cn/item/6665b2345e6d1bfa05f8ce5e.png" alt="操作系统（四）——文件管理——文件存储空间管理——成组链接法回收2.png"><p>上面是第一种情况，分组没有满。现在看第二个情况，如果分组已经满了，该怎么回收：</p><img src="https://pic.imgdb.cn/item/6665b2805e6d1bfa05f941e9.png" alt="操作系统（四）——文件管理——文件存储空间管理——成组链接法回收3.png"><p>如上图，分组已经满了，此时还要再回收一个块，显然无法放到分组里，所以可以把这个新回收的空闲块作为一个新的分组，不过需要注意的是，需要把超级块当中的内容复制到新回收的块里，这样的话，新回收的块作为一个新的分组，就拥有了指向下一个分组的链接的指针。</p><p>而超级块要永远指向第一个分组，所以超级块的数据就要进行修改，让他指向第一个分组，即新的回收块组成的分组。由于新分组中此时只有一个空闲块，所以超级块里的数据为1，指向的块号为300。如下图。</p><img src="https://pic.imgdb.cn/item/6665b3b05e6d1bfa05fac8fa.png" alt="操作系统（四）——文件管理——文件存储空间管理——成组链接法回收4.png"><h3 id="5-3-文件的存储空间管理小结"><a href="#5-3-文件的存储空间管理小结" class="headerlink" title="5.3 文件的存储空间管理小结"></a>5.3 文件的存储空间管理小结</h3><img src="https://pic.imgdb.cn/item/6665b3fd5e6d1bfa05fb2754.png" alt="操作系统（四）——文件管理——文件存储空间管理小结.png"><h2 id="6-文件的基本操作"><a href="#6-文件的基本操作" class="headerlink" title="6. 文件的基本操作"></a>6. 文件的基本操作</h2><p>本节将要学的文件的基本操作如下：</p><img src="https://pic.imgdb.cn/item/666666215e6d1bfa0596e436.png" alt="操作系统（四）——文件管理——文件的基本操作.png"><h3 id="6-1-创建文件"><a href="#6-1-创建文件" class="headerlink" title="6.1 创建文件"></a>6.1 创建文件</h3><img src="https://pic.imgdb.cn/item/666666785e6d1bfa0597443a.png" alt="操作系统（四）——文件管理——文件的基本操作——创建文件.png"><p>在我们创建文件时，背后的操作是调用了操作系统的create系统调用。</p><p>进行create系统调用时，需要提供的几个主要参数：</p><ol><li>所需的外存空间大小</li><li>文件存放路径</li><li>文件名</li></ol><p>操作系统在处理Create系统调用时，主要做了两件事：</p><ol><li>在外存中找到文件所需的空间</li><li>根据文件存放路径的信息找到该目录对应的目录文件，在目录文件中创建该文件对应的目录项。</li></ol><h3 id="6-2-删除文件"><a href="#6-2-删除文件" class="headerlink" title="6.2 删除文件"></a>6.2 删除文件</h3><img src="https://pic.imgdb.cn/item/666666b65e6d1bfa0597845e.png" alt="操作系统（四）——文件管理——文件的基本操作——删除文件.png"><p>在我们删除文件时，背后的操作是调用了操作系统的delete系统调用。</p><p>进行delete系统调用时，需要提供的几个主要参数：</p><ol><li>文件存放路径</li><li>文件名</li></ol><p>操作系统在处理delete系统调用时，主要做了三件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。</li><li>从目录表中删除文件对应的目录项。</li></ol><h3 id="6-3-打开文件"><a href="#6-3-打开文件" class="headerlink" title="6.3 打开文件"></a>6.3 打开文件</h3><img src="https://pic.imgdb.cn/item/666666eb5e6d1bfa0597b844.png" alt="操作系统（四）——文件管理——文件的基本操作——打开文件1.png"><p>在很多操作系统中，在对文件进行操作之前，都要求用户先使用open系统调用“打开文件”。</p><p>在打开文件时，需要提供的几个主要参数：</p><ol><li>文件存放路径</li><li>文件名</li><li>要对文件的操作类型（如只读r等）</li></ol><p>操作系统在处理open系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。如上图的例子就是找到了Demo文件对应的目录表。另外用户对文件的访问权限信息也是记录在目录项中，所以可以根据目录项来检查此时用户请求的操作是否合法。</li><li>若用户有操作权限，则将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。这样之后操作文件就不需要每次都重新查目录，可以加快文件的访问速度。</li></ol><p>另外要注意的是有两种打开文件表，一种是系统的打开文件表，整个系统只有一张；一种是进程的打开文件表，如下图：</p><img src="https://pic.imgdb.cn/item/666667715e6d1bfa059836c5.png" alt="操作系统（四）——文件管理——文件的基本操作——打开文件2.png"><p>系统的打开文件表会记录所有的正在被其他进程使用的文件的信息。</p><p>进程的打开文件表会记录记录了自己的进程已经打开的文件是哪些。</p><p>在进程的打开文件当中有系统表的索引号，比如上图的test.txt文件，在系统表当中编号是k的表项。同样的，如果另一个进程B也打开了test.txt这个文件，那它也会指向同一个系统打开表的表项。</p><p>这里需要注意的是，在系统的打开表里有一个字段叫打开计数器，用来记录这个文件此时已经被几个进程给打开了。此时如果有两个进程打开了这个文件，那打开计数器就应该修改为2。</p><p>打开计数器这个字段是系统的打开表特有的字段，在整个系统当中设置一个打开文件表的总表，这样的方式是比较方便实现某些文件管理的功能的。例如：在Windows系统中，我们尝试删除某个txt文件，如果此时该文件已被某个“记事本”进程打开，则系统会提示我们“暂时无法删除该文件”。其实系统在背后做的事就是先检查了系统打开文件表，确认此时是否有进程正在使用该文件。</p><p>另外在进程的打开文件表里有两个特殊的字段，一是叫读写指针，它记录了这个进程对文件的读写操作进行到了什么位置。二是叫访问权限，注明了该进程可以对该文件进行什么样的操作。</p><h3 id="6-4-关闭文件"><a href="#6-4-关闭文件" class="headerlink" title="6.4 关闭文件"></a>6.4 关闭文件</h3><img src="https://pic.imgdb.cn/item/666667c55e6d1bfa05988a49.png" alt="操作系统（四）——文件管理——文件的基本操作——关闭文件1.png"><p>当一个用户使用完文件，选择关闭文件时，主要做了几件事：</p><ol><li>将进程的打开文件表相应表项删除。</li><li>回收分配给该文件的内存空间等资源。</li><li>系统打开文件表的打开计数器count 减1，若count &#x3D;0，则删除对应表项。</li></ol><p>上图的关闭文件的结果如下图所示：</p><img src="https://pic.imgdb.cn/item/666667e95e6d1bfa0598b3b6.png" alt="操作系统（四）——文件管理——文件的基本操作——关闭文件2.png"><h3 id="6-5-读文件"><a href="#6-5-读文件" class="headerlink" title="6.5 读文件"></a>6.5 读文件</h3><img src="https://pic.imgdb.cn/item/666668165e6d1bfa0598e35d.png" alt="操作系统（四）——文件管理——文件的基本操作——读文件.png"><p>如上图的例子，在双击打开test.txt这个文档时，在背后是调用了操作系统提供的read系统调用，也就是读文件的功能。但通过前面的学习可以知道，在进行读文件之前是要先打开文件的，所以在正式读文件的时候，记事本这个进程的打开文件表当中，已经有了这个文件对应的一个表项，因此记事本这个进程在读文件时只需要指明，自己要读的文件对应的打开文件表的编号到底是多少。这是读文件时需要提供的第一个参数，就是要指明读的是哪一个文件。</p><p>第二个在读文件时还要指明此时要读入的是多少个数据，比如要把上图的txt文件内容全部读入内存，就要指明读入1KB。另外还需要指明读入数据要放在内存的什么位置。这些参数的填充，都是记事本这个进程在背后自己完成的。</p><p>操作系统在处理read系统调用时，会根据打开文件表当中的读写指针读指针指向的外存地址，将用户指定大小的数据读入用户指定的内存区域中。</p><h3 id="6-6-写文件"><a href="#6-6-写文件" class="headerlink" title="6.6 写文件"></a>6.6 写文件</h3><img src="https://pic.imgdb.cn/item/6666683d5e6d1bfa05990dc8.png" alt="操作系统（四）——文件管理——文件的基本操作——写文件.png"><p>如上图，在编辑完一个文本文档以后，可以点击文件保存这样一个功能。点击保存之后，记事本这个应用程序在背后调用了操作系统提供的write系统调用，将文件数据从内存写回外存。</p><p>所以在write系统调用时，也需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可)，还需要指明要写出多少数据（如：写出1KB)、写回外存的数据放在内存中的什么位置。</p><p>操作系统根据write系统调用的参数，会从用户指定的内存区域当中，读出指定大小的数据，然后写回写指针所指向的外存区域当中。</p><h3 id="6-7-文件的基本操作小结"><a href="#6-7-文件的基本操作小结" class="headerlink" title="6.7 文件的基本操作小结"></a>6.7 文件的基本操作小结</h3><img src="https://pic.imgdb.cn/item/6666685e5e6d1bfa05993000.png" alt="操作系统（四）——文件管理——文件的基本操作小结.png"><h2 id="7-文件共享"><a href="#7-文件共享" class="headerlink" title="7. 文件共享"></a>7. 文件共享</h2><img src="https://pic.imgdb.cn/item/6666859b5e6d1bfa05b86dd5.png" alt="操作系统（四）——文件管理——文件共享知识总览.png"><p>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件。</p><p>文件共享实现的方式有两种，一种是基于索引结点的共享方式，又叫硬链接方式。另一种是基于符号链的共享方式，又叫软链接方式。</p><p>注意：多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</p><p>与共享容易混淆的是复制的概念，如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据。其中一个用户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</p><p>接下来看一下实现文件共享的两种方式。</p><h3 id="7-1-硬链接"><a href="#7-1-硬链接" class="headerlink" title="7.1 硬链接"></a>7.1 硬链接</h3><p>先复习一下索引结点的概念，索引结点是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p><img src="https://pic.imgdb.cn/item/666691805e6d1bfa05d3b0cb.png" alt="操作系统（四）——文件管理——文件共享硬链接1.png"><p>如上图，假设一个用户User1创建了一个新文件叫aaa，那么这个文件会对应一个索引结点，并且这个索引结点里会包含这个文件的物理地址和其它的相关属性。</p><p>另外，索引结点中会设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数。如下图，假设此时有第二个用户想共享的使用这个文件，那么这个用户的目录当中也会有一个目录项是指向这个文件的索引结点的，由于此时是有两个目录项指向该索引结点，所以count&#x3D;2。若count &#x3D; 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。</p><img src="https://pic.imgdb.cn/item/666692055e6d1bfa05d6a89a.png" alt="操作系统（四）——文件管理——文件共享硬链接2.png"><p>从该例中还可以发现，不同用户对这个文件起的名字可以是不同的，在用户1目录下，该文件名叫aaa，而在用户2目录下，该文件名叫bbb。</p><p>如果采用这种共享方式，在删除文件时要注意一些小细节：</p><img src="https://pic.imgdb.cn/item/666692d35e6d1bfa05daa09a.png" alt="操作系统（四）——文件管理——文件共享硬链接3.png"><p>若某个用户决定“删除”该文件，则系统只是把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。若count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。除非count&#x3D;0时，文件和其索引结点才会真正的从系统当中删除。</p><h3 id="7-2-软链接"><a href="#7-2-软链接" class="headerlink" title="7.2 软链接"></a>7.2 软链接</h3><img src="https://pic.imgdb.cn/item/666693365e6d1bfa05dc6fcf.png" alt="操作系统（四）——文件管理——文件共享软链接1.png"><p>如上图，假设系统当中有两个用户User1和User2正在使用硬链接的方式共享的使用文件1，而另一个用户User3想要使用软链接的方式来共享文件1，那么User3会建立一个新的文件，这个文件是一种特殊的Link型文件。</p><p>Link文件里记录了文件1的存放路径，这种Link型文件有点类似于Windows系统里的快捷方式。当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。</p><p>所以采用软链接的共享方式，并不是把自己的目录项直接指向这个文件的索引结点，而是创建了一个新的Link型文件，然后Link型文件里记录了这个文件的存放路径，之后操作系统会根据这个路径，来找到想要共享的文件。</p><p>接下来看一下，采用软链接的工作方式，删除一个文件，会不会对软链接造成影响：</p><img src="https://pic.imgdb.cn/item/666694d55e6d1bfa05e16ed1.png" alt="操作系统（四）——文件管理——文件共享软链接2.png"><p>假设User1和User2都不需要再使用文件1，此时count值为0，因此这个文件和其索引结点都会被删除，那此时如果User3访问ccc这个Link型文件，同样的操作系统会首先检查c盘下的User1这个目录，然后从中尝试找到aaa这个文件对应的目录项，但是由于此时aaa这个目录项已经被删除，所以通过这个路径已经找不到文件1，因此这个软链接就失效了。</p><h3 id="7-3-文件共享小结"><a href="#7-3-文件共享小结" class="headerlink" title="7.3 文件共享小结"></a>7.3 文件共享小结</h3><img src="https://pic.imgdb.cn/item/6666958e5e6d1bfa05e22af0.png" alt="操作系统（四）——文件管理——文件共享小结.png"><h2 id="8-文件保护"><a href="#8-文件保护" class="headerlink" title="8. 文件保护"></a>8. 文件保护</h2><p>文件保护就是保护文件数据的安全，一般来说有三种方法：口令保护、加密保护、访问控制。下面依次看这三种算法。</p><h3 id="8-1-口令保护"><a href="#8-1-口令保护" class="headerlink" title="8.1 口令保护"></a>8.1 口令保护</h3><img src="https://pic.imgdb.cn/item/666696035e6d1bfa05e2a15b.png" alt="操作系统（四）——文件管理——文件保护——口令保护.png"><p>口令保护，就是用户请求访问某个文件时，必须提供“口令”。</p><p>比如一个用户为自己的文件设置了一个口令，这个口令是“abc112233”，那其它的用户想要访问这个文件时，就必须提供相同的口令，操作系统会负责验证这个用户提供的口令是否正确，一般来说，正确的口令是存放在与文件相对应的FCB或索引结点当中的，所以操作系统会从FCB当中读出正确的口令，并且和用户提供的口令进行对比，如果这个口令正确，那么就允许这个用户访问文件。</p><p>这种保护口令的优点就是保存口令的空间开销不多，验证口令的时间开销也很小。但缺点在于，这个正确的口令是存放在系统内部的，所以如果有人入侵系统，并且知道了正确的口令，那这个人就可以畅通无阻的访问这个文件，所以口令存在系统内部是不安去的。</p><h3 id="8-2-加密保护"><a href="#8-2-加密保护" class="headerlink" title="8.2 加密保护"></a>8.2 加密保护</h3><img src="https://pic.imgdb.cn/item/666696305e6d1bfa05e2cfe1.png" alt="操作系统（四）——文件管理——文件保护——加密保护.png"><p>加密保护，就是使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。</p><p>如上图是异或加密的例子，可以看到，如果解密密码不正确，那么看到的结果就不是原始数据。因此，一个用户如果不知道正确的解密密码，是无法正常访问文件数据的。</p><p>加密保护的优点是保密性强，并且不需要在系统中存储”密码”。但缺点也很明显，就是加密&#x2F;解密要花费一定时间。</p><h3 id="8-3-访问控制"><a href="#8-3-访问控制" class="headerlink" title="8.3 访问控制"></a>8.3 访问控制</h3><img src="https://pic.imgdb.cn/item/6666965e5e6d1bfa05e41421.png" alt="操作系统（四）——文件管理——文件保护——访问控制1.png"><p>访问控制就是在每个文件的FCB(或索引结点）中增加一个访问控制列表，该表中记录了各个用户可以对该文件执行哪些操作。</p><p>上图给出了某文件的访问控制列表，其中1表示允许，0表示拒绝，根据这个访问控制表，可以看到各个用户能对该文件进行的操作有哪些。所以在这个系统当中的某个用户，在请求访问某个文件的时候，操作系统就可以查看一下这个文件的访问控制表，检查一下这个用户是否拥有对文件进行某种操作的权限，如果没有权限，就可以拒绝访问。</p><p>在上面的例子当中，是以每个用户为单位，来标识每个用户对某个文件的操作的权限。但是有的计算机可能会有很多个用户，因此访问控制列表可能会很大，这时候可以用精简的访问列表解决这个问题</p><img src="https://pic.imgdb.cn/item/666696835e6d1bfa05e4843f.png" alt="操作系统（四）——文件管理——文件保护——访问控制2.png"><p>所谓精简的访问列表，就是以“组”为单位，标记各“组”用户可以对文件执行哪些操作。</p><p>如上图，分为系统管理员、文件主、文件主的伙伴、其他用户这几个分组。而每个用户从属于其中一个或两个分组。当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。所以操做系统也需要管理这些用户分组的信息，需要记录每个用户属于哪个分组。精简的访问列表也可以表示成上图的样子。若想要让某个用户能够读取文件，只需要把该用户放入“文件主的伙伴”分组即可。</p><h3 id="8-4-文件保护小结"><a href="#8-4-文件保护小结" class="headerlink" title="8.4 文件保护小结"></a>8.4 文件保护小结</h3><img src="https://pic.imgdb.cn/item/666696a55e6d1bfa05e4a835.png" alt="操作系统（四）——文件管理——文件保护小结.png"><h2 id="9-文件系统的层次结构"><a href="#9-文件系统的层次结构" class="headerlink" title="9. 文件系统的层次结构"></a>9. 文件系统的层次结构</h2><img src="https://pic.imgdb.cn/item/66669b955e6d1bfa05ea401b.png" alt="操作系统（四）——文件管理——文件系统的层次结构.png"><p>如山图，是文件系统的层次结构。</p><p>最上面一层是用户接口，它是最接近用户&#x2F;应用程序的一个层次，因此它的主要功能就是向上层的用户提供一些简单易用的功能接口。并用于处理用户发出的系统调用请求。</p><p>一般来说，用户在访问一个文件时，都是先提供一个文件的路径，所以，文件目录系统这个层次，就需要通过用户提供的路径，来一层一层的找到文件对应的FCB或索引结点（也就是完成一些查询目录等一系列的操作）。所有和目录、目录项相关的管理工作都在本层完成，如：管理活跃的文件目录表、管理打开文件表等。</p><p>文件目录系统找到对应的FCB以后，并不可以直接访问文件。为了保证文件数据的安全，还需要验证用户是否有访问权限。所以存取控制块这一层主要完成了文件保护相关功能。</p><p>在确定了用户对文件的访问权限以后，接下来的逻辑文件系统与文件信息缓冲区这一层次，会负责把用户提供的文件记录号转换成这个记录存放的逻辑地址。在这里有一个文件信息缓冲区，在我们之前学习文件逻辑结构时，有一个逻辑结构叫做索引文件，如果采用的是索引文件的逻辑结构，会为文件当中的各个记录建立一个索引表，那么为了查询到这些记录对应的逻辑地址，就需要查询索引表，而在查询文件的索引表之前，就需要先把索引表调入内存的文件信息缓冲区。</p><p>当找到记录对应的逻辑地址之后，物理文件系统一层会把逻辑地址转换为实际的物理地址。</p><p>如果此时是往文件里添加或删除一些记录的话，显然就有可能需要为这个文件新分配一些物理块或回收一些物理块，这是辅助分配模块所需要做的事情，也就是负责文件存储空间的管理，即负责分配和回收存储空间。</p><p>在之前提到的所有的准备，最后都是为了来操作外存或者说磁盘上的一些数据，所以最后需要由设备管理模块，来负责和设备进行直接交互。因此设备管理模块，也是最接近硬件的一个层次。</p><p>下面用一个例子来辅助理解各层的功能：</p><img src="https://pic.imgdb.cn/item/66669bb15e6d1bfa05ea5cb3.png" alt="操作系统（四）——文件管理——文件系统的层次结构例子.png"><h2 id="10-文件系统的全局结构（布局）"><a href="#10-文件系统的全局结构（布局）" class="headerlink" title="10. 文件系统的全局结构（布局）"></a>10. 文件系统的全局结构（布局）</h2><h3 id="10-1-文件系统在外存当中的结构"><a href="#10-1-文件系统在外存当中的结构" class="headerlink" title="10.1 文件系统在外存当中的结构"></a>10.1 文件系统在外存当中的结构</h3><img src="https://pic.imgdb.cn/item/6666a67c5e6d1bfa05f7d266.png" alt="操作系统（四）——文件管理——文件系统的全局结构——原始磁盘.png"><p>一个磁盘刚被生成出来的时候，里面没有划分扇区，如上图，第一步要做的事情就是低级格式化，也叫物理格式化，如下图。</p><img src="https://pic.imgdb.cn/item/6666a7c85e6d1bfa05f94d89.png" alt="操作系统（四）——文件管理——文件系统的全局结构——物理格式化.png"><p>物理格式化会把磁盘分为一个一个扇区，同时在物理格式化的时候，也会检测这个磁盘当中有没有坏扇区的存在，如果有坏扇区的存在，那么就会使用一些备用扇区来顶替坏扇区。</p><p>坏扇区的存在对于操作系统来说也是透明的，假设操作系统要访问一个坏扇区，其编号为n，那么磁盘驱动器在物理格式化之后，知道这个是一个坏扇区，那操作系统它想访问n号扇区的时候，磁盘驱动器就会用一个备用扇区来替代坏扇区，替代这个工作是在背后悄悄完成的。</p><p>物理格式化以后，接下来会进行逻辑格式化（又叫高级格式化）：</p><img src="https://pic.imgdb.cn/item/6666a9425e6d1bfa05fb0ce1.png" alt="操作系统（四）——文件管理——文件系统的全局结构——逻辑格式化.png"><p>逻辑格式化会把磁盘分为一个一个的分区，又叫一个一个的分卷，比如上图的C盘、D盘、E盘，就是三个不同的分区。</p><p>一个磁盘被分为多个分区，那每个分区的大小是多少，是从哪个地址到哪个地址（地址范围是多少），这就需要使用分区表来记录。、</p><p>在每个分区当中可以建立各自独立的文件系统，比如在C这个分区里，可以建立UNIX文件系统，UNIX文件系统内部的结构如上图。</p><p>在UNIX文件系统里，首先有一个引导块（引导块的作用可以结合第一章操作系统引导复习）。然后有一个超级块，有了超级块就可以迅速的找到这个磁盘分区里面所有的空闲块，这样当我们要新建一个文件，给一个文件分配磁盘块时，就可以从超级块出发，迅速的找到很多很多的空闲磁盘块用来分配。</p><p>另外，在UNIX文件系统里，还有一个和空闲管理相关的数据结构，比如位示图。位示图可以迅速判断某一个特定的磁盘块是否空闲，而超级块的作用更多的是要迅速的找到若干个空闲的磁盘块。所以这两个数据结构在功能上有一定的重合性，但是在实际使用中会有一些区别。</p><p>接下来，在UNIX文件系统里，会有i结点区，所谓i结点就是我们熟悉的索引结点，每一个文件都会有一个与之对应的索引结点，UNIX文件系统中，所有的索引结点，都是连续存放在i结点区。可以认为这个区域就是一个超大的数组，而数组的元素就是一个一个的索引结点。由于索引结点在这个区域是连续的存储的，而且每个索引结点的大小都相同，所以可以通过一个索引结点的下标，来迅速的定位到一个指定的索引结点。</p><p>下面，在UNIX文件系统里，是根目录。当我们完成了逻辑格式化之后，根目录也会被建立起来，因为任何一个文件系统都必须从根目录出发，来建立新的下一级的目录或存储新的文件。</p><p>所以逻辑格式化以后，在上图当中灰色的部分，就是已经有实际数据的部分，这时逻辑格式化填充进去的东西，而白色的部分会用于保存其他文件和目录，这片区域在逻辑格式化之后是暂时为空的，只有新建了文件或新建了其它目录之后，这些部分，才会慢慢的被填充上数据。这就是逻辑格式化要做的事情、</p><h3 id="10-2-文件系统在内存当中的结构"><a href="#10-2-文件系统在内存当中的结构" class="headerlink" title="10.2 文件系统在内存当中的结构"></a>10.2 文件系统在内存当中的结构</h3><img src="https://pic.imgdb.cn/item/6666ad475e6d1bfa05ffb19a.png" alt="操作系统（四）——文件管理——文件系统的全局结构——文件系统在内存当中的结构1.png"><p>内存分为用户区和内核区，内核区当中有三个比较重要的部分，分别是目录的缓存、系统打开文件表、进程打开文件表。</p><p>首先看一下目录的缓存，最近被访问过的一些目录数据，会暂时被缓存在内存当中。比如说最近查找过目录M，那由于查找目录M，需要把这个目录的数据都给读入主存，如果接下来一段时间内，又访问到了这个目录M，就没有必要反复的从外存一次一次读入，这样很耗费时间。所以近期访问过的一些目录文件数据，会被缓存在内存当中，这么做可以加快目录检索的速度。</p><p>接下来看一下系统的打开文件表和进程的打开文件表。顾名思义，系统打开文件表整个系统只有一张。而进程打开文件表每个进程都有一张，进程打开文件表式包含在每个进程的PCB当中的，记录了某一个进程当前打开了哪些文件。</p><p>接下来用一个例子梳理下，这些东西是怎么工作的：</p><img src="https://pic.imgdb.cn/item/6666ad715e6d1bfa05ffe61f.png" alt="操作系统（四）——文件管理——文件系统的全局结构——文件系统在内存当中的结构2.png"><p>假设现在我们用open系统调用，尝试打开M目录下的A文件。如果现在找到了文件A的存放目录M，接下来会把目录M的数据给读入主存，给它缓存起来。</p><p>读入主存之后，就可以检查这个目录项。一个一个对比，发现其中有一个目录项的名字和要找的文件A是对的上的，接下来要做的事情就是把A这个文件的FCB目录项给复制到系统打开文件表当中，表示这个文件已经打开，同时设置其打开计数为1，这意味着当前有一个进程在使用A这个文件。</p><p>另一方面，刚刚发起open系统调用的进程，有一个进程打开文件表。需要在它的进程打开文件表当中新建一个条目，这个条目当中会记录它的打开方式。在这个进程打开文件表当中，不会保存A这个文件的FCB，只会有一个指向系统打开文件表的索引，这样通过进程打开文件表，就可以找到系统打开文件表中对应的条目，而这个条目当中就可以找到这个文件对应的FCB。</p><p>因此在刚说的进程打开文件表中会新建一个条目，同时返回这个条目的文件描述符，文件描述符就可以简单的理解为指向进程打开文件表的一个指针。也就是说当我们open打开一个文件之后，这个系统调用会给我们程序员返回一个文件描述符fd，接下来我们通过这个文件描述符fd就可以对我们打开的文件进行相应的操作。</p><h2 id="11-虚拟文件系统"><a href="#11-虚拟文件系统" class="headerlink" title="11. 虚拟文件系统"></a>11. 虚拟文件系统</h2><img src="https://pic.imgdb.cn/item/6666adbc5e6d1bfa0500377b.png" alt="操作系统（四）——文件管理——普通的文件系统.png"><p>首先看一下没有虚拟文件系统的情况。普通的文件系统如上图所示。在我们使用计算机的时候，计算机上难免会插上各种各样的外部设备，比如说移动硬盘等。不同的外部存储设备，它里面的文件系统格式可能是各不相同的，比如移动硬盘是NTFS文件系统格式，U盘是FAT文件系统格式，而电脑本身的磁盘可能是UFS文件系统格式。</p><p>所以可以看到，我们的计算机内部有可能同时存在各种各样的文件系统，而不同的文件系统，他的开发者在开发时，定义的函数接口有可能不相同，比如说同样是open打开系统调用，可能UFS系统就只有两个系统参数，而NTFS可能函数名字不一样，参数也只有一个，FAT可能又是另外一种情况，如上图。这就导致，我们在写代码时，如果要从一个文件系统打开一个文件，就需要按照不同的文件系统的规范来写，这对于上层的程序员用户来说很是麻烦。</p><p>因此操作系统内核应该向上层的用户进程提供一个统一标准的函数接口。所以在操作系统当中，就引入了虚拟文件系统(VFS)。</p><img src="https://pic.imgdb.cn/item/6666adf25e6d1bfa05007f97.png" alt="操作系统（四）——文件管理——虚拟文件系统特性1.png"><p>有了虚拟文件系统之后，用户进程在打开一个文件的时候，只需要根据虚拟文件系统制定的标准来写自己的代码文件即可。而文件具体是在哪个文件系统里用户都不需要管。</p><p>所以<strong>虚拟文件系统的第一个特点就是向上层的用户进程提供统一标准的系统调用接口</strong>，因此虚拟文件系统的存在，对普通用户而言，是帮用户屏蔽了底层具体文件系统的实现差异。</p><img src="https://pic.imgdb.cn/item/6666ae165e6d1bfa0500a6e0.png" alt="操作系统（四）——文件管理——虚拟文件系统特性2.png"><p>现在虚拟文件系统可以处理上层用户发来的一个标准的系统调用请求，然后这个虚拟文件系统会负责去操作底层的一个具体文件系统。但是刚刚说，每一个文件系统的函数参数列表可能都不一样，这对于虚拟文件系统来说又是一个麻烦。这意味着，只要下层的文件系统对外提供的函数调用接口不统一，那么虚拟文件系统在调用一个具体文件系统的时候，函数代码也要根据不同的文件系统来进行改变，这意味着要频繁修改操作系统内核的代码，显然也是不科学的。为了解决这个问题，虚拟文件系统会要求底层的文件系统必须实现虚拟文件系统规定好的接口。</p><p>因此，<strong>虚拟文件系统的第二个特点就是除了对上层的用户提供了一个统一的文件接口外，还会要求底层的具体文件系统实现规定好的函数接口</strong>。</p><p>如上图，可以看到，虚拟文件系统的底层有可能是一个UFS文件系统，也可能是一个FAT文件系统。我们知道，UFS文件系统的目录项和FAT文件系统的目录项是有很大差别的，如下图：</p><img src="https://pic.imgdb.cn/item/6666ae455e6d1bfa0500da0f.png" alt="操作系统（四）——文件管理——虚拟文件系统存在问题.png"><p>UFS这种文件系统，每个目录项只包含文件名和i结点编号两个信息，我们需要根据i结点编号把i结点读入主存，然后才能知道这个文件具体的原数据以及存储地址等信息。</p><p>而对于FAT文件系统来说，只要读入了某一个文件的目录项，这个FCB里就包含了关于这个文件的所有信息。</p><p>通过分析，可以发现一个新的问题，对于虚拟文件系统来说，当要打开一个具体的文件时，如果文件来自UFS这种文件系统，那读入的文件信息就如上图上。而如果文件来自FAT这种文件系统，那读入的文件信息就如上图下。这样的话，虚拟文件系统在内存当中就必须使用不同的数据结构来表示来自不同文件系统的文件信息。</p><p>为了解决上述问题，在虚拟文件系统当中，每当我们open打开了一个文件之后，这个虚拟文件系统就会给这个文件在主存当中新建一个vnode，也叫v结点。如下图。</p><img src="https://pic.imgdb.cn/item/6666ae735e6d1bfa05010af9.png" alt="操作系统（四）——文件管理——虚拟文件系统特性3.png"><p>vnode里包含了文件的各种各样的信息。无论打开的文件是来自UFS还是FAT，在打开文件之后，都会把这个文件的相关信息给复制到vnode结点当中。</p><p>这样虚拟文件系统就可以用一个统一的数据结构vnode来表示任何一个文件的信息。</p><p>所以，<strong>虚拟文件系统的第三个特点就是每打开一个文件，VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</strong>。</p><p>这里要注意两个地方，第一个值得注意的地方，如上图，vnode和inode看起来很像，但他们是两个完全不一样的东西，vnode只存在于主存当中，每一个被打开的文件，在主存当中都会有一个与之对应的vnode。而inode既会被调入主存，也会在外存中存储。</p><p>如果此时打开的文件刚好在UFS文件系统中，那么找到这个文件对应的目录项以后，会把文件的inode从外存先读入主存，然后在主存当中会把刚刚读入的inode信息复制到vnode当中。这里要注意vnode和inode的区别。</p><p>接下来说第二个值得注意的地方，依然是上图，可以发现vnode指针里有一个函数功能指针没有说过，之前我们说过，不同的文件系统需要实现虚拟文件系统规定的一些函数的功能，比如open、read等，如下图。</p><img src="https://pic.imgdb.cn/item/6666aeb55e6d1bfa05014e9e.png" alt="操作系统（四）——文件管理——vnode.png"><p>而不同的文件系统对应的open、read等，其背后的具体实现代码是不相同的，所以<strong>vnode当中的函数功能指针，其实是指向了对应文件系统的函数功能列表</strong>。这样只要open打开了一个文件，之后对文件的任何操作，都可以先找到这个文件对应的vnode，然后根据vnode当中记录的这个函数功能指针，再找到具体的对应的文件系统的函数功能列表，然后执行具体的函数，这样就可以实现从上到下，一层一层函数的调用。</p><p>所以在vnode当中，除了文件的原数据各种信息之外，还会保存这个文件所属的文件系统所提供的函数功能的列表。</p><p>接下来看文件系统的挂载：</p><img src="https://pic.imgdb.cn/item/6666af255e6d1bfa0501c7d0.png" alt="操作系统（四）——文件管理——文件系统挂载.png"><p>文件系统的挂载又叫文件系统的安装&#x2F;装载，也就是如何将一个文件系统挂载的操作系统上。</p><p>比如把一个U盘插到电脑上，那U盘这个文件系统就需要挂载到操作系统上，具体来说就是要挂载到操作系统的虚拟文件系统里。</p><p>文件系统的挂载需要做的事：</p><ol><li>在VFS中注册新挂载的文件系统。在<strong>内存中</strong>，虚拟文件系统会管理一个数据结构叫做挂载表，<strong>挂载表包含每个文件系统的相关信息</strong>，包括文件系统类型、容量大小等。</li><li>新挂载的文件系统，要向VFS提供<strong>一个函数地址列表</strong>。这样才可以让虚拟文件系统调用新挂载的文件系统所提供的功能函数。</li><li>将新文件系统加到<strong>挂载点</strong>，也就是将新文件系统挂载在某个父目录下。</li></ol><p>这里补充一下什么是挂载点，如果用的是Windows系统，当插入一个U盘或移动硬盘时，会发现，在此电脑的界面里，有与C盘、D盘平级的新的盘符出现。所以对于Windows系统而言，新挂载的文件系统，挂载点就是此电脑的界面处，与C盘平级。</p><p>要注意，只有确定了新文件系统挂载的位置，接下来才可以正常的访问和使用新的文件系统。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（七）——排序</title>
      <link href="/2024/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构（七）——排序"><a href="#数据结构（七）——排序" class="headerlink" title="数据结构（七）——排序"></a>数据结构（七）——排序</h1><h2 id="1-排序的基本概念"><a href="#1-排序的基本概念" class="headerlink" title="1. 排序的基本概念"></a>1. 排序的基本概念</h2><img src="https://pic.imgdb.cn/item/665e71af5e6d1bfa05be09a5.png" alt="数据结构（七）——排序——排序的基本概念.png"><p>排序就是把一堆数据元素按照它们关键字递增或递减的顺序，把它们的关键字重新排列一遍。</p><p>在设计排序算法时，除了要关注时间复杂度和空间复杂度两个指标以外，还要关注算法的稳定性。</p><img src="https://pic.imgdb.cn/item/665e73045e6d1bfa05bf3f70.png" alt="数据结构（七）——排序——排序算法的稳定性.png"><p>所谓稳定性就是两个相同的关键字，在排序前后，其依次出现的顺序没有发生改变，如上图的例子。</p><p>但是不论是稳定的还是不稳定的，其结果都是一样的。另外，稳定的排序算法并不一定比不稳定的好，这需要结合具体实际来判断。</p><p>接下来看一下排序算法的分类：</p><img src="https://pic.imgdb.cn/item/665e740f5e6d1bfa05c046f7.png" alt="数据结构（七）——排序——排序算法的分类.png"><p>排序算法可以分为内部排序和外部排序。</p><p>内部排序就是我们可以把所有的排序需要的数据都放在内存当中，比如自己定义的int型数组。但有时候我们会遇到需要排序的数据量很大，没有办法全部放入内存，这时候就需要外部排序。</p><p>外部排序就是数据太多，无法全部放入内存。比如我们有一个8GB的内存，但是存储在外存的文件远远大于内存容量。这个时候就无法把文件全部读入内存进行排序，所以只能采取一部分一部分排序的策略。</p><p>对于内部排序算法，由于对数据的处理全部都是在内存当中的，而内存又是一个很高速的设备，所以在设计内部算法时更关注算法的时间复杂度和空间复杂度。</p><p>对于外部排序算法，除了关注算法的时间复杂度和空间复杂度外，还要关注怎么追求更少的磁盘&#x2F;读写次数。因为磁盘的读写速度很慢，每次读取数据和写回数据都会浪费大量时间，而内存的处理速度很快，所以当这些数据进入内存以后的处理时间消耗反而不是很多，所以对外部排序算法，重点是要关注怎么让磁盘读写次数更少。</p><p>下面对该部分进行一个小结：</p><img src="https://pic.imgdb.cn/item/665e76bf5e6d1bfa05c44fba.png" alt="数据结构（七）——排序——排序的基本概念小结.png"><h2 id="2-插入排序-希尔排序（插入排序的优化）"><a href="#2-插入排序-希尔排序（插入排序的优化）" class="headerlink" title="2. 插入排序&amp;希尔排序（插入排序的优化）"></a>2. 插入排序&amp;希尔排序（插入排序的优化）</h2><h3 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h3><img src="https://pic.imgdb.cn/item/665e770a5e6d1bfa05c48e83.png" alt="数据结构（七）——排序——插入排序思想.png"><p>插入排序算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</p><p>这里以上图例子为例进行算法过程说明，刚开始会从第二个元素38入手，认为在第二个元素之前的数（即第一个数49）是排好序的。现在需要把38与之前已经排好序的数依次进行对比，比当前元素38大的，都要向后移动一位。比如49大于38，所以49要后移，然后把38插到49前面。排序结果如下图：</p><img src="https://pic.imgdb.cn/item/665e7a2f5e6d1bfa05c7152b.png" alt="数据结构（七）——排序——插入排序例子1.png"><p>现在排序65，将65与之前排序好的元素进行比较，发现没有大于65的，所以65不需要前移，97同理。</p><p>接下来排序76，把76与之前已经排好序的数依次进行对比，发现97比76大，所以要把97后移，76放到97的位置。</p><img src="https://pic.imgdb.cn/item/665e7af55e6d1bfa05c7bd95.png" alt="数据结构（七）——排序——插入排序例子2.png"><p>接下来排序13，把13与之前已经排好序的数依次进行对比，发现97、76、65、49、38都比13大，所以要把这些数都后移一位，13放到38的位置。如下图：</p><img src="https://pic.imgdb.cn/item/665e7b435e6d1bfa05c80972.png" alt="数据结构（七）——排序——插入排序例子3.png"><p>接下来的步骤就不再说，直接给出最后排序的结果：</p><img src="https://pic.imgdb.cn/item/665e7b715e6d1bfa05c84827.png" alt="数据结构（七）——排序——插入排序例子4.png"><p>注意，这里有两个49，第二个是最后排序的49，我们每次排序都是让比当前元素大的后移，与当前元素相等的不会后移，这么做是为了保证算法的稳定性。</p><p>下面看一下代码实现：</p><img src="https://pic.imgdb.cn/item/665e7bc85e6d1bfa05c8bb58.png" alt="数据结构（七）——排序——插入排序代码实现.png"><p>这里算法的排序很简单，代码的实现就是刚刚说的过程，代码也很简单。</p><p>这里需要注意一点，我们在进行比较时，是从当前位置往前依次比较，每有一个比当前元素大的，就将其向后移动一位，直到找到第一个不大于当前元素的元素，则将当前元素插入到该不大于当前元素的后面。另外进行后移操作时，会把当前要插入的元素覆盖掉，所以要先用一个temp变量充当中间变量，将当前插入的元素保存下来。</p><p>当然，也可以采用哨兵的方法，如下图：</p><img src="https://pic.imgdb.cn/item/665e7cb05e6d1bfa05ca55dc.png" alt="数据结构（七）——排序——插入排序代码实现（带哨兵）.png"><p>采用哨兵的方法，就是数组首位空出来充当哨兵，而元素的实际存放位置是从数组下标为1处开始的，每次要进行插入排序时，不再像上面那样定义一个中间变量，而是直接把当前要插入的元素放到数组首位置（即哨兵处），让哨兵充当中间变量。这样做还有一个好处，就是如果前面的值都大于当前元素，则遍历时，不需要加上一个j&gt;&#x3D;0判断，即不需要检查当前位置是否合法。</p><p>带哨兵算法虽然好一点，但好的有限，硬要说的话，带哨兵的其实并没有上面的不带哨兵的算法更清晰易理解，考研中如果考到插入排序算法，可以根据自己喜好选择写哪个。</p><p>接下来分析一下算法的效率：</p><img src="https://pic.imgdb.cn/item/665e911f5e6d1bfa05e1cc17.png" alt="数据结构（七）——排序——插入排序空间复杂度.png"><p>算法里只有了i，j两个用于循环的变量，不带哨兵还会定义一个中间变量temp，所有的这些变量所需要的辅助空间都是常数级的，和问题规模n没有关系。所以这个算法的空间复杂度就是O(1)数量级。</p><p>接下来看时间复杂度，在进行插入排序时，要从第二个元素开始，每个元素都要经历一个for循环，所以总体来看要处理n-1个元素，即需要进行n-1趟处理，每趟处理都需要进行关键字的对比和元素的移动，时间复杂度的主要开销就来自这两个部分。</p><p>先看一下最好的情况：</p><img src="https://pic.imgdb.cn/item/665e92235e6d1bfa05e38773.png" alt="数据结构（七）——排序——插入排序时间复杂度最好情况.png"><p>最好情况就是各个元素的排列本身就是有序的，这样每一趟只需要对比一次关键字，共需要对比n-1趟，时间复杂度为O(n)。</p><p>下面看一下最坏情况：</p><img src="https://pic.imgdb.cn/item/665e93c05e6d1bfa05e4e172.png" alt="数据结构（七）——排序——插入排序时间复杂度最坏情况.png"><p>最坏情况，元素的排列是逆序的，此时要把元素排成顺序，则第i趟需要对比关键字i+1次，移动元素i+2次。则最后一趟，即如上图插入10，如果有n个元素，需要对比n-1次，移动n-1次，时间复杂度达到O(n<sup>2</sup>)。</p><p>综合最优和最坏两种情况，可以得出算法的平均时间复杂度：</p><img src="https://pic.imgdb.cn/item/665e94d45e6d1bfa05e5c81d.png" alt="数据结构（七）——排序——插入排序时间复杂度.png"><p>求平均可得，算法的平均时间复杂度为O(n<sup>2</sup>)，且该算法也是稳定的。</p><p>接下来看一下插入算法的优化：</p><img src="https://pic.imgdb.cn/item/665e958a5e6d1bfa05e64ffa.png" alt="数据结构（七）——排序——插入排序算法优化.png"><p>之前对比都是采用顺序查找的方式找到要插入元素的插入位置，但是由于插入元素前的元素已经排序成功，所以可以采用折半插入的方式进行排序。比如上图插入55，对其前元素进行折半查找，查找结果如下图：</p><img src="https://pic.imgdb.cn/item/665e96075e6d1bfa05e6b5e2.png" alt="数据结构（七）——排序——插入排序算法优化1.png"><p>当low&gt;high时折半查找停止，此时low即其右边的元素都应该大于当前要插入的元素，所以应将[low, i-1]内的元素全部右移，并将A[0]复制到 low所指位置。</p><p>所以55的插入结果如下图：</p><img src="https://pic.imgdb.cn/item/665e96875e6d1bfa05e72cce.png" alt="数据结构（七）——排序——插入排序算法优化2.png"><p>现在插入60这个元素：</p><img src="https://pic.imgdb.cn/item/665e96b75e6d1bfa05e754bf.png" alt="数据结构（七）——排序——插入排序算法优化3.png"><p>可以发现，会出现mid&#x3D;high&#x3D;low，而A[mid]&#x3D;A[0]，这时候为了保证算法的稳定性，要继续进行一步low&#x3D;mid+1，此时low即其右边的元素都应该大于当前要插入的元素，所以应将[low, i-1]内的元素全部右移，并将A[0]复制到 low所指位置。</p><p>插入完60以后，现在要插入90：</p><img src="https://pic.imgdb.cn/item/665e97445e6d1bfa05e7cd88.png" alt="数据结构（七）——排序——插入排序算法优化4.png"><p>可以发现，当low&gt;high时折半查找停止，此时low&gt;i-1，所以low及其右边没有元素，并不需要移动，只需要把A[0]放到low所指位置即可。</p><p>之后的过程同理就再赘述，下面看一下这种算法的代码实现：</p><img src="https://pic.imgdb.cn/item/665e986b5e6d1bfa05e8ce92.png" alt="数据结构（七）——排序——插入排序算法优化代码.png"><p>这里的程序也很简单，其中稍微有点难度的折半查找算法在上一章查找里也已经说过。上图代码里的else部分就是保证算法稳定性的部分。</p><p>与直接插入排序相比，折半查找比较关键字的次数减少了，但是移动元素的次数没变，因此整体来看时间复杂度依然是O(n<sup>2</sup>)，并没有质的飞跃。</p><p>插入排序算法这种思想，前面一直是对顺序表进行操作，但这种思想也可以对链表进行操作，需要注意，如果对链表进行操作，折半插入排序就无法使用，因为链表没有随机存取的特性。</p><img src="https://pic.imgdb.cn/item/665e99485e6d1bfa05e98cf1.png" alt="数据结构（七）——排序——插入排序链表.png"><p>对链表进行茶蕊排序，移动元素只需改变指针指向即可，不过只能顺序的依次比较各个关键字，用这样的方式来确定插入位置，关键字的比较次数依然会保持O(n<sup>2</sup>)数量级，因此整体来看时间复杂度还是O(n<sup>2</sup>)。</p><p>总之，只要采用插入排序，其时间复杂度总会达到O(n<sup>2</sup>)数量级。但如果元素原本就是有序的，这时插入排序也可以得到一个不错的执行效率。</p><p>下面，对插入排序做个小结：</p><img src="https://pic.imgdb.cn/item/665e9a275e6d1bfa05ea5bc9.png" alt="数据结构（七）——排序——插入排序小结.png"><h3 id="2-2-希尔排序"><a href="#2-2-希尔排序" class="headerlink" title="2.2 希尔排序"></a>2.2 希尔排序</h3><img src="https://pic.imgdb.cn/item/665fecd55e6d1bfa054a8eaa.png" alt="数据结构（七）——排序——希尔排序.png"><p>在插入排序里，我们知道如果数据元素原本就是有序的，那在这种情况下，插入排序可以得到一个很不错的排序效率。或者把条件放宽一点，如果能保证排序元素基本有序，那这种情况下，直接插入的排序效率也很不错，如上图。</p><p>希尔排序的思想就是基于上面的考虑，先追求表中元素部分有序，再逐渐逼近全局有序。</p><p>下面以一个例子来理解希尔排序：</p><img src="https://pic.imgdb.cn/item/665feda05e6d1bfa054b56be.png" alt="数据结构（七）——排序——希尔排序例子1.png"><p>希尔排序会把表里的元素拆分成一个一个子表。在每趟拆分的过程当中都会设置一个增量d，然后把相距距离为d的各个元素看做是一个特殊的子表。然后把这些子表当中的元素进行直接插入排序。比如上图的例子，假设第一趟拆分的d&#x3D;4，如下图。</p><img src="https://pic.imgdb.cn/item/665fee7d5e6d1bfa054c193f.png" alt="数据结构（七）——排序——希尔排序例子1_1.png"><p>当d&#x3D;4时，会把相距距离为4的元素当做一个子表，拆分结果如上图，然后我们会对每个子表当中的元素进行插入排序，排序结果如下图：</p><img src="https://pic.imgdb.cn/item/665feec55e6d1bfa054c5bba.png" alt="数据结构（七）——排序——希尔排序例子1_2.png"><p>所以经过第一趟排序结果应该如下图：</p><img src="https://pic.imgdb.cn/item/665feef35e6d1bfa054c8907.png" alt="数据结构（七）——排序——希尔排序例子1_3.png"><p>接下来会进行第二趟排序，第二趟排序会缩小增量的值，会在之前d<sub>1</sub>的基础上除2，所以第二趟的增量值d<sub>2</sub>&#x3D;2。这个时候会把距离为2的元素划分为同一个子表，如下图：</p><img src="https://pic.imgdb.cn/item/665fefbb5e6d1bfa054d5c63.png" alt="数据结构（七）——排序——希尔排序例子1_4.png"><p>接下来对子表里的元素进行插入排序，结果如下图：</p><img src="https://pic.imgdb.cn/item/665fefe35e6d1bfa054d8864.png" alt="数据结构（七）——排序——希尔排序例子1_5.png"><p>所以经过第二条排序以后，表里各元素的位置应该如下图这样：</p><img src="https://pic.imgdb.cn/item/665ff0165e6d1bfa054db8ca.png" alt="数据结构（七）——排序——希尔排序例子1_6.png"><p>接下来第三趟处理，会让增量d值继续缩小2倍，此时d<sub>3</sub>&#x3D;1，这就意味着表中所有元素都会被划分为同一个子表，所以最后这趟处理，就是对表中所有元素进行一次总体的直接插入排序。而经过前面两趟的处理，这个时候得到序列已经达成了基本有序的理想状态。接下来对所以元素进行直接插入排序可以得到排序结果，如下图：</p><img src="https://pic.imgdb.cn/item/665ff0f65e6d1bfa0550185b.png" alt="数据结构（七）——排序——希尔排序例子1_7.png"><p>我们对这个例子进行汇总如下图：</p><img src="https://pic.imgdb.cn/item/665ff1445e6d1bfa05506f58.png" alt="数据结构（七）——排序——希尔排序例子小结.png"> <p>这里要注意一点，在本例里，我们的增量d第一次取的是元素总数的一半，并且之后缩小时，也是缩小一半，这种改变增量的方法也是希尔本人建议的。但考研里，可能会遇到不同的增量序列，比如d&#x3D;1,2,3。所以要看清题目要求，并会求不同增量序列下的希尔排序，建议找相关题目做一下。</p><p>接下来看一下希尔排序的算法实现：</p><img src="https://pic.imgdb.cn/item/665ff7295e6d1bfa05563f27.png" alt="数据结构（七）——排序——希尔排序算法实现.png"><p>这个算法的程序实现过程与我们前面所说的思想有点出入，如果自己分析不了，建议看一下视频动态讲解：<a href="https://www.bilibili.com/video/BV1b7411N798/?p=88&spm_id_from=pageDriver&vd_source=7fb4b255ed876969a742738d7b84f461">希尔排序</a>，大概在10~16分钟。</p><p>接下来看一下希尔排序算法的性能如何：</p><img src="https://pic.imgdb.cn/item/665ffbbb5e6d1bfa055b0804.png" alt="数据结构（七）——排序——希尔排序性能分析.png"><p>显然，对于希尔排序的空间复杂度来说，我们只需要常数级的辅助空间O(1)。</p><p>而时间复杂度的分析就困难的多，比如上图，当采用不同的增量序列时，排序趟数会受到影响，而每一趟中各个元素的对比和移动次数也会受到影响，所以关于希尔排序的时间复杂度是什么样的，到目前为止都没有数学手段能证明其确切的时间复杂度。</p><p>但对于希尔排序来说，如果第一趟的d&#x3D;1，这种情况下，算法就退化成了直接插入排序，所以最坏情况下，希尔排序的时间复杂度也可以达到和直接插入排序一个数量级O(n<sup>2</sup>)。</p><p>另外，如果数据元素的数量不是特别大，在某个范围内时，希尔排序的效率可以达到O(n<sup>1.3</sup>)数量级，相比于O(n<sup>2</sup>)还是提升了很多。所以希尔排序还是比直接插入排序优秀了不少，只不过没有办法用数学手段证明其确定的时间复杂度是多少。</p><p>接下来看一下希尔排序的算法稳定性：</p><img src="https://pic.imgdb.cn/item/665ffd635e6d1bfa055c96d5.png" alt="数据结构（七）——排序——希尔排序稳定性.png"><p>从上图的例子可以看到，希尔排序是不稳定的。</p><p>另一方面，希尔排序的实现只能基于顺序表，因为需要用增量d来快速的找到与之相邻的从属于一个子表的各个元素，所以必须有随机访问的特性才能实现，所以希尔排序只能基于顺序表实现，而不能基于链表实现。</p><p>最后，对希尔排序做个小结：</p><img src="https://pic.imgdb.cn/item/665ffe095e6d1bfa055d2ca5.png" alt="数据结构（七）——排序——希尔排序小结.png"><h2 id="3-交换排序"><a href="#3-交换排序" class="headerlink" title="3. 交换排序"></a>3. 交换排序</h2><img src="https://pic.imgdb.cn/item/66728a7cd9c307b7e94f6a4b.png" alt="数据结构（七）——排序——交换排序.png"><p>所谓交换排序就是根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置，交换排序属于一大类，基于交换排序的思想，接下来会学习冒泡排序和快速排序。</p><h3 id="3-1-冒泡排序"><a href="#3-1-冒泡排序" class="headerlink" title="3.1 冒泡排序"></a>3.1 冒泡排序</h3><p><strong>冒泡排序就是从后往前（或从前往后）两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换它们，直到序列比较完。称这样过程为“一趟”冒泡排序。</strong></p><p>接下来用一个例子来说明冒泡排序的执行过程：</p><img src="https://pic.imgdb.cn/item/66607aef5e6d1bfa05e84fdf.png" alt="数据结构（七）——排序——冒泡排序例子1.png"><p>假设从后往前比较，首先第一趟，先比较27和49，不是逆序，所以不需要改变27与49的位置。然后比较13与27，不是逆序，所以不需要改变13与27的位置。接下来比较76与13，是逆序，所以需要交换76与13的位置。如下图：</p><img src="https://pic.imgdb.cn/item/66607c015e6d1bfa05e9f14f.png" alt="数据结构（七）——排序——冒泡排序例子1_1.png"><p>接下来比较97与13，发现也是逆序，所以需要交换97与13的位置。同理比较65与13，仍为逆序，交换位置。继续比较38与13，为逆序，交换位置。最后比较49与13，逆序，交换位置，则第一趟比较结束，最后结果如下图：</p><img src="https://pic.imgdb.cn/item/66607de05e6d1bfa05ec620b.png" alt="数据结构（七）——排序——冒泡排序例子1_2.png"><p>经过第一趟排序，最后的结果就是最小的一个元素会被放到前面。</p><p>接下来，看第二趟排序：</p><img src="https://pic.imgdb.cn/item/66607eb95e6d1bfa05ed5ecc.png" alt="数据结构（七）——排序——冒泡排序例子1_3.png"><p>第二趟排序同理，从后面开始往前比较，但注意，由于第一趟已经把最小的元素放到了最前面，所以第二趟排序不需要再与前面确定的元素进行比较，所以经过第二趟排序，会把第二小的元素放到第二个位置。</p><p>接下来看第三趟：</p><img src="https://pic.imgdb.cn/item/66607f8f5e6d1bfa05ee5d70.png" alt="数据结构（七）——排序——冒泡排序例子1_4.png"><p>第三趟排序同理，最终会把第三小的元素放到第三个位置，如上图。</p><p>同理进行第四趟：</p><img src="https://pic.imgdb.cn/item/66607fea5e6d1bfa05eebd8b.png" alt="数据结构（七）——排序——冒泡排序例子1_5.png"><p>第五趟：</p><img src="https://pic.imgdb.cn/item/6660801a5e6d1bfa05eef271.png" alt="数据结构（七）——排序——冒泡排序例子1_6.png"><p>在第五趟里，整个过程当中没有发生任何一次交换，这种情况说明整体来看已经达到了一个有序的状态，所以经过第五趟的处理后，就可以确定整个表已经有序，就不需要再进行第六趟的处理，这就是冒泡排序的原理。</p><p>理清楚了刚刚的逻辑以后，代码的理解也会变得简单，代码的实现如下图：</p><img src="https://pic.imgdb.cn/item/666080cc5e6d1bfa05efbe1a.png" alt="数据结构（七）——排序——冒泡排序代码实现.png"><p>注意上图代码里的比较部分，通过这个比较判断，可以确保算法的稳定性。</p><p>接下来分析一下冒泡排序算法的性能：</p><img src="https://pic.imgdb.cn/item/666082605e6d1bfa05f1e13f.png" alt="数据结构（七）——排序——冒泡排序算法性能分析.png"><p>空间复杂度显然是O(1)数量级。</p><p>时间复杂度，最好的情况是本身就是有序的，这样只需要比较n-1次，交换0次，所以最好的时间复杂度是O(n)。最坏情况是原本逆序，此时第一趟要比较n-1次第，第二趟要比较n-2次，按照这样递推下去，最后一趟要比较1次，累加起来，如上图，得到最坏的情况时间复杂度是O(n<sup>2</sup>)。综合来看，平均时间复杂度也会达到O(n<sup>2</sup>)。</p><p>另外要注意这里的交换次数的含义，交换次数是调用交换函数swap的次数，而swap里会移动元素3次，即3次移动次数。所以一次交换次数，会有3次移动次数。要注意区分调用次数与移动次数。</p><p>接下来探讨一个问题，冒泡排序是否适用于链表？显然是可以的，比如下图：</p><img src="https://pic.imgdb.cn/item/6660829f5e6d1bfa05f252d2.png" alt="数据结构（七）——排序——冒泡排序适用链表.png"><p>之前是从后往前，这里可以从前往后，从链头开始，检查当前元素与其后元素，若当前检查元素比其后元素大，则交换位置。若当前检查元素比其后元素小，则不用交换位置，只需要让扫描指针后移即可。在这方式下，每一趟会让一个最大的元素放到末尾。</p><p>这种从前往后的思想在我们学C语言时就已经接触过，现在来说应该很简单，所以考试时如果没有特别要求，也可以写这种我们从C语言基础时就接触的从前往后的冒泡排序。</p><p>下面对这部分进行小结：</p><img src="https://pic.imgdb.cn/item/666082c65e6d1bfa05f2a345.png" alt="数据结构（七）——排序——冒泡排序小结.png"><h3 id="3-2-快速排序-重点"><a href="#3-2-快速排序-重点" class="headerlink" title="3.2 快速排序(重点)"></a><font color=red>3.2 快速排序(重点)</font></h3><p>首先看一下快速排序的思想：</p><img src="https://pic.imgdb.cn/item/66703c5cd9c307b7e9a82656.png" alt="数据结构（七）——排序——快速排序算法思想.png"><p>快速排序的核心思想就是在待排序序列中任取一个元素，然后以这个元素为枢纽，通过一趟排序，将大于这个元素的数放到其右边，小于这个元素的数放到其左边，这样经过一次排序，就可以确定该元素在待排序序列里的位置，并可以将这个排序序列划分为两个独立的部分。</p><p>下面以一个例子来看下快速排序的实现过程：</p><img src="https://pic.imgdb.cn/item/66703d9ad9c307b7e9aaddb3.png" alt="数据结构（七）——排序——快速排序1.png"><p>如上面的待排序序列，如果我们采用快速排序的思想，要先用两个指针low和high分别指向序列头和序列尾。</p><p>然后我们选择low所指向的这个元素，让它作为基准元素，如下图：</p><img src="https://pic.imgdb.cn/item/66703e23d9c307b7e9ac0ba4.png" alt="数据结构（七）——排序——快速排序2.png"><p>这个例子里，我们选取low所指向的元素49，让其做为基准元素，下面我们要做的就是通过移动指针调整数据位置，将序列里小于49的元素放到其左边，大于49的元素放到其右边。</p><p>接下来看怎么操作可以实现上面说的目的：</p><p>在选取了基准元素以后，会让low和high这两个指针开始往中间移动，我们会用low和high这两个指针把所有的这些待排序的元素都给扫描一遍，在整个扫描过程当中，需要保证high所指的位置的右边都是大于等于当前的基准元素49的，而low指针的左边要保证都是小于49的。</p><p>由于low所指的位置是空的，所以会先从high指针所指处开始操作，可以看到，high当前指向的元素是49，属于大于等于基准元素的范畴，所以下标为7的元素并不需要移动，接下来让high左移一步，指到下标为6的位置，如下图。</p><img src="https://pic.imgdb.cn/item/66704035d9c307b7e9b07d52.png" alt="数据结构（七）——排序——快速排序3.png"><p>此时high所指的位置元素为27，该元素是要小于49的，所以将27放到low所指位置处，如下图。</p><img src="https://pic.imgdb.cn/item/66704088d9c307b7e9b130d1.png" alt="数据结构（七）——排序——快速排序4.png"><p>现在high所指的位置空出来了，接下来我们要开始操作low指针，可以看到low指针就是刚刚放过来的27，显然是小于49的，所以要把low指针右移，如下图。</p><img src="https://pic.imgdb.cn/item/66704103d9c307b7e9b230b5.png" alt="数据结构（七）——排序——快速排序5.png"><p>显然，low指针当前所指的元素是38，仍然小于49，所以low指针继续右移。</p><img src="https://pic.imgdb.cn/item/66704160d9c307b7e9b2f072.png" alt="数据结构（七）——排序——快速排序6.png"><p>这时，low指针指向的元素65是大于49的，所以要把65这个元素放到high指针指向处。</p><img src="https://pic.imgdb.cn/item/667041b9d9c307b7e9b3c916.png" alt="数据结构（七）——排序——快速排序7.png"><p>此时low指针的位置空出来，接下来要操作high指针。可以看到，high指针指向的位置是大于49的，所以high指针要左移。</p><img src="https://pic.imgdb.cn/item/66704206d9c307b7e9b4665b.png" alt="数据结构（七）——排序——快速排序8.png"><p>此时high指针指向13，是要小于49的，所以要把13放到low指针处。</p><img src="https://pic.imgdb.cn/item/6670423cd9c307b7e9b4d4d2.png" alt="数据结构（七）——排序——快速排序9.png"><p>此时high指针位置空出，接下来要操作low指针，显然low指针当前所指是小于49的，所以low指针右移。</p><img src="https://pic.imgdb.cn/item/6670427bd9c307b7e9b55ad7.png" alt="数据结构（七）——排序——快速排序10.png"><p>显然97大于49，要把97放到high指针处。</p><img src="https://pic.imgdb.cn/item/667042a7d9c307b7e9b5b74b.png" alt="数据结构（七）——排序——快速排序11.png"><p>low位置空出，开始操作high指针，显然high所指大于49，要把high指针左移，而左移以后的76仍然是大于49的，所以high指针要继续左移，此时high指针与low指针指向同一个位置，如下图。</p><img src="https://pic.imgdb.cn/item/66704301d9c307b7e9b66be5.png" alt="数据结构（七）——排序——快速排序12.png"><p>当low和high碰到一起的时候，就说明我们已经把所有的待排序元素都给扫描了一遍。所以比基准元素49小的，我们都放到了low指针的左边，比基准元素49大的，我们都放到了high指针的右边。到这一步，我们就可以确定基准元素49是放在下标为3的位置，也就是low和high相遇的位置，如下图。</p><img src="https://pic.imgdb.cn/item/66704423d9c307b7e9b86291.png" alt="数据结构（七）——排序——快速排序13.png"><p>到这里，就是一次所谓的划分过程。</p><p>这一次划分确定了基准元素49的位置，并把小于49的元素都放到了49的左边，大于49的元素都放到了49的右边。所以，在接下来的排序当中，我们就不需要管49这个元素，只需要再对49左边的元素子表和右边的子表再分别进行划分即可。</p><p>下面先来看对左子表进行划分：</p><img src="https://pic.imgdb.cn/item/66704a8ed9c307b7e9c5071e.png" alt="数据结构（七）——排序——快速排序14.png"> <p>同样，用low和high指向序列头和尾，然后用low作为基准进行划分，划分结果如下图。</p><img src="https://pic.imgdb.cn/item/66704ad1d9c307b7e9c59567.png" alt="数据结构（七）——排序——快速排序15.png"><p>可以看到，0<del>2这个子表再一次被刚刚选中的基准元素27划分为了左右两个部分，由于剩余的左右两个部分都只有一个元素，所以显然这两个部分不需要再进行别的处理，也就是说0</del>2这个子表当中，所有这些元素的最终位置此时都已经确定。</p><p>接下来看对4~7这个右子表的处理：</p><img src="https://pic.imgdb.cn/item/66704b6cd9c307b7e9c6ce40.png" alt="数据结构（七）——排序——快速排序16.png"><p>同样的方法，让low所指元素作为基准元素，然后进行一次划分，划分结果如下图。</p><img src="https://pic.imgdb.cn/item/66704ba8d9c307b7e9c74335.png" alt="数据结构（七）——排序——快速排序17.png"><p>这样，对于4~7这个子表，我们通过基准元素76，再次的把它划分成了更小的两个部分，对于左半部分的处理思路是一样的，处理结果如下图。</p><img src="https://pic.imgdb.cn/item/66704c08d9c307b7e9c80f30.png" alt="数据结构（七）——排序——快速排序18.png"><p>最后还剩65和97这两个元素，显然这两个元素的最终位置此时也已经确定，所以这就是快速排序的整个过程。</p><p>在快速排序中，我们会不断的进行划分这个动作，每一次的划分都会使得一个连续的序列，被分为左边和右边两个部分，左边的元素都要比基准元素小，而右边的元素都要比基准元素大，接下来只要递归的对左右两个子表分别进行划分就可以实现排序。</p><p>下面看一下具体的代码实现：</p><img src="https://pic.imgdb.cn/item/66704cd8d9c307b7e9ca33df.png" alt="数据结构（七）——排序——快速排序代码实现.png"><p>快速排序算法的代码考察频率是所有排序算法里最高的一个。如果对于递归类算法有基础的话，快速排序代码看起来会很简单。如果对递归没有了解的话，看起来可能会麻烦点。但不论会不会递归，这里都推荐看一下原视频教学，可以动态的看到算法的执行过程以及递归是如何实现的，可以加深对快速排序算法的了解与记忆。原视频跳转链接：<a href="https://www.bilibili.com/video/BV1b7411N798?p=90&vd_source=7fb4b255ed876969a742738d7b84f461">快速排序</a>。</p><p>接下来对快速排序算法的效率进行分析：</p><img src="https://pic.imgdb.cn/item/66704dfbd9c307b7e9cc7a20.png" alt="数据结构（七）——排序——快速排序时间复杂度.png"><p>根据上面的分析，再结合程序的实现，可以看到，第一层要处理0~7的范围内的元素，对他们进行一次划分，此时要把这些元素都扫描一遍，它的时间复杂度不会超过O(n)数量级。</p><p>经过第一层的划分，会确定一个元素的最终位置，这个元素把原表划分成了左右两个部分，接下来要对第二层进行一个划分。第二层的划分要扫描除第一层已经确定位置外的所有元素，此时时间复杂度也不会超过O(n)数量级。下面每层的划分同理，都不会超过O(n)数量级。</p><p>每一层的递归调用时间复杂度都不会超过O(n)，所以总的时间复杂度就是O(n*递归层数)。因此快速排序算法的时间复杂度和递归层数是息息相关的。</p><p>空间复杂度同理，如下图：</p><img src="https://pic.imgdb.cn/item/66704e2ad9c307b7e9ccdaed.png" alt="数据结构（七）——排序——快速排序空间复杂度.png"><p>每一层递归的调用都需要开辟一小片空间来保存这层函数调用相关的局部变量、返回地址之类的信息。所以递归调用的层数越深，空间复杂度也会相应的越高。由于在快速排序算法里，每一层的调用只需要几个固定的变量，所以总的空间复杂度就是O(递归层数)。</p><p>由此可以看到，要想研究快速排序算法的时间和空间复杂度，都必须先研究它的递归层数。</p><p>接下来看一下如何得到快速排序算法的递归层数：</p><p>根据之前的例子，我们可以知道，在经历第一层划分时会确定49的位置。然后经过第二层的划分，可以确定49左子表中27的位置和右子表中76的位置。然后经过第三层划分，可以确定13,38,49,97这四个元素的位置。下面经过第四层划分就可以确定最后一个元素65的位置。按层数划分的结果如下图。</p><img src="https://pic.imgdb.cn/item/66704e85d9c307b7e9cd94fd.png" alt="数据结构（七）——排序——快速排序递层数.png"><p>到这里就可以发现，用刚才的分析思路，可以把n个元素组织成一棵二叉树，而这个二叉树的层数就是递归调用的层数。所以快速排序算法的深度就可以转换成对二叉树的高度的上限和下限的判断。n个结点的二叉树的最小高度和最大高度如上图右下，这个都很熟悉，就不再赘述了。</p><p>求出了递归层数，我们就可以把层数代入之前的时间和空间复杂度之中，如下图：</p><img src="https://pic.imgdb.cn/item/66704eadd9c307b7e9cde6fd.png" alt="数据结构（七）——排序——快速排序递复杂度.png"><p>这里我们可以求得快速排序算法的最好时间和空间复杂度以及最坏时间和空间复杂度。</p><p>经过分析，可以发现，一般来说比较好的情况，就是下面这种：</p><img src="https://pic.imgdb.cn/item/66704ee8d9c307b7e9ce5ee3.png"><p>每一次选中的基准都可以将待排序序列划分为均匀的两个部分，此时递归的深度最小，算法效率最高。</p><p>而最坏的情况是下面这样：</p><img src="https://pic.imgdb.cn/item/66704f07d9c307b7e9ce9ea6.png" alt="数据结构（七）——排序——快速排序最坏的情况.png"><p>每一次选中的基准将待排序序列划分为很不均匀的两个部分，这样会导致递归深度增加，算法效率变低。</p><p>而最坏的情况是初始序列是有序或逆序，如上图，此时快速排序每次选择的都是最靠边的元素，如果按照二叉树的思路，就是我们每次都会在右子树（或者左子树）处增加高度，最后使树高为n。所以这种情况下，快速排序的性能最差。</p><p>所以，对于快速排序，我们可以采用下面提供的思路进行优化，其核心就是尽量选择可以把数据中分的基准元素：</p><img src="https://pic.imgdb.cn/item/66704f33d9c307b7e9cef8b6.png" alt="数据结构（七）——排序——快速排序算法的优化思路.png"><p>但在实际应用中，快速排序算法的平均时间复杂度其实是要将近于最好的时间复杂度的，如下图：</p><img src="https://pic.imgdb.cn/item/667055ced9c307b7e9dd8b87.png" alt="数据结构（七）——排序——快速排序算法的实际应用效率.png"><p>所以在实际应用中，快速排序这个算法是在所以内部排序算法中平均性能最优的排序算法。</p><p>最后看一下算法的稳定性如何，如下图：</p><img src="https://pic.imgdb.cn/item/667056c3d9c307b7e9df9b73.png" alt="数据结构（七）——排序——快速排序算法的稳定性.png"><p>从上图不难发现，这个算法是不稳定的。</p><p>下面对本节进行一个小结：</p><img src="https://pic.imgdb.cn/item/66705764d9c307b7e9e121b6.png" alt="数据结构（七）——排序——快速排序算法小结.png"><p>这里注意一下，上图的思维导图有错误，时间复杂度的最好和最坏情况颠倒了。另外，log是以2为底的，这里也没有显示出来，注意这两点错误。</p><p>另外，要说一点有歧义的地方，在有些教材里，对于快速排序算法所谓的一趟排序和一次划分是画了等号的，一次划分等于一趟排序。但是在408原题中，会告诉我们所谓的一趟排序是对所有的尚未确定最终位置的元素进行一遍处理，这样的一遍处理才叫一趟排序，显然与一次划分是不相同的。如果用上面的例子来看，408原题给的一趟排序的定义其实是指的对一层的处理，所以这一趟可能确定多个元素的位置。而一次划分只是对一个连续区间进行处理，一次划分只能确定一个元素的位置。这里注意一下这个歧义，如果考408就按408的方式来理解，如果自命题，建议看一下往年原题是如何定义的。</p><h2 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4. 选择排序"></a>4. 选择排序</h2><h3 id="4-1-简单选择排序"><a href="#4-1-简单选择排序" class="headerlink" title="4.1 简单选择排序"></a>4.1 简单选择排序</h3><img src="https://pic.imgdb.cn/item/66610d135e6d1bfa054d8b85.png" alt="数据结构（七）——排序——简单选择排序知识总览.png"><p>简单选择排序从大类上说属于选择排序这一大类，而除了简单选择排序，8.堆排序里学的堆排序算法也是基于选择排序的的思想。</p><p>选择排序：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列。</p><p>接下来以一个例子看一下简单选择排序是怎么样运行的：</p><img src="https://pic.imgdb.cn/item/66610e065e6d1bfa054e4221.png" alt="数据结构（七）——排序——简单选择排序例1_1.png"><p>刚开始遍历待排序元素，找到数值最小的元素，显然13是最小的，那么会把13这个位置与最前面的位置（49）进行交换。如下图：</p><img src="https://pic.imgdb.cn/item/66610ec55e6d1bfa054ecd3a.png" alt="数据结构（七）——排序——简单选择排序例1_2.png"><p>此时第一趟排序结束，接下来就不需要管最前面的位置了，第二趟从待排序元素中的第一个开始，进行遍历，找到最小元素27：</p><img src="https://pic.imgdb.cn/item/66610f305e6d1bfa054f234c.png" alt="数据结构（七）——排序——简单选择排序例1_3.png"><p>然后把27放到最前面，与最前面的位置进行调换：</p><img src="https://pic.imgdb.cn/item/66610f575e6d1bfa054f451d.png" alt="数据结构（七）——排序——简单选择排序例1_4.png"><p>到此为止第二趟排序结束。接下来按照这种方式依次进行，最后第七趟结束，得到下图的结果：</p><img src="https://pic.imgdb.cn/item/66610fcf5e6d1bfa054fa4fe.png" alt="数据结构（七）——排序——简单选择排序例1_5.png"><p>此时最后剩一个元素，不需要再处理就知道肯定是最大的一个。</p><p>因此，**<font color=red>对n个元素进行简单选择排序需要n-1趟处理。</font>**</p><p>接下来看一下简单选择排序算法实现：</p><img src="https://pic.imgdb.cn/item/6661113b5e6d1bfa0550ba7c.png" alt="数据结构（七）——排序——简单选择排序算法实现.png"><p>这个算法实现非常简单，感觉就是C语言期中难度，所以不多说了。</p><p>接下来分析一下算法性能：</p><img src="https://pic.imgdb.cn/item/666111aa5e6d1bfa055108e2.png" alt="数据结构（七）——排序——简单选择排序性能分析.png"><p>空间复杂度显然O(1)只需要定义几个变量就可以让算法顺利执行。</p><p>而对于时间复杂度，无论序列是什么样的，都要经历n-1趟处理，并且每一趟处理都要从待排序序列的头到尾，把这些关键关键字进行两两对比，因此对于一个有n个关键字的序列，需要n(n-1)&#x2F;2次对比，整体来看，它的时间复杂度都是O(n<sup>2</sup>)数量级。</p><p>接下来看算法的稳定性：</p><img src="https://pic.imgdb.cn/item/666113565e6d1bfa05525986.png" alt="数据结构（七）——排序——简单选择排序稳定性.png"><p>从上图可以看出来，<strong>该算法是不稳定的</strong>。另外，前面说的都是基于顺序表，显然用链表来实现简单排序算法也是可以适用的，就是把链表从头到尾扫描一遍，然后把最小的关键字放到链尾或链头。</p><p>最后对简单选择排序进行一个小结：</p><img src="https://pic.imgdb.cn/item/666113985e6d1bfa055297d1.png" alt="数据结构（七）——排序——简单选择排序小结.png"><h3 id="4-2-堆排序"><a href="#4-2-堆排序" class="headerlink" title="4.2 堆排序"></a>4.2 堆排序</h3><p>堆排序是选择排序思想的一种，主要的思想和上面的简单选择排序一样，每一趟在待选择排序元素中选取关键字最小（或最大）的元素加入有序子序列。堆排序是比较难理解，同时考察频率也比较高的一种排序算法。这种算法的实线基于一种叫做堆的数据结构，所以接下来先看一下什么是堆。</p><img src="https://pic.imgdb.cn/item/66724205d9c307b7e9d6716d.png" alt="数据结构（七）——排序——堆结构.png"><p>堆这种数据结构又可以进一步划分为大根堆和小根堆，大根堆和小根堆的定义如上图，如果下标为i的元素比下标为2i和2i+1的元素都大，那就是大根堆，如果下标为i的元素比下标为2i和2i+1的元素都小，那就是小根堆。</p><p>其实堆这种所谓的结构，从物理视角来看，看起来是一个连续存放的数组，但从逻辑视角上来看，我们应该把其理解为是一棵顺序存储的完全二叉树，编号为1的结点就是完全二叉树的根结点。数组下标为i的结点，它的左孩子下标就是2i，右孩子下标是2i+1。另外，当i的值小于等于n&#x2F;2时，这个结点就一定是分支结点。</p><img src="https://pic.imgdb.cn/item/6672448bd9c307b7e9da091a.png" alt="数据结构（七）——排序——大根堆.png"><p>所以，大根堆简化一点理解就是在完全二叉树当中，如果所有子树的根节点都要大于等于它的左右孩子，这样一棵顺序存储的完全二叉树就是大根堆，如上图。</p><p>同理，小根堆简化一点理解就是在完全二叉树当中，如果所有子树的根节点都要小于等于它的左右孩子，这样一棵顺序存储的完全二叉树就是小根堆，如下图。</p><img src="https://pic.imgdb.cn/item/667244b0d9c307b7e9da5a6f.png" alt="数据结构（七）——排序——小根堆.png"><p>知道了什么是堆以后，接下来就要基于堆这种数据结构进行排序，而之前也说了，堆排序在大类上属于选择排序当中的一种，而选择排序的一个基本思想就是每一趟在待选择排序元素中选取关键字最小（或最大）的元素加入有序子序列。</p><p>根据堆的特性我们可以知道，如果现在有了一个大根堆(小根堆)，那从大根堆(小根堆)里选择出关键字值最大(最小)的元素就非常方便。所以接下来要探讨的是，对于一个初始序列，如何把它建立成大根堆(小根堆)应该有的特性。</p><p>注：本节以大根堆为例进行探讨，小根堆的方法原理同大根堆一样，故没有对小根堆进行介绍。</p><p>建立大根堆：</p><img src="https://pic.imgdb.cn/item/66725b77d9c307b7e9fe24cb.png" alt="数据结构（七）——排序——建立大根堆1.png"><p>如上图，由于大根堆的特性是根大于等于左右结点，所以我们要保证所有子树的根节点都要比它的左右孩子的值要大，也就是说在上图的这棵树里，要检查所有的分支结点，因为所有的分支结点都是它所属的这棵子树的根节点。</p><p>所以接下来的思路就是把所有非终端结点都检查一遍，看看是否满足大根堆的要求，如果不满足，则进行调整。</p><p>而在之前也说过，对于顺序存储的完全二叉树，非终端结点的编号i&lt;&#x3D;[n&#x2F;2]，所以对于上例中，一共有8个结点，所以i&lt;&#x3D;[8&#x2F;2]&#x3D;4，所以我们只需要检查i小于等于4的结点即可。</p><p>接下来会从后往前，依次处理这个些结点：</p><p>第一步，处理4号结点，检查以4号结点为根的部分，是否满足大根堆的要求。</p><img src="https://pic.imgdb.cn/item/66725f9ed9c307b7e9048c10.png" alt="数据结构（七）——排序——建立大根堆2.png"><p>我们可以用上图右下角的特性来进行检查，如该例子中，检查以4号结点为根的子树，将4号结点与其左孩子和右孩子比较，由于其没有右孩子，所以只比较左孩子。根据左孩子下标是2i，可以知道左孩子是8号结点，通过比较发现以4号结点为根的子树，其根结点值小于左孩子值，不满足大根堆特性，所以要将当前结点值与其孩子中最大的一个值互换。该例将9和32互换。互换结果如下图。</p><img src="https://pic.imgdb.cn/item/66726108d9c307b7e906b4ec.png" alt="数据结构（七）——排序——建立大根堆3.png"><p>接下来处理3号结点：</p><img src="https://pic.imgdb.cn/item/6672612fd9c307b7e906ed77.png" alt="数据结构（七）——排序——建立大根堆4.png"><p>3号结点的左右孩子的下标是6和7，由于右孩子的值比其大，所以不符合大根堆的特性，所以将右孩子的值与其互换，互换结果如下图。</p><img src="https://pic.imgdb.cn/item/667261c4d9c307b7e907bd65.png" alt="数据结构（七）——排序——建立大根堆5.png"><p>接下来处理2号结点：</p><img src="https://pic.imgdb.cn/item/66726247d9c307b7e90884ed.png" alt="数据结构（七）——排序——建立大根堆6.png"><p>同理要和其最大的孩子进行互换，这里最大的孩子是45，所以和45进行互换，互换结果如下图。</p><img src="https://pic.imgdb.cn/item/66726287d9c307b7e908f6fd.png" alt="数据结构（七）——排序——建立大根堆7.png"><p>接下来处理1号结点：</p><img src="https://pic.imgdb.cn/item/667262c8d9c307b7e9095fc1.png" alt="数据结构（七）——排序——建立大根堆8.png"><p>同理，1号结点值小于其右孩子结点值，要进行互换，互换结果如下图：</p><img src="https://pic.imgdb.cn/item/66726311d9c307b7e909d39d.png" alt="数据结构（七）——排序——建立大根堆9.png"><p>这里产生了问题，当我们把53下坠以后，现在导致以53为根的这一棵子树不符合大根堆的要求，这时候就要继续用之前的方法，将53继续向下调整。现在53的左右子树中，最大的是78这个元素，所以要把53和78进行一个互换，互换结果如下图。</p><img src="https://pic.imgdb.cn/item/667263b9d9c307b7e90ad6db.png" alt="数据结构（七）——排序——建立大根堆10.png"><p>像53这样的，小元素不断向下调整的过程，一般喜欢称之为小元素不断下坠，当小元素无法继续下坠时，就意味着调整完成。</p><p>到此为止，这一整棵树就符合了大根堆的要求。</p><p>上面用手算的方式实现了大根堆的建立，接下来看一下如何用代码实现：</p><img src="https://pic.imgdb.cn/item/66726583d9c307b7e90ddd20.png" alt="数据结构（七）——排序——建立大根堆11.png"><p>上面是代码实现，这里说一个注意点，可以看到，我们的初始序列0号下标处，一直是没有存放数据的，这个位置是用来充当哨兵的，也就是用来作为交换结点值时的中间暂存位，这一点从上面代码里就可以看出。</p><p>另外，如果在0号位存放数据的话，那么它的左右孩子结点下标就无法通过2i和2i+1来查找，此时应该通过2i+1和2i+2来查找其左右孩子结点，这一点也需要注意。所以，考试时要看清题目是从0号下标开始存储还是1号下标开始存储。</p><p>如果上面代码实现有看不懂的地方，可以点击跳转链接，看代码讲解（大概10分钟~15分钟处）：<a href="https://www.bilibili.com/video/BV1b7411N798?p=92&vd_source=7fb4b255ed876969a742738d7b84f461">堆排序</a>。</p><p>在有了大根堆以后，接下来要讨论的就是怎么基于大根堆进行排序：</p><img src="https://pic.imgdb.cn/item/66726db0d9c307b7e91be0dc.png" alt="数据结构（七）——排序——基于大根堆排序.png"><p>基于选择排序的思想，每一趟会让堆顶元素加入有序子序列，即让堆顶元素与待排序序列中的最后一个元素交换。上例中，堆顶元素是87，待排序序列最后一个元素是9，所以会让87和9进行交换。交换结果如下图：</p><img src="https://pic.imgdb.cn/item/66726e34d9c307b7e91cb680.png" alt="数据结构（七）——排序——基于大根堆排序1.png"><p>我们把87换到末尾以后，87的位置就已经确定了，所以接下来的操作中，就不需要考虑87这个元素，可以看到上图，我们把87的连接线画成了虚线。</p><p>在交换以后，我们可以看到，此时根节点为9，不满足大根堆的特性，所以我们要把9下坠，将其调整为大根堆。这里由于87已经确定位置，所以在进行下坠处理时，只需要考虑前7个元素即可，不需要考虑87这个元素。所以可以看到上图右下，我们在进行大根堆处理时，传入的len变成了7，而不是8。</p><p>大根堆处理以后的结果如下图：</p><img src="https://pic.imgdb.cn/item/66726f3cd9c307b7e91e6422.png" alt="数据结构（七）——排序——基于大根堆排序2.png"><p>可以看到，此时上面待排序序列又满足了大根堆的特性，到这里就完成了第一趟处理。在第一趟排序里，我们把最大的元素移到了末尾，同时把剩余的元素恢复成了大根堆的样子。</p><p>接下来进行第二趟处理，同理将堆顶元素和待排序序列最后一个元素进行交换。</p><img src="https://pic.imgdb.cn/item/66726ff7d9c307b7e91fb472.png" alt="数据结构（七）——排序——基于大根堆排序3.png"><p>此时78和87就已经确定了位置，不需要再处理。而53换到了堆顶，破坏了大根堆的特性，所以接下来要让53这个元素下坠，进行大根堆建立处理。处理结果如下图：</p><img src="https://pic.imgdb.cn/item/66727075d9c307b7e9208708.png" alt="数据结构（七）——排序——基于大根堆排序4.png"><p>这里由于78和87已经确定了，所以不需要对78和87进行操作。因此，这里53是没有右孩子的，只需要和左孩子进行比较即可。53大于其左孩子，所以53就是该以53为根的子树的根结点，下坠完成，此时待排序序列又满足大根堆的特性。</p><p>接下来进行第三趟处理，将65和09进行互换：</p><img src="https://pic.imgdb.cn/item/667270fed9c307b7e9218215.png" alt="数据结构（七）——排序——基于大根堆排序5.png"><p>同理，对09进行下坠处理：</p><img src="https://pic.imgdb.cn/item/66727136d9c307b7e921daa5.png" alt="数据结构（七）——排序——基于大根堆排序6.png"><p>第四趟处理，堆顶53和堆底17进行互换：</p><img src="https://pic.imgdb.cn/item/6672716fd9c307b7e92232da.png" alt="数据结构（七）——排序——基于大根堆排序7.png"><p>同理，对17进行下坠处理：</p><img src="https://pic.imgdb.cn/item/66727193d9c307b7e922685d.png" alt="数据结构（七）——排序——基于大根堆排序8.png"><p>第五趟处理，堆顶45和堆底17进行互换：</p><img src="https://pic.imgdb.cn/item/667271cbd9c307b7e922c1bd.png" alt="数据结构（七）——排序——基于大根堆排序9.png"><p>同理对17进行下坠处理：</p><img src="https://pic.imgdb.cn/item/6672721dd9c307b7e9235640.png" alt="数据结构（七）——排序——基于大根堆排序10.png"><p>第六趟处理，堆顶32和堆底09进行互换：</p><img src="https://pic.imgdb.cn/item/66727247d9c307b7e923a509.png" alt="数据结构（七）——排序——基于大根堆排序11.png"><p>同理，对09进行下坠处理：</p><img src="https://pic.imgdb.cn/item/6672726fd9c307b7e923e3bf.png" alt="数据结构（七）——排序——基于大根堆排序12.png"><p>第七趟处理，堆顶17和堆底09进行互换：</p><img src="https://pic.imgdb.cn/item/667272b9d9c307b7e9245f76.png" alt="数据结构（七）——排序——基于大根堆排序13.png"><p>此时只剩下最后一个待排序元素，则位置已经确定，所以不用再进行调整，最后结果如下图。</p><img src="https://pic.imgdb.cn/item/66727301d9c307b7e924d4ba.png" alt="数据结构（七）——排序——基于大根堆排序14.png"><p>所以，对于n个元素的序列，在经过了n-1趟处理以后，就可以得到一个递增的元素序列。注意，刚刚是基于大根堆来进行这样的排序，如果是基于小根堆的话，最终得到的应该是递减序列。</p><p>弄清楚原理以后，接下来看一下如何用代码实现基于大根堆的排序：</p><img src="https://pic.imgdb.cn/item/6672744cd9c307b7e9280b4a.png" alt="数据结构（七）——排序——基于大根堆排序代码实现.png"><p>大根堆的排序主要就是将堆顶和堆底元素进行互换，剩下的就是调用上面说的大根堆建立的代码以保证待排序序列是大根堆，所以重点还是大根堆的建立（就是每次交换以后，要保证待排序元素是大根堆，所以需要不断的进行元素下坠的处理），其余的就很简单。个人感觉，这一块重点还是要掌握大根堆建立的代码，只要掌握了大根堆建立的代码实现，剩下的这些操作就是最基础的C语言交换程序。</p><p>下面我们把上面的实现过程汇总起来，如下图：</p><img src="https://pic.imgdb.cn/item/66727563d9c307b7e929f2d9.png" alt="数据结构（七）——排序——基于大根堆排序算法效率分析.png"><p>到此为止，我们就知道了整个堆排序分为这样的两个大步骤，第一步需要建立一个初始的堆，然后有了堆以后才可以根据这个堆进行排序，而在建堆时需要调用下坠调整的函数，当我们在排序时，同样也需要调用下坠调整的函数。所以必须分析下坠调整这个函数的时间复杂度是多少，我们才有可能知道整个堆排序的时间复杂度。</p><p>下面看这样的一个例子，如下图，假设现在要调整09这个元素，让它下坠。</p><img src="https://pic.imgdb.cn/item/667277fdd9c307b7e92e6b49.png" alt="数据结构（七）——排序——基于大根堆排序算法效率分析1.png"><p>根据代码的逻辑，我们第一步应该对比09这个元素的左右孩子之间，谁更大，所以这涉及到1次关键字对比。然后当确定了一个更大的孩子以后，接下来还需要把根节点和这个更大的孩子进行一次对比，所以这又涉及到了一次关键字对比。所以一个结点如果有左右两个孩子的话，那它往下下坠一层，总共需要对比两次关键字。如下图。</p><img src="https://pic.imgdb.cn/item/66727832d9c307b7e92ec60e.png" alt="数据结构（七）——排序——基于大根堆排序算法效率分析2.png"><p>接下来，09这个元素还需要继续下坠，此时总共有8个元素，09这个元素的编号是4，然后它的左孩子编号应该是8，那由于此时左孩子的编号和元素的总数是相等的，说明此时的左孩子是没有右兄弟的，因此就不需要再对比左右孩子的关键字。所以如果当前这个结点只有左孩子的话，那只需要进行一次关键字对比，如下图。</p><img src="https://pic.imgdb.cn/item/6672785ad9c307b7e92f0c16.png" alt="数据结构（七）——排序——基于大根堆排序算法效率分析3.png"><p>经过上面的一系列分析可以知道，一个结点每下坠一层，最多只需要对比关键字2次，所以如果树高为h，然后某个结点在第i层，那这个结点最多只需要下坠h-i层，而每下坠一层最多需要对比两次关键字，所以总的来看，关键字对比次数不会超过2(h-i)次。</p><p>而之前说过，对于一个完全二叉树来说，如果有n个结点，那树高h&#x3D;[log<sub>2</sub>n]+1。另一方面，对于一个完全二叉树，它的第i层最多有2<sup>i-1</sup>个结点。而我们在建立一个初始堆的时候，最下面一层的结点是不要调整的，只有上面的h-1层需要进行下坠调整。</p><p>基于这个思想，我们考虑最坏的情况，即每一层每一个结点都要进行下坠，且有左右孩子，及要对比两次关键字，所以最坏算出的结果如下面的等式，而这个式子经过化简代换处理，最后是小于等于4n的，所以在我们建堆的过程中，关键字的对比次数不会超过4n次，即建堆的时间复杂度为0(n)数量级。如下图。</p><p>这里说一下，关于这个式子的推导过程是比较负杂的，有兴趣可以去看下讲解，讲解链接（大概24~26分钟处）：<a href="https://www.bilibili.com/video/BV1b7411N798?p=92&vd_source=7fb4b255ed876969a742738d7b84f461">堆排序</a>。当然如果没时间或理解不了的话，也可以不关注过程，但结果一定要记住。</p><img src="https://pic.imgdb.cn/item/66727b06d9c307b7e933d327.png" alt="数据结构（七）——排序——基于大根堆排序算法效率分析4.png"><p>现在我们知道了建堆过程是O(n)数量级，也就是说对于下图程序实现的第一步，建立初始堆时需要O(n)数量级的时间复杂度：</p><img src="https://pic.imgdb.cn/item/66727dfcd9c307b7e938ad92.png" alt="数据结构（七）——排序——基于大根堆排序算法效率分析5.png"><p>现在看一下排序的过程的时间复杂度。从上图程序可以看到，整个排序的过程需要进行n-1趟，而每一趟都会把堆底元素交换到堆顶，交换到堆顶的元素又会不断下坠，而这个下坠调整最多会进行h-1层，且之前说过，每下坠一层，最多需要进行两次关键字对比，也就是说关键字每下坠一层，时间开销只需要常数级就可以完成。</p><p>这样看来，根结点总共最多下坠h-1层，那么对根结点的下坠调整，其时间复杂度就不可能超过O(h)这个数量级，而完全二叉树的树高h&#x3D;[log<sub>2</sub>n]+1，所以，每进行一趟的排序，最坏的时间复杂度不可能超过O(log<sub>2</sub>n)这样的数量级。而总共需要进行n-1趟处理，所以排序的总的时间复杂度就应该是O(nlog<sub>2</sub>n)这样的一个数量级。</p><p>因此，一次完整的一个堆排序，需要O(n)的时间来建堆，然后还需要O(nlog<sub>2</sub>n)的时间进行排序，那两个大O相加，只保留更高阶的一项，所以整体来看，时间复杂度应该是O(nlog<sub>2</sub>n)的这样一个量级。而空间复杂度，因为只使用了固定数量的几个常量，所以显然就是O(1)数量级。</p><img src="https://pic.imgdb.cn/item/66728571d9c307b7e9469069.png" alt="数据结构（七）——排序——堆排序的空间和时间复杂度.png"><p>最后，要探讨一下，堆排序的稳定性如何：</p><img src="https://pic.imgdb.cn/item/667285e5d9c307b7e9474cf5.png" alt="数据结构（七）——排序——堆排序的稳定性.png"><p>如上图的例子，假设初始给的序列是122，现在在初始序列的基础上建立一个大根堆，此时调整根结点，由于左右孩子结点都比根结点要大，所以肯定需要进一次交换。但是现在问题产生了，左右孩子的值都是一样的，根据代码的逻辑，此时优先交换左孩子。因此会把带下划线的2给换上去。</p><p>到此完成了建堆的工作，接下来看排序的过程：把堆顶元素和堆底元素进行交换，如下图：</p><img src="https://pic.imgdb.cn/item/66728728d9c307b7e9497b16.png" alt="数据结构（七）——排序——堆排序的稳定性1.png"><p>此时剩余的元素依然是一个大根堆，所以接下来进行第二趟排序，同样堆顶和堆底进行交换，到此进行了3-1趟排序，排序结束，排序结果如下图：</p><img src="https://pic.imgdb.cn/item/6672876dd9c307b7e949eadc.png" alt="数据结构（七）——排序——堆排序的稳定性2.png"><p>根据排序结构，显然堆排序是不稳定的。</p><p>下面对本节进行小结：</p><img src="https://pic.imgdb.cn/item/6672880dd9c307b7e94af366.png" alt="数据结构（七）——排序——堆排序小结.png"><p>最后再强调一下，本部分只介绍了大根堆的建立与排序，小根堆的思想方法是同理的，所以没有对小根堆进行介绍，不过下面留了一道有关小根堆的练习题，左边是初始序列，右边是进行小根堆建立的结果，可以自己试着去对初始序列进行小根堆建立，然后看看与右边的结果一不一样，之后还可以试着进行排序，但是要注意，小根堆排序的结果是递减序列，与大根堆刚好相反。</p><img src="https://pic.imgdb.cn/item/667288eed9c307b7e94c7b41.png" alt="数据结构（七）——排序——小根堆练习.png"><h3 id="4-3-堆的插入和删除"><a href="#4-3-堆的插入和删除" class="headerlink" title="4.3 堆的插入和删除"></a>4.3 堆的插入和删除</h3><p>如果有了一个大根堆或小根堆，那么现在要往这个堆里插入或删除一个元素，那应该如何做呢？</p><p>下面首先看一下如何插入一个新元素：</p><img src="https://pic.imgdb.cn/item/66751f86d9c307b7e99ac4b8.png" alt="数据结构（七）——排序——堆插入.png"><p>如上图的小根堆，现在要往这个小根堆里插入一个新元素13，那么这个新插入的13会首先放到表尾的位置，从逻辑视角来看就是放到了堆底这个地方。如下图。</p><img src="https://pic.imgdb.cn/item/6675203ad9c307b7e99be94b.png" alt="数据结构（七）——排序——堆插入1.png"><p>插入13以后，原本蓝色区域是一个小根堆，现在插入13以后就破坏了原小根堆的特性，即根结点要小于左孩子和右孩子。此时我们需要进行调整处理。</p><p>处理方法：将新元素与父结点相比较，如果新元素比父节点大，则不需要调整；如果新元素比父节点小，则二者互换，然后继续与父结点比较，如果还比父节点小，则继续上升，就这样，直到无法继续上升为止。</p><p>看上图，新元素是插到表尾下标为9的位置，要找其父结点只需要通过[i&#x2F;2]即可找到，这里[9&#x2F;2]&#x3D;4，所以13的父节点存储在下标为4的地方，存储值为32。现在将13与32比较发现13小于32，所以将13与32互换。如下图。</p><img src="https://pic.imgdb.cn/item/667521c5d9c307b7e99f1f3e.png" alt="数据结构（七）——排序——堆插入2.png"><p>换完以后，还不能停止，还要继续让13与其父结点比较。同理，先找到父结点存储在下标为[4&#x2F;2]&#x3D;2的地方，存储值为17，将13与17比较，发现13小于17，所以要继续互换。如下图。</p><p><img src="https://pic.imgdb.cn/item/66752288d9c307b7e9a07115.png" alt="数据结构（七）——排序——堆插入3.png">13与17互换以后，调整仍没有结束，接下来要继续向上与父结点对比，13与9对比，发现13不小于9，所以无需互换，此时调整完成。总的来看，<strong>插入13一共经历了3次关键字对比</strong>。</p><p>接下来看插入新元素46：</p><img src="https://pic.imgdb.cn/item/667522fcd9c307b7e9a13997.png" alt="数据结构（七）——排序——堆插入4.png"><p>插入46以后，同理和父结点比较，大于父结点，所以不需要调整，插入结束。<strong>插入新元素46只需要对比关键字1次</strong>。</p><p>接下来看如何删除一个元素：</p><p>还是上面的例子，现在如果删除13这个元素，删除13以后，如下图，此时13的位置看出来，接下来该如何处理呢？</p><img src="https://pic.imgdb.cn/item/667529acd9c307b7e9af8f01.png" alt="数据结构（七）——排序——堆删除1.png"><p>此时，我们会用堆底的元素来代替被删除的元素，也就是让46移到13之前存储的位置。如下图。</p><img src="https://pic.imgdb.cn/item/667529f6d9c307b7e9b02804.png" alt="数据结构（七）——排序——堆删除2.png"><p>此时，我们需要让这个整体恢复成小根堆该有的特性，所以我们需要让46这个元素不断下坠，直到无法下坠为止。也就是说，46会和它下一层的两个结点对比，让更小的一个孩子和其交换（这里对比的过程和大根堆一样，先让两个孩子比较，选择较小的那个和46比较，如果较小的那个还比46大，则不需要下坠，否则将其互换）。该例46和17互换，结果如下图。</p><img src="https://pic.imgdb.cn/item/66752aebd9c307b7e9b277e5.png" alt="数据结构（七）——排序——堆删除3.png"><p>接下来46要继续和下一层对比，将一个更小的元素置换上来，这里46和32互换。结果如下图。</p><img src="https://pic.imgdb.cn/item/66752b18d9c307b7e9b2d097.png" alt="数据结构（七）——排序——堆删除4.png"><p>到这一步，46无法再继续下坠，所以对堆的调整就结束了。整个过程中，需要4次对比关键字（第一次17和45，第二次17和46，第三次53和32，第四次32和46）。</p><p>注意，这里要注意关键字的对比次数，考试时有可能会出相关题型。在4.2里已经讲过下坠过程中关键字对比的次数，如果只有孩子只有1个，则只需要对比1次，如果孩子有2个，则需要对比2次。这个地方忘了可以回去看一下4.2的内容。</p><p>下面，再看一个删除的例子，还是上面的例子，此时删除65，此时65位置空出，我们就要用堆底元素46进行替换，替换完以后可以发现46小于其孩子结点，所以不需要下坠，如下图。这个过程中会进行2次关键字对比（第一次78和87，选出小的一个，然后第二次用较小的78和46比较，78大于46，所以不需要下坠）。</p><img src="https://pic.imgdb.cn/item/66752cf0d9c307b7e9b686eb.png" alt="数据结构（七）——排序——堆删除5.png"><p>接下来对该部分进行一个小结：</p><img src="https://pic.imgdb.cn/item/66752d49d9c307b7e9b764ef.png" alt="数据结构（七）——排序——堆插入和删除小结.png"><h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><img src="https://pic.imgdb.cn/item/66752d95d9c307b7e9b824fd.png" alt="数据结构（七）——排序——归并排序.png"><p>所谓归并排序就是将两个或多个已经有序的序列合并成一个。如上图，已经有了两个有序序列，然后我们会定义一个更大的数组，这样才能将这两个序列合并到一起。接下来可以设置如图的三个指针，然后每次对比i和j所指的两个元素，将更小的一个放到k的位置。</p><p>如上图例子，此时i和j分别指向12和7，很明显更小的元素是7，所以将7放到k所指的位置，然后将j和k都向后移动一位，处理结果如下图：</p><img src="https://pic.imgdb.cn/item/667537bfd9c307b7e9ce7c06.png" alt="数据结构（七）——排序——归并排序过程1.png"><p>接下来继续比较i和j所指位置的元素大小，10小于12，所以把10放到k所指位置，然后j和k都后移，如下图：</p><img src="https://pic.imgdb.cn/item/667537f9d9c307b7e9cef312.png" alt="数据结构（七）——排序——归并排序过程2.png"><p>接下来继续比较i和j所指位置的元素大小，12小于21，所以把12放到k所指位置，然后i和k都后移，如下图：</p><img src="https://pic.imgdb.cn/item/66753824d9c307b7e9cf5152.png" alt="数据结构（七）——排序——归并排序过程3.png"><p>接下来，放入16、24，这两个同理，就不再叙述，直接看接下来的情况：</p><img src="https://pic.imgdb.cn/item/66753864d9c307b7e9cff3d2.png" alt="数据结构（七）——排序——归并排序过程4.png"><p>此时i和j所指元素都是24，这个时候由于代码是我们自己写的，所以我们既可以让i所指24放到k处，也可以让j所指24放到k处，这两种处理方式都可以。一般情况下，我们会让左边的优先，也就是说我们会让i所指24放到k的位置。如下图。</p><img src="https://pic.imgdb.cn/item/667538ded9c307b7e9d12462.png" alt="数据结构（七）——排序——归并排序过程5.png"><p>接下来还是同理，我们直接跳到最后：</p><img src="https://pic.imgdb.cn/item/66753959d9c307b7e9d22ed8.png" alt="数据结构（七）——排序——归并排序过程6.png"><p>当我们把j所指的37放入k处以后，将j和k都向后移动，此时j所指位置已经超出数组范围，这就说明右边这个数组所有的元素都已经进行了合并，所以接下来就不需要再进行关键字的对比，可以直接把左边表里的所有元素直接放到总表的表尾当中，如下图。</p><img src="https://pic.imgdb.cn/item/667539bdd9c307b7e9d2d5f1.png" alt="数据结构（七）——排序——归并排序过程7.png"><p>到此，就完成了两个有序序列的归并。</p><p>接下来要引入一个概念——2路归并。</p><img src="https://pic.imgdb.cn/item/66753a8dd9c307b7e9d43edf.png" alt="数据结构（七）——排序——二路归并.png"><p>所谓2路归并就是刚刚做的这个过程，把两个有序序列合二为一。所以在进行二路归并时，每当要选出一个更小的元素，只需要对比i所指元素和j所指元素谁更小，这里只需要对比一次就可以选出。</p><p>既然有二路归并，当然也可以有多路归并，比如说如下图的四路归并。</p><img src="https://pic.imgdb.cn/item/66753c43d9c307b7e9d82bb0.png" alt="数据结构（七）——排序——四路归并.png"><p>如上图，给出了4个有序的数组，如果把这四个数组合四为一，这样的一个合四为一的过程就是所谓的四路归并。在上图里，设置了4个指针P1、P2、P3、P4分别指向这四个有序数组当中目前剩余的最小的一个元素，现在要把这四个数组进行归并，就需要每一次都从这四个数组当中挑选出最小的一个元素放到k的位置处。由于总共有四个元素，所以至少需要对比关键字3次，才可以挑出最小的一个。</p><p>所以这里，我们可以总结出一个结论，<font color=red><strong>如果进行m路归并，每选出一个最小（或最大）的元素就需要对比关键字m-1次</strong></font>。因此，如果归并路数越多，挑选一个关键字所需要的对比次数就越多。</p><p>在进行内部排序时，归并排序通常使用二路归并来实现，如下图。</p><img src="https://pic.imgdb.cn/item/66753c71d9c307b7e9d87b6b.png" alt="数据结构（七）——排序——归并排序手算模拟.png"><p>如果一开始给出一个初始序列，那么刚开始会把这个初始序列当中的每一个单独的元素都看做是一个一个独立的、已经排好序的部分。</p><p>首先，第一趟归并排序，会把相邻的两个部分分别进行二路归并，如上图第一趟归并（由于6单出来，所以单独对其进行归并就相当于什么也没做）。</p><p>接下来，第二趟归并排序，会基于第一趟结果，再次对第一趟归并的结果进行归并，同样如图。</p><p>经过第二趟归并以后，会得到两个已经有序的子序列，所以最后一趟归并排序，只需要再把这两个有序子序列给归并起来，就可以得到一个整体有序的序列。</p><p>经过上面过程的了解可以看到，**归并排序最最重要的一个核心操作就是要能够<font color=red>把数组当中两个有序的序列归并为一个</font>**。</p><p>接下来看如何用代码实现这个核心操作：</p><img src="https://pic.imgdb.cn/item/66753f5ad9c307b7e9deaa5a.png" alt="数据结构（七）——排序——两个有序序列的归并代码实现.png"><p>比如现在有一个如上图的数组A，3到6这个范围是已经有序的，7到9这个范围也是有序的，两个有序子序列相邻，那么会用low指针指向最前面的这个元素，mid指针指向第一个有序子序列的最后一个元素，然后再用high指针指向第二个有序子序列的最后一个元素。这样的话就可以用low、mid、high来区分出要归并的两个有序子序列的范围。</p><p>现在看一下上图的代码是如何实现合并这两个有序子序列的，在这首先会定义一个辅助的数组B，这个数组的大小和A数组一致。现在要归并的是A数组当中low到mid的这个子序列和mid+1到high这个子序列，这两个子序列原本就已经是有序的。</p><p>接下来第一个for循环，会把A数组当中的元素复制到B数组当中。这里用k指针指向low，然后把k所指的元素放到B中，再进行自加操作，将下一个元素放到B中，直到k指针把最后一个元素放到B以后，再次进行自加操作，此时k的指向已经超过high，到此意味着复制完成。</p><p>接下来进入第二个循环，这个for循环所做的事情就是进行归并，如下图：</p><img src="https://pic.imgdb.cn/item/66754522d9c307b7e9ecd1eb.png" alt="数据结构（七）——排序——两个有序序列的归并代码实现1.png"><p>这里用i指针指向第一个有序子序列当中的第一个元素，j指针指向第二个有序子序列当中的第一个元素，k所指位置就是接下来i和j比较得到的小元素的存放位置。这里的过程和前面演示的一样，所以不再重复叙述。</p><p>这里要注意一点，在上面合并的过程中，会出现下图这种i和j所指位置元素一样的情况，这个时候两个元素相等，为了保证算法的稳定性，我们会采用前面的那个元素，将其放到k的位置。</p><img src="https://pic.imgdb.cn/item/667545c3d9c307b7e9ee4082.png" alt="数据结构（七）——排序——两个有序序列的归并代码实现2.png"><p>当其中一个序列的元素全部放入到A数组中以后，这个for循环就会结束，如下图：</p><img src="https://pic.imgdb.cn/item/6675467bd9c307b7e9efc3f7.png" alt="数据结构（七）——排序——两个有序序列的归并代码实现3.png"><p>此时j指向指向超过第二个子序列的范围，这意味着第二个子序列已经全部放入A数组中，此时for循环结束，接下来的while循环会将另一个子序列的剩下的没有归并完的部分复制到A数组的尾部。到此，将两个有序子序列归并的过程就已经结束了。</p><p>接下来看一下实现归并排序的完整的程序：</p><img src="https://pic.imgdb.cn/item/6675479dd9c307b7e9f27f5d.png" alt="数据结构（七）——排序——两个有序序列的归并代码实现4.png"><p>我们要对一个数组A进行排序，那么会用low和high来这指明这个归并元素的范围，然后会用mid&#x3D;(low+high)&#x2F;2把这一整个无序的序列从中间拆分成左右两部分，左半部分是low到mid，右半部分是mid+1到high，接下来会分别对左半部分和右半部分递归的进行归并排序，经过递归归并排序处理后，左右两个部分都会变得有序，接下来再用上面提到的归并函数，将左右两个有序的子序列进行归并即可。</p><p>注意，这里的牵扯到递归，如果看不懂的话，可以跳转链接，去听动态讲解：<a href="https://www.bilibili.com/video/BV1b7411N798?p=94&vd_source=7fb4b255ed876969a742738d7b84f461">归并排序</a>。</p><p>接下来分析一下归并排序算法的效率：</p><img src="https://pic.imgdb.cn/item/66756b97d9c307b7e9492a7c.png" alt="数据结构（七）——排序——归并排序算法的效率.png"><p>如上图归并排序的示意图，有些地方会把其称为归并树，因为它的形态就像一个倒立的二叉树，如果我们把其看成一个倒立的二叉树，那就可以用熟悉的二叉树的知识对其进行分析。</p><p>看上图，如果把其看成一个倒立的二叉树，那树高就为h，归并排序的趟数就为h-1趟，所以可以用这些特性来推算出，含有n个元素的表进行二路归并排序总共需要多少趟。</p><p>而二叉树的第h层最多有2<sup>h-1</sup>个结点，所以如果有n个元素，它所对应的归并树树高为h的话，由于n个元素都应该出现在最后一层，所以应该满足n&lt;&#x3D;2<sup>h-1</sup>这个式子，解这个式子可得<strong>h-1&#x3D;⌈log<sub>2</sub>n⌉</strong>。注意一下，这个式子，如果log<sub>2</sub>n为整数，则h-1&#x3D;log<sub>2</sub>n，如果log<sub>2</sub>n不是整数，则h-1&#x3D;(log<sub>2</sub>n)+1，这是因为h-1是归并趟数，归并趟数不可能为小数，这里的”⌈ ⌉”符号是向上取整符号，千万别和取整符号”[ ]”混淆，”[ ]”取整符号同向下取整” ⌊ ⌋ “是一个意思。</p><p>由于h-1是归并趟数，且<strong>h-1&#x3D;⌈log<sub>2</sub>n⌉</strong>，所以n个元素进行2路归并排序，归并的总趟数就应该是⌈log<sub>2</sub>n⌉，而每一趟归并的时间复杂度都是O(n)数量级，所以算法的总体时间复杂度就应该是每一趟的时间O(n)再乘总趟数log<sub>2</sub>n，就应该是**O(nlog<sub>2</sub>n)**数量级。</p><p>这里可能会对每一趟归并的时间复杂度都是O(n)数量级这个地方有疑问，这里解释一下为什么是O(n)。可以看上面的例子，假设进行最后一趟排序，就是基于第二趟排序的结果，要把第二趟排序产生的两个有序子序列合二为一。合并的过程中会使用i和j两个指针分别指向当前子序列所剩余的最小的元素，然后每对比关键字一次，就可以从中挑出一个更小的元素，那最终把这两个有序子表合二为一，所需要进行的关键字对比次数肯定是小于等于n-1次的，也就是说最多进行n-1次对比，就一定可以完成这一趟归并。所以最后一趟归并，它的关键字对比次数最多是n-1，也就是O(n)数量级。再分析基于初始序列的第一趟归并，把初始序列进行两两对比，那每一对元素都只需要进行一次关键字对比，因此第一趟的归并所需要的关键字对比次数约等于n&#x2F;2，也是O(n)数量级。所以不管是哪一趟的归并，我们所需要的关键字对比次数都是O(n)这样的一个数量级，因此每一趟归并的时间复杂度也是O(n)这个数量级。</p><p>对于归并排序来说，无论给出的初始序列到底是有序还是无序又或者是任何一种状态，最终时间复杂度肯定都是O(nlog<sub>2</sub>n)这个数量级。也就是说归并排序的最好、最坏和平均时间复杂度都是一样的，都是O(nlog<sub>2</sub>n)。</p><p>接下来看空间复杂度，归并排序的空间复杂度主要来自于上面提到的辅助数组B，我们定义的辅助数组B和原本用于存放元素的数组A是同样的大小，长度为n，所以空间复杂度是O(n)。</p><p>对于空间复杂度可能会有疑问，因为归并排序算法是用递归的方式实现的，既然涉及到递归，递归工作栈也是需要一定的辅助空间的，但是因为递归深度不会超过⌈log<sub>2</sub>n⌉这样一个数量级，所以递归带来的空间复杂度应该是O(log<sub>2</sub>n)，它和数组带来的O(n)复杂度进行相比，是低阶的，所以把这两个部分相加，只需要保留更高阶的O(n)，所以整体来看的空间复杂度主要还是受辅助空间B的影响。</p><p>除了上面的空间复杂度和时间复杂度，还要看这个算法的稳定性，而稳定性我们已经说过了，当我们对两个连续的有序子序列进行归并时，如果说在两边同时出现了关键字值相等的情况，那我们会优先让靠前的元素合并，所以归并排序是一个稳定的算法。</p><p>下面对该部分进行小结：</p><img src="https://pic.imgdb.cn/item/66756d3dd9c307b7e94d1bb0.png" alt="数据结构（七）——排序——归并排序算法小结.png"><p>注意，当我们进行内部排序时，归并算法常采用2路归并，但如果将归并算法用于外部排序的话，那就还会使到更多路的归并排序。</p><h2 id="6-基数排序"><a href="#6-基数排序" class="headerlink" title="6. 基数排序"></a>6. 基数排序</h2><p>基数排序不同于之前的排序，之前的排序都是采用比较关键字的大小来进行排序，而基数排序并非如此，下面直接以一个例子说明基数排序的工作方式：</p><img src="https://pic.imgdb.cn/item/667594d0d9c307b7e9c2791e.png" alt="数据结构（七）——排序——基数排序示例1.png"><p>如上图，假设有如图的一些无序序列，现在需要用基数排序将其排为一个递减的序列。注意观察会发现，这里所有的关键字都可以拆分成三个部分，分别是个位、十位和百位。并且个十百这三个部分有可能得到的取值都可能是0<del>9，所以可以建立如图的十个辅助队列，分别对应每一位的取指为0</del>9的十种情况。</p><p>接下来进行第一趟处理，以个位进行分配，第一个元素个位是0，所以把520这个元素放到Q0这个队列中，如下图：</p><img src="https://pic.imgdb.cn/item/6675962ed9c307b7e9c7787b.png" alt="数据结构（七）——排序——基数排序示例2.png"><p>在这个图示当中，辅助队列靠近上面的部分是队头的方向，靠近下方的是队尾的方向。</p><p>接下来的元素同520一样，都按照个位的值进行分配，分配的结果如下图：</p><img src="https://pic.imgdb.cn/item/667596c1d9c307b7e9c9209f.png" alt="数据结构（七）——排序——基数排序示例3.png"><p>这样我们就完成了第一趟的分配操作，也就是以各个关键字的个位作为参考来进行分配。</p><p>在分配结束以后，接下来要进行的操作叫收集，就是要把各个队列里的元素给收集起来组织成一个统一的链表。由于最终是想得到一个递减的排序序列，所以应该从各位值最大的队列开始收集，如下图。</p><img src="https://pic.imgdb.cn/item/6675976cd9c307b7e9cb4541.png" alt="数据结构（七）——排序——基数排序示例4.png"><p>第一个Q9这个队列是空的。第二个Q8这个队列里有三个元素，队头元素是438，然后它指向下一个元素888，888又指向队尾元素168，那把这三个结点从辅助队列中拆下来，就如下图的样子：</p><img src="https://pic.imgdb.cn/item/66759804d9c307b7e9ccf7bd.png" alt="数据结构（七）——排序——基数排序示例5.png"><p>接下来会依次把Q7、Q6……Q1辅助队列中的元素依次放到收集队列队尾，最后收集的结果如下图：</p><img src="https://pic.imgdb.cn/item/667598fdd9c307b7e9cfc586.png" alt="数据结构（七）——排序——基数排序示例6.png"><p>到这里就完成了第一趟的收集工作，由于第一趟的分配是按个位进行分配的，所以按照这种收集方式，最终会得到一个按照个位递减的排序序列。</p><p>接下来基于第一趟排序的结果进行第二趟排序，如下图，还是同样的辅助队列，不过此次排序是以十位进行分配：</p><img src="https://pic.imgdb.cn/item/667599cfd9c307b7e9d235bd.png" alt="数据结构（七）——排序——基数排序示例7.png"><p>第二趟分配的结果如下图：</p><img src="https://pic.imgdb.cn/item/66759a76d9c307b7e9d4697d.png" alt="数据结构（七）——排序——基数排序示例8.png"><p>可以看到，经过第一趟按个位分配以后，这时候再按十位分配，如果十位相同的话，<strong>个位越大的就越先入队</strong>。</p><p>接下来进行第二趟收集，收集结果如下图：</p><img src="https://pic.imgdb.cn/item/66759b28d9c307b7e9d68678.png" alt="数据结构（七）——排序——基数排序示例9.png"><p>第二趟收集会得到按十位递减排序的序列，如果十位相同的话，就会按个位递减排序。</p><p>接下来进行第三趟排序，第三趟排序会按百位进行分配，分配结果如下图：</p><img src="https://pic.imgdb.cn/item/66759b74d9c307b7e9d770a3.png" alt="数据结构（七）——排序——基数排序示例10.png"><p>可以看到，<strong>在百位相同的情况下，十位越大的就越先入队，如果十位相同的情况下，个位越大的就越先入队</strong>。</p><p>接下来看第三趟的收集：</p><img src="https://pic.imgdb.cn/item/66759cbfd9c307b7e9db3689.png" alt="数据结构（七）——排序——基数排序示例11.png"><p>到这里，就得到了一个全局来看有序的递减序列，因为第三趟的分配是按百位进行分配的，然后又是按照百位从大到小的顺序来收集，所以第三趟分配其实是得到了一个按照百位递减的序列，当百位相同时，又会按照十位递减顺序排列，当十位相同时，又会按照个位递减顺序排列。呈现出这个规律的原因是因为算法第一趟是按照个位分配和收集，第二趟是按照十位分配和收集，第三趟是按照百位分配和收集，这个排序过程是基础排序的原理。</p><p>这里把这个例子的排序过程汇总在下面这张图里，方便对比学习：</p><img src="https://pic.imgdb.cn/item/66759e6fd9c307b7e9e037c1.png" alt="数据结构（七）——排序——基数排序示例12.png"><p>到此，我们就可以把基础排序的过程用文字总结如下图：</p><img src="https://pic.imgdb.cn/item/66759ee1d9c307b7e9e17881.png" alt="数据结构（七）——排序——基数排序.png"><p>假设有一个表长为n的线性表，然后每个节点的关键字都可以拆分为d元组，像上面的例子就是把它拆分成了三元组，分别是百位、十位和个位。那把d元组进行一个编号分别是d-1到0这样的d个编号，最靠近左边的这一位被称为最高位关键字（或叫最主位关键字），最靠近右边的这一位被称为最低位关键字（或叫最次位关键字）。像上面的例子中，百位就是最高位关键字，而个位就是最低位关键字，因为百位的数值是对整个关键字的数值影响最大、最高的，所以我们把它称为最高位的关键字，而个位的数值是对整个关键字的数值影响最小、最低的，所以我们把它称为最低位的关键字。</p><p>由于每一位有可能得到的取值是0到r-1，所以r称为基数。像上面的例子就是0~9这样的一个取值范围，基数r&#x3D;10，说明关键字的每个部分都有可能得到十种不同的取值。</p><p>如果我们要用基数排序得到一个递减的序列的话，其过程如下：</p><ol><li>由于每个关键字位可能得到r种取值，所以需要设置r的辅助队列，来分别对应这r种取值。这r个队列的编号为Qr-1,Qr-2，……，Q0。</li><li>根据关键字位权重递增的次序（例：个-&gt;十-&gt;百）来对这d个关键字分别做分配和收集。</li><li>顺序扫描各个元素，如果当前处理的关键字位等于x，那就要放到Qx队列的队尾。</li><li>由于要得到递减序列，所以会从值更大的队列开始收集。</li></ol><p>上面是基数排序得到递减序列的过程，下面看一下得到递增序列的过程：</p><img src="https://pic.imgdb.cn/item/66762900d9c307b7e9ae4238.png" alt="数据结构（七）——排序——基数排序递增序列.png"><p>可以看到要想得到递增序列，只需要在收集各个位时，先从值更小的队列开始收集，就可以得到一个递增的序列。</p><p>接下来对基数排序算法效率进行分析：</p><img src="https://pic.imgdb.cn/item/667629bed9c307b7e9af80c7.png" alt="数据结构（七）——排序——基数排序算法效率分析.png"><p>基数排序算法大多数情况下都是基于链式存储的结构来实现，所以上面给出的图示就是一个单链表，其结构定义在上图左。然后会定义十个队列，由于队列中链接的元素就是一个一个的结点，所以十个队列就是十个链式队列。每个队列从代码角度看就是定义了一个队头指针和队尾指针，队头指针指向最上面的元素，队尾指针指向最下面的元素，虽然上图没有画出，但要清楚一个队列中各个结点间是用指针互相连接起来的。而上面定义了十个队列，其实就是定义了队列的数组，这个数组当中含有十个元素分别对应十个队列。</p><p>接下来看一下空间复杂度，显然基数排序的执行主要需要定义一个辅助队列，而这个辅助队列的长度是r，又因为每新增一个队列只是增加两个指针域，因此每个队列所需要的空间都是O(1)数量级，所以总的空间复杂度就是Q(r)数量级。</p><p>接下来看时间复杂度，算法执行的过程是总共进行了d趟的分配和收集，而每一趟的分配就是从头到尾把链表(序列)中的元素给扫描一遍，总共有n个元素，所以都扫一遍需要O(n)的时间，而一趟收集只需要O(r)的时间，每收集一个队列的元素只需要O(1)的复杂度，因此总体来看时间复杂度就是O(d(n+r))。</p><p>这里解释一下为什么收集一个队列的元素只需要O(1)的复杂度，如下图：</p><img src="https://pic.imgdb.cn/item/66762d32d9c307b7e9b5cd05.png" alt="数据结构（七）——排序——基数排序算法收集效率.png"><p>假设前面都已经收集完成，现在要收集Q6，用p指针指向已收集的链表的链尾，当我们要收集Q6时，只需要将Q6的队头拼接到已收集的链表尾，然后将p移动到新的表尾即可，如上图右下的程序。这个过程只需要简单的改动指针的指向即可，所以收集一个队列的元素只需要O(1)的复杂度。</p><p>接下来看一下算法的稳定性：</p><img src="https://pic.imgdb.cn/item/6676348ad9c307b7e9c4e478.png" alt="数据结构（七）——排序——基数排序算法稳定性.png"><p>从上图可以看到，同样的两个元素，在原序列里靠前的元素，经过分配收集以后，仍然会处于靠前的位置，所以基数排序算法是稳定的。</p><p>下面看一下基数排序的应用：</p><img src="https://pic.imgdb.cn/item/667634ffd9c307b7e9c598fa.png" alt="数据结构（七）——排序——基数排序的应用.png"><p>假设某一个学校有10000个学生，现在需要把学生信息按年龄递减的顺序进行排序。那么可以用学生的出生年月日来作为关键字进行排序，假设所有学生的出生年份是1991<del>2005这15个可能取值，月有可能取得1</del>12这12个取值，日有可能取得1~31这31个取值。而生日这三组信息，肯定是年的影响大于月大于日，所以按照基数排序的思想，在进行分配和收集时应该先按照日来，再按月，最后再按年进行。</p><p>算法进行的过程设计的辅助队列如上，这里要注意一下，由于要得到年龄递减的排序，而日期越大，出生就越晚，年龄就越小，所以这里的辅助队列是按照数值递增的次序排列的。经过上面的三趟分配与回收就可以得到学生按年龄递减的排序。</p><p>这里计算一下该例的时间复杂度，这里由于三趟的r不同，所以选取最坏的一趟r&#x3D;31，通过O(d(n+r))可以计算出时间复杂度约为O(30000)，而采用之前的排序算法，坏一点的像冒泡之类的，时间复杂度就达到O(n<sup>2</sup>)&#x3D;O(10<sup>8</sup>)，好一点的像堆排序之类的，时间复杂度就为O(nlog<sub>2</sub>n)&#x3D;O(140000)。所以可以看到，在这种场景下，采用基数排序所得到的时间复杂度，要比之前的所有算法都要优秀。</p><p>所以基数排序适合解决的问题，我们就可以总结如下图：</p><img src="https://pic.imgdb.cn/item/667637fad9c307b7e9cb4ade.png" alt="数据结构（七）——排序——基数排序适合解决的问题.png"><p>下面用几个反例来帮助理解上图的这三个条件：</p><img src="https://pic.imgdb.cn/item/66763835d9c307b7e9cbc9f8.png" alt="数据结构（七）——排序——基数排序适合解决的问题反例.png"><p>第一个条件要求拆分的分组d不能太多。这里看一个反例，比如说给5个人的身份证号排序，那每个人的身份证号有18位，也就是d&#x3D;18，这种情况使用基数排序的话，那总共需要进行18趟的分配回收，而本来只有5个人的数据，所以如果数据元素个数n很小，而分组d又很大的时候，这种情况使用基数排序的效率显然是很低很低的。</p><p>第二个条件要求每组关键字取值范围不能太大，即r较小。同样看一个反例，如果说要给人中文人们进行排序，中国人名有可能是三个字又或者两个字、四个字，总之d是比较小的，但名字中会出现各种各样的汉字，这个r是很大的，相应的空间复杂度就会很高，而且时间复杂度也不低，因此这种场景就不适合用基数排序。</p><p>第三个条件，要求数据元素个数n较大。还是身份证的例子，如果n足够大，比如给10亿人的身份证号排序，这时虽然身份证号有18位，要进行18次分配回收，但比起O(nlog<sub>2</sub>n)和O(n<sup>2</sup>)，基数排序仍然会得到一个很好的时间效率。所以，在分析实际问题时，不能教条化，还是要具体问题具体分析。</p><p>下面对基数排序进行小结：</p><img src="https://pic.imgdb.cn/item/66763859d9c307b7e9cc1b2b.png" alt="数据结构（七）——排序——基数排序小结.png"><h2 id="7-外部排序"><a href="#7-外部排序" class="headerlink" title="7. 外部排序"></a>7. 外部排序</h2><p>从本部分开始，往后进入外部排序的篇章。这里先贴一张本节知识总览，方便重点学习和理解。</p><img src="https://pic.imgdb.cn/item/66763b52d9c307b7e9d24a90.png" alt="数据结构（七）——排序——外部排序.png"><p>首先，看一下外存、内存之间的数据是如何进行交换的：</p><img src="https://pic.imgdb.cn/item/66763be3d9c307b7e9d32edd.png" alt="数据结构（七）——排序——外存和内存的数据交换1.png"><p>这里的外存特指磁盘，就是所谓的机械硬盘。磁盘这种设备有一个特点就是里面存储数据的存储单元是以所谓的磁盘块为单位的，操作系统也是以块为单位对磁盘存储空间进行管理。磁盘块里可以存储各种各样的数据，如图，磁盘块4和11里就存储了数据。现在有一个问题，如何去修改磁盘里的数据？我们要修改这些数据必须做到事情就是需要把对应的磁盘块读到内存里，也就是说要在内存里申请开辟一片缓冲区，缓冲区的大小可以和一个块的大小保持一致，上图例子为1KB。</p><p>接下来就可以把磁盘块4里的数据给读到内存当中，如下图：</p><img src="https://pic.imgdb.cn/item/667642dbd9c307b7e9e29205.png" alt="数据结构（七）——排序——外存和内存的数据交换2.png"><p>磁盘的读写都是以块为单位来进行的，也就是说每次读一块或写一块。</p><p>当数据读入内存以后，接下来就可以用程序代码对内存里的数据进行修改，修改后的样子如下图：</p><img src="https://pic.imgdb.cn/item/6676434fd9c307b7e9e3641b.png" alt="数据结构（七）——排序——外存和内存的数据交换3.png"><p>现在只是修改了内存里的数据，如果想要修改磁盘块的数据，还需要把数据写回磁盘，同样也是以块为单位进行写操作。我们可以把上图中内存里修改的数据写回磁盘块4，当然也可以写到其它磁盘块，比如写到磁盘块11，如下图。这就是内存、外存之间交换的原理，每次以块为单位进行读写。</p><img src="https://pic.imgdb.cn/item/667643e8d9c307b7e9e4b9fd.png" alt="数据结构（七）——排序——外存和内存的数据交换4.png"><p>理解了外存和内存之间是如何进行数据交换的以后，下面看一下外部排序的原理。</p><img src="https://pic.imgdb.cn/item/66765700d9c307b7e90a91fc.png" alt="数据结构（七）——排序——外部排序1.png"><p>所谓的外部排序是指数据元素存放在外存中，由于磁盘容量很大而内存容量很小，所以很多时候没有办法把磁盘的数据都给读入内存，所以要对存在于磁盘中的数据进行排序，这就是外部排序。</p><p>而实现外部排序的思想就是基于前面所学的归并排序，使用这种方式，最少只需在内存中分配3块大小的缓冲区即可对任意一个大文件进行排序。也就是说如上图在内存里申请的3个缓冲块，这3个缓冲块的大小都和一个磁盘块的大小是一致的，如果磁盘块大小为1KB，则3个缓冲区大小也都是1KB。</p><p>如上图，为了接下来的演示方便，在此规定整个文件总共只包含16块数据，每个磁盘块里包含3个记录，每个记录都有一个关键字，现在要对整个文件里的所有记录用归并排序的方式把它变成一个递增的序列，接下来看一下如何进行。</p><p>由于归并排序每一趟是把两个有序的子序列合并成一个更长的子序列，所以在归并排序开始前，需要构造一些已经有序的子序列。我们内存里已经有了两块输入缓冲区，可以存放两块内容，那就可以先从磁盘里，把第一块和第二块内容给读到内存中。如下图。</p><img src="https://pic.imgdb.cn/item/66765971d9c307b7e90ecc01.png" alt="数据结构（七）——排序——外部排序2.png"><p>被读入内存中的数据，我们想怎么操作都可以，所以可以对其进行内部排序，排序结果如下图：</p><img src="https://pic.imgdb.cn/item/667659bad9c307b7e90f4b59.png" alt="数据结构（七）——排序——外部排序3.png"><p>此时，第一块和第二块缓冲区的内容就成了一种递增状态。现在要把调整以后的数据放回外存中，要先把输入缓冲区1的内容放到输出缓冲区，如下图：</p><img src="https://pic.imgdb.cn/item/66765a2dd9c307b7e91011b8.png" alt="数据结构（七）——排序——外部排序4.png"><p>然后通过输出缓冲区写回磁盘，而这些数据的大小刚好是和磁盘块大小一样的，所以把8,9,26写回磁盘的第一个块，如下图：</p><img src="https://pic.imgdb.cn/item/66765a71d9c307b7e9111fc3.png" alt="数据结构（七）——排序——外部排序5.png"><p>同理，可以把36,42,48写回第二个块：</p><img src="https://pic.imgdb.cn/item/66765acbd9c307b7e911d03f.png" alt="数据结构（七）——排序——外部排序6.png"><p>现在，第一个磁盘块和第二个磁盘块里的这些记录就变成了一个递增有序的子序列，也叫归并段，之后就可以用这个有序的子序列来进行归并排序。</p><p>接下来同理，读取剩下块的记录并进行内部排序再写回外存，总共可以得到8个初始的归并段，如下图：</p><img src="https://pic.imgdb.cn/item/66765b82d9c307b7e9130e72.png" alt="数据结构（七）——排序——外部排序7.png"><p>之后，我们可以用这8个初始的归并段进行归并排序。由于整个文件有16块的内容，而每一块的内容都会被读入内存一次，在内存里排好序以后，还会把对应的块写回外存，所以总共有16块的数据，这16个块都要被读一次写一次，所以在上图例子里，构造初始归并段总共发生了16*2&#x3D;32次的读写磁盘的操作。</p><p>上面就是外部排序的第一个步骤，构造初始归并段，接下来使用初始归并段进行归并排序。</p><img src="https://pic.imgdb.cn/item/667664cfd9c307b7e923258b.png" alt="数据结构（七）——排序——外部排序8.png"><p>第一趟归并排序，如上图，会把初始归并段1和2进行二路归并。我们会先把初始归并段1和2中的更小的块给读入内存，分别放到缓冲区1和缓冲区2中，如下图。</p><img src="https://pic.imgdb.cn/item/6676655bd9c307b7e9242289.png" alt="数据结构（七）——排序——外部排序9.png"><p>接下来对初始归并段1和2的归并就变成了内部归并排序，这时就按照二路归并排序的算法，对比两个归并段的最小关键字，挑出最小的放到输出缓冲区。然后从剩下的记录里，再次挑出最小的放到输出缓冲区，直到把输出缓冲区放满，如下图。</p><img src="https://pic.imgdb.cn/item/6676673dd9c307b7e9275027.png" alt="数据结构（七）——排序——外部排序10.png"><p>现在，要输出缓冲区里的数据给写回外存，如下图：</p><img src="https://pic.imgdb.cn/item/6676677dd9c307b7e927c577.png" alt="数据结构（七）——排序——外部排序11.png"><p>此时输出缓冲区里的数据就写回了外存，输出缓冲区被清空，接下来要继续使用归并排序往输出缓冲区里写入数据，此时会出现下图的情况：</p><img src="https://pic.imgdb.cn/item/667667d4d9c307b7e9285e24.png" alt="数据结构（七）——排序——外部排序12.png"><p>我们在继续向输出缓冲区里写数据时，会出现输入缓冲区1空了的情况，由于输入缓冲区1里存放的是归并段1的第一个磁盘块，所以要立即用归并段1的后一个磁盘块里的内容来填补输入缓冲区1，如下图。</p><p>注意，这里说一种情况，由于内存外存之间是按块交换，每个块里有三个数据，如果此时输入缓冲区1空了，而归并段1里也没有未归并的块，则输入缓冲区2中的记录数与输出缓冲区中的剩余可放入记录数之和一定为3，如果输入缓冲区2中有3个记录，则输出缓冲区中记录已满，我们先把输出缓冲区的数据写回外存，再把输入缓冲区2的数据放入输出缓冲区写回外存，然后看归并段2有没有剩余的未归并块，如果有再把归并段2剩余的未归并块直接拼到归并序列的后面即可。如果输入缓冲区2中没有3个记录，则输出缓冲区中记录未满，且剩余数量肯定刚好够把输入缓冲区2中的数据放入，我们就直接把输入缓冲区2的数据放入输出缓冲区凑够一个块，然后写回外存，然后看归并段2有没有剩余的未归并块，如果有再把归并段2剩余的未归并块直接拼到归并序列的后面即可。</p><img src="https://pic.imgdb.cn/item/66766871d9c307b7e92a9701.png" alt="数据结构（七）——排序——外部排序13.png"><p>这么做可以保证输入缓冲区1永远是包含了归并段1里此时暂时还没有被归并但是数值最小的一个记录，下面继续让两个归并段继续归并，接下来最小的关键字是27，把它写入输出缓冲区，如下图：</p><img src="https://pic.imgdb.cn/item/6676691dd9c307b7e92bc95e.png" alt="数据结构（七）——排序——外部排序14.png"><p>此时把输出缓冲区里数据写回外存，同时由于输入缓冲区2空了，所以要把归并段2的后一个块放入输入缓冲区2，如下图：</p><img src="https://pic.imgdb.cn/item/66766960d9c307b7e92c47db.png" alt="数据结构（七）——排序——外部排序15.png"><p>接下来继续进行归并排序，然后把数据写回外存，最后得到的结果如下图：</p><img src="https://pic.imgdb.cn/item/667669b7d9c307b7e92ce6d4.png" alt="数据结构（七）——排序——外部排序16.png"><p>到此为止，两个归并段就归并为了一个更长更大的段，如上图。</p><p>这里要说一下，在上图里，我们归并之后的归并段并没有放回原位置，这是因为我们把归并之后的归并段放回外存的位置并不一定是一开始两个初始归并段的位置，至于放到哪，这主要涉及到从内存把数据写回外存的写回算法，有兴趣可以去了解一下。</p><p>不过为了方便理解和学习，我们还是把它移动到原位置，如下图：</p><img src="https://pic.imgdb.cn/item/66766b49d9c307b7e92faef6.png" alt="数据结构（七）——排序——外部排序17.png"><p>接下来用同样的方法，把剩下的6个初始归并段进行归并，最后总共可以得到4个更长的归并段，如下图：</p><img src="https://pic.imgdb.cn/item/66766bafd9c307b7e93058ef.png" alt="数据结构（七）——排序——外部排序18.png"><p>到此，第一趟归并就完成了。</p><p>接下来进行第二趟归并，这一趟归并会把4个有序子序列两两归并，归并过程与第一趟归并一致，最后可以得到如下图的归并结果：</p><img src="https://pic.imgdb.cn/item/66766c41d9c307b7e9316855.png" alt="数据结构（七）——排序——外部排序19.png"><p>经过第二趟归并，可以得到两个更长的有序子序列。</p><p>接下来进行第三趟归并，这一趟归并会把第二趟归并得到的2个有序子序列再次归并，归并过程与前面归并一致，最后可以得到如下图的归并结果：</p><img src="https://pic.imgdb.cn/item/66766fc6d9c307b7e937c769.png" alt="数据结构（七）——排序——外部排序20.png"><p>到此，我们就可以得到一个整体有序的排列。</p><p>下面，我们对这个过程进行时间开销分析：</p><img src="https://pic.imgdb.cn/item/66767010d9c307b7e9385059.png" alt="数据结构（七）——排序——外部排序时间开销分析.png"><p>还是上面的例子，我们在进行外部排序时，刚开始是把原始的乱序数据给生成一个初始归并段，这个过程需要读写磁盘块各16次，另外把数据读入内存以后还要进行内部排序，经过这样处理得到了8个初始归并段，每个初始归并段占两块磁盘块。</p><p>接下来会进行3趟归并，每一趟归并会基于上一趟的结果，把两个归并段合并为一个更长的归并段，经过3趟以后，可以得到一个整体有序的文件。</p><p>通过上面的演示过程，不难发现，每一趟归并都需要把16块的数据读入内存16次，然后写回外存16次，在读入以后还需要进行内部归并。</p><p>所以**<font color=red>外部排序时间开销&#x3D;读写外存的时间+内部排序所需时间+内部归并所需时间</font>**。这里面由于读写外存是很慢的，而内部排序和内部归并由于在内存里，处理起来很快，所以大部分时间开销花费在读写外存上，要想优化就要在读写外存上想办法。</p><p>由于读写外存的时间与读写磁盘次数是成正比的，所以通过刚刚的分析可以知道，整个过程需要读写磁盘32+32*3&#x3D;128次，这个式子里的32是文件的总块数，而3是归并趟数，显然文件的总块数32是无法改变的，所以只能想办法让文件归并的趟数减少，归并的趟数变小，读写磁盘的次数就会下降，相应的外部排序时间开销也会下降，所以优化思路就是如何减少归并的趟数。</p><p>下面看一下如何进行优化：</p><p>我们可以采用多路归并来进行归并处理，之前是采用2路归并，现在看一下如果采用4路归并，如下图。</p><img src="https://pic.imgdb.cn/item/66767331d9c307b7e93dee48.png" alt="数据结构（七）——排序——外部排序优化.png"><p>采用4路归并，相应的就要在内存里分配4个输入缓冲区，然后把4个归并段的内容分别读入缓冲区，接下来归并的原理是一样的。</p><p>如果采用4路归并，那么经过推算可以发现，只需要进行两趟归并，就可以得到一个整体有序的文件。如下图。</p><img src="https://pic.imgdb.cn/item/66767457d9c307b7e9400e6e.png" alt="数据结构（七）——排序——外部排序优化1.png"><p>因此，如果采用4路归并的话，那归并趟数只需要两趟，读写磁盘次数就只需要96次。所以采用多路归并的方式，可以减少归并趟数，从而减少磁盘I&#x2F;O读写的次数。</p><p>而在归并排序里我们也说过，对r个初始归并段，做k路归并，则归并树可用k叉树表示。对于一个k叉树，第h层最多会有k<sup>h-1</sup>个结点，而r个初始归并段都需要在k叉树的最底层，也就是h层，所以需要满足r&lt;&#x3D;k<sup>h-1</sup>，解这个不等式就可以得到(h-1)<sub>最小</sub>&#x3D;⌈log<sub>k</sub>r⌉。由于归并趟数刚好等于h-1，所以⌈log<sub>k</sub>r⌉也代表了进行k路归并时，有可能得到的最小的归并趟数。而根据对数性质又可以知道，k越大，则归并趟数越少，也就意味着读写磁盘次数会减少。另一方面，如果能让r也就是初始归并段数量变少，那么归并的趟数也可以减少。</p><p>所以，经过分析，对于外部排序，我们可以总结出两种优化思路。第一种就是让归并路数k变得大一些，第二种就是让r也就是初始归并段数量小一些。不过这里要强调一下，并不是让归并路数k越大越好，因为归并路数越多，也会带来一些负面影响。比如k路归并时，需要开辟k个输入缓冲区，内存开销增加。而且每挑选一个关键字需要对比关键字(k-1)次，K变大，内部归并所需时间就会增加（补充一下，这里的k路归并时需要对比的关键字次数可以通过败者树减少）。总之，这里要强调的就是k越大，读写磁盘次数就会变少，相应的外部排序时间开销也会变少，但是k并不是可以无限增大的。</p><p>接下来看怎么减少r，也就是减少初始归并段数量：</p><img src="https://pic.imgdb.cn/item/66767937d9c307b7e949e18c.png" alt="数据结构（七）——排序——外部排序优化2.png"><p>在刚刚进行4路归并时，分配了4个输入缓冲区，既然分配了4个输入缓冲区，对于一个刚开始无序的文件就可以读取4块文件的内容，然后把这些记录在内存里进行排序然后写回外存，这样得到的初始归并段就包含了4块的内容，用这种方式构造初始归并段就只会有4个。<strong>所以如果生成初始归并段的内存工作区越大，那么生成初始归并段的长度就越长，每一个归并段越长，就意味着归并段总数r越少，所以外部排序的整体效率就会提升。</strong></p><p>因此，这里可以得出如下图的结论：</p><img src="https://pic.imgdb.cn/item/66767a48d9c307b7e94be9f3.png" alt="数据结构（七）——排序——外部排序优化3.png"><p>如果能增加初始归并段的长度，则可以减少初始归并段数量r，r越小，则归并趟数越少，读写磁盘次数就越少。</p><p>下面对这部分进行小结：</p><img src="https://pic.imgdb.cn/item/66767ae1d9c307b7e94d1648.png" alt="数据结构（七）——排序——外部排序小结.png"><p>注：按照本节介绍的方法生成的初始归并段，若共N个记录，内存工作区可以容纳L个记录，则初始归并段数量r&#x3D;N&#x2F;L。</p><p>最后，补充一个概念——多路平衡归并。</p><img src="https://pic.imgdb.cn/item/66767b37d9c307b7e94db36d.png" alt="数据结构（七）——排序——多路平衡归并.png"><p>有的地方可能对多路平衡归并的定义是对r个初始归并段，做k路平衡归并，归并树可用严格k叉树(即只有度为k与度为0的结点的k叉树)来表示。</p><p>上面的这个定义是由问题的，如上图的4路平衡归并，里面包含了度为2的结点，这是不符合上面的定义的，所以上面的定义是有问题的。</p><p>实际上k路过平衡归并的定义应该是：</p><ol><li>最多只能有k个段归并为一个。</li><li>每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到[m&#x2F;k]个新的归并段。</li></ol><p>满足这两个特性才能叫多路平衡归并。</p><p>下面看一个反例：</p><img src="https://pic.imgdb.cn/item/66767d26d9c307b7e9514e15.png" alt="数据结构（七）——排序——多路平衡归并反例.png"><p>上图的例子用了4路归并，所以是4路归并排序，但一开始的8个归并段经过一趟处理后得到3个新的归并段，并不满足多路平衡归并的第二个特性，所以它不是4路平衡归并。  </p><h2 id="8-败者树"><a href="#8-败者树" class="headerlink" title="8. 败者树"></a>8. 败者树</h2><p>在7.外部排序末说过，如果增加归并路数k的话，那么可以减少归并的趟数，从而可以减少读写磁盘的次数，这样就可以让外部排序的时间开销整体来看有一个较大的优化。但是这么做带来的负面影响就是，如果使用k路平衡归并，那么每从这k路里挑选一个最小的元素就需要对比关键字(k-1)次，这就会导致内部归并所需时间增加。</p><p>而本节学习的败者树可以对这个问题进行优化，可以让我们从k个归并段里挑选出最小的关键字所需要的对比次数变得更少。</p><p>下面首先先来认识一下什么是败者树。</p><img src="https://pic.imgdb.cn/item/6676d289d9c307b7e9f58daf.png" alt="数据结构（七）——排序——败者树的构造.png"><p>如上图的例子，这时一个很常见的比赛晋级图，我们让两两比赛，胜利者进入下一回合比拼，失败者留在这一回合，最终这8个人经过7次比拼，可以决出一个优胜者。比赛的过程晋级图如上图，这是一个类似二叉树的结构，我们把它称之为败者树。</p><p>败者树的定义如下图：</p><img src="https://pic.imgdb.cn/item/6676d3fed9c307b7e9f891b1.png" alt="数据结构（七）——排序——败者树的使用.png"><p>下面思考一个问题，上图例子里，如果此时天津饭选手宣布放弃冠军，接下来会由另一个选手派大星顶替其位置，那是不是意味着要重新进行7场比赛才能选出冠军呢？</p><p>答案并非如此，我们完全可以基于之前构建好的这棵败者树来对比赛的流程进行优化，可以进行更少的比赛就找出谁最强。</p><p>现在我们根据构建好的败者树来看看如何进行优化：</p><img src="https://pic.imgdb.cn/item/6676d513d9c307b7e9faae85.png" alt="数据结构（七）——排序——败者树的使用1.png"><p>从上图中可以看到，派大星顶替了天津饭的位置，现在要想从这8个人里重新选一个冠军，完全不需要重新进行。根据构建好的败者树，可以发现最右边的4个人不需要重新比赛，因为这4个人中谁更厉害，之前的比赛就已经知道了，而且狼人和程龙谁更厉害也已经知道，所以他们两也不要重新比赛。</p><p>现在不知道的是派大星和阿乐谁更厉害，所以可以让派大星和阿乐比赛一场，假如派大星赢了，接下来就可以让派大星和程龙比赛一场，如果派大星又赢了，接下来就可以让派大星和孙悟空比赛一场，假如孙悟空赢了，那派大星就要留在原来孙悟空的位置，孙悟空就成了新的冠军。所以新的一轮的败者树就构造如下图。</p><img src="https://pic.imgdb.cn/item/6676d749d9c307b7e9ff1dba.png" alt="数据结构（七）——排序——败者树的使用2.png"><p>这一轮冠军的选取就可以发现，基于已经构建好的败者树，再次选出新的胜者只需要进行3场比赛，并不用重新比赛7场。</p><p>其实这个例子中的比赛就可以看做是关键字的对比，所以接下来就看看怎么样在多路平衡归并中使用败者树减少关键字对比次数。</p><img src="https://pic.imgdb.cn/item/6676d80bd9c307b7e900b2e7.png" alt="数据结构（七）——排序——败者树在多路平衡归并中的应用1.png"><p>现在有如图的8个归并段，如果要从这8个归并段中每次选出一个最小的数据元素，则每选出一个最小的元素都要进行7次关键字对比。</p><p>不过现在可以使用败者树来减少关键字对比次数，做法如下：</p><img src="https://pic.imgdb.cn/item/6676d8b0d9c307b7e901d951.png" alt="数据结构（七）——排序——败者树在多路平衡归并中的应用2.png"><p>首先我们会先构造一棵败者树，如图，上面这棵败者树的每一个叶子结点会对应一个归并段。现在放到叶子结点里面的这些元素就是每一个归并段的第一个元素（即每个归并段里最小的元素）。接下来会构建这棵败者树，从中找出关键字值最小的一个，构建的方法和前面的比赛晋级的方法一样。</p><p>先来看第一个归并段和第二个归并段，27和12比较，由于要选出最小的值，而12比27更小，因此27就是失败者，12晋级。同理1和17比较，17是失败者，1晋级。接下来2和9，11和4同理，2和4晋级。</p><p>接下来会让晋级的在一起比较，首先比较的就是12和1，1更小，所以1继续晋级；然后比较2和4，2更小，所以2继续晋级。最后1和2对比，1更小，2是失败者，所以2留在了失败结点，1成为冠军，即是最小结点，晋级过程如下图。</p><img src="https://pic.imgdb.cn/item/6676da56d9c307b7e9064972.png" alt="数据结构（七）——排序——败者树在多路平衡归并中的应用3.png"><p>当我们构造这一棵败者树的时候，在这些失败结点当中通常记录的是失败元素来自于哪一个归并段，而并非失败元素本身。比如第一场的比赛失败元素是27，而27来自归并段1，所以第一个失败结点里记录的就是归并段1的编号1，剩下的依次类推，最后就可以得到一棵初始的败者树，如下图。</p><img src="https://pic.imgdb.cn/item/6676db29d9c307b7e907fb89.png" alt="数据结构（七）——排序——败者树在多路平衡归并中的应用4.png"><p>在这棵败者树的根节点处，记录了冠军也就是最小的一个元素来自哪一个归并段，这个例子里记录的是3，所以最小的元素来自3号归并段。因此第一轮通过7次关键字对比之后，找到了最小的元素1。</p><p>接下来按照归并排序的规则，还要再在这几个归并段里选出下一个最小的元素，因此接下来会先让归并段3里下一个元素6替代1这个元素位置，如下图。</p><img src="https://pic.imgdb.cn/item/6676dc1bd9c307b7e909d662.png" alt="数据结构（七）——排序——败者树在多路平衡归并中的应用5.png"><p>接下来，想从这些元素中找出下一个更小的元素，那只需要让新元素6和第四个归并段中最小的元素17进行对比，显然新元素6是更小的，因此3号段的新元素6就会进入下一轮对比。下一轮要和2号段的最小元素进行对比，对比之后，同样是来自3号段的新元素6胜出，因此来自3号段的新元素又可以进入下一轮的对比。接下来要和5号段的最小元素2进行对比，显然5号段的2更小，则来自3号段的新元素6就止步于此，最终选出新的最小元素来自5号段。</p><p>新元素6执行比较的结果如下图：</p><img src="https://pic.imgdb.cn/item/6676dd5fd9c307b7e90c7eb5.png" alt="数据结构（七）——排序——败者树在多路平衡归并中的应用6.png"><p>从这个例子当中可以看到，只要构建好了败者树，接下来每次要选出一个最小的元素只需要进行3次关键字对比，也就是刚好和灰色结点的层数是相等。因此可以把这个结论广义化，<strong>对于k路归并，构建好了败者树以后，接下来选出最小的元素，只需要进行⌈log<sub>2</sub>n⌉次关键字对比即可</strong>。</p><p>接下来解释一下这个结论是怎么来的，由于关键字对比的次数和灰色结点的层数是相等的。那么假设对于k路归并，它所对应的败者树的树高为h，注意这个h是不包含最上方的蓝色结点的，但是它包含最下方的绿色叶子结点，所以h包含的就是一棵完全二叉树。而对于一棵完全二叉树，第h层最多会有2<sup>h-1</sup>个结点，而我们构造的是k路归并所对应的败者树，那k路归并的败者树会对应k个叶子结点，显然对于一棵有h层的完全二叉树，叶子结点的数量k应该是要小于等于2<sup>h-1</sup>，即k&lt;&#x3D;2<sup>h-1</sup>，把这个不等式解出来就可以得到h-1&#x3D;⌈log<sub>2</sub>n⌉，而h-1刚好就代表分支结点有多少层（就是图中灰色结点有多少层）。再结合之前的结论，分支结点有多少层，最多就要进行多少次关键字的对比，因此有了败者树以后，要选出一个最小的关键字最多就只需要进行⌈log<sub>2</sub>n⌉次关键字对比。所以构建了一棵败者树以后，就可以让我们在进行多路归并的时候，关键字对比的次数变得更少。</p><p>考研中对于败者树的考察频率不是很高，如果考察到通常也都是手算，但对于程序的实现思路也要了解一下，下面看一下如何用程序实现败者树：</p><img src="https://pic.imgdb.cn/item/6676e0f2d9c307b7e9136f0f.png" alt="数据结构（七）——排序——败者树的代码实现.png"><p>还是用刚刚的例子，如果要进行8路归并，其实只需要定义一个长度为8的int型数组，用这个数组就可以表示8路归并所对应的败者树。数组下标为1的元素对应了传统意义上的二叉树的根节点，数组下标为0的位置对应的就是新增加的小头头，后续的元素就是和完全二叉树都是对应的。</p><p>另外从上图还可以发现，这些叶子结点在实际的数组当中是不对应任何一个数据的，也就是说这些叶子结点是虚拟的，在逻辑上看这些叶子结点是存在的，并且每一个叶子结点会对应一个归并段，但实际上这些叶子接点只是我们脑补上去的，真正的”叶子结点“其实就是各个归并段里的最小元素。</p><p>下面对这部分进行小结：</p><img src="https://pic.imgdb.cn/item/6676e795d9c307b7e922aa0f.png" alt="数据结构（七）——排序——败者树的小结.png"><p>最后补充一点，我们求得的⌈log<sub>2</sub>n⌉是最多要进行关键字对比的次数，如果出现上图下的五个归并段构建败者树，我们通过⌈log<sub>2</sub>n⌉求得的3是最多要进行关键字对比的次数，也就是4和5这两个归并段选出一个最小的新元素最多要对比3次，但如果新的元素填补在归并段1和2和3的话，最多只需要进行2次归并。所以，这里想补充强调的就是⌈log<sub>2</sub>n⌉是最多要进行关键字对比的次数，并不是每次填补一个新元素都要进行⌈log<sub>2</sub>n⌉次关键字对比。</p><h2 id="9-置换-选择排序"><a href="#9-置换-选择排序" class="headerlink" title="9. 置换-选择排序"></a>9. 置换-选择排序</h2><p>在7.外部排序里，我们说，在进行外部排序时，需要进行S趟k路归并，那么S&#x3D;⌈log<sub>k</sub>r⌉，如果能让初始归并段变得更少，也就是让r减少的话，那么外部排序的效率可以得到进一步的提升。而本部分学习的置换-选择排序就可以用于构造更长的初始归并段，也就是让初始归并段的数量减少。</p><p>下面先来回顾一下之前构造初始归并段的方法：</p><img src="https://pic.imgdb.cn/item/6677b802d9c307b7e956667c.png" alt="数据结构（七）——排序——土办法构造初始归并段.png"><p>如上图，在内存里有两个输入缓冲区也就是说同时最多只能读入两块的内容，然后把这些记录在内存里排序，之后再写回外存，这样就得到了一个初始归并段，如上图。由于上图中用于内部排序的工作区，最多只能容纳6个记录，所以用之前的这种方法构造的初始归并段里面同样也只能包含6个记录。</p><p>对于这个问题的处理，最容易想到的一种方法是，在内存里开辟一片更大的区域，然后专门用这片区域来进行内部排序，这样的话就可以得到更长的初始归并段。如下图</p><img src="https://pic.imgdb.cn/item/6677b9b7d9c307b7e9595e29.png" alt="数据结构（七）——排序——土办法构造初始归并段1.png"><p>假设对于内存中的用于内部排序的区域，如果我们将其扩充为可以容纳18个记录，那我们就可以一口气把18个记录的信息都给读入到这一片空间里，然后对这18个记录进行内部排序，再依次的输出写回外存，这样的话得到的初始归并段就可以包含18个记录。而每一个初始归并段包含的记录数增多，就意味着整体来看初始归并段的数量r会下降。</p><p>我们在进行内部排序时，如果内存工作区的大小只能容纳l个记录，这就意味着我们构造的初始归并段，每个归并段也只能包含l个记录，所以如果文件总共有n个记录，那最终构造得到的初始归并段数量应该是n&#x2F;l，即初始归并段数量r&#x3D;n&#x2F;l。也就是说构造的初始归并段数量会直接由内存工作区的容量大小决定，这是该方法的局限性。</p><p>接下来看一下，怎么构造一个比内存工作区更大的初始归并段，这个问题就可以用置换-选择排序来解决。置换-选择排序如下图，这里为了演示方便对图示做了简化。</p><img src="https://pic.imgdb.cn/item/6677bb09d9c307b7e95ce5fe.png" alt="数据结构（七）——排序——置换选择排序示例1.png"><p>如上图右，假设是初始待排序文件包含的记录，接下来会用这些记录来构造一系列的初始归并段，现在假设内存工作区就是用于内部排序的工作区，大小只能容纳3个记录。那按照之前的方法，这个条件就意味着生成的初始归并段，每一个归并段也只能包含3个记录，所以上图总共24个记录就会构造出8个初始归并段。下面看一下选择排序是怎么解决这个问题的。</p><p>在刚开始，会从待排序的序列中读入三个记录，如下图：</p><img src="https://pic.imgdb.cn/item/6677bc5fd9c307b7e95f7cfc.png" alt="数据结构（七）——排序——置换选择排序示例2.png"><p>现在要构造递增的归并段，所以检查内存工作区里的这几个记录，发现关键字最小的是4，那么会把这个记录放到归并段1当中，并且会用一个变量MINIMAX把刚才输出的关键字的值给记录下来，如下图。</p><img src="https://pic.imgdb.cn/item/6677bcb4d9c307b7e9601741.png" alt="数据结构（七）——排序——置换选择排序示例3.png"><p>现在内存工作区中出现了空位，那么会从待排序文件当中读入下一个记录，如下图：</p><img src="https://pic.imgdb.cn/item/6677bcfad9c307b7e9609133.png" alt="数据结构（七）——排序——置换选择排序示例4.png"><p>再次经过对比发现，此时最小的一个记录应该是6，并且它的值要比刚才输出的4更大，所以把6放到归并段1的后面，然后更新变量MINIMAX为6，由于6移出去了，所以空出一个位置，要把下一个变量13放进来，变换过程如下图。</p><img src="https://pic.imgdb.cn/item/6677bd9bd9c307b7e961b9a1.png" alt="数据结构（七）——排序——置换选择排序示例5.png"><p>接下来同理，在内存工作区里经过对比，找当当前最小的记录是7，且7大于刚刚输出的6，所以也要把7放到归并段1里6的后面，然后再从待排序文件里读入一个记录。所以接下来相同的过程我们就直接跳过。</p><p>当内存工作区工作到输出的最小值为13时，此时再次读入的值为10，如下图：</p><img src="https://pic.imgdb.cn/item/6677be81d9c307b7e96375a3.png" alt="数据结构（七）——排序——置换选择排序示例6.png"><p>内存工作区此时最小的一个记录是10，但是通过MINIMAX这个变量我们知道，之前我们输出到归并段1的记录应该是13，所以现在10这个记录不能放到归并段1的末尾，因为归并段1的内部肯定是要递增的，因此虽然10这个记录是在内存工作区里最小的，但是不能把它置换出去。而除了10之外，最小的是14，14要比刚刚输出的13大，所以可以把14放到归并段1的末尾，然后读入下一个记录22，过程如下图。</p><img src="https://pic.imgdb.cn/item/6677bf43d9c307b7e965093f.png" alt="数据结构（七）——排序——置换选择排序示例7.png"><p>接下来的工作过程就是输出16，读入30，然后输出22，读入2，由于2,10均小于刚刚输出的22，所以只能输出30，然后再读入3，此时内存工作区里的记录数量已满，而且都小于MINIMAX，如下图：</p><img src="https://pic.imgdb.cn/item/6677bfc6d9c307b7e9660144.png" alt="数据结构（七）——排序——置换选择排序示例8.png"><p>如果某一时刻，内存工作区当中所有的元素都要比记录下来的MINIMAX更小，那么现在构造的归并段就应该到此为止，也就是说上图中的第一个归并段已经生成结束。</p><p>接下来会构造第二个归并段，现在会把MINIMAX的值刷新，然后再从内存工作区里找出一个最小的元素进行归并段2的构造，如下图。</p><img src="https://pic.imgdb.cn/item/6677c06dd9c307b7e9674fb7.png" alt="数据结构（七）——排序——置换选择排序示例9.png"><p>此时内存工作里的元素最小的是2，所以会把2输出作为归并段2的第一个元素，然后记录MINIMAX的值为2，由于2输出，此时内存工作区会有一个空记录，所以会从待排序的文件里读入下一个记录19。接下来的工作原理同归并段1构造一样，最后归并段2的构造结果如下图。</p><img src="https://pic.imgdb.cn/item/6677c102d9c307b7e968683d.png" alt="数据结构（七）——排序——置换选择排序示例10.png"><p>此时内存工作区里的元素值都小于MINIMAX记录的值，所以归并段2构造结束，接下来会刷新MINIMAX进行归并段3的构造。归并段3的构造结构如下图：</p><img src="https://pic.imgdb.cn/item/6677c150d9c307b7e9690124.png" alt="数据结构（七）——排序——置换选择排序示例11.png"><p>到此，整个文件的初始归并段就构造完成，可以看到使用置换-选择排序，可以让每个初始归并段的长度超越内存工作区大小的限制，这也说明使用置换-选择排序可以减少初始归并段的总数量r，而r越小，在进行外部排序时读写磁盘的次数也会相应的越少。所以这就是置换-选择排序的原理。</p><p>下面对刚刚的置换-选择排序的过程中，可能会有疑惑的地方进行一个补充：</p><img src="https://pic.imgdb.cn/item/6677c229d9c307b7e96aa328.png" alt="数据结构（七）——排序——置换选择排序示例解释.png"><p>如上图是刚刚演示过程的例子，这个地方给的所谓的输出文件FO，是存放在磁盘里的，而刚刚的演示过程是每一次把一个记录给输出到磁盘中，但其实背后真正的执行并非如此。在内存里会有一个输出缓冲区，然后每一次选出的这些元素都会先放到输出缓冲区里，每当输出缓冲区满了，凑足了一块的内容之后，才会把整个磁盘块的内容一次性给写回外存，所以虽然刚刚演示的过程是一个记录一个记录的往外写，但其实在背后是把这些记录进行了一个组团的操作，读写磁盘仍然是以磁盘块为单位的。</p><p>对于原始文件的输入也是一样的，刚刚演示的过程也是每次读入一个记录，但其实每次是读入一整块的内容，也就是说一次会读入好几个记录，只不过，每次只会把一个记录给挪到内存工作区。</p><p>下面对置换-选择排序的过程进行一个总结，也是对本节内容进行一个小结：</p><img src="https://pic.imgdb.cn/item/6677c3b6d9c307b7e96d8335.png" alt="数据结构（七）——排序——置换选择排序小结.png"><h2 id="10-最佳归并树"><a href="#10-最佳归并树" class="headerlink" title="10. 最佳归并树"></a>10. 最佳归并树</h2><p>在学习最佳归并树前，先来看一下归并树的一个隐藏性质。通过9.置换-选择排序的学习，我们可以知道，如果使用置换-选择排序来构造初始的归并段的话，那么这些初始归并段的长度可能是各不相同的。如下图。</p><img src="https://pic.imgdb.cn/item/6676e917d9c307b7e925ebcc.png" alt="数据结构（七）——排序——归并树隐藏的性质.png"><p>上图给出了五个初始归并段，归并段里的数字表示每个归并段占多少个磁盘块，像R2这个归并段就是占5个磁盘块。</p><p>现在要对这5个初始归并段进行二路归并，首先可以归并R2和R3，如下图：</p><p><img src="https://pic.imgdb.cn/item/6676eb58d9c307b7e92a8fcc.png" alt="数据结构（七）——排序——归并树隐藏的性质1.png">R2和R3的长度一个是5一个是1，所以我们要在内存里对他们进行归并，肯定要把R2的5块内容和R3的1块内容都读入内存，而之前又说过，读写磁盘是以磁盘块为单位的，所以把这6块的数据读入内存，需要读磁盘6次，而在内存中会把这两个归并段把它们合二为一，最终会生成一个总共占6块的归并段，再把这个归并段写回磁盘，总共需要6次的写操作。所以我们把R2和R3进行一个二路归并，总共需要读磁盘和写磁盘各6次。</p><p>接下来归并R4和R5原理同R2和R3一样，归并结果如下图：</p><img src="https://pic.imgdb.cn/item/6676eba8d9c307b7e92b3740.png" alt="数据结构（七）——排序——归并树隐藏的性质2.png"><p>可以看到，把R4和R5进行一个二路归并，总共需要读磁盘和写磁盘各8次。</p><p>接下来，可以把刚才得到的两个较长的归并段再一次进行归并，归并结果如下图：</p><img src="https://pic.imgdb.cn/item/6676ebfcd9c307b7e92bdf8b.png" alt="数据结构（七）——排序——归并树隐藏的性质3.png"><p>可以看到，把这两个较长的归并段进行一个二路归并，总共需要读磁盘和写磁盘各14次。</p><p>最后再把R1这个归并段，和刚刚得到这个比较长的归并段进行一个归并，归并结果如下图：</p><img src="https://pic.imgdb.cn/item/6676ec7fd9c307b7e92ce8fb.png" alt="数据结构（七）——排序——归并树隐藏的性质4.png"><p>可以看到，最后一次二路归并，总共需要读磁盘和写磁盘各16次。</p><p>所以按照这样的策略进行归并，那么总共需要进行读写各44次。</p><p>现在我们来做这样一件事，我们把这些绿色结点，也就是这几个归并段，把它们看做是这棵二叉树的五个叶子结点，那么可以算一下这棵树的带权路径长度等于44(带权路径长度计算过程参考上图)，和我们计算的读或写磁盘的次数是相同的。所以如果算读写的总次数，也就是磁盘的I&#x2F;O次数，就可以用带权路径的长度乘2求出。</p><p>因此这里我们可以得出一个重要结论就是，**<font color=red>在归并过程中的磁盘I&#x2F;O次数&#x3D;归并树的WPL*2</font>**。基于这个结论不难想到，如果我们想追求归并的过程磁盘I&#x2F;O总次数最少，那么这个问题其实就是求一棵带权路径长度最小的归并树，而带权路径最小的树就是哈夫曼树(哈夫曼树的知识忘了可以复习回去第五章)。</p><p>所以接下来我们会构造一棵哈夫曼树，来优化这五个初始归并段的二路归并策略，构造过程如下图：</p><img src="https://pic.imgdb.cn/item/6676ee8dd9c307b7e931580b.png" alt="数据结构（七）——排序——构造2路归并的最佳归并树.png"><p>根据哈夫曼树构造的原理，刚开始我们会把这些结点看做是一个一个独立的树，只不过每棵树只有一个根节点而已。接下来，我们会从这几棵树当中挑选出根节点的权值最小的两棵，让他们成为兄弟。</p><p>刚开始权值最小的是1和2，那就让他们俩成为兄弟，然后新的根节点的权值就是他们俩的权值之和，为3。现在剩下4棵树，根节点权值最小的应该是3和2，所以让他们俩成为兄弟，构造出新的结点，新结点权值因该为3+2&#x3D;5。后面的构造同理，不难发现其实就是哈夫曼树的构造。</p><p>最后，我们可以得到如上图一个哈夫曼树，也就是2路的最佳归并树。而这个归并树背后的含义就是一开始我们会把R1和R3这两个初始归并段，归并成一个总长度为3的新的归并段，然后接下来用长度为3的归并段和R5这个归并段进行一个归并，得到一个长度为5的新的归并段。接下来用长度为5的归并段和R2这个归并段进行一个归并，得到一个长度为10的新的归并段。最后，用长度为10的归并段和R4这个归并段进行一个归并，得到一个总长度为16的有序文件。</p><p>我们通过这棵哈夫曼树计算器带权路径长度，计算结果为34，也就是说用这个归并方案，总共只需要读磁盘34次，写磁盘34次，总的磁盘I&#x2F;O次数只需要68次，而前面的第一种方案总共要88次磁盘I&#x2F;O。所以，这就是为什么这棵树被称为最佳归并树，因为按最佳归并树的方案来进行二路归并，可以得到最少的磁盘I&#x2F;O次数。</p><p>接下来再来看一下多路归并的情况：</p><img src="https://pic.imgdb.cn/item/6676f1add9c307b7e9379020.png" alt="数据结构（七）——排序——多路归并的情况.png"><p>假设现在有如图的几个初始归并段，和之前一样，每个小圆点里的数字表示这个归并段总共占磁盘多少块。那假设现在要采用3路归并的策略，按照之前的方法进行3路归并，归并的结果如下图：</p><img src="https://pic.imgdb.cn/item/6676f21fd9c307b7e9386dd9.png" alt="数据结构（七）——排序——多路归并的情况1.png"><p>计算器磁盘I&#x2F;O次数为484次，显然这并不是一个最佳的归并树。</p><p>那三路归并的最佳归并树应该如何构造呢？其实原理和二路归并是非常类似的。我们会选出权值最小的三个结点，让它们成为兄弟，那首先被选出来的应该就是2,3,6这三个，然后我们把这3个段进行归并，得到一个总长度为11的归并段。归并结果如下图：</p><img src="https://pic.imgdb.cn/item/6676f2c8d9c307b7e939d757.png" alt="数据结构（七）——排序——多路最佳归并1.png"><p>接下来权值最小的三个应该是9,11,12，所以下一次归并会让这三个段进行归并，得到一个长度为32的新的段，结果如下图：</p><img src="https://pic.imgdb.cn/item/6676f342d9c307b7e93abdc7.png" alt="数据结构（七）——排序——多路最佳归并2.png"><p>接下来权值最小的三个应该是17,18,24，所以下一次归并会让这三个段进行归并，得到一个长度为59的新的段，结果如下图：</p><img src="https://pic.imgdb.cn/item/6676f36ad9c307b7e93b089a.png" alt="数据结构（七）——排序——多路最佳归并3.png"><p>接下来还剩三个树，所以再把它们进行一次三路归并，最终得到一个总长度为121块的有序文件，如下图：</p><img src="https://pic.imgdb.cn/item/6676f3e0d9c307b7e93be9b0.png" alt="数据结构（七）——排序——多路最佳归并4.png"><p>使用这样的方法得到的一棵三路归并的归并树，它就是一棵最佳归并树，我们可以算出其带权路径长度为223，也就是说按照这样的方法来进行归并排序，那么总共只需要读写磁盘446次。</p><p>接下来有一个问题，我们刚刚给的是9个归并段，现在我们把长度为30的这个归并段给删掉，也就是说我们只有如下图的8个归并段来参与三路归并。</p><img src="https://pic.imgdb.cn/item/6676f4ecd9c307b7e93e6d53.png" alt="数据结构（七）——排序——缺一个归并段的3路归并.png"><p>那按照之前构造三叉哈夫曼树的规则，归并到最后会出现这样一种情况，如下图：</p><img src="https://pic.imgdb.cn/item/6676f553d9c307b7e9400a8a.png" alt="数据结构（七）——排序——缺一个归并段的3路归并1.png"><p>如上图，归并到最后会出现只剩下两棵树的情况，那要把这两棵树进行归并肯定只能进行二路归并，归并结果如下图，最终得到一个总长度为91的有序文件。</p><img src="https://pic.imgdb.cn/item/6676f5b8d9c307b7e940c979.png" alt="数据结构（七）——排序——缺一个归并段的3路归并2.png"><p>我们可以计算出这棵树的带权路径长度为193，那么按照这样的策略来进行归并，总共需要磁盘I&#x2F;O次数为386次。</p><p>这里要强调的是这种构造方法是不对的，问题出在最后的这一次归并只是两路归并而不是三路归并，而如果初始归并段能够再多一个，那就刚好可以保证在每次归并时都是三路归并。</p><p>所以正确的做法应如下图所述：</p><img src="https://pic.imgdb.cn/item/6676f684d9c307b7e9424fb6.png" alt="数据结构（七）——排序——缺一个归并段的3路归并的正确处理方法.png"><p><strong>对于k叉归并，若初始归并段的数量无法构成严格的k叉归并树，则需要补充几个长度为0的“虚段”，再进行k叉哈夫曼树的构造。</strong></p><p>像上面的例子，我们需要先补充一个长度为0的虚段，如上图所示，然后再进行3叉哈夫曼树的构造。所以对于上例，正确的三叉哈夫曼树构造如下图所示：</p><img src="https://pic.imgdb.cn/item/6676f72ad9c307b7e94391cd.png" alt="数据结构（七）——排序——缺一个归并段的3路归并的正确处理方法1.png"><p>上面的这个三叉哈夫曼树就是3路归并的最佳归并树，计算其带权路径长度为163，说明总的磁盘I&#x2F;O次数只需要326次。</p><p>这里再解释一下长度为0的虚段是什么意思，第一次归并应该是2,3,0这几个归并段的一个归并。在进行三路归并时，需要设置三个输入缓冲区，那2这个归并段的数据会被放入第一个输入缓冲区，3这个归并段的数据会被放入第二个输入缓冲区，然后长度为0的虚段就意味着在第三个输入缓冲区里什么也不要放，接下来进行三路归并时，只需要把最后的归并段看作是一个已经把所有元素都归并完的归并段就可以了。这就是虚段背后的原理。</p><p>总之，当进行k路归并时，如果k大于2，就可能遇到初始归并段的数量无法构成严格的k叉归并树这样的情况，如果遇到这种情况就需要补充几个长度为0的虚段，然后再进行k叉哈夫曼树的构造，那到底要补充几个虚段呢，这就是接下来要研究的问题。</p><img src="https://pic.imgdb.cn/item/667791ecd9c307b7e90e461b.png" alt="数据结构（七）——排序——添加虚段的数量.png"><p>假设现在要进行k路归并，那么k路归并的最佳归并树最终—定是一个严格的k叉树，所谓严格的意思就是说这个树中只包含度为k或度为0的结点。</p><p>现在设度为k的结点有n<sub>k</sub>个，度为0的结点有n<sub>0</sub>个，归并树总结点数&#x3D;n，那么在这棵归并树中，刚开始给出的初始归并段还有补充的虚段它们肯定都是叶子结点，也就是说它们都是度为0的结点，因此，**初始归并段数量+虚段数量&#x3D;n<sub>0</sub>**。</p><p>另外，根据k叉树的性质，还应该有这样两天结论：</p><ol><li>因为这个最佳归并树是严格的k叉树，只包含度为k和度为0的结点，所以把这两类结点的数量加和，就是这棵树的总结点数，即n&#x3D;n<sub>k</sub>+n<sub>0</sub>。</li><li>在这个k叉树归并树里，总共有n<sub>k</sub>这么多个分支结点，而每一个分支结点的度都是k，所以每一个分支节点会发出k个分叉，而除了根节点外，其余所有的节点头上肯定都会连着一个分叉，所以kn<sub>k</sub>应该是分叉的总数量，那么n-1就是总的结点数减掉一个跟节点。这两个值应该是相等的，即kn<sub>k</sub>&#x3D;n-1。</li></ol><p>根据上面得到的两个式子就可以推出：n<sub>0</sub>&#x3D;(k-1)n<sub>k</sub>+1。则n<sub>k</sub>&#x3D;(n<sub>0</sub>-1)&#x2F;(k-1)，在这个式子里，n<sub>k</sub>指的是度为k的节点的数量，它肯定是一个整数，所以式子的右边(n<sub>0</sub>-1)&#x2F;(k-1)这个除式肯定刚好可以除得一个整数。</p><p>因此，再结合前面的的推论，我们将初始归并段数量加上补充的虚段数量再减一，应该是刚好能够除尽k-1的。所以，若**<font color=red>(初始归并段数量-1)%(k-1)&#x3D;0</font><strong>，说明刚好可以构成严格k叉树，此时不需要添加虚段。而如果</strong><font color=red>(初始归并段数量-1)%(k-1)&#x3D;u，u不等于0</font><strong>，那么就说明初始归并段的这些数量无法构成一棵严格的k叉树，那么就需要补充</strong><font color=red>(k-1)-u</font>**个虚段才可以构成严格的k叉树，这里(k-1)-u是怎么得来的，是模运算的问题，如果不懂可以去看下模运算。</p><p>下面对本节进行小结：</p><img src="https://pic.imgdb.cn/item/66779752d9c307b7e9181fd9.png" alt="数据结构（七）——排序——最佳归并树小结.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（六）——查找</title>
      <link href="/2024/05/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/"/>
      <url>/2024/05/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构（六）——查找"><a href="#数据结构（六）——查找" class="headerlink" title="数据结构（六）——查找"></a>数据结构（六）——查找</h1><h2 id="1-查找的基本概念"><a href="#1-查找的基本概念" class="headerlink" title="1. 查找的基本概念"></a>1. 查找的基本概念</h2><img src="https://pic.imgdb.cn/item/6655e4d4d9c307b7e9075464.png" alt="数据结构（六）——查找——查找的基本概念.png"><p>在学习查找相关工作前，首先要知道查找的基本概念，这里需要注意一下关键字。</p><p>关键字是数据元素中<font color=red><strong>唯一标识</strong></font>该元素的某个数据项的值，要注意，使用关键字查找的结果应该唯一，若结果不唯一，则说明不是使用关键字查找的。</p><p>接下来看一下对查找表的常见操作：</p><img src="https://pic.imgdb.cn/item/6655e5f2d9c307b7e908a4ba.png" alt="数据结构（六）——查找——对查找表的常见操作.png"><p>对查找表的常见操作有两种，第一种只是单纯的查找，并不对表中数据进行修改；第二种会对查找表进行插入、删除等操作，会导致查找表数据发生修改。</p><p>如果一个查找表只需要进行查的操作，这种查找表称为静态查找表。</p><p>如果一个查找表不仅需要进行查的操作，还要对表中数据进行修改，则这种查找表称为动态查找表。</p><p>接下来看一下怎么评价一个查找算法的优劣：</p><img src="https://pic.imgdb.cn/item/6655e708d9c307b7e909e788.png" alt="数据结构（六）——查找——查找算法的评价指标.png"><p>评价一个查找算法的优劣主要是看一个查找算法的平均查找长度（ASL），评价查找长度的相关概念及计算公式如上图。</p><p><strong>另外补充两点：</strong></p><ol><li><strong>ASL的数量级反应了查找算法的时间复杂度。</strong></li><li><strong>评价一个查找算法的效率时，通常考虑查找成功和查找失败两种情况的ASL。</strong></li></ol><p>最后对查找的基本概念进行小结：</p><img src="https://pic.imgdb.cn/item/6655e7dfd9c307b7e90b2825.png" alt="数据结构（六）——查找——查找的基本概念小结.png"><h2 id="2-顺序查找"><a href="#2-顺序查找" class="headerlink" title="2. 顺序查找"></a>2. 顺序查找</h2><p>首先，看一下顺序查找的算法思想：</p><img src="https://pic.imgdb.cn/item/6655e831d9c307b7e90bb214.png" alt="数据结构（六）——查找——顺序查找算法思想.png"><p>顺序查找的算法思想很简单，就是从线性表头开始依次往后查找，直到找到与目标相同的元素。</p><p>基于这个思想，来看一下顺序查找如何实现：</p><img src="https://pic.imgdb.cn/item/6655e8d3d9c307b7e90cc3e5.png" alt="数据结构（六）——查找——普通顺序查找的实现.png"><p>上图给出了顺序表存储结构的顺序查找实现方式，可以看到，算法的实现是不论查找成功与否都返回查找指针下标，若下标等于数组长度，则说明查找失败，返回-1；否则说明查找成功，返回数组下标。（这里给的写法是这样，但也可以不按照这种写法，只要按照顺序查找思路写的就行。）</p><p>接下来看一下另一种添加哨兵的顺序查找实现思路：</p><img src="https://pic.imgdb.cn/item/6655e9ffd9c307b7e90e6a3f.png" alt="数据结构（六）——查找——哨兵顺序查找的实现.png"><p>与之前的不同，这种添加了哨兵的顺序查找思路是将数组首位空出，用来存放查找目标，也就是所谓的哨兵，然后从数组尾部向前查找，如果查找到与哨兵相同的数据元素的数组下标不是0，则查找成功，否则查找失败。</p><p>这种带有哨兵的查找算法与之前相比无需进行越界判断，执行效率会更高一些，但从时间复杂度上来看其实并没有质的提升。</p><p>下面看一下这种带哨兵的顺序查找算法的查找效率：</p><img src="https://pic.imgdb.cn/item/6655eb55d9c307b7e910a83a.png" alt="数据结构（六）——查找——哨兵顺序查找的效率.png"><p>要看一个查找算法的查找效率，就是计算一个查找算法的平均查找长度。这里以查找成功为例，由于算法是从后往前查找的，假设有n个数，最后一个为37，所以37被查找成功需要进行1次，概率为1&#x2F;n。倒数第二个元素被查找的成功，需要进行2次，查找概率为1&#x2F;n。按照这种方式递推，最后可得到上图的查找成功公式。查找失败同理。</p><p>另外，前面说过，ASL的数量级反应了查找算法的时间复杂度，所以这个算法的查找成功与失败的时间复杂度都为O(n)。</p><p>接下来看一下，顺序查找算法可不可以继续优化。</p><img src="https://pic.imgdb.cn/item/6655eb89d9c307b7e910f473.png" alt="数据结构（六）——查找——顺序查找优化.png"><p>如果查找表中的元素有序存放，如图，现在要查找21，则可以不用从头扫到尾才能确定查找表中没有该元素，只要扫到29时就可以确定。</p><p>基于这种思想，我们可以对有序表的顺序查找构造出一个如上图下的查找判定树，在这个判定树里查找21，只需要从根开始（上图的7）判断与21的大小，如果小于21则继续向右孩子走；如果大于21则继续向左孩子走，当向左孩子走就意味着落入一个区间内，此时查找失败。</p><p>从上图，显然可以看到，如果这个有序表有n个元素，则总共有可能出现n+1种失败的情况。所以在这种情况下要计算查找失败的评价查找长度，则可以认为出现这n+1种情况的概率是相等的。如果想找查找的关键字的值落在第一个区间内，则只需要对比1次关键字，而发生这种情况的概率是1&#x2F;(n+1)。如果想找查找的关键字的值落在第二个区间内，则需要对比2次关键字，发生这种情况的概率也是1&#x2F;(n+1)。如此递推，把n+1种情况都考虑进去，最后可以得到一个查找失败情况下的平均查找长度，如上图。</p><p>另外，这里需要体会一下如何画查找判定树：</p><img src="https://pic.imgdb.cn/item/6655ebbed9c307b7e9113a13.png" alt="数据结构（六）——查找——查找判定树.png"><p>如上图的查找判定树，我们把圆形的结点称为成功结点，方形结点称为失败结点。</p><p>如果我们查找的关键字在某一个成功结点当中，那么查找这样一个关键字的查找成功长度应该等于这个结点自身所在的层数。</p><p>如果我们查找的关键字在某一个失败结点当中，那么查找这样一个关键字的查找失败长度应该等于这个结点的父结点所在的层数。</p><p>接下来看一下如果各个关键字被查找的概率不同的情况：</p><img src="https://pic.imgdb.cn/item/6655ebf2d9c307b7e91174e8.png" alt="数据结构（六）——查找——被查概率不同的顺序查找.png"><p>如果各个关键字被查找的概率不同，则可以把被查找概率大的关键字放在靠前位置。当然，按照这种策略来给各个数据排序的话，则这些关键字又会变成乱序的。所以对于这种策略，提高了查找成功的ASL，但对于查找失败的ASL，又需要从头查找到尾才行。</p><p>因此，使用什么样的查找策略还是需要结合具体实际分析才行。</p><p>最后，对这小节进行总结：</p><img src="https://pic.imgdb.cn/item/6655ec1dd9c307b7e911a73d.png" alt="数据结构（六）——查找——顺序查找小结.png"><h2 id="3-折半查找"><a href="#3-折半查找" class="headerlink" title="3. 折半查找"></a>3. 折半查找</h2><p>折半查找，又称“二分查找”，仅适用于**<font color=red>有序的顺序表</font>**。</p><p>折半查找的算法思想就是，用两个指针low和high分别指向顺序表的表头和表尾，再用一个mid指针指向表头表尾指针的中间位置，将查找目标与mid指针所指位置的数据相比，若相等，则直接返还mid下标，若大于，则令low指针指向mid+1处，然后让mid指针再次指向表头表尾指针的中间位置，进行第二轮查找；若小于，则令high指针指向mid-1处，同样让mid指针再次指向表头表尾指针的中间位置，进行第二轮查找。</p><p>下面以一个具体的例子来学习折半查找的过程：</p><img src="https://pic.imgdb.cn/item/665723c8d9c307b7e94fcd54.png" alt="数据结构（六）——查找——折半查找1.png"><p>在上图的例子里，low指针指向表头，high指针指向表尾，mid指针指向(low+high)&#x2F;2处。然后让目标数33与mid指针所指位置比较，发现33大于mid所指处的29，所以33只能在mid右边区域，接下来要让low指针指向mid+1处进行第二轮查找。</p><img src="https://pic.imgdb.cn/item/665725add9c307b7e951da18.png" alt="数据结构（六）——查找——折半查找2.png"><p>在第二轮中，low指向下标为6处，high指向下标为10处，所以mid要指向(10+6)&#x2F;2&#x3D;8处，然后将mid所指数据与33比较，发现大于33，所以33只能在mid左边区域，接下来要让high指向mid-1处。</p><img src="https://pic.imgdb.cn/item/66572621d9c307b7e95263d3.png" alt="数据结构（六）——查找——折半查找3.png"><p>在第三轮中，low指向下标为6处，high指向下标为7处，所以mid要指向(6+7)&#x2F;2&#x3D;6<strong>（在算法里除不尽的要取整）</strong>处，然后将mid所指数据32与33比较，发现小于33，所以33只能在mid右边区域，接下来要让llow指向mid+1处。</p><img src="https://pic.imgdb.cn/item/66572691d9c307b7e952edc3.png" alt="数据结构（六）——查找——折半查找4.png"><p>在第三轮中，low指向下标为7处，high指向下标为7处，所以mid要指向(7+7)&#x2F;2&#x3D;14处，然后将mid所指数据33与33比较，发现等于33，所以查找成功。</p><p>上面是查找成功的例子，下面看一下查找失败的例子：</p><img src="https://pic.imgdb.cn/item/665726edd9c307b7e9547095.png" alt="数据结构（六）——查找——折半查找失败1.png"><p>这里以查找目标12为例，第一轮让12与mid所指29比较，发现12小于29，所以12在mid左边。</p><img src="https://pic.imgdb.cn/item/66572e17d9c307b7e95d87dc.png" alt="数据结构（六）——查找——折半查找失败2.png"><p>第二轮同理，我就不在叙述。</p><img src="https://pic.imgdb.cn/item/66572e3dd9c307b7e95dada2.png" alt="数据结构（六）——查找——折半查找失败3.png"><p>第三轮同理。</p><img src="https://pic.imgdb.cn/item/66572e7dd9c307b7e95e001b.png" alt="数据结构（六）——查找——折半查找失败4.png"><p>第四轮如上图，发现low&#x3D;high&#x3D;mid所指小于12，所以low会指向mid+1处，如下图：</p><img src="https://pic.imgdb.cn/item/66572ed4d9c307b7e95e6b7e.png" alt="数据结构（六）——查找——折半查找失败5.png"><p>这个时候low大于high，我们就认为查找失败。</p><p>结合一开始所说的算法思想并结合上面的例子，我们可以设计如下的折半查找算法：</p><img src="https://pic.imgdb.cn/item/66572f5fd9c307b7e95f1544.png" alt="数据结构（六）——查找——折半查找算法实现.png"><p>注意，这里给出的是升序排列的顺序表的实现。在一开始我们也说，折半查找适用于**<font color=red>有序的顺序表</font>**，是因为顺序表具有随机访问的特性，而链表没有，所以折半查找无法基于链表实现。</p><p>接下来分析一下折半查找的查找效率：</p><img src="https://pic.imgdb.cn/item/665730a0d9c307b7e96088ac.png" alt="数据结构（六）——查找——折半查找的效率分析.png"><p>根据折半查找的实现流程，如果第一轮就查找成功，则查找到的应该是29；如果第二轮查找成功，则查找到的应该是13和37。按照这样的方式往下推，再结合在2.顺序查找里的判定树构造，我们可以构造出如上图的上例折半查找判定树。</p><p>基于这个判定树我们就可以计算出上例查找成功与失败的查找长度分别是3和11&#x2F;3。</p><p>接下来，继续研究一下折半查找判定树有怎么样的特性（或者说怎么样构造）：</p><img src="https://pic.imgdb.cn/item/6657329ed9c307b7e963098c.png" alt="数据结构（六）——查找——折半查找判定树特性.png"><p>之前给出的例子，low和high之间有奇数个元素，所以mid指针可以刚好指向中间位置。这里我们给出一个low和high之间有偶数个元素的例子，此时mid指针会指向中间偏左的位置，继而可以得到上图的查找判定树。</p><p>结合之前的例子，可以发现下面两个规则：</p><ol><li>如果当前low和high之间有奇数个元素，则 mid分隔后，左右两部分元素个数相等。</li><li>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素。</li></ol><p>基于这两个规则，我们可以得到如下图的有关折半查找判定树的结论（特性）：</p><img src="https://pic.imgdb.cn/item/6657340bd9c307b7e964e60b.png" alt="数据结构（六）——查找——折半查找判定树结论.png"><p>基于上图的这个结论，我们可以推演一下如果有1个元素、2个元素、3个元素、……、16个元素，那折半查找判定树分别应该如何构造？</p><img src="https://pic.imgdb.cn/item/6657346cd9c307b7e9655d64.png" alt="数据结构（六）——查找——折半查找判定树特性的构造.png"><p>上图就给出了1~16个元素的折半查找判定树的构造，需要注意的是，结点上的数字代表的是结点的编号。根据编号的构造规律，可以进一步验证我们上面得出折半查找判定树的结论（即折半查找判定树的特性）。</p><p>另外，在构造这个折半查找判定树的过程中，不难发现，这个折半查找判定树一定是一个**<font color=red>平衡二叉树</font>**。</p><p>此外，**折半查找的判定树和完全二叉树一样，只有最下面一层是不满的。因此，元素个数为n时树高<font color=red>h &#x3D; [log<sub>2</sub>(n +1)]</font>**。（公式的推导可以参考 数据结构（四）——树与二叉树 中的完全二叉树的树高推导。）</p><img src="https://pic.imgdb.cn/item/66573748d9c307b7e96a221c.png" alt="数据结构（六）——查找——折半查找判定树构造.png"><p>再回到之前这个例子，我们可以发现，失败结点就是二叉树的空链域，在树一节我们学过，一个有n个结点的二叉树，总共会有n+1个空链域，所以总共会有n+1个失败结点。</p><p>搞清楚这些以后，我们可以很容易分析出，有n个结点的折半查找的效率是怎么样的：</p><img src="https://pic.imgdb.cn/item/66573840d9c307b7e96b58cc.png" alt="数据结构（六）——查找——折半查找效率.png"><p>在知道树高以后，我们可以知道，不论查找是成功还是失败，所查找结点的对比次数肯定不会超过树高h，而树高h &#x3D; [log<sub>2</sub>(n +1)]，所以折半查找的时间复杂度(也就是查找需要对比的次数)&#x3D;O(log<sub>2</sub>n)。它比顺序查找的时间复杂度要优秀的多。</p><p>接下来对该部分进行小结：</p><img src="https://pic.imgdb.cn/item/66573981d9c307b7e96ceb67.png" alt="数据结构（六）——查找——折半查找小结.png"><p>接下来拓展思考两个问题：</p><p>(1) 折半查找的速度一定比顺序查找更快嘛？</p><img src="https://pic.imgdb.cn/item/665739d5d9c307b7e96d56f7.png" alt="数据结构（六）——查找——折半查找拓展思考1.png"><p>根据上图，我们可以轻易得到答案，答案显然是否定的，在上图的例子里，如果查找7，顺序查找只需要对比一次，而折半查找要对比多次。因此，我们可以说，大部分情况下折半查找的表现要比顺序查找优秀，但是不能说任何情况下，折半查找都一定优秀。</p><p>(2) 刚刚构造折半查找判定树是向下取整，如果向上取整，则判定树是什么样的呢？</p><img src="https://pic.imgdb.cn/item/66573a86d9c307b7e96e31d8.png" alt="数据结构（六）——查找——折半查找拓展思考2.png"><p>如果采用向上取整，那么与之前相比，特性要倒过来，即mid左子树的结点数-mid右子树的结点数&#x3D;1或0，与之前刚好相反。</p><h2 id="4-分块查找"><a href="#4-分块查找" class="headerlink" title="4. 分块查找"></a>4. 分块查找</h2><img src="https://pic.imgdb.cn/item/66573d25d9c307b7e971416b.png" alt="数据结构（六）——查找——分块查找.png"><p>分块查找将无序数组分块，每一个块中的元素虽然无序，但都比前一个块中元素大（或小），然后每个块都有一个对应的索引，多个块的索引就构成索引表，索引表中保存每个分块的最大关键字和分块的存储区间。</p><p>下面以一个例子来介绍分块查找的工作流程：</p><img src="https://pic.imgdb.cn/item/66573e3bd9c307b7e9729de4.png" alt="数据结构（六）——查找——分块查找成功示例1.png"><p>比如查找22，则先查找索引表，查找到第3个分块，该分块的最大数为30，大于22，这说明22如果存在，则应该存储在这个分块中。接下来根据这个分块区间，去依次查找6,7,8三个编号处的数据，最终在7处查找到目标数据。</p><img src="https://pic.imgdb.cn/item/66573f50d9c307b7e973e027.png" alt="数据结构（六）——查找——分块查找成功示例2.png"><p>上面给出的是查找成功的例子，下面看一下查找失败的情况：</p><img src="https://pic.imgdb.cn/item/66573f70d9c307b7e9740838.png" alt="数据结构（六）——查找——分块查找失败示例1.png"><p>如果查找29，则先查找索引表，最终确定在第三个块内，然后查找块内。</p><img src="https://pic.imgdb.cn/item/66573f89d9c307b7e97428e7.png" alt="数据结构（六）——查找——分块查找失败示例2.png"><p>按照顺序把块内数据查找完以后，发现指针的指向超出分块范围，则说明查找失败。</p><p>所以分块查找的思想就是先查找索引表，确定目标在哪个分块，然后再块内进行顺序查找。</p><img src="https://pic.imgdb.cn/item/6657403dd9c307b7e9751d31.png" alt="数据结构（六）——查找——分块查找思想.png"><p>注意，这里对索引表的查找可以是顺序查找也可以是折半查找，之前我们给的例子是顺序查找，下面看一下折半查找的情况：</p><p>第一种情况：</p><img src="https://pic.imgdb.cn/item/665740c7d9c307b7e975c92c.png" alt="数据结构（六）——查找——分块查找与折半查找示例1.png"><p>这里是对索引表进行折半查找的第一种情况，可以看到查找目标是30，刚好与mid所指的索引表上的数据相同，则说明30一定在该块内，下面只需要直接对该块内进行顺序查找即可。</p><p>下面看一下第二种情况，如果查找的目标是19，则对索引表进行折半查找，最后high与low指针会如下图所示：</p><img src="https://pic.imgdb.cn/item/66574197d9c307b7e976ba7b.png" alt="数据结构（六）——查找——分块查找与折半查找示例2.png"><p>此时low&gt;high，但并不能说明查找失败，我们还要对low所指分块进行块内查找，如果查找不到才能说明查找失败。这是因为排除前面的例子给出的直接查找到的情况，不论怎样，最后low所指的关键字一定会大于目标关键字，这个时候目标关键字可能会存储在low所指分块内，所以需要对该块进行查找。</p><img src="https://pic.imgdb.cn/item/665742dbd9c307b7e9784257.png" alt="数据结构（六）——查找——分块查找与折半查找示例2——成功.png"><p>最后，可以在该块内查找到目标元素，则说明查找成功。补充一下，如果在块内没有查找到，则说明查找失败。</p><p>下面看一下第三种情况：</p><img src="https://pic.imgdb.cn/item/66574350d9c307b7e979888f.png" alt="数据结构（六）——查找——分块查找与折半查找示例3.png"><p>如果查找54，经过对索引表的折半查找，最后low会超出索引表，此时会认为查找失败。</p><p>下面看一下分块查找的查找效率分析：</p><img src="https://pic.imgdb.cn/item/665743d4d9c307b7e97a4ec2.png" alt="数据结构（六）——查找——分块查找的ASL.png"><p>如果索引表采用顺序查找，则可以从头开始可以数出每个元素需要进行的查找次数，然后根据ASL公式可以计算查找效率。</p><p>如果索引表采用折半查找，则要根据折半查找的工作流程来计算查找每个元素的次数，比如查找27，不是对比2次就可以的，索引表会经过多次折半查找，最后当low指向30分块时，才会进行块内查找，才能找到27。所以索引表采用折半查找的ASL计算起来比较复杂，一般不考，当然不排除给一个简单的例子，然后让索引表使用顺序查找来计算ASL。</p><p>这里给出的都是查找成功的ASL，并没有给出失败的计算方法，是因为很难对查找失败的情况进行划分，也并没有像之前折半查找那样能很明确一个失败的区间，所以失败的ASL分析起来更麻烦，考试一般也不会进行考察。</p><p>接下来看一个可能被考察的比较特别的情况：</p><img src="https://pic.imgdb.cn/item/665745c8d9c307b7e97d5ce6.png" alt="数据结构（六）——查找——分块查找的查找效率1.png"><p>如果长度为n的查找表可以被均分为b个块，每个块s个元素，则分块查找的平均长度&#x3D;索引表的平均查找长度+块内查找的平均查找长度。</p><p>上图给出了索引表采用顺序查找的方式得到的分块查找的平均查找长度，令b&#x3D;s&#x2F;n代入可以化简，如上图得出的ASL。将得出的式子进行求导，最后可以得到当s&#x3D;sqrt(n)时，ASL最小，即效率最高。</p><img src="https://pic.imgdb.cn/item/665745f4d9c307b7e97d91d9.png" alt="数据结构（六）——查找——分块查找的查找效率2.png"><p>上面给出的是索引表采用折半查找时的ASL，分析方式同前面采用顺序表的一样。</p><p>下面对分块查找进行小结：</p><img src="https://pic.imgdb.cn/item/66574615d9c307b7e97db713.png" alt="数据结构（六）——查找——分块查找小结.png"><p>这里进行一个拓展：如果查找表式动态查找表，有没有更好的实现方式？</p><img src="https://pic.imgdb.cn/item/665747a4d9c307b7e97fa894.png" alt="数据结构（六）——查找——分块查找拓展.png"><p>比如上图，如果现在要插入8，则要插入第一个块内，那数组中在第一个块后的每一个元素都要向后移动，这样就显得很麻烦，所以我们可以采用如下图的链式存储来实现分块。</p><img src="https://pic.imgdb.cn/item/66574819d9c307b7e98030a5.png" alt="数据结构（六）——查找——分块查找拓展1.png"><p>采用链式存储，让索引表的各个表项使用指针连接起来，然后各个分块的元素也可以使用指针连接起来，如上图。这个时候如果插入8，只需要先找到8要插入第一个分块，然后再该分块的最后插上8即可。同样删除一个元素有很简单。甚至采用这种方式，当某一个分块内的元素过多时，也可以很方便的调整。</p><p>总之，还是那句话，算法是学不尽的，只要能结合具体问题具体分析实现即可，考试时也只需要根据题目要求来就行，题目若很开放只要思路清晰言之有理就行。</p><h2 id="5-二叉排序树"><a href="#5-二叉排序树" class="headerlink" title="5. 二叉排序树"></a>5. 二叉排序树</h2><img src="https://pic.imgdb.cn/item/665a815cd9c307b7e9924d51.png" alt="数据结构（六）——查找——二叉排序树的定义.png"><p>二叉排序树又称二叉查找树，缩写是BST。</p><p>二叉排序树需满足的特性：左子树结点值&lt;根结点值&lt;右子树结点值。</p><p>基于二叉树排序树的特性，如果进行中序遍历，可以得到一个递增的有序序列。</p><p>接下来看一下二叉排序树的查找：</p><img src="https://pic.imgdb.cn/item/665a825ad9c307b7e9933207.png" alt="数据结构（六）——查找——二叉排序树的查找（非递归）.png"><p>二叉排序树的查找就是从树的根结点开始，依次与目标值相比较，如果结点值小于目标值，则向右查找，如果大于，则向左查找。比如上图的查找12，先与19相比，小于19，向左查找。与13比，小于13，向左查找。与11比，大于11，向右查找，查找到NULL，则说明查找失败。</p><p>上面是非递归的实现，基于树的递归性，也可以采用递归的方式来实现二叉排序树的查找：</p><img src="https://pic.imgdb.cn/item/665a833ad9c307b7e993f2b0.png" alt="数据结构（六）——查找——二叉排序树的查找（递归）.png"><p>显然采用非递归的算法只需要常数级的辅助空间，但是如果采用递归算法，一棵树有多高，递归算法就有可能往下深入几层，而每深入一层，都要在递归栈里多分配一层的空间，因此用递归实现的空间复杂度应该为O(h)量级。</p><p>接下来看怎么插入一个结点：</p><img src="https://pic.imgdb.cn/item/665a84e1d9c307b7e9959a6a.png" alt="数据结构（六）——查找——二叉排序树插入）.png"><p>二叉排序树插入以后，要保证二叉排序树的特性，所以要先查找到在什么地方插入结点，然后进行插入操作。</p><p>上图给出了递归算法的实现，要注意，新插入的结点一定是叶子结点。另外，此递归算法的最坏空间复杂度为O(h)。</p><p>这里还需注意，要是某个结点已经存在，再插入就是插入失败。</p><p>基于二叉排序的插入，现在来看一下如何构造一个二叉排序树（就是不断插入新结点的一个过程）：</p><img src="https://pic.imgdb.cn/item/665a85bed9c307b7e996aca3.png" alt="数据结构（六）——查找——二叉排序树构造1.png"><p>上图给出了一个二叉排序树构造的例子，需要注意的是，不同的关键字序列可能得到同款二叉排序树。</p><img src="https://pic.imgdb.cn/item/665a8609d9c307b7e996eb93.png" alt="数据结构（六）——查找——二叉排序树构造2.png"><p>当然，不同的关键字序列也可能得到不同款二叉排序树。</p><p>接下来看一下删除的操作：</p><img src="https://pic.imgdb.cn/item/665a8691d9c307b7e9977dfa.png" alt="数据结构（六）——查找——二叉排序树删除.png"><p>对于上图的二叉排序树，如果删除一个结点，需要保证二叉排序树的特性，所以要看是删除哪个结点，然后分情况处理。</p><p>(1) 如果删除的是叶子结点：</p><img src="https://pic.imgdb.cn/item/665a86e4d9c307b7e997cb32.png" alt="数据结构（六）——查找——二叉排序树删除叶子结点.png"><p>如果删除的是叶子结点，只需要找到目标结点，然后删除即可。如上图是删除8,21,65三个叶子结点。</p><p>(2) 如果删除的结点只有一棵左子树和右子树：</p><img src="https://pic.imgdb.cn/item/665a874cd9c307b7e9983370.png" alt="数据结构（六）——查找——二叉排序树删除2.png"><p>若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。如上图是删除13和60两个结点</p><p>(3) 如果删除的结点既有左子树又有右子树：</p><img src="https://pic.imgdb.cn/item/665a8806d9c307b7e998dbea.png" alt="数据结构（六）——查找——二叉排序树删除3.png"><p>如果删除的结点既有左子树又有右子树，这时候有两种处理方法，一种是找前驱，一种是找后继。上图给出了删除50结点找后继的方法。</p><p>找后继，就是从结点的右子树里找到最小的一个结点，即中序遍历的第一个结点（可以通过中序遍历找后继）。然后把后继的值赋值到要被删除结点里，然后把后继当做删除结点进行处理。</p><p>比如上图，删除50结点，找到后继为60，将60赋值到50的位置，然后把原60的结点当做被删除结点处理，最后得到上图的结果。</p><p>下面看一下找前驱的处理方式：</p><img src="https://pic.imgdb.cn/item/665a8944d9c307b7e999fcc9.png" alt="数据结构（六）——查找——二叉排序树删除4.png"><p>找后继，就是从结点的左子树里找到最大的一个结点，即中序遍历的最后一个结点（可以通过中序遍历找前驱）。然后把前驱的值赋值到要被删除结点里，然后把前驱当做删除结点进行处理。</p><p>比如上图，删除50结点，找到前驱为30，将30赋值到50的位置，然后把原30的结点当做被删除结点处理，最后得到上图的结果。</p><p>接下来分析一下查找效率：</p><img src="https://pic.imgdb.cn/item/665a8fb8d9c307b7e9a111f1.png" alt="数据结构（六）——查找——二叉排序树查找效率.png"><p>根据上图的两个例子可以发现，树高越小，查找成功的平均查找长度就越小。另外在树一章学过，二叉树的最小高度为(log<sub>2</sub>n)+1，所以在构建二叉排序树树时，为了保证查找效率最高，就应该尽可能的让树的高度接近期待的最小值，基于这种思想就引出了平衡二叉树（平衡二叉树的知识参考6.平衡二叉树）。</p><p>下面看一下查找失败的平均ASL：</p><img src="https://pic.imgdb.cn/item/665a916dd9c307b7e9a2979e.png" alt="数据结构（六）——查找——二叉排序树查找效率失败.png"><p>显然，查找失败的效率也是树高越小，效率越高。这进一步说明了，我们在构建二叉排序树时，要让树的高度尽可能小。</p><p>最后对二叉排序树进行小结：</p><img src="https://pic.imgdb.cn/item/665a91cad9c307b7e9a2ec8e.png" alt="数据结构（六）——查找——二叉排序树小结.png"><h2 id="6-平衡二叉树"><a href="#6-平衡二叉树" class="headerlink" title="6. 平衡二叉树"></a>6. 平衡二叉树</h2><h3 id="6-1-平衡二叉树的定义"><a href="#6-1-平衡二叉树的定义" class="headerlink" title="6.1 平衡二叉树的定义"></a>6.1 平衡二叉树的定义</h3><img src="https://pic.imgdb.cn/item/665aa928d9c307b7e9ba1c55.png" alt="数据结构（六）——查找——平衡二叉树定义.png"><p>平衡二叉树，简称平衡树（AVL树）――树上任一结点的左子树和右子树的高度之差不超过1。</p><p>在平衡二叉树里，每个结点都有一个平衡因子，结点的平衡因子&#x3D;左子树高-右子树高。根据平衡二叉树定义可以知道平衡因子只能取1，0，-1。</p><p>在5. 二叉排序树里我们了解到，让一个二叉排序树保持平衡，就可以让这个二叉排序树的查找效率达到O(log<sub>2</sub>n)数量级。因此这部分需要着重研究的是，在插入一个新结点后，如何让二叉树保持平衡。</p><h3 id="6-2-平衡二叉树的插入"><a href="#6-2-平衡二叉树的插入" class="headerlink" title="6.2 平衡二叉树的插入"></a>6.2 平衡二叉树的插入</h3><img src="https://pic.imgdb.cn/item/665aadfed9c307b7e9c06d55.png" alt="数据结构（六）——查找——平衡二叉树插入.png"><p>如上图，我们在二叉平衡树里插入一个67结点，则67结点的所有祖先的平衡因子都受到影响。为了让这个树恢复平衡，我们需要从新插入的结点向上找，找到第一个不平衡的结点，调整以该结点为根的子树。而由这个结点和其子树构成的树就是最小不平衡子树。</p><p>在二叉平衡树的插入操作里，每次调整的对象都是最小不平衡子树。</p><p>接下来要讨论，如何调整最小不平衡子树：</p><img src="https://pic.imgdb.cn/item/665aaf26d9c307b7e9c19f1f.png" alt="数据结构（六）——查找——调整最小不平衡子树.png"><p>最小不平衡子树的调整有上面四种情况，接下来分别看一下。</p><p><strong>(1) LL</strong></p><img src="https://pic.imgdb.cn/item/665aaf72d9c307b7e9c1f44d.png" alt="数据结构（六）——查找——调整最小不平衡子树LL.png"><p>上图下已经介绍了LL型的调整方法，我就不再叙述。需要注意，图中给的都是最小不平衡子树，并不是完整的一棵树。</p><p>另外，这里思考一点，为什么在一开始时假定所有的子树的高度都是H？注意，我们探讨的是加入一个新结点以后才出现不平衡的情况，如果AR&#x3D;H+1也是可以的，但这个时候如果加入一个结点是不会导致不平衡的情况出现的；如果AR&#x3D;H-1，则现在已经出现不平衡的情况，应该即刻调整而不是我们探讨的插入以后才调整。如果BL或BR等于H+1，则也应该即刻调整。如果BL或BR等于H-1，则可能出现添加新结点无需调整的情况。综合来看，为了满足探索要求，应该将所有子树的高度都假定为H。</p><p><strong>(2) RR</strong></p><img src="https://pic.imgdb.cn/item/665ab1efd9c307b7e9c49da9.png" alt="数据结构（六）——查找——调整最小不平衡子树RR.png"><p>上图下已经介绍了RR型的调整方法，我就不再叙述。</p><p>接下来看一下如何用代码实现刚刚说的左旋和右旋操作：</p><img src="https://pic.imgdb.cn/item/665ab264d9c307b7e9c51f6f.png" alt="数据结构（六）——查找——左旋右旋的代码思路.png"><p><strong>(3) LR</strong></p><img src="https://pic.imgdb.cn/item/665ab2d1d9c307b7e9c58f05.png" alt="数据结构（六）——查找——调整最小不平衡子树LR.png"><p>LR型调整方法如上图所说，调整结果如下：</p><img src="https://pic.imgdb.cn/item/665ab37fd9c307b7e9c643f6.png" alt="数据结构（六）——查找——调整最小不平衡子树LR1.png"><p>这里有一点需要说一下，对于LR型的插入，以该例为例，新插入的结点可以是插入到C的左子树也可以是右子树，但无论插入哪个，都是LR型，只要是LR型，其调整方法都一样。</p><p><strong>(4) RL</strong></p><img src="https://pic.imgdb.cn/item/665ab3dcd9c307b7e9c6a69a.png" alt="数据结构（六）——查找——调整最小不平衡子树RL.png"><p>RL型调整方法如上图所说，调整结果如下：</p><img src="https://pic.imgdb.cn/item/665ab40ad9c307b7e9c6d7f0.png" alt="数据结构（六）——查找——调整最小不平衡子树RL1.png"><p>类似的，对于RL型的插入，以该例为例，新插入的结点可以是插入到C的左子树也可以是右子树，但无论插入哪个，都是RL型，只要是RL型，其调整方法都一样。</p><p>下面对这四种情况进行一个汇总：</p><img src="https://pic.imgdb.cn/item/665ab471d9c307b7e9c73cdd.png" alt="数据结构（六）——查找——调整最小不平衡子树小结.png"><p>接下来填一个小坑，为什么在插入操作中，只要将最小不平衡子树调整平衡，则其他祖先结点都会恢复平衡？</p><p>这是因为插入操作导致“最小不平衡子树”高度+1，经过调整后高度恢复，相应的祖先的平衡因子也会恢复。</p><p>接下来看一下查找效率：</p><img src="https://pic.imgdb.cn/item/665ab55fd9c307b7e9c83583.png" alt="数据结构（六）——查找——二叉平衡树的效率分析.png"><p>在一棵树里进行查找，主要影响查找效率的是树的高度，若树高为h，则查找一个关键字最多需要对比h次，则查找的时间复杂度最多不会超过O(h)。因此分析效率就是分析一棵平衡二叉树的高度有多高。</p><p>基于平衡二叉树的特性，可以假设n<sub>h</sub>是深度为h的平衡树中含有的最少结点数。显然h&#x3D;0时，n<sub>0</sub>&#x3D;0；h&#x3D;1时，n<sub>1</sub>&#x3D;1；h&#x3D;2时，n<sub>2</sub>&#x3D;2；由此可以递推，高度为h的二叉树，结点数最少的情况是一个根结点加上一个结点最少的高为h-1的左（右）子树和一个高为h-2的右（左）子树。</p><p>所以可得递推公式：<strong>n<sub>h</sub>&#x3D;n<sub>h-1</sub>+n<sub>h-2</sub>+1</strong>。</p><p>基于这个公式，如果结点总数为n，那么它的最高大度应为**O(log<sub>2</sub>n)**数量级。而最大高度反应了最坏情况下的查找时间的复杂度，因此平衡二叉树的平均查找长度或时间复杂度应该和树高是同一个数量级的。</p><p>另外补充一点，如何通过递推公式来证明最大高度是**O(log<sub>2</sub>n)**数量级，这个证明很麻烦，知道是由递推公式得出的就好。</p><p>最后小结一下这部分：</p><img src="https://pic.imgdb.cn/item/665ab7e7d9c307b7e9caeb26.png" alt="数据结构（六）——查找——二叉平衡树小结.png"><h3 id="6-3-平衡二叉树的删除"><a href="#6-3-平衡二叉树的删除" class="headerlink" title="6.3 平衡二叉树的删除"></a>6.3 平衡二叉树的删除</h3><img src="https://pic.imgdb.cn/item/665ab853d9c307b7e9cb579f.png" alt="数据结构（六）——查找——平衡二叉树的删除.png"><p>平衡二叉树进行删除结点的操作和二叉排序树一样，但是删除完一个以后要保证树仍是二叉平衡树，所以和平衡二叉树的插入一样，平衡二叉树在删除结点以后也需要对不平衡性进行调整，这里先给出了平衡二叉树删除一个结点的步骤，如上图。接下来用具体的示例来进行解读。</p><p>例1：</p><img src="https://pic.imgdb.cn/item/665abae7d9c307b7e9cf480b.png" alt="数据结构（六）——查找——平衡二叉树的删除例1.png"><p>在上图，删除9这个结点，根据步骤1可以知道，删的是叶子结点，直接删除。然后进行第二步，发现找不到最小平衡子树，则表明不需要调整，删除成功。</p><p>例2：</p><p>在例题1删除9的基础上，要再次删除55这个结点：</p><img src="https://pic.imgdb.cn/item/665abb95d9c307b7e9d01088.png" alt="数据结构（六）——查找——平衡二叉树的删除例2-1.png"><p>发现55是叶子结点，根据第一步骤，直接删除。进入第二步，找到最小不平衡子树以75为根结点。然后进入第三步，以75为根，找到个头最高的儿子和孙子，如下图：</p><img src="https://pic.imgdb.cn/item/665abbdbd9c307b7e9d06b8b.png" alt="数据结构（六）——查找——平衡二叉树的删除例2-2.png"><p>然后进入第四步，发现孙子在RR的位置，于是进行儿子左单旋调整，调整结果如下图：</p><img src="https://pic.imgdb.cn/item/665abc69d9c307b7e9d11a6f.png" alt="数据结构（六）——查找——平衡二叉树的删除例2-3.png"><p>这个时候最小不平衡子树就恢复了平衡状态。现在要进行第五步，发现没有向上传导不平衡，于是删除结点成功。</p><p>例3：</p><img src="https://pic.imgdb.cn/item/665abcd4d9c307b7e9d1b227.png" alt="数据结构（六）——查找——平衡二叉树的删除例3-1.png"><p>如上图，删除32这个结点，根据步骤1可以知道，删的是叶子结点，直接删除。然后进行第二步，找到最小不平衡子树以44为根结点。然后进入第三步，以44为根，找到个头最高的儿子和孙子，如下图：</p><img src="https://pic.imgdb.cn/item/665abd4dd9c307b7e9d232de.png" alt="数据结构（六）——查找——平衡二叉树的删除例3-2.png"><p>接下来进入第四步，根据孙子所处位置为RL，然后进行RL型平衡调整，先右旋再左旋。</p><img src="https://pic.imgdb.cn/item/665abd8dd9c307b7e9d277ec.png" alt="数据结构（六）——查找——平衡二叉树的删除例3-3.png"><p>显然，这个时候最小不平衡子树就恢复了平衡状态。且没有向上传导不平衡，于是删除结点成功。</p><p>例4（有不平衡传导）：</p><img src="https://pic.imgdb.cn/item/665abde3d9c307b7e9d2d383.png" alt="数据结构（六）——查找——平衡二叉树的删除例4-1.png"><p>如上图，删除32这个结点，可以看到，上图根结点的右子树就是例3，所以这部分的调整过程省略，直接看调整后的结果。</p><img src="https://pic.imgdb.cn/item/665b1fd7d9c307b7e9447cb8.png" alt="数据结构（六）——查找——平衡二叉树的删除例4-2.png"><p>可以看到，在对最小不平衡子树调整以后，不平衡向上传导到根结点33，这时候要从刚刚调整的子树的根出发，一路向北找到最小不平衡子树，然后按照步骤继续执行。</p><p>找到最小不平衡子树的根结点是33，这时候就要进行第三步，找个头最高的儿子和孙子，查找结果如下图：</p><img src="https://pic.imgdb.cn/item/665b2063d9c307b7e9451f9f.png" alt="数据结构（六）——查找——平衡二叉树的删除例4-3.png"><p>接下来进入第四步，根据孙子所处位置为LR，然后进行LR型平衡调整，先左旋再右旋。最后结果如下图：</p><img src="https://pic.imgdb.cn/item/665b20ead9c307b7e945c5bc.png" alt="数据结构（六）——查找——平衡二叉树的删除例4-4.png"><p>此时进行第五步，发现没有不平衡，则删除成功。</p><p>例5：</p><img src="https://pic.imgdb.cn/item/665b213dd9c307b7e94629f5.png" alt="数据结构（六）——查找——平衡二叉树的删除例5-1.png"><p>例5删除的结点是75，这个结点既有左子树也有右子树。由于平衡二叉树的删除和二叉排序树一样，所以这里用前驱和后继来顶替被删结点，然后转换为对前驱和后继的删除。</p><p>假设用前驱代替，及用60代替75，然后转换为删除60这个结点。</p><img src="https://pic.imgdb.cn/item/665b2554d9c307b7e94afafe.png" alt="数据结构（六）——查找——平衡二叉树的删除例5-2.png"><p>此时60只有左子树，即删除60，并用左子树顶替即可，之后按步骤进行调整即可，这里就不再演示。</p><p>如果用后继代替，则用77覆盖75，然后转换为删除77这个结点：</p><img src="https://pic.imgdb.cn/item/665b25a9d9c307b7e94b575c.png" alt="数据结构（六）——查找——平衡二叉树的删除例5-3.png"><p>可以看到77是叶子结点，所以直接删除即可，然后按步骤找最小不平衡子树调整平衡即可。</p><p>最后对该部分做个汇总：</p><img src="https://pic.imgdb.cn/item/665b2627d9c307b7e94bdf9a.png" alt="数据结构（六）——查找——平衡二叉树的删除小结.png"><h2 id="7-红黑树"><a href="#7-红黑树" class="headerlink" title="7. 红黑树"></a>7. 红黑树</h2><h3 id="7-1-红黑树的定义和性质"><a href="#7-1-红黑树的定义和性质" class="headerlink" title="7.1 红黑树的定义和性质"></a>7.1 红黑树的定义和性质</h3><img src="https://pic.imgdb.cn/item/665b2bc3d9c307b7e9535426.png" alt="数据结构（六）——查找——红黑树.png"><p>由于平衡二叉树的插入&#x2F;删除很容易破坏“平衡”特性，需要频繁调整树的形态，这导致时间开销很大，所以引入红黑树的概念。</p><p>红黑树的插入&#x2F;删除很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即使需要调整，也可以在常数级时间内完成。所以红黑树的实用性更强。</p><p>接下来具体看一下红黑树的定义：</p><img src="https://pic.imgdb.cn/item/665b2c91d9c307b7e9545422.png" alt="数据结构（六）——查找——红黑树的定义.png"><p><strong>满足上面五个性质的二叉排序树就是红黑树</strong>。红黑树的程序结构描述上图也给出。</p><p>对于红黑树的性质可以总结为：左根右，根叶黑，不红红，黑路同，这12个字。</p><p>这里需要注意第三条，红黑树里的叶结点（外部结点、NULL结点、失败结点）均是黑色的。这里的叶结点并不是我们平常说的普通树上的叶结点，而是指失败结点，也叫NULL结点。下面给个图理解：</p><img src="https://pic.imgdb.cn/item/665b2ec0d9c307b7e9570d07.png" alt="数据结构（六）——查找——红黑树的例子.png"><p>如上图，每个有关键字的结点若是没有左子树或右子树则会连上对应的NULL结点，这些结点也叫叶结点或失败结点。</p><p>另外，从这个图里，也可以看到，红黑树的其它性质，比如根结点是黑色的等。可以结合这个例子加深对红黑树性质的理解。</p><p>考试时可能会出现辨别红黑树的题，比如下图给出的题：</p><img src="https://pic.imgdb.cn/item/665b2f7bd9c307b7e957fcb8.png" alt="数据结构（六）——查找——辨别红黑树.png"><p>这道题里，左上的树不满足不红红的性质，所以不是红黑树。右上的树根结点不是黑的，所以也不是红黑树。左下的不满足黑路同性质，所以也不是红黑树。所以只有右下的是红黑树。</p><p>补充一个概念——结点的“黑高”</p><img src="https://pic.imgdb.cn/item/665b3c41d9c307b7e968a2bc.png" alt="数据结构（六）——查找——黑高.png"><p>所谓黑高就是从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点总数。</p><p>下面看一下红黑树的性质：</p><img src="https://pic.imgdb.cn/item/665b3c8dd9c307b7e968f317.png" alt="数据结构（六）——查找——红黑树的性质.png"><p>解释一下第一条性质，从根结点到叶结点的最短路径就是只有黑结点，如果是最长路径，则应该存在红结点，且根据红黑树的不红红和黑路同的性质，最长路径就是红结点依次穿插进黑结点的路径。所以，<strong>从根结点到叶结点的最长路径不大于最短路径的2倍</strong>。这也说明红黑树的左右子树高度之差不会超过两倍，相比于平衡二叉树左右子树高度之差不能超过1，所以红黑树在进行插入删除操作时，由于其要求相比于平衡二叉树来说较宽，所以红黑性不容易被破坏，这也就是为什么红黑树的插入删除比平衡二叉树更高效的原因。</p><p>对于第二条性质，这里先记一下关系式，在7.3讲完红黑树的插入操作，了解了红黑树的构造，对红黑树有了更深一层的理解以后，再解释如何得到这个关系式。由于树高反应时间复杂度，所以红黑树的查找时间复杂度是O(log<sub>2</sub>n)数量级。</p><h3 id="7-2-红黑树的查找"><a href="#7-2-红黑树的查找" class="headerlink" title="7.2 红黑树的查找"></a>7.2 红黑树的查找</h3><img src="https://pic.imgdb.cn/item/665b3e3ed9c307b7e96ad1cc.png" alt="数据结构（六）——查找——红黑树的查找.png"><p>红黑树的查找操作与平衡二叉树、二叉排序树一样，这里就不说了。重点看一下插入操作。</p><h3 id="7-3-红黑树的插入"><a href="#7-3-红黑树的插入" class="headerlink" title="7.3 红黑树的插入"></a>7.3 红黑树的插入</h3><img src="https://pic.imgdb.cn/item/665b3ef2d9c307b7e96b95e0.png" alt="数据结构（六）——查找——红黑树的插入步骤.png"><p>先给出红黑树的插入步骤，结合这个步骤，我们再以上图上抛出的问题充当例子来具体讲解红黑树的插入过程。</p><p>需要注意一下，上图给出的步骤里，所谓染色就是将当前结点的颜色染上另一种颜色。比如如果原来是红，就染成黑；如果原来是黑，就染成红。</p><img src="https://pic.imgdb.cn/item/665bdc91d9c307b7e9ee5bc1.png" alt="数据结构（六）——查找——红黑树的插入1.png"><p>首先插入20，20是根结点，根据步骤直接染成黑色。</p><p>插入10，根据步骤是叶子结点，先染成红色，得到上图中第二棵树，该树满足红黑树定义，插入成功。</p><p>插入5，根据步骤是叶子结点，先染成红色，得到上图中第三棵树，但该树不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是黑色的，这时候再根据新插入结点是LL型，进行右单旋操作，用父亲换爷爷，最后再将父亲和爷爷分别染色（即染上原颜色的相反色）。这个时候就得到了上图中右下角满足红黑树性质的树。</p><p>接下来插入30结点：</p><img src="https://pic.imgdb.cn/item/665bf526d9c307b7e9079fcd.png" alt="数据结构（六）——查找——红黑树的插入2.png"><p>插入30，根据步骤是叶子结点，先染成红色，得到上图中第一棵树，但该树不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是红色的，这时候需要让叔父爷染色，并让爷结点充当新结点，此时爷结点是根结点且是红色，所以染黑即可。这个时候就得到了上图右满足红黑树性质的树。</p><p>接下来插入40结点：</p><img src="https://pic.imgdb.cn/item/665bf66ed9c307b7e908abdc.png" alt="数据结构（六）——查找——红黑树的插入3.png"><p>插入40，是叶子结点，先染成红色，得到上图中第一棵树，但该树不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是黑色的，这时候再根据新插入结点是RR型，进行左单旋操作，用父亲换爷爷，最后再将父亲和爷爷分别染色（即染上原颜色的相反色）。这个时候就得到了上图右角满足红黑树性质的树。</p><p>接下来插入57结点：</p><img src="https://pic.imgdb.cn/item/665bf6e1d9c307b7e9090a41.png" alt="数据结构（六）——查找——红黑树的插入4.png"><p>插入57，根据步骤是叶子结点，先染成红色，得到上图中第一棵树，但该树不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是红色的，这时候需要让叔父爷染色，并让爷结点充当新结点，新得到树没有不满足红黑树的性质。这个时候就得到了上图右满足红黑树性质的树。</p><p>接下来插入3结点：</p><img src="https://pic.imgdb.cn/item/665bf7b0d9c307b7e909beea.png" alt="数据结构（六）——查找——红黑树的插入5.png"><p>新插入的3结点没有破坏红黑树的性质，所以不需要调整，直接插入成功。</p><p>接下来插入2结点：</p><img src="https://pic.imgdb.cn/item/665bf7f2d9c307b7e90a1f0c.png" alt="数据结构（六）——查找——红黑树的插入6.png"><p>插入2，是叶子结点，先染成红色，得到上图中第一棵树，但该树不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是黑色的，这时候再根据新插入结点是LL型，进行右单旋操作，用父亲换爷爷，最后再将父亲和爷爷分别染色（即染上原颜色的相反色）。这个时候就得到了上图下满足红黑树性质的树。</p><p>接下来插入4结点：</p><img src="https://pic.imgdb.cn/item/665bf851d9c307b7e90a842f.png" alt="数据结构（六）——查找——红黑树的插入7.png"><p>插入4，根据步骤是叶子结点，先染成红色，得到上图中第一棵树，但该树不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是红色的，这时候需要让叔父爷染色，并让爷结点充当新结点，新得到树没有不满足红黑树的性质。这个时候就得到了上图右满足红黑树性质的树。</p><p>接下来插入35，25，18结点：</p><img src="https://pic.imgdb.cn/item/665bf8f7d9c307b7e90b2446.png" alt="数据结构（六）——查找——红黑树的插入8.png"><p>这三个结点都不需要调整，所以直接给结果。</p><p>接下来插入22结点：</p><img src="https://pic.imgdb.cn/item/665bf939d9c307b7e90b64fb.png" alt="数据结构（六）——查找——红黑树的插入9.png"><p>插入22，根据步骤是叶子结点，先染成红色，得到上图中第一棵树，但该树不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是红色的，这时候需要让叔父爷染色，并让爷结点充当新结点。</p><p>以爷爷结点为新结点时发现不满足红黑树的性质中不红红的特性，所以需要进一步调整红黑树。按照步骤，这个时候需要根据新结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是红色的，这时候需要让叔父爷染色，并再让爷结点充当新结点，此时爷结点变为根结点，需要染黑。这个时候就得到了上图右下满足红黑树性质的树。</p><p>接下来插入23结点：</p><img src="https://pic.imgdb.cn/item/665bf9dad9c307b7e90c02bf.png" alt="数据结构（六）——查找——红黑树的插入10_1.png"><p>插入23，是叶子结点，先染成红色，得到上图中的树，但该树不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是黑色的，这时候再根据新插入结点是LR型，先进行左旋，再进行右旋，用儿子换爷爷，最后再将儿子和爷爷分别染色（即染上原颜色的相反色）。就得到了下图：</p><img src="https://pic.imgdb.cn/item/665bfa54d9c307b7e90c7786.png" alt="数据结构（六）——查找——红黑树的插入10_2.png"><p>此时满足红黑树的特性，插入成功。</p><p>接下来插入24结点：</p><img src="https://pic.imgdb.cn/item/665bfa80d9c307b7e90ca3f8.png" alt="数据结构（六）——查找——红黑树的插入11_1.png"><p>插入24，是叶子结点，先染成红色，得到上图中的树，但该树不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是红色的，这时候需要让叔父爷染色，并让爷结点充当新结点，就得到了下图：</p><img src="https://pic.imgdb.cn/item/665bfadbd9c307b7e90d0b98.png" alt="数据结构（六）——查找——红黑树的插入11_2.png"><p>这个时候把爷结点视作新结点加入后，显然又破坏了不红红的性质，这个时候需要进一步进行调整，从图中看的叔叔结点是黑色的，这时候再根据新插入结点是LR型，进行先左旋再右旋操作，用儿子换爷爷，最后再将儿子和爷爷分别染色（即染上原颜色的相反色）。如下图：</p><img src="https://pic.imgdb.cn/item/665bfb6dd9c307b7e90db3e6.png" alt="数据结构（六）——查找——红黑树的插入11_3.png"><p>经过调整以后满足红黑树的性质，就不需再调整。</p><p>接下来插入19结点：</p><img src="https://pic.imgdb.cn/item/665bfb9ed9c307b7e90de6de.png" alt="数据结构（六）——查找——红黑树的插入12.png"><p>显然19没有破坏红黑树的性质，直接插入即可。</p><p>接下来插入18结点：</p><p>这个时候会发现，原先已经有18这个结点了，此时18应该插入哪个地方，这个时候可以根据具体的应用场景自己定位，可以插到18的左边，有可以插到18的右边。</p><p>比如插到18的右边，如下图：</p><img src="https://pic.imgdb.cn/item/665bfc39d9c307b7e90e92f6.png" alt="数据结构（六）——查找——红黑树的插入13.png"><p>此时不满足红黑树的性质中不红红的特性，所以需要调整红黑树。按照步骤，这个时候需要根据新插入结点的叔叔结点的颜色来进行调整。可以从图中看的叔叔结点是黑色的，这时候再根据新插入结点是RL型，进行先右旋再左旋的操作，用儿子换爷爷，最后再将儿子和爷爷分别染色（即染上原颜色的相反色）。这个时候就得到了下图满足红黑树性质的树。</p><img src="https://pic.imgdb.cn/item/665bfc9ad9c307b7e90f7e6f.png" alt="数据结构（六）——查找——红黑树的插入13_1.png"><p>当然也可以选择插在左边，这个时候结果和上图一样，但是要注意中间的变换过程不一样，如果是直接插入左边，则上图红色的18是新插入的结点。如果是插入右边，则上图红色的18是原来的爷结点。</p><p>接下来做个小结：</p><img src="https://pic.imgdb.cn/item/665bfd1ed9c307b7e910181a.png" alt="数据结构（六）——查找——红黑树的插入小结.png"><p>接下来填补一个坑，就是红黑树的第二条性质：有n个内部节点的红黑树高度**h&lt;&#x3D;2log<sub>2</sub> (n+1)**这个关系是如何求出来的：</p><img src="https://pic.imgdb.cn/item/665bff6ad9c307b7e912e6e1.png" alt="数据结构（六）——查找——黑高理论.png"><p>首先看一下黑高理论，若黑高为h的红黑树，<strong>内部结点数最少的情况是总共h层全是黑结点的满树形态</strong>。</p><p>这里补充两个易错点：</p><ol><li>计算黑高时，是从某结点出发计算，但不算该结点。而算内部结点数时，是不算NULL结点的，应该NULL结点是外部结点。</li><li>这里有一个疑问，就是内部结点数最少的情况是总共h层全是黑结点的满树形态，为什么一定是满树形态，是因为如果不是满树，就满足不了黑路同的性质。比如上图黑高为2的树，如果右边没有带关键字的结点，就是NULL结点，此时黑路同的性子就不满足了。</li></ol><p>根据内部结点数最少的情况是总共h层全是黑结点的满树形态，可以得到一个结论，<strong>若根节点黑高为h，内部结点数（关键字）最少有2<sup>h</sup>-1个。</strong></p><p>知道上面的结论以后，可以证明性质2，证明如下：</p><img src="https://pic.imgdb.cn/item/665c014dd9c307b7e914b6fd.png" alt="数据结构（六）——查找——红黑树性质2证明.png"><p>若红黑树总高度&#x3D;h，则根据红黑树的特点，根节点的黑高至少得是h&#x2F;2，因此内部结点数n&gt;&#x3D;2<sup>h&#x2F;2</sup>-1，将此式化简，便可得到h&lt;&#x3D;2log<sub>2</sub>(n+1)。</p><h3 id="7-4-红黑树的删除"><a href="#7-4-红黑树的删除" class="headerlink" title="7.4 红黑树的删除"></a>7.4 红黑树的删除</h3><img src="https://pic.imgdb.cn/item/665c02ead9c307b7e9167d1e.png" alt="数据结构（六）——查找——红黑树的删除.png"><p>上面便是红黑树的删除需要知道的考点，由于红黑树的删除比插入还要复杂，考试时不大可能会去考查，所以知道上面的知识点足够了，如果复习留有余力的，且担心会考察具体操作的，可以自己再搜集资料进行学习。</p><h2 id="8-B树"><a href="#8-B树" class="headerlink" title="8. B树"></a>8. B树</h2><h3 id="8-1-B树的定义与性质"><a href="#8-1-B树的定义与性质" class="headerlink" title="8.1 B树的定义与性质"></a>8.1 B树的定义与性质</h3><img src="https://pic.imgdb.cn/item/665c32a4d9c307b7e94922ef.png" alt="数据结构（六）——查找——五叉查找树.png"><p>对于一个二叉排序树，是结点里面只有一个关键字，然后分出两个区间，即有两个孩子。我们将其扩展，如图，如果扩展成一个五叉排序树，则每个结点里最多有4个关键字，然后划分出5个区间，即有5个孩子，当然在五叉排序树里，每个结点也可以只有一个关键字，然后有两个孩子。所以五叉排序树的结构描述可以如上图左上，通过num来记录结点里有几个关键字，孩子个数可以通过num+1求得。</p><p>在此我们思考一下，如果在一个五叉排序树里，每个结点都存储一个关键字，这就又退化成了二叉排序树。显然，如果关键字个数一定，则结点里存储的关键字个数越少，树就越高，要查找的层次就更高，效率就低。</p><p>为此我们可以引入下面的这样一个策略：</p><img src="https://pic.imgdb.cn/item/665c344ed9c307b7e94ab44f.png" alt="数据结构（六）——查找——m叉查找树策略1.png"><p>为了保证查找的效率，**<font color=red>在m叉查找树中，规定除了根节点外，任何结点至少有[m&#x2F;2]个分叉，即至少含有[m&#x2F;2]-1个关键字</font>**。引入了这个策略，就可以保证树高（也就是保证查找效率），不会出现一个多叉查找树退化成二叉查找树的情况。</p><p>注意一点，在策略里说除根节点以外，任何结点至少有[m&#x2F;2]个分叉。这里为什么要强调除根节点，是因为根节点无法满足至少有[m&#x2F;2]个分叉。比如，一个五叉查找树，除根节点外，每个节点都要有[5&#x2F;2]&#x3D;3个分支（“[ ]”是向上取整符号），那么在构造一个五叉查找树的时候，只插入一个22，显然22这个关键字只能放在根节点里，而且也只能引出两个孩子，无法引出3个分支，所以规定中把根节点排除。</p><img src="https://pic.imgdb.cn/item/665c365fd9c307b7e94d5587.png" alt="数据结构（六）——查找——m叉查找树策略2.png"><p>上图给出第二种情况，对于这样一个五叉查找树，显然满足了前面所说的特性，但是它的高度依然很高，是因为它没有满足平衡性。这个时候回想到二叉平衡树的定义，二叉平衡树定义里要让左右子树高度之差不超过1。但是对于一个五叉树来说，这样的比较会比较麻烦，所以引入了第二条简化策略，**<font color=red>m叉查找树中，规定对于任何一个结点，其所有子树的高度都要相同</font>**。</p><p>综合这两种策略，我们就可以保证m叉查找树的效率，同时可以得到下图的B树的概念：</p><img src="https://pic.imgdb.cn/item/665c37bad9c307b7e94e9dc4.png" alt="数据结构（六）——查找——B树.png"><p>注意一点，在B树里，我们通常会把最下面一层的失败结点叫做叶子结点，而在失败结点上面一层的结点叫做终端结点。</p><p>对B树的非叶结点的结构描述如下图：</p><img src="https://pic.imgdb.cn/item/665c3876d9c307b7e94f671a.png" alt="数据结构（六）——查找——B树结点结构.png"><p>将上面的信息压缩一下，我们可以总结出下面的B树的核心特性：</p><img src="https://pic.imgdb.cn/item/665c38bcd9c307b7e94fb014.png" alt="数据结构（六）——查找——B树核心特性.png"><p>接下来思考一下如何计算B树的最大最小高度：</p><img src="https://pic.imgdb.cn/item/665c3908d9c307b7e94ff99c.png" alt="数据结构（六）——查找——B树的最小高度.png"><p><strong>需要注意，没有特别说明，算B树的高度一般不包括叶子结点。</strong></p><p>对于一个含n个关键字的m阶B树，最小高度就是每一层都有m个结点，每个结点都存储m-1个关键字。所以最小高度的计算如上图。这里稍微解释一下，每个结点最多有m-1个关键字，第一层最多有1个结点，第二层最多m个，第三层最多m<em>m，依次类推，将每一层的最多结点数加起来乘上每个结点的最多关键字数，可以得到一个h层的m叉查找树所存储的最大关键字字数。由此可以得到公式n&lt;&#x3D;(m-1)(1+m+m*m+……+m<sup>h-1</sup>)&#x3D;m<sup>h</sup>-1，化简这个公式可以得到</em>*<font color=red>含n个关键字的m阶B树的最小高度为h&gt;&#x3D;log<sub>m</sub>(n+1)</font>**。</p><p>下面看一下B树的最大高度：</p><img src="https://pic.imgdb.cn/item/665c3b56d9c307b7e9525b99.png" alt="数据结构（六）——查找——B树的最大高度.png"><p>B树的最大高度就是根节点只有1个关键字，这样第二层只有两个结点，然后每一层结点的个数都是[m&#x2F;2]，即除了根节点是1个关键字外，每个结点都只有[m&#x2F;2]-1个关键字。</p><p>根据上面所述，这样得到的每层结点数都是最少数，则第h层有2([m&#x2F;2])<sup>h-2</sup>个结点，所以第h+1层至少有2([m&#x2F;2])<sup>h-1</sup>个失败结点。</p><p>这里再补充一个特性，**<font color=red>对于一个n个关键字的B树必有n+1个叶子结点</font>**。这是因为，n个关键字相当于把数域划分为n+1个区间，这n+1个区间就是查找失败的失败区间，也就是失败结点。</p><p>根据特性以及我们求得的第h+1层的最小失败结点数，可以得到这样一个关系式：2([m&#x2F;2])<sup>h-1</sup>&lt;&#x3D;n+1。把这个关系式化简，就可以得到**<font color=red>h&lt;&#x3D;log<sub>[m&#x2F;2]</sub>(n+1&#x2F;2)+1</font>**。</p><p>上面是从结点入手求最大高度，这里再给另一种B树最大高度的求解思路，即从关键字入手：</p><img src="https://pic.imgdb.cn/item/665c3f62d9c307b7e956864c.png" alt="数据结构（六）——查找——B树的最大高度2.png"><p>从关键字入手的思路就是假设每一层的关键字数都是最少的，这样可以求得一个h层B树的最小关键字数，如果小于这个数，则达不到h这个高度。具体的求解过程参考上图。</p><p>下面对该部分进行一个小结：</p><img src="https://pic.imgdb.cn/item/665c40abd9c307b7e957cf03.png" alt="数据结构（六）——查找——B树性质小结.png"><h3 id="8-2-B树的插入与删除"><a href="#8-2-B树的插入与删除" class="headerlink" title="8.2 B树的插入与删除"></a>8.2 B树的插入与删除</h3><h4 id="8-2-1-B树的插入"><a href="#8-2-1-B树的插入" class="headerlink" title="8.2.1 B树的插入"></a>8.2.1 B树的插入</h4><p>这里以一个五阶B树为例，来进行插入操作：</p><img src="https://pic.imgdb.cn/item/665c4a94d9c307b7e9619267.png" alt="数据结构（六）——查找——B树插入1.png"><p>如上图，首先插入25，则直接放到根节点里，需要注意，这里省略了失败结点。接下来依次插入38、49、60都放入到根节点里。到目前为止，根节点里所能存储的关键字个数已经到达了上限。此时如果继续往里插入关键字，就会导致关键字超出上限，对于这种情况就要把当前根节点分裂成两个结点。</p><p>假设插入80这个关键字，分裂的结果如下图：</p><img src="https://pic.imgdb.cn/item/665c4b9bd9c307b7e9627eea.png" alt="数据结构（六）——查找——B树插入2.png"><p>在插入关键字后，若导致原结点关键字数超过上限，则从结点中间位置([m&#x2F;2]）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置([m&#x2F;2])的结点插入原结点的父结点。</p><p>接下来插入990这个元素，需要注意每次插入新元素，一定是插入到最底层“终端节点”，所以要用“查找”来确定插入位置：</p><img src="https://pic.imgdb.cn/item/665c4c77d9c307b7e9633ee0.png" alt="数据结构（六）——查找——B树插入3.png"><p>这里说一下为什么要插入最底层，如果没有插到最底层，如下图：</p><img src="https://pic.imgdb.cn/item/665c4cd7d9c307b7e963897b.png" alt="数据结构（六）——查找——B树插入4.png"><p>如果没有插到最底层，会发现失败结点不在同一层，且失败结点没有出现在最下面一层，这与B树的特性相矛盾，所新结点要插入最底层。</p><p>接下来插入99：</p><img src="https://pic.imgdb.cn/item/665c4d54d9c307b7e963f301.png" alt="数据结构（六）——查找——B树插入5.png"><p>接下来插入88：</p><img src="https://pic.imgdb.cn/item/665c4e6cd9c307b7e964f2e9.png" alt="数据结构（六）——查找——B树插入6.png"><p>发现88插入的结点关键字数达到上限，所以要进行分裂，得到结果如下图：</p><img src="https://pic.imgdb.cn/item/665c4ebbd9c307b7e9653a06.png" alt="数据结构（六）——查找——B树插入7.png"><p>接下来插入70、83、87：</p><img src="https://pic.imgdb.cn/item/665c4f55d9c307b7e965d2a7.png" alt="数据结构（六）——查找——B树插入8.png"><p>插完以后发现结点出现上限，所以要分裂，但这里分裂的80要考虑一下放到父节点的哪个位置，为了保证顺序性，所以80要放到49与88之间，分裂结果如下图：</p><img src="https://pic.imgdb.cn/item/665c4fddd9c307b7e9665b44.png" alt="数据结构（六）——查找——B树插入9.png"><p>接下来插入92,93,94分裂结果如下图：</p><img src="https://pic.imgdb.cn/item/665c5011d9c307b7e96688d9.png" alt="数据结构（六）——查找——B树插入10.png"><p>现在要插入73,74,75同样会导致结点达到上限，如下图：</p><img src="https://pic.imgdb.cn/item/665c5070d9c307b7e966fa5b.png" alt="数据结构（六）——查找——B树插入11.png"><p>经过分裂，形成下图的结果：</p><img src="https://pic.imgdb.cn/item/665c509ad9c307b7e967249f.png" alt="数据结构（六）——查找——B树插入12.png"><p>此时根节点由于提上来一个关键字而达到上限，所以需要进一步分裂根节点：</p><img src="https://pic.imgdb.cn/item/665c50f0d9c307b7e967739d.png" alt="数据结构（六）——查找——B树插入13.png"><p>到此，对B树的插入操作就完成，下面总结一下B树的插入操作：</p><img src="https://pic.imgdb.cn/item/665c5196d9c307b7e96849be.png" alt="数据结构（六）——查找——B树插入总结.png"><h4 id="8-2-2-B树的删除"><a href="#8-2-2-B树的删除" class="headerlink" title="8.2.2 B树的删除"></a>8.2.2 B树的删除</h4><p>以下图的5阶B树为例，来看一下如何进行删除操作：</p><img src="https://pic.imgdb.cn/item/665c524fd9c307b7e9690dc0.png" alt="数据结构（六）——查找——B树删除.png"><p>假设删除60这个结点：</p><img src="https://pic.imgdb.cn/item/665c5297d9c307b7e9694d0e.png" alt="数据结构（六）——查找——B树删除1.png"><p>60在终端节点里，直接删除该关键字，且删完该关键字以后，该节点的关键字个数没有低于下限，所以删除成功。</p><p>接下来删除80这个关键字，由于80不在终端节点里，所以需要用其前驱或后继来代替80的位置：</p><img src="https://pic.imgdb.cn/item/665c536ed9c307b7e96a0aa7.png" alt="数据结构（六）——查找——B树删除2_1.png"><p>这里是用直接前驱来代替80，80的直接前驱就是其左侧指针所指子树中最右下的元素，即77，所以用77代替80，并从原位置删除77。</p><p>下面看一下用后继代替的例子：</p><img src="https://pic.imgdb.cn/item/665c53c9d9c307b7e96a5015.png" alt="数据结构（六）——查找——B树删除2_2.png"><p>80的后继就是其右侧指针所指子树中最左下的元素，即82，所以用82代替80，并从原位置删除82。</p><p>经过这两个例子可以知道，如果删除一个非终端节点，要找其前驱和后继，即找到最下面一层的结点，所以对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作。</p><p>接下来看一个删除某个关键字以后，结点里的关键字低于下限的情况。</p><p>删除38，此时出现低于下限的情况，这时又要划分为多种情况讨论：</p><p><strong>(1) 兄弟够借</strong></p><img src="https://pic.imgdb.cn/item/665c54f3d9c307b7e96b45f2.png" alt="数据结构（六）——查找——B树删除3_1.png"><p>若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟结点的关键字个数还很宽裕，则需要调整该结点、右(或左）兄弟结点及其双亲结点(父子换位法)。</p><p>比如上图删除38，此时该结点只剩一个25，低于下限，这时候兄弟结点还有很多关键字，可以向兄弟借一个关键字。但注意，不是直接从兄弟结点里拿一个70放到该结点中，因为这样该结点里的关键字的最大值就是70，显然不属于49的左侧区间。所以要把70放到父节点的49处，然后把49放到该结点里。</p><p>调整后的结果如下图：</p><img src="https://pic.imgdb.cn/item/665c562cd9c307b7e96c5e32.png" alt="数据结构（六）——查找——B树删除3_2.png"><p>总结一下这种情况，如果右兄弟结点很宽裕时，可以用右兄弟结点里的最小关键字顶替父节点，然后把父节点放到当前低于下限的结点里。</p><p>刚刚看的是借右兄弟关键字的例子，接下来看一下借左兄弟关键字的例子，比如删除90：</p><img src="https://pic.imgdb.cn/item/665c5742d9c307b7e96d5ff1.png" alt="数据结构（六）——查找——B树删除3_3.png"><p>删完90以后，该节点出现空缺，此时右节点兄弟不富裕，但左兄弟富裕，可以从左兄弟处借走一个关键字。</p><p>注意，这里有右兄弟相反，当左兄弟结点很宽裕时，可以用左兄弟结点里的最大关键字顶替父节点，然后把父节点放到当前低于下限的结点里，调整结果如下：</p><img src="https://pic.imgdb.cn/item/665c57b8d9c307b7e96dcc21.png" alt="数据结构（六）——查找——B树删除3_4.png"><p>总结下来，不论是哪种，其调整的本质都是要保证左边的子树关键字值小于与之对应的父节点的关键字值小于父节点右边的子树的关键字值。</p><p><strong>(2) 兄弟不够借</strong></p><p>上面说的都是兄弟够借的情况，接下来看一下兄弟不够借的情况。</p><p>还是上面的例子，现在如果删除49，会发现，如果删除49，则49所在节点低于下限，但兄弟结点又没有富裕结点，如下图：</p><img src="https://pic.imgdb.cn/item/665c6f4cd9c307b7e988a1cc.png" alt="数据结构（六）——查找——B树删除4_1.png"><p>对于这种被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均&#x3D;[m&#x2F;2]-1，则将关键字删除后与左(或右)兄弟结点及双亲结点中的关键字进行合并。</p><p>如上例，删除49以后出现兄弟不够借，这个时候将该低于下限的结点中的25与兄弟结点的71,72和双亲结点里的70合并，合并结果如下图：</p><img src="https://pic.imgdb.cn/item/665c705ed9c307b7e989e1ff.png" alt="数据结构（六）——查找——B树删除4_2.png"><p>由于合并从父节点里扣了一个值出来，所以此时父节点也出现自身低于下限，兄弟不富裕的情况，这个时候需要再进行合并。合并完以后，根节点没有关键字，所以可以把根节点删除，最后得到的结果如下图：</p><img src="https://pic.imgdb.cn/item/665c7f79d9c307b7e99c3689.png" alt="数据结构（六）——查找——B树删除4_3.png"><h4 id="8-2-3-小结"><a href="#8-2-3-小结" class="headerlink" title="8.2.3 小结"></a>8.2.3 小结</h4><img src="https://pic.imgdb.cn/item/665c7fd5d9c307b7e99ca631.png" alt="数据结构（六）——查找——B树插入与删除的小结.png"><h3 id="8-3-B-树"><a href="#8-3-B-树" class="headerlink" title="8.3 B+树"></a>8.3 B+树</h3><img src="https://pic.imgdb.cn/item/665c8154d9c307b7e99e8270.png" alt="数据结构（六）——查找——B+树.png"><p>首先，看一下什么是B+树，满足上图五个条件的树就是B+树。不难发现，B+树和分块查找很相似。</p><p>在B+树中，一般会把最下面一层称为叶子结点，其余结点称为分支结点。</p><p>这里解释一下第二点，非叶根结点至少有两棵子树，其他每个分支结点至少有「m&#x2F;2]棵子树：</p><img src="https://pic.imgdb.cn/item/665c8213d9c307b7e99f702d.png" alt="数据结构（六）——查找——B+树第二条性质.png"><p>从上图可以看到，第一个结点是根结点，当然也是叶结点，所以它的下面可以没有子树。但是如果该根节点不是叶子结点，它的下面至少要有两棵子树，如上图第三个。至于中间第二个，由于根节点不是叶子结点，而且根节点只有一棵子树，所以这个树不能称之为B+树。</p><p>至于为什么要求其他每个分支结点至少有「m&#x2F;2]棵子树，原理同B树一样，为了保证树高不会太高(即保证查找效率)。</p><p>另外，第三条，<strong>结点的子树个数域关键字个数相等</strong>，这一点也很容易考到，注意与B树区分。</p><p>第四条，在B+树里，所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来，这也就意味着我们可以通过指针P，从第一个叶子节点开始，一个一个往后遍历，然后把所有的叶子结点都遍历完，即B+树支持顺序查找。</p><p>另外补充一点，B+树里的叶子结点，是一个整体，里面包含的都是关键字，同B树一样。</p><p>接下来看一下B+树怎么查找：</p><img src="https://pic.imgdb.cn/item/665c8704d9c307b7e9a51f32.png" alt="数据结构（六）——查找——B+树查找.png"><p>假设查找9，就会从根节点开始，先对比15，发现9小于15，然后就会向15对应的块进行查找。第一个比对3，3小于9，指针后移，第二个比对9，9和9相同，所以去9下面的块查找，然后遍历6,8,9最终找到9的位置。</p><p>到这里，不难发现，B+树的查找和分块查找很相似，所以可以结合分块查找进行理解，如果能结合分快查找进行理解，会发现B+树并不是很难。</p><p>接下来看一个查找失败的情况：</p><img src="https://pic.imgdb.cn/item/665c8807d9c307b7e9a6533c.png" alt="数据结构（六）——查找——B+树查找失败.png"><p>假设查找7，就会从根节点开始，先对比15，发现7小于15，然后就会向15对应的块进行查找。第一个比对3，3小于7，指针后移，第二个比对9，9大于7，所以7可能存在于9对应的话，然后去9下面的块查找，然后遍历6,8,9最终没有找到7，则查找失败。</p><p>可以看到，在B+树中，无论查找成功与否，最终一定都要走到最下面一层叶子结点。而在B树里，查找成功可能会停留在任何一层。</p><p>接下来看一下B+树的另一种查找方法——顺序查找，如下图：</p><img src="https://pic.imgdb.cn/item/665c88e1d9c307b7e9a73e3a.png" alt="数据结构（六）——查找——B+树的顺序查找.png"><p>可以通过指针P向后遍历叶子结点，最终可以遍历到9的位置。</p><p>B+树有很多东西和分块查找很类似，也有很多东西和B树类似，但是考研里喜欢将B+树和B树放到一起考，所以接下来看一下B+树和B树的区别：</p><ol><li>m阶B+树里，结点中的n个关键字对应n棵子树，而m阶B树里，结点中的n个关键字对应n+1棵子树。</li><li>m阶B树里，根节点的关键字数n&#x3D;[1, m-1]，其他结点的关键字数n&#x3D;[ [m&#x2F;2]-1, m-1]。而m阶B+树，根节点的关键字数n&#x3D;[1, m]，其他结点的关键字数n&#x3D;[ [m&#x2F;2], m]。</li><li>在B+树中，叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中。在B树中，各结点中包含的关键字是不重复的。</li><li>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用)非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。B树的结点中都包含了关键字对应的记录的存储地址。</li></ol><p>接下来补充一个知识点，如下图：</p><img src="https://pic.imgdb.cn/item/665c8cc5d9c307b7e9ac2236.png" alt="数据结构（六）——查找——B+树与B树的磁盘应用.png"><p>在B+树里，这些一个一个的结点是存放在磁盘里的（即外存当中），而操作系统对磁盘的读写一般以磁盘块为单位。所以一般来说，B+树的一个结点，就会存放在某一个磁盘块当中，所有的结点都是存放在不同的磁盘块里。</p><p>因此对B+树的查找其实是这样的一个过程：先从根节点查找，系统在背后做的事情是会找到根节点到底存放在哪个磁盘块当中，接下来会把该磁盘块读到内存中，然后处理其中数据找到下一步去哪个分支找到数据，系统会把该分支的磁盘块读到内存里，像这样推进下去，直到系统找到数据最终存放位置为止。</p><p>从上面的过程可以看到，对于B+树的查找，每查找一层节点，都要从磁盘读入一次数据，对于B树也是一样的。由于磁盘是慢速设备，所以计算机读磁盘开销是很大的。这也就意味着，如果B+树越高，读磁盘的次数就越多，查找效率就越低。如何处理这个问题呢？如果每个结点包含的关键字越多，也就意味着树的高度就越低，而这些结点是存放在一个一个磁盘块里，磁盘块的大小是固定的，所以需要在有限的磁盘块里存储足够多的关键字，这也就是B+树为什么要这么设计的原因。</p><p>在B+树里，每一个非叶子结点，并不包含关键字对应记录的存储地址，这也就导致这样一份数据可以花更少的空间存储。而在B树里，每一个非叶子结点，都包含关键字对应记录的存储地址。所以同样一个磁盘块，B+树能存储更多的关键字，这就导致B+树的高度会更矮，读取磁盘的次数会更少，查找也会更快。这就是B+树与B树的本质区别。</p><p>最后将B+树与B树放在一起对比，做个小结：</p><img src="https://pic.imgdb.cn/item/665c9029d9c307b7e9b0912b.png" alt="数据结构（六）——查找——B+树小结.png"><p>考试时，B+树考察不会太深，一般考察相关概念，多数会和B树放在一起考察选择题辨析等。</p><h2 id="9-散列查找"><a href="#9-散列查找" class="headerlink" title="9. 散列查找"></a>9. 散列查找</h2><h3 id="9-1-散列表的基本概念与散列函数的构造方法"><a href="#9-1-散列表的基本概念与散列函数的构造方法" class="headerlink" title="9.1 散列表的基本概念与散列函数的构造方法"></a>9.1 散列表的基本概念与散列函数的构造方法</h3><p>散列查找这个算法需要基于一个叫散列表的数据结构，所以接下来先看一下什么是散列表：</p><img src="https://pic.imgdb.cn/item/665d165b5e6d1bfa057bbd5d.png" alt="数据结构（六）——查找——散列表的概念.png"><p>散列表的特点就是<strong>数据元素的关键字与其存储地址直接相关</strong>。那如何建立关键字与存储地址的联系？通常是通过**散列函数(哈希函数)**实现两者间的映射关系。</p><p>接下来看一个例子：</p><img src="https://pic.imgdb.cn/item/665d17075e6d1bfa057c4386.png" alt="数据结构（六）——查找——散列表例子.png"><p>如上图的一堆关键字，可以设置这样一个散列函数：用关键字的值对13取余。因此，任何一个关键字通过这个散列函数的处理，最终肯定能被映射到0~12这个区间内。</p><p>比如19%13&#x3D;6，所以19放在6内。14%13&#x3D;1，所以14放在1内。23%13&#x3D;10，所以23放在10内。接下来1%13&#x3D;1，所以1也要放到1内。这时候1和14发生了冲突，如下图：</p><img src="https://pic.imgdb.cn/item/665d17f75e6d1bfa057cfc8b.png" alt="数据结构（六）——查找——散列表冲突.png"><p>这里补充两个概念：</p><ol><li>若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”。</li><li>通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”。</li></ol><p>面对这种冲突，可以使用如下的拉链法来解决：</p><img src="https://pic.imgdb.cn/item/665d18945e6d1bfa057d80cf.png" alt="数据结构（六）——查找——散列表冲突处理拉链法.png"><p>所谓拉链法，就是区间内不存储数据，而是存储这向这些数据元素的指针，即把所有同义词存储在一个链表中，通过区间指针来找到这些链表。</p><p>接下来看一下如何基于散列表进行查找操作：</p><p>假设查找27：</p><img src="https://pic.imgdb.cn/item/665d19345e6d1bfa057e0cf0.png" alt="数据结构（六）——查找——散列表查找1.png"><p>首先通过哈希函数确定27处于1区间内，然后通过1内的指针找到对应的存储链表，然后遍历链表找到27，这里需要对比3次，所以27的查找长度为3。</p><p>现在看查找21的情况：</p><img src="https://pic.imgdb.cn/item/665d198a5e6d1bfa057e4f00.png" alt="数据结构（六）——查找——散列表查找2.png"><p>通过哈希函数确定21处于8区间内，然后发现8区间内没有存储数据，所以查找失败。</p><p>这里需要强调的是查找长度是0，并不是没有查找长度，所谓查找长度就是在查找运算中，需要对比关键字的次数，查找21没有进行对比，所以21的查找长度为0。但是要注意，这个查找长度有的自命题学校会认为是1，就是把查找8这个区间当做一次查找，所以对于这种情况，查找长度是0还是1，需要看一下往年的评卷的标准，如果没有就按第一种情况来做（查找长度为0）。</p><p>接下里看查找66的情况：</p><img src="https://pic.imgdb.cn/item/665d1ab55e6d1bfa057f4794.png" alt="数据结构（六）——查找——散列表查找3.png"><p>同样，先通过哈希函数确定66处于1区间内，然后通过1内的指针找到对应的存储链表，然后遍历链表查找66，发现没有，则查找失败。这里需要对比4次，所以66的查找失败长度为4。</p><p>下面看一下查找成功的平均查找长度：</p><img src="https://pic.imgdb.cn/item/665d1b745e6d1bfa057fd05c.png" alt="数据结构（六）——查找——散列表查找成功ASL.png"><p>上图提供了两种计算方法，第一种是按层计算，第二种是按单个计算。这里看一下第二种计算里红框圈出的冲突部分，思考一下如果没有冲突，则分子应当是全为1相加，最终计算出来的ASL应该是1，如下图：</p><img src="https://pic.imgdb.cn/item/665d1c755e6d1bfa05809303.png" alt="数据结构（六）——查找——散列表查找成功ASL1.png"><p>可以看到，冲突越多，查找效率越低，而最理想的情况是散列表查找时间复杂度可达到O(1)，即上图的情况。理论上，如果哈希函数设计的够好，是可以达到这个标准，那如何设计冲突更少的散列函数呢？在探讨这个问题前，先看一下查找失败的ASL。</p><img src="https://pic.imgdb.cn/item/665d1d305e6d1bfa05812600.png" alt="数据结构（六）——查找——散列表查找失败ASL.png"><p>通过计算失败的平均查找长度可以发现，分子是表中记录数，而分母是散列表的长度，计算出来的结果就是失败的ASL。</p><p>同时我们也把表中记录数&#x2F;散列表的长度的结果称为装填因子，装填因子会直接影响散列表的查找效率。这是因为，装填因子如果增大，则说明表中记录数变多，冲突也会变多，这时候不论查找成功还是失败的ASL都会增加。</p><p>接下来看一下如何设计散列函数：</p><p><strong>(1) 除留余数法</strong></p><img src="https://pic.imgdb.cn/item/665d22085e6d1bfa05855598.png" alt="数据结构（六）——查找——除留余数法.png"><p>对于散列函数可以采用除留余数法设计，如上图，对于其中的除数p，选取不大于散列表表长但最接近于散列表表长的质数。</p><p>这个时候可以发现一个问题，如上图给出的两种情况，对于第一种情况，表长是13，选取的p可以直接选取13。但是对于第二种情况，表长为15，按照规则来说p只能选取13，此时取余的结果就是0~12，会有13和14空出，所以为什么p不直接取15呢？首先要明白散列函数设计的目的是为了让不同关键字的冲突尽可能地少，而在除留余数法里，选取最接近表长的质数其避免冲突效果最好。</p><p>举例说明一下：</p><img src="https://pic.imgdb.cn/item/665d242b5e6d1bfa05877a7e.png" alt="数据结构（六）——查找——除留余数法举例0.png"><p>看到上面这个例子可以发现，结果并不像我们想的那样，取质数的效率最好，这是因为关键字是顺序出现的，如果换一组关键字，如下图：</p><img src="https://pic.imgdb.cn/item/665d24015e6d1bfa05875179.png" alt="数据结构（六）——查找——除留余数法举例.png"><p>此时就可以发现用质数取模分布会更均匀，冲突更少。所以这也说明散列函数的设计要根据关键字的分布特点考虑。当然对于考试时，除留余数法p的取值，给出的标准答案还是选取不大于散列表表长但最接近于散列表表长的质数。</p><p><strong>(2) 直接定址法</strong></p><img src="https://pic.imgdb.cn/item/665d274a5e6d1bfa058a757e.png" alt="数据结构（六）——查找——直接定址法.png"><p>直接定址法如上图，这种方法构造出一个直线函数，不会产生冲突，适合关键字分布基本连续的情况。如果关键之分布不连续，则空出会很多，空间会被浪费。</p><p><strong>(3) 数字分析法</strong></p><img src="https://pic.imgdb.cn/item/665d28055e6d1bfa058b1e5c.png" alt="数据结构（六）——查找——数码分析法.png"><p>注意，数码分析法选取分布较均匀的若干位作为散列地址，但并不代表不会产生冲突。</p><p><strong>(4) 平方取中法</strong></p><img src="https://pic.imgdb.cn/item/665d28e65e6d1bfa058bf331.png" alt="数据结构（六）——查找——平方取中法.png"><p>同样，平方取中法使得散列地址分布比较均匀，但也并不代表不会产生冲突。</p><p>下面提供一种不会产生冲突的方法：</p><img src="https://pic.imgdb.cn/item/665d29765e6d1bfa058c7150.png" alt="数据结构（六）——查找——无冲突.png"><p>比如存储身份证信息，可以用一个足够长的表存储，然后用每个学生的身份证号做散列地址，这样做绝对不会产生冲突，而且查找时间复杂度为O(1)。但这样做显然不合理，因为这样做需要的存储空间是海量的。</p><p>从这里可以看到，散列查找是典型的“用空间换时间”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率越低，查找所需时间就越低。</p><h3 id="9-2-处理冲突的方法"><a href="#9-2-处理冲突的方法" class="headerlink" title="9.2 处理冲突的方法"></a>9.2 处理冲突的方法</h3><p>在上面已经介绍过一种处理冲突的方法——拉链法。接下来会介绍另一种处理冲突的方法——开放定址法。</p><img src="https://pic.imgdb.cn/item/665d323f5e6d1bfa0594f1e2.png" alt="数据结构（六）——查找——开放定址法.png"><p>使用开放定址法处理冲突的大致思想就是，数组当中依然存放一个一个数据元素，但数组当中空闲的地址既向同义词开放，也向非同义词开放。假设如上图的散列表，现在要插入元素1，那么1和3在这个哈希函数的映射下，显然不是同义词。但是采用开放定址法的意思就是允许把非同义词1放到3的位置。</p><p><strong>这里会确定一个冲突放置规则：当发生第i次冲突时，会用原本哈希函数算得的地址作为起始，然后加上一个增量，再对哈希表的表长取模（公式如上图）。</strong>而至于增量怎么设计，需要掌握三种方法，分别是线性探测法、平方探测法、伪随机序列法。</p><p><strong>(1) 线性探测法</strong></p><img src="https://pic.imgdb.cn/item/665d342e5e6d1bfa0596ae51.png" alt="数据结构（六）——查找——线性探测法.png"><p>如果采用线性探测法，则每次发生冲突时，往后探测相邻的下一个单元是否为空。可以看到插入1时，通过散列函数计算到起始地址，然后将该起始地址放到开放定址法的线性探测函数里，进而确定放置位置。插入1，通过散列函数计算到起始地址H(key)，然后发生第0次冲突，d&#x3D;0，通过线性探测计算得到放置地址为1，与14产生冲突，发生第一次冲突，所以d&#x3D;1，通过线性探测计算得到放置地址为2，无冲突，所以1放到2的位置。</p><p>按照上述思路，最后插入完成的结果如下图：</p><img src="https://pic.imgdb.cn/item/665d359d5e6d1bfa0597e1fd.png" alt="数据结构（六）——查找——线性探测法插入完成.png"><p><strong>这里注意一个细节，在计算哈希函数时，除数取得是最接近表长的质数。而使用开放定址法处理哈希冲突时，除数取得是表长。</strong></p><p>下面看一下查找操作：</p><img src="https://pic.imgdb.cn/item/665d360e5e6d1bfa05983bf5.png" alt="数据结构（六）——查找——线性探测法查找.png"><p>假设查找27，需要先通过哈希函数确定查找的位置，如果发生冲突，则通过线性探测法的处理公式依次往后查找，最后可以找到27。查找过程中需要对比14,1,68,27四个数，所以查找长度为4。</p><p>这里说一点，在查找过程中，14,1,27才是同义词，而68这个元素和27并不是同义词。所以用开放定址法计算下一个存放地址时，既有可能和同义词冲突，也可能和非同义词冲突。所以在查找时，同义词、非同义词都需要被检查。</p><p>下面看一个查找失败的情况：</p><img src="https://pic.imgdb.cn/item/665d370b5e6d1bfa059910b8.png" alt="数据结构（六）——查找——线性探测法查找失败.png"><p>假设查找21，通过哈希函数确定查找的起始位置是8，然后依次向后对比，对比84,79,23,11,10五个数据，但是要注意，我们还需要和13处的空数据进行对比，这也要算做一次对比，所以21的查找长度是5+1&#x3D;6。</p><p><strong>这里想强调的是空位置的判断也要算作一次对比，与拉链法是不同的。</strong></p><p>对于线性探测法，由于查找失败需要查找到空位置，所以如果让很多元素扎堆的存储在一块，则查找效率会受到影响，如果这些元素之间存在空缺，则查找效率可能会得到提升。同样的上例，如果把10处的元素干掉，如下图：</p><img src="https://pic.imgdb.cn/item/665d381a5e6d1bfa0599fdf9.png" alt="数据结构（六）——查找——线性探测法查找失败1.png"><p>可以发现，如果10处没有元素，查找失败的效率会得到提升。</p><p>接下来看怎么删除一个元素：</p><img src="https://pic.imgdb.cn/item/665d38885e6d1bfa059a5507.png" alt="数据结构（六）——查找——线性探测法删除.png"><p>假设删除1，如果直接删除，这个时候在查找27，会发现，确定27的起始位置是1，但与14冲突以后，就遇到空位置，直接判定查找失败，但实际上27在散列表里，如下图：</p><img src="https://pic.imgdb.cn/item/665d3a4b5e6d1bfa059bcbbc.png" alt="数据结构（六）——查找——线性探测法删除1.png"><p>如何处理这个问题？这就需要再删除时进行标记操作，如下图：</p><img src="https://pic.imgdb.cn/item/665d3aaf5e6d1bfa059c119a.png" alt="数据结构（六）——查找——线性探测法删除2.png"><p>采用“开放定址法”时，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径，可以做一个“删除标记”，进行逻辑删除。如下图：</p><img src="https://pic.imgdb.cn/item/665d3b045e6d1bfa059c4e5b.png" alt="数据结构（六）——查找——线性探测法删除3.png"><p>当做完标记以后，再查找该位置时，会继续向后查找，而不是认为是空然后判断查找失败。</p><p>接下来看另一个问题，如下图：</p><img src="https://pic.imgdb.cn/item/665d3b455e6d1bfa059c8f49.png" alt="数据结构（六）——查找——线性探测法删除4.png"><p>此时查找79时，会从1开始查找，由于前面的都被删除，即使空了，79也需要查找到9处才能查找到。所以这个散列表看起来很满，但实际上很空，这也是用开放定址法解决冲突的一个弊端。</p><p>下面看一下查找效率：</p><img src="https://pic.imgdb.cn/item/665d3be65e6d1bfa059d1106.png" alt="数据结构（六）——查找——线性探测法查找成功的查找效率.png"><p>上面是查找成功的查找效率，把每个数查找成功的查找长度加起来再乘每个关键字被查找到的概率即可。</p><p>下面看一下查找失败的效率：</p><img src="https://pic.imgdb.cn/item/665d3c775e6d1bfa059d8113.png" alt="数据结构（六）——查找——线性探测法查找失败的查找效率.png"><p>查找失败的效率计算方法，就是从0开始，计算每一个查找失败的长度，把他们加起来，然后乘上每个关键字被查找的概率即可。</p><p>可以看到，该例的查找失败的效率是7，这个效率已经很低了。</p><p>造成这种低效率的原因是：<strong>线性探测法很容易造成同义词、非同义词的“聚集(堆积)”现象，严重影响查找效率</strong>。产生这种现象的原因是因为当产生冲突后，每次都是往后一个一个的寻找。所以发生冲突后，再探测一定是放在某个连续的位置，这就导致大量数据的堆积。</p><p>面对上述问题，该如何解决呢？这就要引入接下来的方法——平方探测法。</p><img src="https://pic.imgdb.cn/item/665d4af75e6d1bfa05aae070.png" alt="数据结构（六）——查找——平方探测法1.png"><p>所谓平方探测法，就是发生冲突以后，d的取值不再是依次取0,1,2,3,4,……，而是取0,+1,-1,+2<sup>2</sup>,-2<sup>2</sup>,……+k<sup>2</sup>,-k<sup>2</sup>。</p><p>如上图，假设有一堆数据存储到6的位置，这时就会发生碰撞，所以要进行平方探测，最后存储结果如下图：</p><img src="https://pic.imgdb.cn/item/665d4bf45e6d1bfa05abb8e7.png" alt="数据结构（六）——查找——平方探测法2.png"><p>这里要说一点，84存储时，d&#x3D;-9，这里6的左边没有9个位置，但是84却存储到了24的位置，这是因为进行的是模运算，所以不够的会从后面补。</p><p>到这里可以看到，平方探测法相较于线性探测来说，更不容易产生“堆积”问题。</p><p>接下来看一下查找的过程：</p><img src="https://pic.imgdb.cn/item/665d4d005e6d1bfa05acc06a.png" alt="数据结构（六）——查找——平方探测法查找.png"><p>假设查找71，则会从6开始，依次查找6,19,32,45,58,71然后找到数据。这里想强调的是即使采用开发定址法，当采用的增量序列不同时，查找的方法也不同。</p><p>接下来说一个不是重点但又难以理解的小地方：当采用平方探测法时，散列表长度m必须是一个可以表示成4j＋3的素数，才能探测到所有位置。举个例子说明，如下图：</p><img src="https://pic.imgdb.cn/item/665d4ebb5e6d1bfa05b002c6.png" alt="数据结构（六）——查找——平方探测法散列表确定.png"><p>看上面两个例子，左边一个表长满足4j+3，而右面一个不满足。当以5为起始时，可以看到左边的可以遍历完所以的位置。而右边的会出现重复探测，但却无法探测到7的位置。所以散列表长度m必须是一个可以表示成4j＋3的素数。至于更具体的原因，这涉及到数论，有兴趣可以去数论里查找，而考研只需要了解到这里即可。</p><p>接下来看第三种探测法——伪随机序列法。</p><p><strong>(3) 伪随机序列法</strong></p><p>所谓伪随机序列法就是定义一个伪随机的增量序列d，然后每次根据这个序列所指明的位置进行探测。如下图：</p><img src="https://pic.imgdb.cn/item/665d4fd15e6d1bfa05b114e4.png" alt="数据结构（六）——查找——伪随机序列法.png"><p>如上图有一组数据发生冲突，现在要根据伪随机序列d进行探测，探测存饭的结果就如下图：</p><img src="https://pic.imgdb.cn/item/665d50155e6d1bfa05b1532a.png" alt="数据结构（六）——查找——伪随机序列法1.png"><p>到这里我们就了解完了开放定址法，这里进行一个开放定址法的小结：</p><img src="https://pic.imgdb.cn/item/665d50455e6d1bfa05b18122.png" alt="数据结构（六）——查找——开放定址法小结.png"><p>接下来看最后一个处理冲突的方法——再散列法（再哈希法）：</p><p>所谓再散列法，就是除了原始的散列函数H(key)之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止。</p><img src="https://pic.imgdb.cn/item/665d50f15e6d1bfa05b22275.png" alt="数据结构（六）——查找——再散列法.png"><p>这部分最容易被考察的是线性探测法和平方探测法，所以着重学习这两种方法。</p><h3 id="9-3-散列查找小结"><a href="#9-3-散列查找小结" class="headerlink" title="9.3 散列查找小结"></a>9.3 散列查找小结</h3><img src="https://pic.imgdb.cn/item/665d51535e6d1bfa05b27fd5.png" alt="数据结构（六）——查找——散列查找小结.png"><p>这里补充一个小问题，看一下对拉链法的优化：</p><img src="https://pic.imgdb.cn/item/665d51965e6d1bfa05b2bd0f.png" alt="数据结构（六）——查找——拉链法优化.png"><p>如果我们在进行拉链法处理冲突时，能保持关键字有序，那么可以微微提高查找的效率，具体的原因在顺序查找里已经说过，可以翻到上面去看看顺序查找，这里就不再过多赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（三）——内存管理</title>
      <link href="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（三）——内存管理"><a href="#操作系统（三）——内存管理" class="headerlink" title="操作系统（三）——内存管理"></a>操作系统（三）——内存管理</h1><h2 id="1-内存的基础知识"><a href="#1-内存的基础知识" class="headerlink" title="1. 内存的基础知识"></a>1. 内存的基础知识</h2><h3 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h3><p>写在开头：这部分相当于对计组内存相关知识的复习。深入理解可以去学习计算机组成原理第三章——存储系统。这里给个跳转链接：<a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.md">计算机组成原理(三)——存储系统</a></p><p>首先复习一下内存的概念：</p><img src="https://pic.imgdb.cn/item/6648124dd9c307b7e923f14b.png" alt="操作系统（三）——内存管理——内存的概念.png"><p>内存用来存放数据，程序执行前需要先放到内存中才能被CPU处理。</p><p>为了区分各个程序的数据在内存里的存放位置，就要给内存编号，这就是内存地址。内存地址是从0开始，每个地址对应一个存储单元。</p><p>存储单元的大小和计算机编址方式有关，如果使用按字节编址，则每个存储单元大小为1字节；如果按字编址，则每个存储单元大小为1个字。</p><img src="https://pic.imgdb.cn/item/664813eed9c307b7e9259185.png" alt="操作系统（三）——内存管理——内存的大小.png"><p>内存的地址使用二进制编码方式，题目中会出现给内存的大小，求地址长度，这时候要先考虑编址方式，然后转换成对应2<sup>n</sup>模型，得到地址长度就是n。</p><h3 id="1-2-指令"><a href="#1-2-指令" class="headerlink" title="1.2 指令"></a>1.2 指令</h3><img src="https://pic.imgdb.cn/item/664828d0d9c307b7e93ed74d.png" alt="操作系统（三）——内存管理——指令工作的基本原理.png"><p>使用高级语言编写的代码经过编译以后，会形成与之等价的机器语言指令，每一条指令就是让CPU干一件具体的事情。</p><p>当一个程序运行时，系统会为其建立一个相应的进程，一个进程在内存中会有一片区域叫程序段，用于存放进程相关代码指令。另外还有一个部分叫数据段，用来存放程序处理的一些变量之类的数据。</p><p>CPU执行一条一条指令的实质就是处理内存或寄存器当中的数据。而怎么找到这些数据，就要基于地址来寻找。内存会有自己的地址编址，同样的寄存器也会有自己的地址编址。所以，指令的工作是基于“地址”的，每个地址对应一个数据的存储单元。</p><p>上图给出了一个x&#x3D;x+1的例子，通过编译以后，转换成了右边三条指令。这里以第三条指令为例，该指令的意思是将寄存器地址为00000011中的数据放到内存的地址01001111中，这里指令给出的内存地址是物理地址（绝对地址），直接指明了放到内存的某个位置，能这么使用的原因是，该程序在内存里是连续存放的且以0地址为起始地址。</p><p>现在考虑一下，如果该进程在程序里的地址不是从0开始的呢？为了方便理解，我们默认操作系统给进程分配的是一片连续内存空间。</p><img src="https://pic.imgdb.cn/item/66483600d9c307b7e94ea8f4.png" alt="操作系统（三）——内存管理——指令的寻址.png"><p>C语言经过编译、链接处理后，生成装入模块，即可执行文件，然后就可以把可执行文件放入内存中，然后开始执行这个程序。</p><p>需要注意的是，在装入模块里指明的地址参数是逻辑地址或称为相对地址，它是基于该进程的起始地址的地址。同样的例子，把该装入模块放入内存里，如果从0地址起始，这里指令里对应的地址不在是主存的物理地址，而是相对于该模块起始地址0的相对地址。比如指令里的79，原先指主存地址79，但这里指的是进程起始地址偏移79，即0+79得到在内存里的存放地址。</p><p>下面这个例子会更好的理解：</p><img src="https://pic.imgdb.cn/item/66483792d9c307b7e950c927.png" alt="操作系统（三）——内存管理——相对地址与物理地址.png"><p>在上面这个例子里，将装入模块放入到了主存地址的100<del>279内，该装入模块在主存里的起始地址变为100。这时候再看指令0，这里的79指的就是相对地址，该指令所找的存储单元地址就是100+79&#x3D;179，而不是79，如果看成物理地址，那所找的地址就是79，不在100</del>279范围内，显然该操作是违法的，因为它改动了非自己区域的地址79，而这个79地址可能属于别的进程。</p><p>这里补充两点，</p><ol><li><strong>物理地址与逻辑地址的概念：物理地址就是内存中各物理存储单元的地址从统一的基地址进行的顺序编址，物理地址也可以看成内存的绝对地址。而逻辑地址是指程序代码中使用的地址，它是由程序员或操作系统生成的。</strong></li><li>一个程序经过编译会生成装入模块，里面存放当前程序所要执行的指令以及数据等。当装入模块放入主存里以后就会被CPU调用运行，进而形成进程。进程运行的实质就是存储在主存里的指令的执行，在第二章进程里我们学过，两个进程之间是不能直接互相访问数据的，若想相互访问数据，需要通过CPU分配共享空间。所以，指令的调用数据都是在自己的装入模块内，如果指令的访问地址，不在装入模块存放在主存里的地址范围内，那么该指令可能访问的是共享空间或指令特殊，否则认为该指令违法。</li></ol><p>经过上面两点的补充，我们知道装入模块会被放入到内存的哪个物理地址是无法确定的，所以程序员写程序时使用的都是逻辑地址，而操作系统会将逻辑地址转换为物理地址。</p><p>这里就有一个很重要的问题，操作系统如何实现逻辑地址转换为物理地址。接下来就探讨地址转换的问题。</p><h3 id="1-3-地址转换"><a href="#1-3-地址转换" class="headerlink" title="1.3 地址转换"></a>1.3 地址转换</h3><p>这部分会介绍三种策略来解决逻辑地址转换为物理地址的问题。</p><p>三种策略：</p><ol><li>绝对装入。</li><li>可重定位装入（静态重定位）。</li><li>动态运行时装入（动态重定位）。</li></ol><h4 id="1-3-1-绝对装入"><a href="#1-3-1-绝对装入" class="headerlink" title="1.3.1 绝对装入"></a>1.3.1 绝对装入</h4><img src="https://pic.imgdb.cn/item/66483eedd9c307b7e95991b5.png" alt="操作系统（三）——内存管理——绝对装入.png"><p>绝对装入，指在编译时将逻辑地址转换为物理地址。如果在编译时知道程序要放入内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照装入模块的地址，将程序和数据装入内存。</p><p>比如上图例子，在编译时知道装入模块要从地址为100的地方开始存放，编译链接后的装入模块指令就会变成物理地址。</p><p>如果此时想让这个程序的可执行文件放到另一台电脑当中运行，如果另一台电脑无法让该文件装入100为起始地址的存储区，那么该程序的可执行文件就无法运行，所以这种方式的灵活性很差，只适用于单道程序环境。</p><h4 id="1-3-2-可重定位装入"><a href="#1-3-2-可重定位装入" class="headerlink" title="1.3.2 可重定位装入"></a>1.3.2 可重定位装入</h4><img src="https://pic.imgdb.cn/item/66484098d9c307b7e95bccdf.png" alt="操作系统（三）——内存管理——可重定位装入.png"><p>与绝对装入不同，可重定位编译和链接后的装入模块地址都是从0开始的逻辑地址，只有当装入模块装入内存时，才会在装入内存的过程中将逻辑地址改为物理地址。</p><p>这种装入模式的特点是，给这些作业分配的地址空间必须是连续的，而且作业要一次性全部装入内存。如果没有足够的内存，就不能装入作业，而且作业一旦进入内存后，在运行期间就不能再移动（如果移动，但地址不会被更改，就会出现地址指向错误），也不能再申请内存空间。</p><p>可重定位装入适用于早期的多道批处理操作系统。</p><h4 id="1-3-3-动态重定位"><a href="#1-3-3-动态重定位" class="headerlink" title="1.3.3 动态重定位"></a>1.3.3 动态重定位</h4><img src="https://pic.imgdb.cn/item/6648422ed9c307b7e95da81a.png" alt="操作系统（三）——内存管理——动态重定位.png"><p>动态重定位，编译和链接后的装入模块地址都是从0开始的逻辑地址，而且当装入模块装入内存时，也不会把逻辑地址变成物理地址，只有在指令真正运行时，才会将逻辑地址变为物理地址。</p><p>动态重定位实现逻辑地址与物理地址的转换是通过重定位寄存器来进行的，重定位寄存器里存放装入模块的起始位置，运行指令时，需要将指令里的逻辑地址与重定位寄存器里的起始地址相加得到真正的物理地址。显然，通过这种方式装入，想要改变进程的存放位置是很方便的，如果存放位置改变，也只需要跟着改变重定位寄存器里的起始位置即可。</p><p>除此以外，动态分配方式还有很多的优点，可参考上图，这里可能有不理解的地方，可以等学完虚拟存储部分再回来理解。</p><p>动态重定位装入适用于现代的操作系统。</p><h3 id="1-4-写程序到程序运行的过程"><a href="#1-4-写程序到程序运行的过程" class="headerlink" title="1.4 写程序到程序运行的过程"></a>1.4 写程序到程序运行的过程</h3><img src="https://pic.imgdb.cn/item/6648446fd9c307b7e9623861.png" alt="操作系统（三）——内存管理——写程序到运行程序.png"><p>写程序到程序运行的过程如上图，源代码文件编译后，会形成与之对应的目标模块，并且这些目标模块里已经包含了源代码里所对应的指令，而这些指令的编址都是逻辑地址且从0开始编址（各目标模块的逻辑地址相互独立）。</p><p>接下来会执行链接步骤，将这些目标模块组装成一个完整的装入模块，而且装入模块也有完整的逻辑地址。</p><p>接下来把装入模块调入主存就可以开始运行。</p><p>这就是从写程序到运行程序的完整执行过程。</p><p>之前介绍的是装入的三种方式，接下来看一下链接的三种方式。</p><h3 id="1-5-链接的三种方式"><a href="#1-5-链接的三种方式" class="headerlink" title="1.5 链接的三种方式"></a>1.5 链接的三种方式</h3><h4 id="1-5-1-静态链接"><a href="#1-5-1-静态链接" class="headerlink" title="1.5.1 静态链接"></a>1.5.1 静态链接</h4><img src="https://pic.imgdb.cn/item/664845e0d9c307b7e963e85b.png" alt="操作系统（三）——内存管理——静态链接.png"><p>静态链接和前面介绍写程序到运行程序的过程中的装入方式很类似，就是在程序运行前将各目标模块组装成完整的装入模块，之后就不再拆开。也就是说在形成装入模块后，就确定了装入模块的完整逻辑地址。</p><h4 id="1-5-2-装入时动态链接"><a href="#1-5-2-装入时动态链接" class="headerlink" title="1.5.2 装入时动态链接"></a>1.5.2 装入时动态链接</h4><img src="https://pic.imgdb.cn/item/664846bfd9c307b7e964d70e.png" alt="操作系统（三）——内存管理——装入时动态链接.png"><p>装入时动态链接，将各目标模块边装入内存边链接。也就是说，采用这种方式的话，这个进程的完整逻辑地址是一边装入一边形成的。</p><h4 id="1-5-3-运行时动态链接"><a href="#1-5-3-运行时动态链接" class="headerlink" title="1.5.3 运行时动态链接"></a>1.5.3 运行时动态链接</h4><img src="https://pic.imgdb.cn/item/66484822d9c307b7e9665206.png" alt="操作系统（三）——内存管理——运行时动态链接.png"><p>运行时动态链接，只有在需要该模块时，才会把该模块调入内存。比如上图一开始，只运行main函数，就把main函数的目标模块调入内存，当运行过程中，调用到了a函数，就又会把a的目标模块调入内存。没有用到b函数，就不会把b的目标模块调入内存。</p><p>采用这种方式的灵活性就比较高，且资源利用率也比较高。</p><h3 id="1-6-内存的基础知识小结"><a href="#1-6-内存的基础知识小结" class="headerlink" title="1.6 内存的基础知识小结"></a>1.6 内存的基础知识小结</h3><img src="https://pic.imgdb.cn/item/6648486ed9c307b7e9669695.png" alt="操作系统（三）——内存管理——内存的基础知识小结.png"><h2 id="2-内存管理的概念"><a href="#2-内存管理的概念" class="headerlink" title="2. 内存管理的概念"></a>2. 内存管理的概念</h2><p>操作系统作为系统资源的管理者，当然也要对内存进行管理，那么操作系统在管理内存时，需要做一些什么事情呢？</p><p>我们知道，各种进程投入内存时，首先要把进程的相关数据放到内存当中，那么内存当中有的区域已经被分配出去了，而有的区域还是空闲的，操作系统应该怎么管理这些空闲和非空闲的区域。</p><p>另外如果有一个新的进程想要投入运行，那么这个进程的相关数据需要放入内存当中，但是如果内存当中有很多个地方都可以放入这个进程的相关数据，那这个数据应该放在什么位置呢？这也是操作系统需要回答的问题。</p><p>如果有一个进程运行结束了，那么这个进程之前所占有的那些内存空间应该怎么被回收呢？</p><p>因此内存管理的第一件事，就是要操作系统来负责内存空间的分配与回收。</p><img src="https://pic.imgdb.cn/item/66484936d9c307b7e967679e.png" alt="操作系统（三）——内存管理——内存管理的功能一.png"><p>在第一章节介绍操作系统虚拟性时说过，一个游戏大小为60GB，但电脑运行内存只有4GB，那这个游戏为什么可以顺利运行呢？</p><p>因此内存管理的第二件事，就是操作系统要提供某种技术从逻辑上对内存空间进行扩充（把物理上很小的内存扩充为逻辑上很大的内促）。</p><img src="https://pic.imgdb.cn/item/66484bf5d9c307b7e96a5433.png" alt="操作系统（三）——内存管理——内存管理的功能二.png"><p>为了方便编程，使程序员只需要关注指令、数据的逻辑地址，所以操作系统需要提供地址转换功能。</p><p>内存管理的第三件事就是负责程序的逻辑地址与物理地址的转换。</p><img src="https://pic.imgdb.cn/item/66484c2fd9c307b7e96a9337.png" alt="操作系统（三）——内存管理——内存管理的功能三.png"><p>内存管理的第四个功能是提供内存保护。即保证各进程在各自存储空间内运行、互不干预。</p><img src="https://pic.imgdb.cn/item/66484d48d9c307b7e96bb8ca.png" alt="操作系统（三）——内存管理——内存管理的功能四.png"><p>这里对内存保护进行进一步介绍：</p><img src="https://pic.imgdb.cn/item/66484dcbd9c307b7e96c4b14.png" alt="操作系统（三）——内存管理——内存保护方法一.png"><p>在内存当中，一般来说会分成操作系统使用的内存区域和普通的用户程序使用的内存区域，各个用户进程都会被分配到各自的内存空间，如上图左。</p><p>此时，如果进程一想访问操作系统的内存空间是不可以的，如果进程一可以随意更改操作系统的数据，很明显会影响整个系统的安全。同理，进程一也无法访问进程二的内存空间，进程一只能访问进程一的内存空间。</p><p>假设进程一的逻辑地址空间为0<del>179，物理地址空间为100</del>279。则有两种方式进行内存保护，第一种如上图右。</p><p>第一种方式通过设置上、下限寄存器来存储进程在内存空间的上下限，从而实现内存保护。如果进程一的某条指令想访问某个内存单元时，CPU会根据指令当中想要访问的内存单元的地址与上下限的地址进行比较，只有在上下地址之间，才允许被访问。</p><p>下面看第二种方法，采用重定位寄存器和界地址寄存器进行越界检查。如下图，重定位寄存器存放进程的起始物理地址，界地址寄存器存放进程的最大逻辑地址。</p><img src="https://pic.imgdb.cn/item/66484fa2d9c307b7e96e5d29.png" alt="操作系统（三）——内存管理——内存保护方法二.png"><p>上图也给出了内存保护第二种方法的例子，先与界地址寄存器相比，判断要访问存储单元的逻辑地址是否越界，没有则根据重定位寄存器算出存储单元的物理地址。</p><p>最后，对本部分内容进行小结：</p><img src="https://pic.imgdb.cn/item/66485073d9c307b7e96f5188.png" alt="操作系统（三）——内存管理——内存管理小结.png"><h2 id="3-覆盖与交换"><a href="#3-覆盖与交换" class="headerlink" title="3. 覆盖与交换"></a>3. 覆盖与交换</h2><img src="https://pic.imgdb.cn/item/66485114d9c307b7e9701e24.png" alt="操作系统（三）——内存管理——交换与覆盖知识总览.png"><p>在2. 内存管理的概念中，我们知道了内存管理的4个功能，如上图。其中地址转换我们在1. 内存的基础知识里已经说过，存储保护在2. 内存管理中也说过了，本部分看内存空间的扩充。</p><p>内存空间的扩充有三种技术，如上图，虚拟存储技术是操作系统里的一个重点，会放在后面介绍。这部分先介绍覆盖与交换技术。</p><p>注意，这两个技术在今年的考纲里已经删除，可以跳过不看，但我觉得可以辅助学习理解内存空间的扩充，所以还是在这里记录一下。</p><h3 id="3-1-覆盖技术"><a href="#3-1-覆盖技术" class="headerlink" title="3.1 覆盖技术"></a>3.1 覆盖技术</h3><img src="https://pic.imgdb.cn/item/66485666d9c307b7e9777f97.png" alt="操作系统（三）——内存管理——覆盖技术.png"><p>覆盖技术的概念和特征如上图，接下来看一个具体的覆盖技术的例子。</p><img src="https://pic.imgdb.cn/item/664857f5d9c307b7e9793da6.png" alt="操作系统（三）——内存管理——覆盖技术的例子.png"><p>如果程序的调用结构如上图左，采用覆盖技术就可以进行如图右的设置，可以把包含main函数的固定模块A放到固定区里，这个固定区的大小就是A的大小为8K。由于B、C两模块不能同时被访问，也就是同一时间段内，内存要么有B要么有C，所以可以让B、C两模块共享一个覆盖区，这个覆盖区的大小为B、C两模块中的最大模块为准，也就是10K。同理D、E、F丧模块共占一个覆盖区，大小为12K。</p><p>可以看到采用了覆盖技术，只需要30K的内存大小就可以让程序顺利运行。</p><p>但这个技术有很明显的缺点，因为程序当中的调用结构操作系统是不知道的，所以程序的调用结构必须由程序员来显性的声明。然后操作系统会根据程序员的声明来自动完成覆盖。所以这种技术的缺点是对用户不透明，增加了用户编程负担，现在已经很少使用该技术。</p><h3 id="3-2-交换技术"><a href="#3-2-交换技术" class="headerlink" title="3.2 交换技术"></a>3.2 交换技术</h3><img src="https://pic.imgdb.cn/item/66485bb7d9c307b7e97d9964.png" alt="操作系统（三）——内存管理——交换技术.png"><p>交换技术的设计思想如上图，在第二章说处理机调度时，已经说过一个和交换技术息息相关的知识点——中级调度。中级调度就是为了实现交换技术而使用的一种策略。</p><p>本来在内存当中有很多进程在并发运行，如果某一时刻发现内存紧张，就可以把其中的某些进程暂时换出外存，而进程的相关PCB会保留在内存当中，并且插入到挂起队列，直到内存空间不紧张时，这些进程的相关数据才会换入内存。</p><p>进程的PCB需要常驻内存的原因：进程被换出外存后，必须要通过某种方式记录下这个进程到底放在外存的什么位置，这个信息就可以记录在与之对应的PCB中，操作系统就可以根据PCB当中的记录信息对进程进行管理。所以进程的PCB需要常驻内存。</p><p>中级调度也称内存调度，其实就是在交换技术当中选择一个处于外存的进程，把它换入内存的这样一个过程。</p><p>这里就会有几个新的疑问，被换出的进程存放在外存的什么位置？什么时候进行交换？那些进程应该换出？对于这三个问题，下图给出了完美的解释，这里我就不再过多赘述。</p><img src="https://pic.imgdb.cn/item/66485c07d9c307b7e97df6ab.png" alt="操作系统（三）——内存管理——交换技术的应用.png"><h3 id="3-3-覆盖与交换小结"><a href="#3-3-覆盖与交换小结" class="headerlink" title="3.3 覆盖与交换小结"></a>3.3 覆盖与交换小结</h3><img src="https://pic.imgdb.cn/item/66485c22d9c307b7e97e1d0c.png" alt="操作系统（三）——内存管理——覆盖与交换小结.png"><h2 id="4-连续分配管理方式"><a href="#4-连续分配管理方式" class="headerlink" title="4. 连续分配管理方式"></a>4. 连续分配管理方式</h2><img src="https://pic.imgdb.cn/item/66496bc4d9c307b7e9b24b6e.png" alt="操作系统（三）——内存管理——连续分配管理方式.png"><p>前面说过了内存管理的存储保护、地址转换和内存空间的扩充，这部分看一下内存空间的分配与回收。内存空间的分配与回收主要包括连续分配管理方式和非连续分配管理方式。连续分配方式主要包括单一连续分配、固定分区分配和动态分区分配。</p><p>接下来着重看一下这三种连续分配管理方式。</p><h3 id="4-1-单一连续分配"><a href="#4-1-单一连续分配" class="headerlink" title="4.1 单一连续分配"></a>4.1 单一连续分配</h3><img src="https://pic.imgdb.cn/item/66496cbad9c307b7e9b394eb.png" alt="操作系统（三）——内存管理——单一连续分配.png"><p>单一连续分配的工作方式如上图，由于在单一连续分配里，内存中只能有一道用户程序，所以这种分配方式的优点是无外部碎片，但缺点是有内部碎片。</p><p>这里补充一下外部碎片与内部碎片的概念：</p><p>外部碎片：还没有被分配出去，但由于太小无法分配给新进程的内存空闲区域，处于已分配区域或页面外部的空闲存储块。</p><p>内部碎片：已经被分配出去但不能被利用的内存空间，处于区域内部或页面内部的存储块。</p><h3 id="4-2-固定分区分配"><a href="#4-2-固定分区分配" class="headerlink" title="4.2 固定分区分配"></a>4.2 固定分区分配</h3><img src="https://pic.imgdb.cn/item/66497a26d9c307b7e9c53d97.png" alt="操作系统（三）——内存管理——固定分区分配.png"><p>固定分区分配就是将整个用户空间划分为若干个固定大小的分区，在每一个分区里只装入一道作业。</p><p>固定分区分配可以分为两种，一种是分区大小相等，另一种是分区大小不等。</p><p>如果采用大小相等策略，系统会把整片用户区分割为若干个固定大小并且大小相等的区域。这种策略缺乏灵活性，可能一个很小的进程就会占用一个很大的空间，也可能会有一个很大的进程所需空间大于分区的空间，从而导致大进程无法装入系统。当然这种策略也有自己的适用范围，比如在工厂里对多个相同控制对象进行控制时，程序大小都一样，就可以采用这种方式实现控制。</p><p>如果采用大小不相等策略，系统会把整片用户区分割为若干个固定大小但大小不相等的区域。这种策略灵活性会有所增加，可以根据常在系统中运行的作业大小情况进行划分空间，这样小的进程会分给小的分区，大的进程会分给大的分区。</p><p>接下来考虑下一个问题，操作系统如何记录内存当中各个分区的空闲或分配情况？</p><img src="https://pic.imgdb.cn/item/66497a57d9c307b7e9c5877c.png" alt="操作系统（三）——内存管理——固定分区分配1.png"><p>操作系统会建立一个分区说明表的结构，用来记录内存当中各个分区的空闲或分配情况。如上图，如果操作系统的内存结构如上图右，则可以建立一个如上图左的分区说明表，每个表项对应其中一个分区，表中包含对应分区的大小，起始地址和分配状态。</p><p>如果一个程序想转入内存，操作系统就会根据程序大小检索分区说明表，从中找到一个能满足大小的，未分配的分区，将之分配给该程序，然后修改状态为“已分配”。</p><p>这种分区分配方式也不会产生外部碎片，但仍然会存在产生内部碎片的问题。</p><h3 id="4-3-动态分区分配"><a href="#4-3-动态分区分配" class="headerlink" title="4.3 动态分区分配"></a>4.3 动态分区分配</h3><img src="https://pic.imgdb.cn/item/664984c9d9c307b7e9d13eb7.png" alt="操作系统（三）——内存管理——动态分区分配概念.png"><p>动态分区分配与前面两种不同，这种分配管理方式是在进程装入内存时，根据进程的大小动态地建立分区，并使分区大小正好适合进程的需要，因此在动态分区分配里，系统分区的大小和数目是可变的。</p><p>举个例子，假设计算机内存大小为64MB，系统区占8MB，用户去共56MB，进程1占用20MB，进程2占用14MB，进程3占用18MB，此时用户区还有4MB剩余，操作系统应该用什么样的数据结果来记录内存的使用情况呢？</p><p>如果此时进程2运行结束，并且被移除内存，那么内存当中就会多出14MB的空间。如果此时有新进程到达，并且新进程要占用4MB空间，那这4MB的新进程是会放到进程2刚空出来的空间内，还是放到内存区里原本剩下的4MB内呢，这就是动态分区分配要面对的第二个问题，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><p>假设现在进程3运行结束，并且被移除内存，那么内存当中就会多出18MB的内存，那这个18MB的分区如何进行处理，即动态分区分配的方式如何进行分区的分配与回收操作？</p><p>接下来看第一个问题：操作系统应该用什么样的数据结果来记录内存的使用情况呢？</p><img src="https://pic.imgdb.cn/item/66497a98d9c307b7e9c5da7f.png" alt="操作系统（三）——内存管理——动态分区分配1.png"><p>上面是第一个问题的解答，一般来说操作系统会用两种数据结构来记录内存的使用情况，要么是空闲分区表，要么是空闲分区链。</p><p>上图给出了，图左占用情况的两种存储结构的例子，可以看到，不论是空闲分区表还是空闲分区链，存储的都是空闲分区的信息，而已被分出去占用的空间则没有被存储。</p><p>接下来看第二个问题：当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><img src="https://pic.imgdb.cn/item/664987c5d9c307b7e9d601b2.png" alt="操作系统（三）——内存管理——动态分区分配2.png"><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？这个问题的处理涉及到动态分区分配算法，至于选择哪个分区，需要根据所使用的算法来确定，而有关动态分区分配算法的知识会在接下来的5. 动态分区分配算法里详细介绍。</p><p>接下来看第三个问题：如何进行分区的分配与回收操作？</p><img src="https://pic.imgdb.cn/item/664989bfd9c307b7e9d8dd74.png" alt="操作系统（三）——内存管理——动态分区分配3.png"><p>假设系统采用空闲分区表记录内存使用情况（空闲分区链的工作方式一样），现在要把进程5放入内存，如上图，经过某种分配算法处理以后，决定把进程5分配到第一个空闲分区，这个时候在把进程5放入内存时也要把相应的空闲分区表进行更新。</p><p>上面是空闲区大小大于进程大小的情况，下面看一下空闲区大小等于进程大小的情况：</p><img src="https://pic.imgdb.cn/item/664989bfd9c307b7e9d8dd74.png" alt="操作系统（三）——内存管理——动态分区分配3.png"><p>上面是空闲区大小等于进程大小的情况，这个时候在把进程5放入内存时也要把相应的空闲分区在空闲分区表中删除。</p><p>上面两种是分配的情况，下面来看一下回收的情况：</p><p>情况一：回收区的后面有一个相邻的空闲分区</p><img src="https://pic.imgdb.cn/item/66498a6ad9c307b7e9d9be06.png" alt="操作系统（三）——内存管理——动态分区分配回收情况1_1.png"><p>上面是回收时面对的情况一，回收区的后面有一个相邻的空闲分区，如上图左的存储情况，这时候要进程4运行结束，要回收进程4的空间，此时进程4空出的4MB空间要与后面相邻的空闲分区合并，并更新空闲分区表，如下图：</p><img src="https://pic.imgdb.cn/item/66498aded9c307b7e9da4cde.png" alt="操作系统（三）——内存管理——动态分区分配回收情况1_2.png"><p>情况二：回收区的前面有一个相邻的空闲分区</p><img src="https://pic.imgdb.cn/item/66498b04d9c307b7e9da80d8.png" alt="操作系统（三）——内存管理——动态分区分配回收情况2_1.png"><p>上面是回收时面对的情况二，回收区的前面有一个相邻的空闲分区，如上图左的存储情况，这时候要进程3运行结束，要回收进程3的空间，此时进程3空出的18MB空间要与前面相邻的空闲分区合并，并更新空闲分区表，如下图：</p><img src="https://pic.imgdb.cn/item/66498b4ad9c307b7e9dadda6.png" alt="操作系统（三）——内存管理——动态分区分配回收情况2_2.png"><p>情况三：回收区的前、后各有一个相邻的空闲分区</p><img src="https://pic.imgdb.cn/item/66498b66d9c307b7e9db0603.png" alt="操作系统（三）——内存管理——动态分区分配回收情况3_1.png"><p>上面是回收时面对的情况三，回收区的前、后各有一个相邻的空闲分区，如上图左的存储情况，这时候要进程3运行结束，要回收进程3的空间，此时进程3空出的18MB空间要与前、后相邻的空闲分区合并，并更新空闲分区表，如下图：</p><img src="https://pic.imgdb.cn/item/66498bafd9c307b7e9db5f5d.png" alt="操作系统（三）——内存管理——动态分区分配回收情况3_2.png"><p>情况四：回收区的前、后没有相邻的空闲分区</p><img src="https://pic.imgdb.cn/item/66498bcfd9c307b7e9db8601.png" alt="操作系统（三）——内存管理——动态分区分配回收情况4_1.png"><p>上面是回收时面对的情况四，回收区的前、后没有相邻的空闲分区，如上图左的存储情况，这时候要进程2运行结束，要回收进程2的空间，此时进程2空出的14MB要更新到空闲分区表，即在空闲分区表添加一个空闲分区项，如下图：</p><img src="https://pic.imgdb.cn/item/66498c26d9c307b7e9dbfdda.png" alt="操作系统（三）——内存管理——动态分区分配回收情况4_2.png"><p>接下来对动态分区分配进行总结：</p><img src="https://pic.imgdb.cn/item/66498cd8d9c307b7e9dcff3e.png" alt="操作系统（三）——内存管理——动态分区分配.png"><p>动态分区分配没有内部碎片，但是会产生外部碎片，如果内存空间中的空闲空间的总和本来可以满足某些进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些碎片不能满足进程的需求，这个时候为了避免空间浪费，可以通过紧凑技术来移动各个进程的空间，将所有碎片拼接起来，以满足新进程运行的需求。</p><p>因为紧凑技术需要频繁移动进程的位置，所以采用动态重定位的装入方式最方便实现。</p><p>另外，紧凑之后，需要把进程的起始地址给修改掉，而进程的起始地址信息一般存放在PCB里，如果采用动态重定位的装入还要把起始地址信息更新到重定位寄存器里。</p><h3 id="4-4-连续分配管理方式的小结"><a href="#4-4-连续分配管理方式的小结" class="headerlink" title="4.4 连续分配管理方式的小结"></a>4.4 连续分配管理方式的小结</h3><img src="https://pic.imgdb.cn/item/66498e5ad9c307b7e9df0b3b.png" alt="操作系统（三）——内存管理——连续分配管理小结.png"><h2 id="5-动态分区分配算法"><a href="#5-动态分区分配算法" class="headerlink" title="5. 动态分区分配算法"></a>5. 动态分区分配算法</h2><p>在4.3里遗留了一个问题，就是动态分区分配算法，这部分来详细看一下。</p><p>动态分区分配算法：在动态分区分配方式中，当很多个空闲分区都能满足时，应该选择哪个分区进行分配？</p><p>动态分区分配算法有四种：</p><ol><li>首次适用算法。</li><li>最佳适用算法。</li><li>最坏适应算法。</li><li>邻近适用算法。</li></ol><p>接下来分别看一下这四种算法。</p><h3 id="5-1-首次适用算法"><a href="#5-1-首次适用算法" class="headerlink" title="5.1 首次适用算法"></a>5.1 首次适用算法</h3><img src="https://pic.imgdb.cn/item/664997dfd9c307b7e9ebb6ea.png" alt="操作系统（三）——内存管理——首次适用算法.png"><p>首次适用算法思想就是从低地址开始查找，找到第一个能满足大小的空闲分区。然后将进程放到第一个满足需求的分区。</p><p>在首次适用算法里，<strong>空闲分区以地址递增的次序排列</strong>，每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>如上图的空闲分区，假设使用空闲分区链存储，现在有一个需要15MB的进程要放入分区，通过查找空闲分区链发现第一个空闲分区就满足要求，这时就会将进程放到第一个空闲分区里，并更新空闲分区链，如下图：</p><img src="https://pic.imgdb.cn/item/664998d3d9c307b7e9ecbef8.png" alt="操作系统（三）——内存管理——首次适用算法1.png"><p>在上面这个例子里，我们会发现，首次适用算法有一个很明显的缺点：**<font color=red>首次适用算法每次都从低地址开始查找适合分区，这样虽然会使高地址留下大空闲分区方便大作业进入，但会给低地址部分产生许多小碎片。另外，由于它每次都从低地址开始查找，而低地址在用一段时间后就全是很小的碎片，难以支持进程运行，而且碎片数量会很多，此时还从低地址查找，会产生许多不必要的开销。</font>**。</p><h3 id="5-2-邻近适用算法"><a href="#5-2-邻近适用算法" class="headerlink" title="5.2 邻近适用算法"></a>5.2 邻近适用算法</h3><p>为了解决首次适用算法存在的问题，人们又提出了邻近适用算法。</p><img src="https://pic.imgdb.cn/item/66499f29d9c307b7e9f586c5.png" alt="操作系统（三）——内存管理——邻近适用算法1.png"><p>在邻近适用算法里，<strong>空闲分区以地址递增的次序排列</strong>，每次分配内存时<font color=red><strong>从上次查找结束的位置开始</strong></font>查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p>可以用上图的循环空闲分区链存储空闲分区信息，现在若有一个5MB的进程5想要进入空闲分区，刚开始会从链头开始查找，查找到第二个分区有6MB，满足要求，就会将5MB放入6MB的分区，此时该分区还剩1MB，要更新分区信息。下次若还有进程进入，就会从第二个分区，即当前分区开始往后找，而不是从链头开始。如下图：</p><img src="https://pic.imgdb.cn/item/6649a0b1d9c307b7e9f7c0b3.png" alt="操作系统（三）——内存管理——邻近适用算法2.png"><p><strong><font color=red>邻近适用算法每次都从上一次查找到分区开始往后查找，这就导致无论地址高低，每个空闲分区都有相同概率被使用，这也就导致，高地址的大分区更可能被使用划分为小分区，最后导致无大分区可用的问题。</font></strong></p><img src="https://pic.imgdb.cn/item/6649a0d5d9c307b7e9f7e96a.png" alt="操作系统（三）——内存管理——邻近适用算法的缺点.png"><h3 id="5-3-最佳适用算法"><a href="#5-3-最佳适用算法" class="headerlink" title="5.3 最佳适用算法"></a>5.3 最佳适用算法</h3><img src="https://pic.imgdb.cn/item/6649992ed9c307b7e9ed1acf.png" alt="操作系统（三）——内存管理——最佳适用算法1.png"><p>最佳适用算法<strong>将空闲分区按容量递增次序链接</strong>，每次分配内存是顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区。这种算法可以让每次给进程分配的空间都是当前空闲区里最适合该进程的空间（即大小能满足，且是能满足里的最小分区）。</p><p>上图左下给出了一个内存空间占用情况的例子，其对应的存储结构描述在右边，假设使用空闲分区链存储，现在有一个需要9MB的进程要放入分区，通过查找空闲分区链发现第二个空闲分区满足要求，这时就会将进程放到第二个空闲分区里，并更新空闲分区链，由于此时空闲区2只剩下1MB，小于空闲分区1，所以此时还要将空闲分区链重新排序，如下图：</p><img src="https://pic.imgdb.cn/item/66499aa2d9c307b7e9eebe9b.png" alt="操作系统（三）——内存管理——最佳适用算法2.png"><p>在上面这个例子里，我们会发现，最佳适用算法有一个很明显的缺点：**<font color=red>每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块，因此这种方法会产生很多的外部碎片</font>**。</p><h3 id="5-4-最坏适用算法"><a href="#5-4-最坏适用算法" class="headerlink" title="5.4 最坏适用算法"></a>5.4 最坏适用算法</h3><p>为了解决最佳适用算法存在的问题，人们又提出了最坏适用算法。</p><img src="https://pic.imgdb.cn/item/66499d0ed9c307b7e9f28342.png" alt="操作系统（三）——内存管理——最坏适用算法1.png"><p>最坏适用算法<strong>将空闲分区按容量递减次序链接</strong>，每次分配内存是顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区。</p><p>依然举个例子，上图左下给出了一个内存空间占用情况的例子，其对应的存储结构描述在右边，假设使用空闲分区链存储，现在新进入进程5需要3MB，就会放到第一个分区，此时要更新空闲分区链，第一个空闲分区留下17MB。紧接着进程6需要9MB，也会放到第一个分区，此时要更新空闲分区链，第一个空闲分区留下8MB，此时要更新空闲分区链，但8MB已经不是最大剩余空间，所以要将空闲分区链重新排序，如下图：</p><img src="https://pic.imgdb.cn/item/66499e23d9c307b7e9f4014f.png" alt="操作系统（三）——内存管理——最坏适用算法2.png"><p>**<font color=red>最坏适用算法确实解决了最佳适用算法留下太多难以利用的碎片的问题，但也产生了新的问题，由于每次都选择最大的分区进行分配，这就导致大分区会不断被分为一个一个小分区，之后如果有一个大进程到达，就没有连续大分区可用</font>**。</p><h3 id="5-5-四种分配算法总结比较"><a href="#5-5-四种分配算法总结比较" class="headerlink" title="5.5 四种分配算法总结比较"></a>5.5 四种分配算法总结比较</h3><img src="https://pic.imgdb.cn/item/6649a1bbd9c307b7e9f910d9.png" alt="操作系统（三）——内存管理——分配算法小结.png"><p><strong><font color=red>综合来看，四种算法中，首次适用算法的效果反而更好。</font></strong></p><h2 id="6-基本分页存储管理"><a href="#6-基本分页存储管理" class="headerlink" title="6. 基本分页存储管理"></a>6. 基本分页存储管理</h2><img src="https://pic.imgdb.cn/item/6649a29fd9c307b7e9fa19c2.png" alt="操作系统（三）——内存管理——非连续分配管理.png"><p>到这里，对于文件管理的概念，还有非连续分配管理方式没有说，非连续分配管理方式有三种，分别是基本分页存储管理、基本分段存储管理、段页式存储管理。</p><p>这部分先重点看一下基本分页存储管理。</p><h3 id="6-1-基本分页存储管理概念"><a href="#6-1-基本分页存储管理概念" class="headerlink" title="6.1 基本分页存储管理概念"></a>6.1 基本分页存储管理概念</h3><img src="https://pic.imgdb.cn/item/6649a47ed9c307b7e9fd667c.png" alt="操作系统（三）——内存管理——什么是分页存储.png"><p>上图给出了什么是分页存储的概念，这里讲的很清楚，我就不再赘述了，接下来看一个问题，进程的页面与内存的页框有一一对应的关系，那操作系统是怎么记录这种一一对应的关系的呢？这就涉及到一个很重要的数据结构叫页表。</p><p>接下来看一下什么是页表：</p><img src="https://pic.imgdb.cn/item/6649a659d9c307b7e9ffe957.png" alt="操作系统（三）——内存管理——什么是页表.png"><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。页表通常放在进程的PCB中。</p><p>一个进程对应一张页表，进程中的每个页面对应一个页表项，页表项由页号和块号组成，如上图，其中页号对应进程中的页号，块号对应内存中的页框号。每个页表项里的一组页号和块号则表示着进程页号与内存块号的映射关系。另外注意，每个页表项的长度是相等的。</p><p>现在要思考这么几个问题，每个页表项多大？占几个字节？如何通过页表实现逻辑地址到物理地址的转换？</p><p>先看问题一，每个页表项占多少字节。</p><p>要知道页表项占多少字节，我们得知道页号和块号的长度。这里以一个例子来看一下如何求页表项。假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少应该为多少字节？</p><img src="https://pic.imgdb.cn/item/6649a7e9d9c307b7e9019401.png" alt="操作系统（三）——内存管理——块号长度.png"><p>先求块号，如上图，根据内存块大小&#x3D;页面大小，可以知道内存块大小为4KB，由于内存一个有4GB，所以可以分成2<sup>20</sup>个内存块。所以至少需要3B来表示块号。</p><p>接下来再看一下，页号要占多少字节：</p><img src="https://pic.imgdb.cn/item/6649a8ead9c307b7e9028e1b.png" alt="操作系统（三）——内存管理——页号长度.png"><p>由于页表项是连续存放的，因此页号可以是隐含的，不占存储空间。那如果假设页表中的各项页表项从内存地址为X的地方开始连续存放，如何找到页号为i的页表项呢？</p><p>根据前面所求，我们知道块号为3B，页号不占存储空间，所以页表项的大小为3B，由于页表项连续存放，所以要想找到i号页面对应的页表项可以通过x+3*i得到i号页表项的存放地址。</p><img src="https://pic.imgdb.cn/item/6649a9ebd9c307b7e903bbba.png" alt="操作系统（三）——内存管理——块号对应地址.png"><p>对于该例，每个页表也占3B，如果进程有n页，由于是从0页开始，所以存储整个页表至少需要3*(n+1)B。</p><p>另外，需要注意，块号对应的只是内存块号，而不是内存块的起始地址，要想求得起始地址，还要用块号乘内存块大小才能求得。</p><p>接下来看第二个问题，如何通过页表实现逻辑地址到物理地址的转换？</p><img src="https://pic.imgdb.cn/item/6649aaead9c307b7e904dc77.png" alt="操作系统（三）——内存管理——非连续存储地址转换.png"><p>由于分页存储管理是非连续存储，所以我们不能按照连续存储的方式进行地址转换。但是，不难发现，虽然进程的各个页面是离散存放的，但是页面内部是连续存放的，所以我们可以按照上图的步骤，找到逻辑地址对应的页号，然后根据页表再找到在内存中的起始地址，最后只要确定该逻辑地址的页内偏移量，就可以确定对应的物理地址。</p><p>这里查页表的过程我们已经知道了，现在还要考虑如何获得逻辑地址对应的页号，以及逻辑地址的页内偏移量。下面以一个例子来理解。</p><img src="https://pic.imgdb.cn/item/6649ac79d9c307b7e90680b8.png" alt="操作系统（三）——内存管理——逻辑地址转换例子.png"><p>通过上面的例子，可以总结出页号&#x3D;逻辑地址&#x2F;页面长度，页内偏移量&#x3D;逻辑地址%页面长度。注意，这里的页号要取整数，除不尽的部分就是余数，余数就是页内偏移量。</p><p>得到了页号和页内偏移量，就可以找到逻辑地址在内存中的物理地址。</p><p>上面的例子里页面大小是50B，但其实在现实生活中，计算机内部是用二进制来表示的，如果页面大小刚好是2的整数倍，则计算机硬件可以很快速的把逻辑地址拆分成页号、页内偏移量，如下图：</p><img src="https://pic.imgdb.cn/item/6649af09d9c307b7e9091fc6.png" alt="操作系统（三）——内存管理——二进制拆分.png"><p>经过上面的举例，可以总结处如果每个页面大小为2<sup>k</sup>B，则用二进制数表示逻辑地址，则末尾k位即为页内偏移量，其余部分就是页号。这里牵扯到无符号数左移右移的知识，理解不了的可以记忆。</p><p>除了这个好处，使用二进制还有下面的好处：</p><img src="https://pic.imgdb.cn/item/6649afe2d9c307b7e90a061b.png" alt="操作系统（三）——内存管理——二进制拆分2.png"><p>根据上图的例子，可以发现如果页面大小刚好是2的整数幂，则只需把页表中记录的物理块号拼接上页内偏移量就能得到对应的物理地址。</p><p>经过这样的两个例子，可以总结一下页面大小取2的整数幂的好处，如下图：</p><img src="https://pic.imgdb.cn/item/6649b037d9c307b7e90a5b03.png" alt="操作系统（三）——内存管理——二进制拆分总结.png"><p>如果页面大小是2的整数幂，则可以把逻辑地址分为如下图的两个部分：</p><img src="https://pic.imgdb.cn/item/6649b0d5d9c307b7e90b0386.png" alt="操作系统（三）——内存管理——逻辑地址结构.png"><p>根据上图的逻辑地址结构，可以轻而易举的得到页号和页内偏移量，但如果页面大小不是2的整数次幂，则还是要采用最原始的方法计算。</p><p>下面这部分进行一个小结：</p><img src="https://pic.imgdb.cn/item/6649b19cd9c307b7e90d1e36.png" alt="操作系统（三）——内存管理——基本分页存储管理概念小结.png"><h3 id="6-2-基本地址变换机构"><a href="#6-2-基本地址变换机构" class="headerlink" title="6.2 基本地址变换机构"></a>6.2 基本地址变换机构</h3><p>这部分介绍一下基本分页存储管理的基本地址变换机构（用于实现逻辑地址到物理地址转换的一组硬件机构）。</p><p>该部分内容是重点，需要着重掌握基本地址变换机构的工作原理与流程。</p><img src="https://pic.imgdb.cn/item/664b49b9d9c307b7e92c2b9b.png" alt="操作系统（三）——内存管理——基本地址变换机构.png"><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址，通常会在系统重设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p>接下来看一下逻辑地址转换为物理地址的流程：</p><img src="https://pic.imgdb.cn/item/664b4b10d9c307b7e9309ecd.png" alt="操作系统（三）——内存管理——逻辑地址转换为物理地址的流程.png"><p>操作系统会把内存分为系统区和用户区，在系统区当中会存放着一些操作系统对整个计算机软硬件进行管理的一些相关的数据结构，包括进程控制块PCB也是存放在系统区当中的。如果一个进程被调度上处理机运行，进程切换相关的内核程序就会把这个进程的运行环境给恢复。这些进程运行环境相关的信息本来是保存在PCB当中的，当调度上处理机运行以后，内核程序会把这些信息放到相应的一些列寄存器当中，其中就包括页表寄存器的存放信息。</p><p>页表寄存器当中存放着进程的页表起始地址和页表的长度。PC会指向这个进程下一条需要执行的指令的逻辑地址，而这个逻辑地址转换为物理地址的过程就如上图演示。</p><p>除了上图的流程演示，也可以参考下图的文字描述：</p><img src="https://pic.imgdb.cn/item/664b4d2bd9c307b7e935814b.png" alt="操作系统（三）——内存管理——逻辑地址转换为物理地址的描述.png"><p>上面给出的逻辑地址转换为物理地址是通用的转换方法。如果内存块号、页面偏移量是用二进制表示的，那么可以直接把二者拼起来，这样可以更快得到物理地址。</p><img src="https://pic.imgdb.cn/item/664b4dd6d9c307b7e9382f4f.png" alt="操作系统（三）——内存管理——逻辑地址转换为物理地址的例题.png"><p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，**<font color=red>页式管理中地址是一维的</font>**。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p><p>前面了解过，每个页表项长度相同，页号是隐含的。所以，可以参考下图的例子，对6.1里提过的页表项大小问题进行进一步探讨：</p><img src="https://pic.imgdb.cn/item/664b5124d9c307b7e944fba2.png" alt="操作系统（三）——内存管理——页表大小进一步探索.png"><p>从上图的例子里可以看到，一个页面为4KB，每个页表项3B，一个页框可以存储1365个页表项（0号~1364号），但是会剩下1B的页内碎片，这1B的空间不足以再次存储页表项，所以1365号页表项会放到下一个页框里。</p><p>在实际应用中，为了使空间充分利用以及方便查询页表等操作，即使每个页表项只占3B，也会让其占用4B，这样每个页框刚好可以存储，物理地址的计算也更加方便。</p><p>如果考试时题目遇到像上图的例子，但问题是最少要多个页框存储页表，则还是按照3B去计算，但也要清楚实际应用上可能会采用4B。总而言之，考试时求得什么样的数据，就用什么样的数据，根据题目做就好，应试考试，不用考虑实际的应用。</p><p>下面对该部分内容进行一个小结：</p><img src="https://pic.imgdb.cn/item/664b548ad9c307b7e94f27f4.png" alt="操作系统（三）——内存管理——基本地址变换机构小结.png"><p>这里再补充一个很重要的知识点，在CPU得到一个想要访问的逻辑地址之后，一直到实际访问这个逻辑地址对应的内存单元的整个过程当中，总共需要进行两次访问内存的操作。第一次访问是在查询页表的时候，第二次访问是在实际访问目标内存单元的时候。</p><h3 id="6-3-具有快表的地址变换机构"><a href="#6-3-具有快表的地址变换机构" class="headerlink" title="6.3 具有快表的地址变换机构"></a>6.3 具有快表的地址变换机构</h3><p>基本地址变换机构的基础上引入快表，可以加快地址的变换过程，这部分内容和计组存储系统里的虚拟存储器内容一样，但计组里只是简单介绍了一下，重点还是在操作系统里讲解。不过可以去计组里先了解一下，这样可以更好的辅助操作系统的该部分内容学习。这里给个计组的跳转链接：<a href="./%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F.md">计算机组成原理（三）——存储系统</a></p><p>接下来首先看一下什么是快表：</p><img src="https://pic.imgdb.cn/item/664b5666d9c307b7e9564445.png" alt="操作系统（三）——内存管理——什么是快表.png"><p>快表是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本，要记住，快表不是内存。</p><p>在6.2里，我们说在CPU得到一个想要访问的逻辑地址之后，一直到实际访问这个逻辑地址对应的内存单元的整个过程当中，总共需要进行两次访问内存的操作。但如果添加了快表，CPU可以在快表里找到逻辑地址的对应页表项副本，则只需要进行一次访存就可以，所以快表可以加速地址变换的速度。</p><p>现在思考一下，能否把整个页表都放在快表里？答案是显然不行的，快表作为高速缓存，其增加了访问速度的同时，也变得更加昂贵，为了保证成本，一般快表的存储容量很小，所以不能把整个页表都放在快表里。</p><p>接下来看一下具有快表的地址变换机构的逻辑地址转换为物理地址的流程：</p><img src="https://pic.imgdb.cn/item/664b5855d9c307b7e95d45ed.png" alt="操作系统（三）——内存管理——具有快表的逻辑地址转换为物理地址的流程.png"><p>假设某进行执行过程中要依次访问（0,0）和（0,4）这两个逻辑地址。在访问（0,0）时，快表里没有存储数据，所以快表查询不到，还是要去页表里查询，当查询到对应的页表项以后，会计算对应的物理地址，同时也会把该页表项的副本保存到快表里。当第二个逻辑地址（0,4）执行时，由于页号0对应的页表项经过上一个逻辑地址（0,0）的查找，已经被保存到快表里，所以（0,4）逻辑地址可以直接在快表里命中页号0对应的页表项，此时不需要访问内存查询页表可以直接计算得到物理地址，工作流程的演示可以参考上图，文字描述可以参考下图。</p><img src="https://pic.imgdb.cn/item/664b5a11d9c307b7e9627ab8.png" alt="操作系统（三）——内存管理——具有快表的逻辑地址转换为物理地址的描述.png"><p>注意这里的一点，由于局部性原理，一般来说快表的命中率可以达到90%之上。这里的局部性原理如果学过计组可以轻松理解，没学过也可以去看下面的解释。在解释局部性原理之前，先看一个快表加快访问速度的例子：</p><img src="https://pic.imgdb.cn/item/664b5aa5d9c307b7e9645b82.png" alt="操作系统（三）——内存管理——具有快表的逻辑地址转换为物理地址的例子.png"><p>注意，有的系统支持快表和慢表同时查找，但也有的系统不支持，考试时要具体问题具体分析。</p><p>接下来看一下局部性原理：</p><img src="https://pic.imgdb.cn/item/664b5b2cd9c307b7e966f982.png" alt="操作系统（三）——内存管理——局部性原理.png"><p>上图已经明确给出了局部性原理的介绍，这里再说的简单一点，所谓局部性原理就是指当前访问的数据，短期内可能会频繁的被访问，且由于程序尽可能连续存储的特性，当前访问数据的周围数据也有可能会被访问。</p><p>下面看一下这部分小结：</p><img src="https://pic.imgdb.cn/item/664b5c16d9c307b7e96ab9b1.png" alt="操作系统（三）——内存管理——具有快表的基本地址变换机构小结.png"><p>这里也补充一点，快表和cache并不一样，两者存在一定差别，快表中只有页表项的副本，而cache中可能会有其他各种数据的副本。</p><h3 id="6-4-两级页表"><a href="#6-4-两级页表" class="headerlink" title="6.4 两级页表"></a>6.4 两级页表</h3><p>先看一下单级页表的问题：</p><p>通过下图给出的例子，可以总结出问题一：想要根据页号查询页表，则页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</p><img src="https://pic.imgdb.cn/item/664b5d14d9c307b7e96d7df9.png" alt="操作系统（三）——内存管理——单级页表问题一.png"><p>同样是根据上图的例子，再结合局部性原理可以得到问题二：根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存。</p><p>面对单级页表的这两个问题，我们需要思考一下，如何解决单级页表连续存储的问题？</p><img src="https://pic.imgdb.cn/item/664b5e08d9c307b7e9719578.png" alt="操作系统（三）——内存管理——二级页表.png"><p>结合我们引入单级页表的原因，我们可以将一个单级页表分组，结合我们前面引出问题的例子，可以根据一个内存块里所能存储的页表项的个数，来进行页表分组，比如一个内存块里所能存储的页表项的个数为n，则可以将页表中n个页表项分为一组。然后我们可以离散的将这些分组装入内存块。</p><p>另外，为了能找到对应分组在内存块里的地址，还要再建立一张页表，称为页目录表，用来指示映射原页表的分组在内存块里的存储地址。</p><p>下面结合图像进一步理解：</p><img src="https://pic.imgdb.cn/item/664b62d9d9c307b7e9838992.png" alt="操作系统（三）——内存管理——页表分组.png"><p>如上图，对于一个页表过大时，我们可以根据页面大小将页表分为多个组别。如上图左，一个页面可以存储1024个页表项，就可以将1024个页表项划为一组，这样一个有1048575个页表项的页表，就可以分为1024个有1024个页表项的分组。另外注意一点，被拆分以后，每个分组的页表项的编号都是从0开始的，比如原页表里的1024页表项，被拆分到第二个分组里，成了第二个分组的起始页表项，页号就变成了0。</p><p>在把一个大页表拆分为多个小页表以后，就可以将这些小页表放入到内存块中。为了记录这些小页表的相对顺序，还有他们在内存当中存放的内存块号，就需要为这些小页表，建立再上一级的页表，这一级页表就是页目录表。相应的，这些小页表就称之为二级页表。拆分以后的结构如下图：</p><img src="https://pic.imgdb.cn/item/664b6591d9c307b7e98fc289.png" alt="操作系统（三）——内存管理——页表分组得二级页表.png"><p>从上图中可以很直观的看到，页目录表建立了二级页表的页号与二级页表在内存当中存放的块号的映射关系。</p><p>如果此时想找到0号页表，可以通过页目录表知道0号页表存放在3号内存块里。</p><p>由于采用了两级页表结构，逻辑地址结构也要发生对应的变化。我们可以把以前的20位页号拆分为两个部分，第一部分是10位的二进制用来表示一级页号（即页表号），第二个部分也是10位的二进制用来表示二级页号（即二级页表内的页号）。10位二进制刚好可以表示0~1023的范围。</p><p>接下来结合一个例子看一下怎么实现地址变换：</p><img src="https://pic.imgdb.cn/item/664b67add9c307b7e9970bab.png" alt="操作系统（三）——内存管理——二级页表的地址变换.png"><p>上图给出了一个逻辑地址转换为物理地址的例子，我们可以通过一级页号知道要找0号页表，并通过查询一级页表（一级页表的位置会通过页表寄存器得到）找到0号页表在内存里的存放位置。然后根据二级页号知道要查找0号页表里的1号页表项，通过查询二级页表可以得到0号页表里的1号页表项的起始物理地址，然后加上页内偏移量就可以得到实际的物理地址。这就是逻辑地址转换为物理地址的过程。</p><p>经过之前的分析，解决了单级页表的第一个问题，接下来看单级页表的第二个问题：</p><img src="https://pic.imgdb.cn/item/664b691ad9c307b7e99d3fbf.png" alt="操作系统（三）——内存管理——单级页表第二个问题处理.png"><p>对于第二个问题，可以通过在页表里添加标志位来判断该页面是否已经调入内存。在需要访问页面时，才把页面调入内存（虚拟存储技术）。由于想访问的页面不在内存中，所以要会有缺页中断，即先停止访问，然后把目标页面调入内存，再允许继续访问。</p><p>注：这部分牵扯到虚拟存储的知识，可以结合计组先理解一下，更为详细的介绍可以翻到下面看虚拟存储部分。</p><p>接下来强调几个需要注意的细节，如下图：</p><img src="https://pic.imgdb.cn/item/664b6a4dd9c307b7e9a440c2.png" alt="操作系统（三）——内存管理——两级页表细节注意.png"><p>上图强调了两个需要注意的细节，但这里还要补充一点，假设没有快表，单级页表访问逻辑地址需要进行两次访存，而两级页表需要三次，所以两级页表虽然解决了单级页表的问题，但是这种内存空间利用率上升所付出的代价是多了一次访存，这就导致访问逻辑地址需要花费更多的时间。</p><p>另外，这里可以总结一下，如果没有快表机构，对于n级页表访问逻辑地址时需要进行n+1次访存。</p><p>最后，对两级页表做个小结：</p><img src="https://pic.imgdb.cn/item/664b6aa3d9c307b7e9a700dd.png" alt="操作系统（三）——内存管理——两级页表小结.png"><h2 id="7-基本分段存储"><a href="#7-基本分段存储" class="headerlink" title="7. 基本分段存储"></a>7. 基本分段存储</h2><img src="https://pic.imgdb.cn/item/664c989ed9c307b7e9a3ca8b.png" alt="操作系统（三）——内存管理——什么是分段.png"><p>分段就是按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址。</p><p>由于在分段存储中，是按照逻辑功能进行模块划分，所以用户编程更方便，程序的可读性高。</p><p>另外用户在编程时是使用各个段名来操纵各个段，但CPU具体执行时，使用的是段号。编译程序会把段名转换为段号。</p><p>注意：分段与分页最大的区别是离散分配时所分配的地址空间的基本单位不同。</p><p>采用分段机制之后，逻辑地址结构就由段号和段内地址组成，如下图：</p><img src="https://pic.imgdb.cn/item/664c9c1fd9c307b7e9aaf6cc.png" alt="操作系统（三）——内存管理——分段.png"><p>上图给出了一个分段逻辑地址的例子，在这个例子里，段内地址占16位，段号也占16位。这里需要牢记一点，段号的位数决定了每个进程最多可以分几个段，段内地址位数决定了每个段的最大长度是多少。</p><p>另外如上图下，写程序时使用的段名会被编译成对应段号，助记符A单元和B单元会被编译成段内地址。</p><p><strong>程序被分为多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”。</strong>段表的使用如下图：</p><img src="https://pic.imgdb.cn/item/664c9ebcd9c307b7e9ae5a72.png" alt="操作系统（三）——内存管理——段表.png"><p>段表的作用与页表一样，但不同的是由于分段的长度不确定，所以段表里会添加一列段长字段，用来记录各个段长是多少。</p><p>另外，由于各个段表项的长度是相同的，所以段表也可以像页表一样，将段号隐含。若段表的存放起始地址为M，则K号段对应的段表项的存放地址为M+K*段表项的长度。</p><p>这里要注意一点，段表项的长度由段长字段的长度加上基址字段长度组成。段表项的长度求法可以参考上图第二点给出的例子。</p><p>接下来看一下分段存储的地址变换过程：</p><img src="https://pic.imgdb.cn/item/664ca0c8d9c307b7e9b13750.png" alt="操作系统（三）——内存管理——段表地址变换.png"><p>如上图的汇编语言写的指令，经过编译以后，会形成等价的机器指令。假设编译后的机器指令中的逻辑地址的二进制表示也如图上下所示，现在看一下如何将其从逻辑地址变换为物理地址。</p><img src="https://pic.imgdb.cn/item/664ca208d9c307b7e9b3079f.png" alt="操作系统（三）——内存管理——段表地址变换过程.png"><p>上图给出了分段存储的逻辑地址转换为物理地址的过程。同分页存储一样，进程切换相关的内核程序会根据PCB内信息恢复进程运行环境，其中就包括段表寄存器，系统可以根据段表寄存器得到段表在内存的位置以及段表的长度。然后系统访问进程的过程中，就不可避免的要访问一些逻辑地址，此时系统就要结合逻辑地址与段表将逻辑地址转换为物理地址，转换过程可以参考上图。有了前面基本分页存储变换的基础，这里可以很容易理解上图，我就不再过多赘述这个过程。</p><p>接下来看一下分段与分页的对比：</p><img src="https://pic.imgdb.cn/item/664ca3e8d9c307b7e9b5d695.png" alt="操作系统（三）——内存管理——分段分页管理对比.png"><p>页是信息的物理单位，在分页时只考虑各个页面的大小，另外分页对用户是不可见的，也就是说用户并不知道自己的进程被分为了几页，甚至不知道自己的进程有没有被分页。</p><p>段时信息的逻辑单位，在分段时要考虑信息的逻辑关系，另外分段对用户是可见的，用户编程时要显示的给出段名，所以用户知道自己的程序会被分段，甚至知道会被分为几个段，每个段的段名是多少。</p><p>再补充一点，页的大小是固定的且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址，如上图左下。</p><p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址，如上图右下。</p><p>在分页管理系统当中，在用户看来，自己的地址空间是连续的。但在分段管理系统当中，用户也知道自己的进程地址空间是被分为一个一个段，并且每个段会占据一连串的地址空间。</p><p>除了前面所说，分段相比于分页来说，最大的一个优点是分段更容易实现信息的共享和保护，如下图：</p><img src="https://pic.imgdb.cn/item/664ca432d9c307b7e9b64db3.png" alt="操作系统（三）——内存管理——分段分页管理对比1.png"><p>假设一个生产进程总共16KB，那么可能会被分成如图的三个段，1号段用来实现判断缓冲区是否可访问的功能。除了这个生产者进程外，其他的生产者、消费者进程也需要进行判断缓冲区是否可访问的功能。因此1号段的代码应该运行生产者和消费者进程共享访问。</p><p>那如何实现共享访问呢？假设生产者进程有一个段表，如上图所示，它的1号段存放在内存的120K地址开始处，消费者进程要想共享的使用1号段，可以让消费者的某个段表项同样指向120K处。所以要想实现共享，只需要让各进程的段表项指向同一个段即可。</p><p>这里要注意一点，只有纯代码才可能共享的被访问，可修改的代码是不能被共享的。</p><p>接下来看一下，为什么分页当中不方便实现信息的共享，如下图：</p><img src="https://pic.imgdb.cn/item/664ca459d9c307b7e9b688bf.png" alt="操作系统（三）——内存管理——分段分页管理对比2.png"><p>还是前面的生产者进程，如果进行分页，分页结果如上图，这时候就发现问题，生产者进程的分页里可能会存有两个分段的数据，如上图，第二个页面里就由3KB的橙色分段部分和1KB的绿色分段部分组成。从前面的假设里我们可以知道，这个分页里，绿色部分是可以共享的，橙色部分是不可以被共享的，所以对于分页就很难实现共享。</p><p>对于信息的保护原理也很类似，在分段中1号进程可以允许被其它进程访问，所以只要把1号段标记为允许其他进程访问，其它段标记为不允许，这就很简单的实现了对各个段的保护。</p><p>但如果采用分页存储管理，1、2号页只有一部分允许其他进程访问，因此很难用页表实现信息保护。</p><img src="https://pic.imgdb.cn/item/664ca475d9c307b7e9b6af41.png" alt="操作系统（三）——内存管理——分段分页管理对比3.png"><p>最后看一下在分页和分段访问一个逻辑地址需要几次访存。对于单级页表的分页只需要进行两次，对于分段也只需要进行两次，具体哪两次，可以看上图下的解释。</p><p>与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访存，加快地址变换速度。</p><p>最后对本节做个小结：</p><img src="https://pic.imgdb.cn/item/664ca49cd9c307b7e9b6e34a.png" alt="操作系统（三）——内存管理——分段存储小结.png"><h2 id="8-段页式管理方式"><a href="#8-段页式管理方式" class="headerlink" title="8. 段页式管理方式"></a>8. 段页式管理方式</h2><p>先看一下分段和分页的优缺点：</p><img src="https://pic.imgdb.cn/item/664cb1a2d9c307b7e9d38cd2.png" alt="操作系统（三）——内存管理——分段分页的优缺点.png"><p>这里补充一点：分段管理中产生的外部碎片也可以用“紧凑”来解决，只是需要付出较大的时间代价。</p><p>基于分段管理和分页管理的优缺点，人们又提出了分段和分页两种思想的结合，于是产生了段页式管理。段页式管理就具备了分段和分页两种管理的优点。</p><p>段页式管理中，一个进程会按逻辑模块分段，之后各个段还会分页，如下图：</p><img src="https://pic.imgdb.cn/item/664cb280d9c307b7e9d906fd.png" alt="操作系统（三）——内存管理——段页式管理.png"><p>假设每个页面大小为4KB，内存空间也被分为大小相同的内存块，每个内存块大小和系统当中的页面大小是一样的，各个页面就会被存储当各个内存块当中。</p><p>接下来看一下段页式管理的逻辑地址结构：</p><img src="https://pic.imgdb.cn/item/664cb33bd9c307b7e9dde05d.png" alt="操作系统（三）——内存管理——段页式管理的逻辑地址结构.png"><p>这里需要注意一点，“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。</p><p>因此，段页式管理的地址结构也是二维的。</p><p>与前面讲的分段与分页思想相同，对进程进行分段再分页以后，也需要记录各个段和各个页面的存放位置，如下图：</p><img src="https://pic.imgdb.cn/item/664cb424d9c307b7e9e29ebb.png" alt="操作系统（三）——内存管理——段表页表.png"><p>系统会为进程建立一个段表，进程里的每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号(页表起始地址）组成。每个段表项长度相等，段号是隐含的。</p><p>由于每个内存块大小是固定的，所以只要知道页表存放的物理块号，就可以知道页表存放的实际物理起始地址。比如要查找0号段对应的页表，根据段表，就可以知道0号段对应的页表存放在内存为1号块的地方。</p><p>由于0号段长度为7KB，而每个页面大小为4KB，所以它会被分成两个页面，这两个页面就会依次对应页表当中的一个页表项。每个页表项记录了每个页面存放的内存块号到底是多少。</p><p>从这部分介绍就可以看到，段页式存储中，段表的结构与分段存储的段表不太一样，但页表与分页存储的页表基本一致。</p><p>另外，对于段页式存储的段表、页表的段号和页号也是可以隐藏的。</p><p>接下来看一下，对于段页式存储如何实现逻辑地址与物理地址的转换：</p><img src="https://pic.imgdb.cn/item/664cb467d9c307b7e9e2f104.png" alt="操作系统（三）——内存管理——段页式存储地址变换.png"><p>段页式存储如何实现逻辑地址与物理地址的转换如上图，这里转换过程看图即可。除了转换过程，还要注意访存的次数以及位置，可以根据上图理解。</p><p>当然也可以引入快表，用段号和页号作为快表的查询关键字，这样就只需要一次访存。</p><p>最后对这部分进行小结：</p><img src="https://pic.imgdb.cn/item/664cb49cd9c307b7e9e3392d.png" alt="操作系统（三）——内存管理——段页式存储小结.png"><h2 id="9-虚拟存储"><a href="#9-虚拟存储" class="headerlink" title="9. 虚拟存储"></a>9. 虚拟存储</h2><img src="https://pic.imgdb.cn/item/664d48fad9c307b7e95fc2e2.png" alt="操作系统（三）——内存管理——知识总览.png"><p>上图是内存管理这一章的知识总览，目前仅剩下虚拟存储技术没有介绍，所以接下来会着重介绍虚拟存储的概念。</p><h3 id="9-1-虚拟内存的基本概念"><a href="#9-1-虚拟内存的基本概念" class="headerlink" title="9.1 虚拟内存的基本概念"></a>9.1 虚拟内存的基本概念</h3><p>先看一下传统存储管理方式的缺点：</p><img src="https://pic.imgdb.cn/item/664d49a0d9c307b7e9604f8d.png" alt="操作系统（三）——内存管理——传统存储管理方式的缺点.png"><p>基于上图的传统存储管理方式的缺点，可以使用虚拟技术来解决。虚拟存储技术的提出，是基于著名的局部性原理。</p><img src="https://pic.imgdb.cn/item/664d4a4cd9c307b7e960e005.png" alt="操作系统（三）——内存管理——虚拟存储的局部性原理.png"><p>为了加深理解与记忆，这里就再说一次什么是局部性原理，如上图。</p><p>接下来看一下虚拟内存的定义与特征：</p><img src="https://pic.imgdb.cn/item/664d4aeed9c307b7e9617501.png" alt="操作系统（三）——内存管理——虚拟内存的定义与特征.png"><p>虚拟内存也是操作系统虚拟性的一个体现。所谓虚拟性就是内存的实际物理容量没有变，只是操作系统通过虚拟技术，实现了逻辑上拓充内存容量。</p><p>接下来看一下如何实现虚拟内存技术：</p><img src="https://pic.imgdb.cn/item/664d4c65d9c307b7e962a80d.png" alt="操作系统（三）——内存管理——实现虚拟内存的管理技术.png"><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</p><p>在传统的非连续分配存储管理方式之上，使用虚拟技术，就形成了与传统的非连续分配存储管理方式对应的请求分页存储管理、请求分段存储管理和请求段页式存储管理。</p><p>传统的管理方式与虚拟内存的管理方式最主要的区别在于：</p><ol><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。为了满足这个虚拟，操作系统需要在基本的存储管理方式的基础上，再增加请求调页（调段）功能。</li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。为了满足这个虚拟，操作系统需要在基本的存储管理方式的基础上，再增加页面置换（或段置换）功能。</li></ol><p>最后小结本部分内容：</p><img src="https://pic.imgdb.cn/item/664d4fa5d9c307b7e9658b52.png" alt="操作系统（三）——内存管理——虚拟内存基础小结.png"><h3 id="9-2-请求分页管理方式"><a href="#9-2-请求分页管理方式" class="headerlink" title="9.2 请求分页管理方式"></a>9.2 请求分页管理方式</h3><img src="https://pic.imgdb.cn/item/664d5390d9c307b7e96a9e63.png" alt="操作系统（三）——内存管理——请求分页管理方式.png"><p>请求分页存储管理方式是在基本分页存储管理方式的基础上进行扩展，从而实现的一种虚拟内存管理技术。相比于基本分页管理，操作系统还要新增两个基本的功能。</p><p>第一个功能是请求调页功能，系统需要判断一个页面是否已经调入内存，如果还没有，即页面缺失的话，还需要将页面从外存调入到内存当中。</p><p>第二个功能是页面置换功能，就是当内存不够用时，需要决定把哪个页面换出到外存。</p><p>与基本分页一样，请求分页也需要通过页面来实现逻辑地址与物理地址的映射，如下图：</p><img src="https://pic.imgdb.cn/item/664d550ed9c307b7e96c0576.png" alt="操作系统（三）——内存管理——请求页表.png"><p>与基本分页的页表不一样的是，请求分页的页表需要添加状态位来标志该页面是否被调入内存，如果被访问的页面没有调入内存，还需要先调入内存。</p><p>另外，请求分页的页表还需要添加修改位来标志该页面是否被修改，若没有被修改，则调出时就不需要写回外存。</p><p>还有，请求分页的页表还需要添加访问字段来记录最近被访问过几次或记录上次访问的时间，供置换算法选择换出页面时考虑。</p><p>最后，请求分页的页表还需要一个字段来记录该页面在外存的地址。</p><p>为了实现请求调页功能，系统中需要引入缺页中断机构，接下来看一下缺页中断机构知识：</p><img src="https://pic.imgdb.cn/item/664d5716d9c307b7e96d9210.png" alt="操作系统（三）——内存管理——缺页中断机构.png"><p>在请求分页系统中，为了访问逻辑地址，需要查询页表，缺页机构会根据对应的页表项来判断此时这个页面是否已经在内存当中，如果没有在内存当中，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。</p><p>由于中断处理过程需要IO操作，把页面从外存调入内存，所以在等待IO操作完成的过程当中，之前发生缺页的进程应该被阻塞，然后被调入阻塞队列中，调页完成后再将其唤醒，重新放回就绪队列。</p><p>需要注意，如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项；如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</p><img src="https://pic.imgdb.cn/item/664d6cdad9c307b7e983c542.png" alt="操作系统（三）——内存管理——缺页中断机构1.png"><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断。</p><p>另外，一条指令在执行期间，可能产生多次缺页中断。比如: copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，如果这两个页面都没有被调入内存，则产生两次缺页中断。</p><p>接下来看一下请求分页的地址变换：</p><img src="https://pic.imgdb.cn/item/664d6d60d9c307b7e984323f.png" alt="操作系统（三）——内存管理——请求分页地址变换.png"><p>请求分页存储管理与基本分页存储管理相比，在查找到页面对应的页表项时，要先对页面是否在这个内存进行判断。如果发现此时想访问的页面没有调入内存，就需要进行页面置换的功能。当页面调入、调出或者被访问时，需要对它对应的页表项进行数据修改。</p><p>下面来看一下请求分页管理的执行过程：</p><img src="https://pic.imgdb.cn/item/664d6df6d9c307b7e98596b7.png" alt="操作系统（三）——内存管理——请求分页地址变换过程.png"><p>请求分页管理的执行过程大体上基本分页一致，但要注意前面所说的几个要增加的地方。</p><p>另外，上图给出的过程是具有快表的，需要注意的是快表中有的页面一定是在内存中的。若某个页面被换出外存，则快表中的相应表项也要删除,否则可能访问错误的页面。</p><p>下图给出了更为具体的流程，另外需要注意下图右边提出的几个细节地方：</p><img src="https://pic.imgdb.cn/item/664d71a7d9c307b7e9892e1a.png" alt="操作系统（三）——内存管理——请求分页地址变换过程细节补充.png"><p>这里再补充一点，在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：查快表(未命中)――查慢表(发现未调入内存)――调页(调入的页面对应的表项会直接加入快表)――查快表(命中)――访问目标内存单元。</p><p>最后对该部分内容进行一个小结：</p><img src="https://pic.imgdb.cn/item/664d7214d9c307b7e9899e13.png" alt="操作系统（三）——内存管理——请求分页存储小结.png"><h3 id="9-3-页面置换算法"><a href="#9-3-页面置换算法" class="headerlink" title="9.3 页面置换算法"></a>9.3 页面置换算法</h3><img src="https://pic.imgdb.cn/item/6652c129d9c307b7e9ce6ba1.png" alt="操作系统（三）——内存管理——页面置换算法.png"><p>这部分重点看一下上图的五种页面置换算法。</p><h4 id="9-3-1-最佳置换算法（OPT）"><a href="#9-3-1-最佳置换算法（OPT）" class="headerlink" title="9.3.1 最佳置换算法（OPT）"></a>9.3.1 最佳置换算法（OPT）</h4><img src="https://pic.imgdb.cn/item/6652c1ced9c307b7e9cfd9c5.png" alt="操作系统（三）——内存管理——最佳置换算法.png"><p>最佳置换算法就是从当前要置换的位置开始往后找，找到当前内存已经存储的页面中最后一个被访问或永久不访问的页面置换掉。</p><p><strong><font color=red>注意，最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法只是理想算法，在实际应用中是无法实现的。</font></strong></p><h4 id="9-3-2-先进先出置换算法（FIFO）"><a href="#9-3-2-先进先出置换算法（FIFO）" class="headerlink" title="9.3.2 先进先出置换算法（FIFO）"></a>9.3.2 先进先出置换算法（FIFO）</h4><img src="https://pic.imgdb.cn/item/6652c3f2d9c307b7e9d2f700.png" alt="操作系统（三）——内存管理——先进先出置换算法1.png"><p>先进先出置换算法就是每次选择淘汰的页面是最早进入内存的页面。</p><p>先进先出的实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p>这里要注意一点，上图给的例子是系统为进程分配了三个内存块，总共出现9次缺页，如果我们将内存块扩大，按理来说缺页次数应该下降，但对于先进先出算法来说，缺页次数可能还会出现上升的情况，如下图，是我们将内存块由3个变成4个的情况：</p><img src="https://pic.imgdb.cn/item/6652c4dbd9c307b7e9d40e9c.png" alt="操作系统（三）——内存管理——先进先出置换算法2.png"><p>从上图可以发现，内存块由3个变成4个缺页次数变成了10次，这就是Belady异常，注意，5个页面置换算法里，只有这一个会出现Belady异常。</p><h4 id="9-3-3-最近最久未使用置换算法（LRU）"><a href="#9-3-3-最近最久未使用置换算法（LRU）" class="headerlink" title="9.3.3 最近最久未使用置换算法（LRU）"></a>9.3.3 最近最久未使用置换算法（LRU）</h4><img src="https://pic.imgdb.cn/item/6652c5f1d9c307b7e9d54829.png" alt="操作系统（三）——内存管理——最近最久未使用置换算法.png"><p>最近最久未使用置换算法（LRU)：每次淘汰的页面是最近最久未使用的页面。</p><p>注意，在这几个页面置换算法中，最近最久未使用的性能是最接近最佳置换算法的。</p><h4 id="9-3-4-时钟置换算法（CLOCK）"><a href="#9-3-4-时钟置换算法（CLOCK）" class="headerlink" title="9.3.4 时钟置换算法（CLOCK）"></a>9.3.4 时钟置换算法（CLOCK）</h4><p>之前的算法都无法实现性能与开销的平衡，所以人们又提出了CLOCK算法。对于时钟置换算法，需要掌握两种，一种是简单的CLOCK算法，另一种是改进型CLOCK算法。</p><h5 id="9-3-4-1-简单CLOCK算法"><a href="#9-3-4-1-简单CLOCK算法" class="headerlink" title="9.3.4.1 简单CLOCK算法"></a>9.3.4.1 简单CLOCK算法</h5><img src="https://pic.imgdb.cn/item/6652c781d9c307b7e9d706cb.png" alt="操作系统（三）——内存管理——简单CLOCK算法.png"><p>上面是简单CLOCK算法，实现方法描述的很清晰，但这里要提一点，页面是通过循环队列构成，每次置换时，是从循环队列的指针当前所指位置开始向后访问查找访问位为0的页面，而不是每次都从队头开始查找。</p><h5 id="9-3-4-2-改进的CLOCK算法"><a href="#9-3-4-2-改进的CLOCK算法" class="headerlink" title="9.3.4.2 改进的CLOCK算法"></a>9.3.4.2 改进的CLOCK算法</h5><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p><p>因此，在简单CLOCK算法基础上，添加一个修改位，用来判断页面是否被修改过就是改进CLOCK算法。</p><img src="https://pic.imgdb.cn/item/6652c976d9c307b7e9d9400c.png" alt="操作系统（三）——内存管理——改进CLOCK算法.png"><p>改进CLOCK算法的算法规则在上图描述的很详细，我就不在继续赘述。</p><h4 id="9-3-5-页面置换算法小结"><a href="#9-3-5-页面置换算法小结" class="headerlink" title="9.3.5 页面置换算法小结"></a>9.3.5 页面置换算法小结</h4><img src="https://pic.imgdb.cn/item/6652c9abd9c307b7e9d97a68.png" alt="操作系统（三）——内存管理——页面置换算法小结.png"><h3 id="9-4-页面分配策略"><a href="#9-4-页面分配策略" class="headerlink" title="9.4 页面分配策略"></a>9.4 页面分配策略</h3><p>先看一下驻留集的概念：</p><img src="https://pic.imgdb.cn/item/6652ca6cd9c307b7e9da585c.png" alt="操作系统（三）——内存管理——驻留集.png"><p>对于驻留集，考虑一个极端情况，若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页。所以，若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</p><p>针对驻留集大小是否可变的问题，人们提出了固定分配和可变分配两种分配策略。</p><p>另外，当页面置换时，置换的范围又该是什么，对此，人们提出了局部置换和全局置换两种置换策略。</p><p>将置换和分配的策略两两结合，可以得到上图下的表格，但要注意，固定分配和全局置换不可组合，因为全局置换必导致驻留集大小发生改变。</p><p>下面看一下另外三种组合构成的分配、置换策略：</p><img src="https://pic.imgdb.cn/item/6652cc28d9c307b7e9dc1351.png" alt="操作系统（三）——内存管理——页面分配。置换策略.png"><p>这里要补充说明一点：在可变分配全局置换策略里，提到未锁定的概念，这里解释一下，系统会锁定一些页面，这些页面的内容不能置换出外存，如重要的内核数据可以设为锁定。</p><p>一个进程的页面存储空间已经被分配好，那什么时候调入页面呢？</p><img src="https://pic.imgdb.cn/item/6652cd3fd9c307b7e9dd374f.png" alt="操作系统（三）——内存管理——何时调入页面.png"><p>对于什么时候调入页面，一般来说，有两种策略，如上图。</p><p>先看第一种预调页策略，根据局部性原理，可以知道，如果访问了某个页面，那么在不久的之后，也有可能访问与他相邻的那些页面，因此，基于这方面的考虑，如果能一次调入若干个相邻的页面，那么可能会比一次调入一个页面更加高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存。但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入，由程序员指出应该先调入哪些部分。</p><p>第二种请求调页策略，就是我们前面一直在讲的策略，在运行期间发现缺页才将所缺页面调入内存，这种策略前面一直在说，在这里我就不过多介绍了。</p><p>这里要注意一点，预调页策略是在进程运行前调入，请求调页策略是在进程运行中调入。</p><p>接下来考虑一下，该从什么地方调入页面：</p><p>从什么地方调入页面，这与外存的对换区大小有关，若对换区足够大，则页面的调入调出是内存与对换区之间进行的，如下图：</p><img src="https://pic.imgdb.cn/item/6652ceffd9c307b7e9df21c1.png" alt="操作系统（三）——内存管理——系统拥有足够的对换区空间.png"><p>若对换区不够大，如下图：</p><img src="https://pic.imgdb.cn/item/6652cf6fd9c307b7e9df9bde.png" alt="操作系统（三）——内存管理——系统不拥有足够的对换区空间.png"><p>UNIX系统的页面调入方式：</p><img src="https://pic.imgdb.cn/item/6652cfafd9c307b7e9dfe2ad.png" alt="操作系统（三）——内存管理——UNIX系统调入页面的方式.png"><p>下面，说一下抖动现象：</p><img src="https://pic.imgdb.cn/item/6652d00bd9c307b7e9e11b69.png" alt="操作系统（三）——内存管理——抖动现象.png"><p>为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率。为了研究应该为每个进程分配多少个物理块，提出了进程的“工作集”的概念。</p><img src="https://pic.imgdb.cn/item/6652d08bd9c307b7e9e204e3.png" alt="操作系统（三）——内存管理——工作集.png"><p>上图给出了工作集的概念，另外要注意区分工作集和驻留集。</p><p>最后对该部分进行小结：</p><img src="https://pic.imgdb.cn/item/6652d6c7d9c307b7e9e8db96.png" alt="操作系统（三）——内存管理——页面分配策略小结.png"><h3 id="9-5-内存映射文件"><a href="#9-5-内存映射文件" class="headerlink" title="9.5 内存映射文件"></a>9.5 内存映射文件</h3><p>首先看一下什么是内存映射文件：</p><img src="https://pic.imgdb.cn/item/6652d73fd9c307b7e9e9673a.png" alt="操作系统（三）——内存管理——内存映射文件.png"><p>内存映射文件，简单来说就是操作系统向上层程序员提供的功能，程序员可以很方便的去访问文件数据，另外这个功能也可以方便让多个进程共享同一个文件。</p><p>先来看第一点，为什么说内存映射文件可以方便程序员去使用文件数据。</p><img src="https://pic.imgdb.cn/item/6652dac0d9c307b7e9ed16d8.png" alt="操作系统（三）——内存管理——传统内存映射文件.png"><p>先看一下传统的文件访问方式，如上图，假设文件被拆分成一个一个块存到磁盘里。每个进程都有自己的虚拟地址空间，如果这个进程想要访问这个文件数据，首先要使用open系统调用，来指明打开这个文件。接下来需要使用seek系统调用，来指明想要读取这个文件的哪部分数据，操作系统会用一个读写指针来记录这个位置。接下来，进程可以使用read系统调用，来指明从读写指针所指位置读入多长的数据，该部分数据会被读入内存。进程可以在内存里修改这部分数据。如果想要刚刚的修改被保存，进程会使用write系统调用，把内存里的数据写回磁盘。</p><p>上面是传统文件访问方式，读写文件数据的操作比较麻烦，为了解决这个问题，所以有了内存映射文件。</p><p>还是上面的例子，看一下如果支持内存映射文件，该如何进行文件读写：</p><img src="https://pic.imgdb.cn/item/6652df24d9c307b7e9f2c4f0.png" alt="操作系统（三）——内存管理——传统内存映射文件访问.png"><p>如果支持内存映射文件，程序员可以使用open系统调用打开文件。接下来使用mmap系统调用，让操作系统把文件映射到进程的虚拟地址空间，这个调用会给程序员返回一个指针，这个指针指向刚刚映射区域的起始地址，接下来就可以用访问内存的方式访问文件数据（根据起始地址加上偏移量去访问后面的数据）。</p><p>注意，通过mmp系统调用后，操作系统只是建立了文件数据和内存之间的一个映射关系，但并没有把文件数据直接读入内存，这就相当于一个缺页的状态。接下来假设要访问的数据刚好在第二块，此时操作系统发现这一块数据还没有调入内存，就出现了缺页异常，此时操作系统会自动的把这一块数据给读入内存。</p><p>当一块数据被读入内存以后，进程就可以对其进行修改，当进程不再需要使用一个文件，进程可以使用close系统调用来关闭文件，当它关闭文件以后，操作系统会自动的把文件当中修改的数据给写回磁盘。</p><p>通过对比两种文件访问方式，可以发现，对于支持内存映射文件的操作系统，其文件的读写操作会由操作系统自动执行，而不需要像传统方式一样，需要程序员去手动写入写回。</p><p>接下来第二点，为什么说内存映射文件可以方便文件数据共享。</p><img src="https://pic.imgdb.cn/item/6652df43d9c307b7e9f2e832.png" alt="操作系统（三）——内存管理——内存映射文件共享.png"><p>通过前面的学习知道，对一个文件，进程1可以把该文件映射到自己的虚拟空间里，同理，进程2可以把该文件映射到自己的虚拟空间里。此时，两个进程的虚拟地址空间是相互独立的，但是操作系统会把这两块虚拟地址空间映射到相同的物理内存上，这样两个进程实际上是在共享同一份文件的数据。在这种情况下，当一个进程修改了文件的数据以后，另一个进程立马也可以看到这个文件的数据改变，所以通过内存映射的方式，多个进程可以共享同一个文件的数据。</p><p>注意，文件数据的读入&#x2F;写出完全由操作系统负责，这么做的好处在于，操作系统可以通过某些策略去优化磁盘IO的效率。比如预读入、缓写出等。</p><p>最后小结一下本节内容 ：</p><img src="https://pic.imgdb.cn/item/6652e407d9c307b7e9f7e771.png" alt="操作系统（三）——内存管理——内存映射文件小结.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（五）——图</title>
      <link href="/2024/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE/"/>
      <url>/2024/05/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构（五）——图"><a href="#数据结构（五）——图" class="headerlink" title="数据结构（五）——图"></a>数据结构（五）——图</h1><h2 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1. 图的基本概念"></a>1. 图的基本概念</h2><h3 id="1-1-图的定义"><a href="#1-1-图的定义" class="headerlink" title="1.1 图的定义"></a>1.1 图的定义</h3><img src="https://pic.imgdb.cn/item/66431e3c0ea9cb14038181d0.png" alt="数据结构（五）——图——图的定义.png"><h3 id="1-2-有向图和无向图"><a href="#1-2-有向图和无向图" class="headerlink" title="1.2 有向图和无向图"></a>1.2 有向图和无向图</h3><img src="https://pic.imgdb.cn/item/66431e6e0ea9cb140381d261.png" alt="数据结构（五）——图——无向图和有向图.png"><p>在有向图中，使用圆括号表示一条边，圆括号里元素位置互换没有影响。</p><p>在无向图中，使用尖括号表示一条边，尖括号里元素位置互换则表示的是不同的两条边。</p><h3 id="1-3-简单图和多重图"><a href="#1-3-简单图和多重图" class="headerlink" title="1.3 简单图和多重图"></a>1.3 简单图和多重图</h3><img src="https://pic.imgdb.cn/item/66431ef40ea9cb1403828410.png" alt="数据结构（五）——图——简单图.png"><p>简单图可以解决绝大多数的问题，所以在数据结构里只研究简单图。</p><h3 id="1-4-顶点的度、入度、出度"><a href="#1-4-顶点的度、入度、出度" class="headerlink" title="1.4 顶点的度、入度、出度"></a>1.4 顶点的度、入度、出度</h3><img src="https://pic.imgdb.cn/item/664321650ea9cb140385ddc6.png" alt="数据结构（五）——图——顶点的度、入度、出度.png"><h3 id="1-5-顶点-顶点的关系描述"><a href="#1-5-顶点-顶点的关系描述" class="headerlink" title="1.5 顶点-顶点的关系描述"></a>1.5 顶点-顶点的关系描述</h3><img src="https://pic.imgdb.cn/item/664321cc0ea9cb140386a9c5.png" alt="数据结构（五）——图——顶点-顶点的关系描述.png"><h3 id="1-6-连通图和强连通图"><a href="#1-6-连通图和强连通图" class="headerlink" title="1.6 连通图和强连通图"></a>1.6 连通图和强连通图</h3><img src="https://pic.imgdb.cn/item/664322390ea9cb1403872744.png" alt="数据结构（五）——图——连通图和强连通图.png"><p>注意连通图是基于无向图的，强连通图是基于有向图的。</p><h3 id="1-7-子图"><a href="#1-7-子图" class="headerlink" title="1.7 子图"></a>1.7 子图</h3><img src="https://pic.imgdb.cn/item/664322b90ea9cb140387afe8.png" alt="数据结构（五）——图——无向图的子图.png"><p>所谓子图就是A图的结点和边是B图的子集，则称A为B的子图。若A的结点数等于B的结点数，则称A为B的生成子图。上面是无向图的子图与生成子图，在有向图中的概念是一样的，如下。</p><img src="https://pic.imgdb.cn/item/664322dc0ea9cb140387e20f.png" alt="数据结构（五）——图——有向图的子图.png"><h3 id="1-8-连通分量"><a href="#1-8-连通分量" class="headerlink" title="1.8 连通分量"></a>1.8 连通分量</h3><img src="https://pic.imgdb.cn/item/664324030ea9cb1403899e06.png" alt="数据结构（五）——图——连通分量.png"><p>注意，连通分量是基于无向图的概念，无向图中的极大连通子图称为连通分量。</p><p>极大连通子图：子图必须连通，且包含尽可能多的顶点和边。</p><h3 id="1-9-强连通分量"><a href="#1-9-强连通分量" class="headerlink" title="1.9 强连通分量"></a>1.9 强连通分量</h3><img src="https://pic.imgdb.cn/item/664324710ea9cb14038a10fa.png" alt="数据结构（五）——图——强连通分量.png"><p>注意，强连通分量是基于有向图的概念，有向图中的极大强连通子图称为强连通分量。</p><p>极大强连通子图：子图必须强连通，同时保留尽可能多的边。</p><h3 id="1-10-生成树"><a href="#1-10-生成树" class="headerlink" title="1.10 生成树"></a>1.10 生成树</h3><img src="https://pic.imgdb.cn/item/664324cd0ea9cb14038a7911.png" alt="数据结构（五）——图——生成树.png"><p>连通图的生成树是指包含图中全部顶点的一个极小连通子图。</p><p>极小连通子图：边尽可能的少，但要保持连通。</p><p>注意连通图的生成树的表示不唯一。</p><h3 id="1-11-生成森林"><a href="#1-11-生成森林" class="headerlink" title="1.11 生成森林"></a>1.11 生成森林</h3><img src="https://pic.imgdb.cn/item/664327090ea9cb14038e1b20.png" alt="数据结构（五）——图——生成森林.png"><p>非连通图中连通分量的生成树构成了非连通图的生成森林。</p><h3 id="1-12-边的权-带权图"><a href="#1-12-边的权-带权图" class="headerlink" title="1.12 边的权&amp;带权图"></a>1.12 边的权&amp;带权图</h3><img src="https://pic.imgdb.cn/item/664332cd0ea9cb1403a53370.png" alt="数据结构（五）——图——边的权&带权图.png"><p>边的权，就是在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这个数值可以代表距离，重量等。</p><h3 id="1-13-稀疏图和稠密图"><a href="#1-13-稀疏图和稠密图" class="headerlink" title="1.13 稀疏图和稠密图"></a>1.13 稀疏图和稠密图</h3><img src="https://pic.imgdb.cn/item/664333070ea9cb1403a56e2e.png" alt="数据结构（五）——图——稀疏图和稠密图.png"><p>注意，上图虽然给了一个区分稀疏图和稠密图的公式，但实际上并没有明确的界限，即使使用上述公式求出来是稀疏图，也可以说是稠密图。但考试时可以以这个为界去区分。</p><h3 id="1-14-树和有向树"><a href="#1-14-树和有向树" class="headerlink" title="1.14 树和有向树"></a>1.14 树和有向树</h3><img src="https://pic.imgdb.cn/item/6643334a0ea9cb1403a5bba5.png" alt="数据结构（五）——图——树和有向树.png"><p>注意，树是连通图，但有向树不一定是强连通图。</p><h3 id="1-15-图的概念小结"><a href="#1-15-图的概念小结" class="headerlink" title="1.15 图的概念小结"></a>1.15 图的概念小结</h3><img src="https://pic.imgdb.cn/item/664334be0ea9cb1403a8445c.png" alt="数据结构（五）——图——图的概念小结.png"><h2 id="2-图的存储"><a href="#2-图的存储" class="headerlink" title="2. 图的存储"></a>2. 图的存储</h2><h3 id="2-1-邻接矩阵法"><a href="#2-1-邻接矩阵法" class="headerlink" title="2.1 邻接矩阵法"></a>2.1 邻接矩阵法</h3><img src="https://pic.imgdb.cn/item/66434d870ea9cb1403d34fab.png" alt="数据结构（五）——图——邻接矩阵.png"><p>上图是邻接矩阵法的存储图，以及使用C语言的描述。</p><p>可以看到，所谓邻接矩阵法就是使用一个一维数组存储图中顶点的信息，再用一个二维数组存储图中边的信息，而存储顶点之间的邻接关系的二维数组称为邻接矩阵。</p><p>上图使用Vex数组存储顶点，对于无向图，根据对应顶点的下标，可以查找到该顶点在二维数组里所对应的行或列。也就是说可以通过查询A和D的下标，进而可以找到以A为行以D为列对应位置的数据，如果是1则说明两者之间有边，0则没边。如下图的对应关系：</p><img src="https://pic.imgdb.cn/item/66434faa0ea9cb1403d6ca54.png" alt="数据结构（五）——图——邻接矩阵值.png"><p>对于有向图来说，由于边带了方向，所以查找时要确定查找的是谁到谁的边，比如如果是从A到B的边，就要把A当行，把B当列去查找。一般存储时，也是把边从谁射出，谁当行，射入谁，谁当列。</p><p>下面看一下，对于无向图和有向图，如何分别求其顶点的度、入度和出度。</p><img src="https://pic.imgdb.cn/item/664350170ea9cb1403d7414f.png" alt="数据结构（五）——图——邻接矩阵求度.png"><p>对于无向图，求i个结点的度就是看第i行或第i列有几个1。如果有n个结点，则有n行和n列，所以查找i结点所对应的行或列的时间复杂度就是O(|V|)。</p><p>对于有向图，第i个结点的出度就是求第i行有几个1；入度就是求第i列有几个1。求度只需要把入度和出度加起来即可。同无向图一样，求有向图的出度和入度的时间复杂度都是O(|V|)，而求度的核心还是要求出度和入度，所以求度的时间复杂度也是O(|V|)。</p><p>上面所说全都是不带权图，对于不带权图，只需要用0和1表示两种连接状态即可。下面看一下带权图的表示。</p><img src="https://pic.imgdb.cn/item/664351a30ea9cb1403da0d09.png" alt="数据结构（五）——图——带权图的邻接矩阵.png"><p>对于带权图来说，数组里存储的就不在是表示连接状态的0和1，而是在有边处存储上边的权值，如上图。如果带权图里有两点之间没有边，则对应的邻接矩阵里用0或无穷来表示，有的时候也会使用邻接矩阵对角线上用0表示没有边，其余地方用无穷表示没边。</p><p>带权图的C语言描述如上图，对于无穷的表示，可以通过使用int变量所存储的上限值来表示无穷，另外在Edge数组里，要把对应两点间的连接关系改为边的权值。</p><p>下面对邻接矩阵进行性能分析：</p><img src="https://pic.imgdb.cn/item/664353de0ea9cb1403dfff8f.png" alt="数据结构（五）——图——邻接矩阵性能分析.png"><p>使用领接矩阵法存储图及其边的关系，如果图有n个结点，就要建立一个n×n的数组，所以空间复杂度为O(|V|<sup>2</sup>)。因此，如果图中边数很少，使用此方法就会浪费大量的存储空间，所以领接矩阵法适合存储稠密图。</p><p>另外，不难发现，无向图的领接矩阵是对称矩阵，所以可以压缩存储空间，即存储上三角或下三角。（这部分内容在我写的数据结构（二）——栈与队列与数组中，可以回去复习一下。）</p><p>最后看一下邻接矩阵的性质：</p><img src="https://pic.imgdb.cn/item/6643544f0ea9cb1403e0d0c8.png" alt="数据结构（五）——图——邻接矩阵的性质.png"><p>上图已经给出了领接矩阵的性质，这里再稍微解释一下，例如上图下的例子，A<sup>2</sup>[1][4]&#x3D;1表示的就是从A结点到D结点长度为2的路径的数目为1。对于图G的领接矩阵A，A<sup>2</sup>可以得到右下角的矩阵，这个矩阵里对应两个结点确定的数值，表示从一个结点到另一个结点长度为2的路径的数目。所以在考试时，如果其一个图的某点到另一点的长度为n的路径的数目，我们可以先写出其领接矩阵，然后将n个领接矩阵相乘，得到最后的矩阵，再根据要找的两个点找到由该两点确定的矩阵位置上的数据，这就是两点间的长度为n的路径的数目。</p><h3 id="2-2-邻接表法"><a href="#2-2-邻接表法" class="headerlink" title="2.2 邻接表法"></a>2.2 邻接表法</h3><p>上面使用的领接矩阵法是用数组实现的顺序存储，空间复杂度较高，不适合存储稀疏图。所以，这部分学习邻接表法存储图，邻接表法是通过顺序+链式存储实现的，使用邻接表可以减少不必要的空间浪费。</p><img src="https://pic.imgdb.cn/item/66435d160ea9cb1403f21070.png" alt="数据结构（五）——图——邻接表法.png"><p>上图是领接表的存储结构及C语言描述。</p><p>可以用一维数组来存储各个顶点的信息，然后对于每个顶点，可以通过指针指向它的第一条边，边的描述如上图左下，对于每一条边，它还可以指向下一条与顶点相连边。当最后一个与顶点相连的边没有可指的地方时，就会令它的指向下一条弧的指针为NULL，表示之后再无与顶点相连的边。可以参考上图的例子来辅助理解。</p><p>下面看一下有向图的领接表：</p><img src="https://pic.imgdb.cn/item/66435f830ea9cb1403f6f06f.png" alt="数据结构（五）——图——有向图邻接表法.png"><p>有向图的邻接表存储思路与无向图一致，只不过需要注意弧的方向性。</p><p>到这里，再细看无向图的邻接表法，可以发现，无向图的边没有方向性，按理说每个弧存储一遍就可以了，但是邻接表里却存储了两遍，这就导致边结点数量变成了2|E|，整体空间复杂度就变成了O(|V|+2|E|)。</p><p>而有向图由于边的方向性，所以不存在存储两遍的问题，所以有向图的整体空间复杂度就是O(|V|+|E|)。</p><p>现在思考一下，如何求顶点的度、入度和出度？</p><p>对于无向图来说，没有出度和入度的概念，所以找一个顶点的度，只需要看后面跟了多少个弧即可。</p><p>而对于有向图来说，若要看某一个顶点出度只需要看后面跟了多少个弧即可，但对于入度，则要遍历除该顶点外的每一个顶点，查看每一个顶点后有没有指向该顶点的弧，把所有顶点指向该顶点的弧的数量加起来才能求得入度，度只需要把入度和出度相加即可。所以可以看到，对于有向图来说吗，找一个结点的入度是很麻烦的，这也是有向图一个很大的缺点。</p><p>若要找到与顶点相连的边&#x2F;弧，实质就是找顶点的度，所以可以参考上面的无向图和有向图找度。</p><img src="https://pic.imgdb.cn/item/6643627e0ea9cb1403fe7290.png" alt="数据结构（五）——图——邻接表的表示.png"><p>这里再补充一点，如上图，邻接表法表示的图并不唯一，如上图，对于该无向图至少可以画出上面两种邻接表的表示。但对于邻接矩阵，只要确定了顶点编号，图的邻接矩阵表示方式就唯一确定了。</p><p>下面总结一下邻接表与邻接矩阵：</p><img src="https://pic.imgdb.cn/item/664363130ea9cb1403ff7828.png" alt="数据结构（五）——图——邻接表与邻接矩阵.png"><p>这里说一下，虽然邻接表适合存储稀疏图，但对于无向图来说，邻接表还是浪费了相当一部分资源，所以邻接表比较适合的应该是存储有向图中的稀疏图，不过这点知道即可，考试时也可以直接说邻接表适合存储稀疏图，这样也是对的。</p><h3 id="2-3-十字链表（存储有向图）"><a href="#2-3-十字链表（存储有向图）" class="headerlink" title="2.3 十字链表（存储有向图）"></a>2.3 十字链表（存储有向图）</h3><p>上面说过，邻接矩阵最主要的问题是空间复杂度太高，而邻接表最主要的问题是，当存储有向图，找有向图的入边不方便。为此，提出了十字链表法，通过这种方法可以解决这两个问题。</p><img src="https://pic.imgdb.cn/item/664365090ea9cb1403041c6c.png" alt="数据结构（五）——图——十字链表存储有向图.png"><p>十字链表结构如上图，定义了顶点结点和弧结点分别代指顶点和弧，另外这两个顶点的相关结构及对应字段的含义上图也都给出。此外，上图下是对左下角有向图的十字链表的表示。这里可以结合图自己理解一下。</p><p>使用十字链表法存储有向图，想要找到顶点的入度，只需要沿着橙色指针往后遍历即可；若想要找到顶点的出度，只需要沿着绿色指针往后遍历即可。</p><p>下面分析一下十字链表法的性能：</p><img src="https://pic.imgdb.cn/item/664366990ea9cb14030807ee.png" alt="数据结构（五）——图——十字链表的性能分析.png"><p>使用十字链表法存储有向图，所需空间复杂度为O(|V|+|E|)，同邻接表法一样优秀，并不需要像邻接矩阵一样需要O(|V|<sup>2</sup>)的数量级。</p><p>另外注意，十字链表只用于存储有向图。</p><h3 id="2-4-邻接多重表（存储无向图）"><a href="#2-4-邻接多重表（存储无向图）" class="headerlink" title="2.4 邻接多重表（存储无向图）"></a>2.4 邻接多重表（存储无向图）</h3><img src="https://pic.imgdb.cn/item/664367970ea9cb14030956f8.png" alt="数据结构（五）——图——无向图的邻接矩阵与邻接表存储.png"><p>使用邻接矩存储无向图的问题是空间复杂度太高。而邻接表最主要的问题是重复存储，这时候进行删除操作，如果要删除边还好，只需要从边的两个顶点里删除即可；但要删除顶点就很麻烦，删除该顶点以后，还要遍历邻接表，找到与该顶点相连的顶点，删去相连顶点里存储的与被删顶点相连的信息，时间复杂度太高。所以提出了使用邻接多重表的方法来存储无向图。</p><img src="https://pic.imgdb.cn/item/66436ae50ea9cb140310834e.png" alt="数据结构（五）——图——邻接多重表.png"><p>邻接多重表和十字链表的存储一样，只不过由于邻接多重表用于存储无向图，所以不需要区分两个结点的左右顺序，邻接多重表的存储可以结合上图例子进行理解。</p><p>下面看一下，如果删除边的操作：</p><img src="https://pic.imgdb.cn/item/66436d560ea9cb140315734b.png" alt="数据结构（五）——图——邻接多重表删除边.png"><p>上面是删除A和B相连的边，找到对应的边结点删去以后，由于橙色存储A顶点的边，绿色存储B顶点的边，为了防止删除以后A、B顶点指针无指向，所以在删除之前，要先顺着该边结点的橙色指针找到下一条边对应的结点，让A指向；然后再顺着该边结点的绿色指针找到下一条边对应的结点，让B指向。</p><p>下面下，如果删除顶点的操作：</p><img src="https://pic.imgdb.cn/item/66436dee0ea9cb1403163c87.png" alt="数据结构（五）——图——邻接多重表删除顶点.png"><p>上面是删除顶点E的操作，删除顶点E以后，其所有指向的边结点也都要删除。除此以外，其余若有指向E的边结点的指针都要置为NULL。</p><p>再来看一下邻接多重表的空间复杂度，由于每条边只对应一份数据，所以邻接多重表的时间复杂度为O(|V|+|E|)，比邻接表的空间复杂度还要优秀。此外，邻接多重表的删除边、结点等操作也很方便。但需要注意，邻接多重表只适用于存储无向图。</p><h3 id="2-5-图的存储小结"><a href="#2-5-图的存储小结" class="headerlink" title="2.5 图的存储小结"></a>2.5 图的存储小结</h3><img src="https://pic.imgdb.cn/item/66436eb00ea9cb1403184261.png" alt="数据结构（五）——图——图的存储小结.png"><p>注意，由于十字链表和邻接多重表比较复杂，考试时一般不会要求手写代码，所以对于这两种方式，知道其一些特性即可。</p><h2 id="3-图的基本操作"><a href="#3-图的基本操作" class="headerlink" title="3. 图的基本操作"></a>3. 图的基本操作</h2><h3 id="3-1-图的基本操作总览"><a href="#3-1-图的基本操作总览" class="headerlink" title="3.1 图的基本操作总览"></a>3.1 图的基本操作总览</h3><img src="https://pic.imgdb.cn/item/66436f510ea9cb1403199be1.png" alt="数据结构（五）——图——图的基本操作.png"><p>由于十字链表和邻接多重表比较复杂，所以考研中常考的还是邻接矩阵和邻接表，所以接下来只探讨邻接矩阵和邻接表的基本操作。</p><h3 id="3-2-判断图G是否存在边或弧"><a href="#3-2-判断图G是否存在边或弧" class="headerlink" title="3.2 判断图G是否存在边或弧"></a>3.2 判断图G是否存在边或弧</h3><img src="https://pic.imgdb.cn/item/66436fe70ea9cb14031ab09e.png" alt="数据结构（五）——图——图的基本操作Adjacent.png"><p>对于无向图，如果用邻接矩阵存储，想判断两个顶点间是否有边，只需要找到这两个顶点对应的元素是否为1即可，因此采用邻接矩阵实现判断顶点间是否有边的操作，只需要O(1)的时间复杂度。</p><p>如果用邻接表存储，想判断两个顶点间是否有边，只需要判断一个顶点的边结点是否有另一个结点即可。最好的时间复杂度为O(1)，最坏的时间复杂度为O(|V|)。</p><p>所以如果存储无向图，想实判断两个顶点间是否有边，使用邻接矩阵法更好一点。</p><img src="https://pic.imgdb.cn/item/664370480ea9cb14031bdbe2.png" alt="数据结构（五）——图——图的基本操作有向图的Adjacent.png"><p>对于有向图实现判断两个顶点间是否有边的操作也是一样的，重点是要记住有向图的边是有方向的，要注意区分边的方向，找到对应的顶点。</p><h3 id="3-3-求图G中和结点x邻接的边"><a href="#3-3-求图G中和结点x邻接的边" class="headerlink" title="3.3 求图G中和结点x邻接的边"></a>3.3 求图G中和结点x邻接的边</h3><img src="https://pic.imgdb.cn/item/664371260ea9cb14031daab9.png" alt="数据结构（五）——图——图的基本操作之无向图的Neighbors.png"><p>对于无向图，如果用邻接矩阵存储，想求和结点x邻接的边，只需要遍历x对应的行或列，检查哪些地方是1即可，因此采用邻接矩阵实现，需要O(|V|)的时间复杂度。</p><p>如果用邻接表存储，想求和结点x邻接的边，只需要遍历x的边结点即可。最好的时间复杂度为O(1)，即只有一个边结点，最坏的时间复杂度为O(|V|)，即有|V|个边结点。</p><p>所以如果存储无向图，想实现求和结点x邻接的边的基本操作，使用邻接表法更好一点。</p><img src="https://pic.imgdb.cn/item/664371710ea9cb14031e164f.png" alt="数据结构（五）——图——图的基本操作之有向图的Neighbors.png"><p>如果存储有向图，想求和结点x邻接的边，如果使用邻接矩阵，求出边只要遍历x对应的行，求入边只需要遍历x对应的列。时间复杂度为O(|V|)。</p><p>但如果使用邻接表，遍历出边和无向图一样，只需要遍历x的边结点即可。但遍历入边，就需要遍历邻接表的所有边结点，时间复杂度为O(|E|)。</p><p>所以如果存储有向图，想实现求和结点x邻接的边的基本操作，使用邻接矩阵法更好一点，但也不是绝对的。比如说存储的是一个稀疏图，这是|E|的值就很小，此时使用邻接表法实现该功能也可以得到不错的表现。</p><h3 id="3-4-在图G中插入顶点x"><a href="#3-4-在图G中插入顶点x" class="headerlink" title="3.4 在图G中插入顶点x"></a>3.4 在图G中插入顶点x</h3><img src="https://pic.imgdb.cn/item/664371c30ea9cb14031f197f.png" alt="数据结构（五）——图——图的基本操作之无向图的InsertVertex.png"><p>由于刚插入该顶点，所以该顶点与其他顶点是不相连的。如果采用邻接矩阵存储，只需要在保存这些顶点的数组后面的空白位置，写入新结点的数据即可，在邻接矩阵中，与新结点对应的行和列就可以表现当前新结点与其他顶点的关系。此时，刚插入新结点，看似要在邻接矩阵里插入一堆0，但是实际上矩阵化0操作应该是在矩阵初始化时就已经做好了，所以插入新结点的唯一开销，就是写入新结点的相关信息，因此可以在O(1)的时间复杂度内完成。</p><p>如果采用邻接表存储，只需要在数组末尾插入新结点信息即可，由于新结点刚插入还没有连任何边，所以把新结点指针设为NULL即可，同样使用O(1)复杂度。</p><p>有向图也类似，这里就不在叙述有向图。</p><h3 id="3-5-在图G中删除顶点x"><a href="#3-5-在图G中删除顶点x" class="headerlink" title="3.5 在图G中删除顶点x"></a>3.5 在图G中删除顶点x</h3><img src="https://pic.imgdb.cn/item/66437aa30ea9cb140332e285.png" alt="数据结构（五）——图——图的基本操作之无向图的DeleteVertex.png"><p>对于无向图，以上图中删除C为例，如果采用邻接矩阵存储，就需要删除C对应的行和列，即把C对应的行和列的数据清空。清空以后容易想到的方法就是把删除的行和列周围的元素在拼接起来，但这样做会导致大量数据元素移动，开销很大。所以可以采用置0的方法，即删除C结点后，只需要把C对应的行和列的数据变为0即可。然后在顶点的结构体当中，添加一个bool变量，用来表示C顶点的位置为空顶点。如下图，使用这种方法只需要修改一行和一列的元素，所以在O(|V|)时间内就可以完成。</p><img src="https://pic.imgdb.cn/item/66437c250ea9cb1403375f64.png" alt="数据结构（五）——图——图的基本操作之无向图DeleteVertex.png"><p>如果使用邻接表存储，删除顶点C，还需要遍历其他顶点的边，看有没有和C相连的边。最好的情况是C后面本身就没有边结点，时间复杂度为O(1)，最坏的情况是遍历完全部边结点，时间复杂度为O(|E|)。</p><p>下面看有向图：</p><img src="https://pic.imgdb.cn/item/66437d190ea9cb14033b59d8.png" alt="数据结构（五）——图——图的基本操作之有向图DeleteVertex.png"><p>对于有向图，他的删除操作与无向图一样，自己参阅上图。</p><h3 id="3-6-若图G中没有某条边-弧，则添加该边-弧"><a href="#3-6-若图G中没有某条边-弧，则添加该边-弧" class="headerlink" title="3.6 若图G中没有某条边&#x2F;弧，则添加该边&#x2F;弧"></a>3.6 若图G中没有某条边&#x2F;弧，则添加该边&#x2F;弧</h3><img src="https://pic.imgdb.cn/item/66437e000ea9cb14033dbf96.png" alt="数据结构（五）——图——图的基本操作之无向图的AddEdge.png"><p>这里很简单，唯一要说明的是邻接表里添加该边&#x2F;弧，如果采用尾插法，则要遍历到最后一个边结点，所以采用前插法，可以将时间复杂度缩短到O(1)。</p><p>有向图也类似，不过多叙述。</p><h3 id="3-7-若图G中有某条边-弧，则删除该边-弧"><a href="#3-7-若图G中有某条边-弧，则删除该边-弧" class="headerlink" title="3.7 若图G中有某条边&#x2F;弧，则删除该边&#x2F;弧"></a>3.7 若图G中有某条边&#x2F;弧，则删除该边&#x2F;弧</h3><img src="https://pic.imgdb.cn/item/66437ebb0ea9cb14034014a5.png" alt="数据结构（五）——图——图的基本操作之无向图的RemoveEdge.png"><p>这个也很简单，看图就可以理解，有向图和无向图类似，也不过多叙述。</p><h3 id="3-8-求图G中顶点x的第一个邻接点"><a href="#3-8-求图G中顶点x的第一个邻接点" class="headerlink" title="3.8 求图G中顶点x的第一个邻接点"></a>3.8 求图G中顶点x的第一个邻接点</h3><img src="https://pic.imgdb.cn/item/66437f320ea9cb1403411dcd.png" alt="数据结构（五）——图——图的基本操作之无向图的FirstNeighbor.png"><p>对于无向图，如果用邻接矩阵存储，想求顶点x的第一个邻接点，只需要遍历x对应的行，找到第一个1即可，最好的时间复杂度为O(1)，即第一个就为1，最坏的时间复杂度为O(|V|)，即最后一个为1。</p><p>如果用邻接表存储，想求顶点x的第一个邻接点，只需要往后找第一个边结点即可，时间复杂度为O(1)。</p><img src="https://pic.imgdb.cn/item/66437ff80ea9cb140342fb17.png" alt="数据结构（五）——图——图的基本操作之有向图的FirstNeighbor.png"><p>对于有向图，如果用邻接矩阵存储，想求顶点x的第一个邻接点，根据找出边还是入边，只需要遍历x对应的行或列，找到第一个1即可，最好的时间复杂度为O(1)，即第一个就为1，最坏的时间复杂度为O(|V|)，即最后一个为1。</p><p>如果用邻接表存储，想求顶点x的第一个邻接点，如果找的是出边邻接点，只需要往后找第一个边结点即可，时间复杂度为O(1)。但如果找的是入边的邻接点，最好的情况是遍历的第一个边结点就是入边邻接点，时间复杂度为O(1)；最坏的情况是最后一个才遍历到，复杂度为O(|E|)。</p><h3 id="3-9-求图G中x的第二个邻接点"><a href="#3-9-求图G中x的第二个邻接点" class="headerlink" title="3.9 求图G中x的第二个邻接点"></a>3.9 求图G中x的第二个邻接点</h3><img src="https://pic.imgdb.cn/item/664381010ea9cb140345a30a.png" alt="数据结构（五）——图——图的基本操作之无向图的NextNeighbor.png"><p>对于无向图，如果用邻接矩阵存储，想求顶点x的第二个邻接点，只需要从x对应的行的第一个邻接点向后遍历，找到第二个数值为1的邻接点即可，最好的时间复杂度为O(1)，即第一个就为1，最坏的时间复杂度为O(|V|)，即最后一个为1。</p><p>如果用邻接表存储，想求顶点x的第二个邻接点，只需要从x对应的第一个边结点向后找一个即可，时间复杂度为O(1)。</p><p>有向图的做法也类似，但是需要注意的是如果是有向图要看找的是出边邻接点还是入边邻接点，然后在3.8有向图找第一个邻接点的基础上，向后再找一个即可，这里就不详细说明了。</p><h3 id="3-10-设置-获取权值"><a href="#3-10-设置-获取权值" class="headerlink" title="3.10 设置&#x2F;获取权值"></a>3.10 设置&#x2F;获取权值</h3><img src="https://pic.imgdb.cn/item/6643813f0ea9cb140345f53d.png" alt="数据结构（五）——图——图的基本操作之设置获取权值.png"><p>设置和获取权值的操作和判断图G中边&#x2F;弧是否存在的操作一致力，因为设置和获取权值的核心就在于找到边，所以设置和获取权值的开销和找边的开销一样，这里不再叙述。</p><h2 id="4-图的遍历"><a href="#4-图的遍历" class="headerlink" title="4. 图的遍历"></a>4. 图的遍历</h2><h3 id="4-1-广度优先遍历"><a href="#4-1-广度优先遍历" class="headerlink" title="4.1 广度优先遍历"></a>4.1 广度优先遍历</h3><p>广度优先搜索遍历图的过程是以v为起始点，由近至远依次访问和v有路径相通且路径长度为1,2,……的顶点。</p><img src="https://pic.imgdb.cn/item/6644a85a0ea9cb14030e3432.png" alt="数据结构（五）——图——树和图的广度优先搜索.png"><p>在树的部分，我们也学过树的广度优先搜索，如上图，将树与图做比较，不论是树还是图在进行广度优先搜索时，都要实现通过某一个结点，找到与之相邻的其它结点，因为只有实现这个操作，才可以一层一层的往下找到所有结点。</p><p>另外，由于树结构不存在回路，所以搜索相邻结点时，只需要向下一直搜索即可。而图结构存在回路，所以搜索相邻结点时，还需要判断当前搜所到的结点是否已经被搜索过了，判断是否已经被搜索的方式很简单，只需要给已经被搜索的点做上标记即可。</p><p>在实现树的广度优先遍历时，需要一个辅助队列帮助，所以对于图的广度优先遍历，也可以设置一个类似的辅助队列。</p><p>下面是图的广度优先遍历的实现：</p><img src="https://pic.imgdb.cn/item/6644aa050ea9cb1403104561.png" alt="数据结构（五）——图——图的广度优先搜索.png"><p>要实现图的广度优先遍历，关键在于三点：一是找到与顶点相邻的所有顶点；二是标记哪些顶点被访问过；三是需要一个辅助队列来存储接下来要遍历的点。对于第一点，可以使用在图的基本操作部分的FirstNeighbor和NextNeighbor函数。对于第二点，可以定义一个bool型标记数组，存储各个顶点的标记信息，用false表示未被标记，用true表示标记。对于第三点，只需要定义一个辅助队列即可。</p><p>下面看一下代码实现：</p><img src="https://pic.imgdb.cn/item/6644ab230ea9cb140311a7d0.png" alt="数据结构（五）——图——图的广度优先遍历代码实现.png"><p>上图左边是以2为出发点实现广度优先搜索的例子，右边是实现广度优先搜索的程序，可以结合理解。</p><p>注意：考试时可能会遇到给一个图G，然后让以某个顶点为出发点，然后写广度优先搜索序列的题目，如上图左边的例子。</p><p>另外，从上面的遍历序列的例子里，不难发现，我们在找6的邻接点时，可以选3和7，不过上面是按照递增的顺序来选的，然而也可以先选7，至于遍历序列究竟该如何选择，这与图的存储方式有关，如下图：</p><img src="https://pic.imgdb.cn/item/6644ac570ea9cb1403131bbc.png" alt="数据结构（五）——图——遍历序列的可变性.png"><p>如果图是以邻接矩阵的方式存储，因为一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一，且是按照前面所说的递增顺序选取。</p><p>但是如果图是以邻接表的方式存储，因为一个图的邻接表的表示方式不唯一，因此广度优先遍历序列也不唯一，如上图右。</p><p>接下来，接着看广度优先的代码实现，会发现，当图是一个非连通图时，就会无法遍历完所有结点，如下图：</p><img src="https://pic.imgdb.cn/item/6644ad8f0ea9cb1403149420.png" alt="数据结构（五）——图——图的广度优先遍历优化.png"><p>这里对BFS进行了优化，在广度优先遍历的代码之上，添加了一个二次查看标记数组的标记号，如果调用BFS以后，标记数组仍存在标记位false的值，就会以标记为false的结点为顶点再次使用广度优先搜索算法，直到标记数组里没有未被访问的点为止。</p><p>这里总结出一个结论，**<font color=red>对于无向图，调用BFS函数的次数&#x3D;连通分量数。</font>**</p><p>接下来对图的广度优先搜索算法进行复杂度分析：</p><img src="https://pic.imgdb.cn/item/6644aea50ea9cb140315c6df.png" alt="数据结构（五）——图——图的广度优先遍历复杂度分析.png"><p>如果使用邻接矩阵存储，所需要时间复杂度为O(|V|<sup>2</sup>)，这个很简单就不多说。</p><p>如果使用邻接表存储，所需要时间复杂度为O(|V|+|E|)，这是因为访问|V|个顶点需要O(|V|)时间复杂度，而邻接表存储无向图会存储两次（前面有说过为什么存储两次），查找各个顶点的邻接点需要2|E|的时间，但大O表示法，可以不计系数，所以时间复杂度为O(|V|+|E|)。</p><p>这里会有疑问，在分析上面BFS算法的时间复杂度时，为什么没有像以前一样分析最深层循环的次数？举个例子，如果一个图没有边并且使用邻接表存储，显然循环次数就为0次，然而事实上对每一个结点的访问都要调用一次BFS，因此访问所有结点也需要O(|V|)的时间，所以只考虑最深层的循环是会出问题的，所以分析时间复杂度和算法实现的方式有关。总之，遇到分析BFS和DFS的时间复杂度时，不要深入代码，只需要记住算法的时间开销来自于访问顶点和找各条边即可，所以可以拆开分析访问点的时间与找边的时间，然后结合具体存储结构即可。</p><p>接下来看一下广度优先生成树的概念：</p><img src="https://pic.imgdb.cn/item/6644b27c0ea9cb14031d4b58.png" alt="数据结构（五）——图——广度优先生成树.png"><p> 在广度遍历的过程中，可以得到一课遍历树，称为广度优先生成树。</p><p>注意，如果图是以邻接矩阵的方式存储，因为一个图的邻接矩阵表示方式唯一，广度优先遍历序列唯一，因此广度优先生成树唯一。</p><p>但是如果图是以邻接表的方式存储，因为一个图的邻接表的表示方式不唯一，广度优先遍历序列也不唯一，因此广度优先生成树不唯一。</p><p>接下来再看一个比较相近的概念，广度优先生成森林：</p><img src="https://pic.imgdb.cn/item/6644b6c90ea9cb140323fb08.png" alt="数据结构（五）——图——广度优先生成森林.png"><p>如图，对于一个非连通图，其上面的连通分量可以生成一个广度优先生成树，下面的连通分量也可以生成一个广度优先生成树，两个树合在一起就成了一个广度优先生成森林。</p><img src="https://pic.imgdb.cn/item/6644b74e0ea9cb140324bc57.png" alt="数据结构（五）——图——有向图的BFS.png"><p>不难发现，上面的例子都是无向图，但是对于有向图，广度优先算法依然成立，但这里要明确一点，由于有向图的边带了方向性，所以对于同一图，以不同的顶点为出发点，调用BFS的次数不同，如上图，从1出发与从7出发的BFS调用次数就不相同。</p><p>下面对本节进行一个汇总：</p><img src="https://pic.imgdb.cn/item/6644b7610ea9cb140324d642.png" alt="数据结构（五）——图——BFS小结.png"><h3 id="4-2-深度优先遍历"><a href="#4-2-深度优先遍历" class="headerlink" title="4.2 深度优先遍历"></a>4.2 深度优先遍历</h3><img src="https://pic.imgdb.cn/item/6644b87e0ea9cb1403267d25.png" alt="数据结构（五）——图——图的DFS.png"><p>图的深度优先遍历和树的先序遍历很类似，两者都使用了递归的思想（可以结合学习），与广度优先搜索不同，这种搜索算法所遵循的策略是尽可能深地搜索一个图。如上图的例子，使用深度优先搜索算法得到的序列是21563478，注意考试时也可能让写深度优先搜索的遍历序列。</p><p>同广度优先搜素一样，上面的算法也存在相同问题，如果面对的是非连通图，则无法遍历完所有结点，所以也需要添加一个二次检查标记数组的函数，全部代码实现如下图：</p><img src="https://pic.imgdb.cn/item/6644ba170ea9cb140328e330.png" alt="数据结构（五）——图——图的DFS改进.png"><p>接下来分析一下DFS的复杂度：</p><img src="https://pic.imgdb.cn/item/6644ba980ea9cb140329897b.png" alt="数据结构（五）——图——图的DFS空间复杂度.png"><p>空间复杂度最坏情况，是如上图上面的形式的图，这时候深度优先搜索需要递归深度为O(|V|)。空间复杂度最好情况，是如上图下面的形式的图，这时候深度优先搜索需要递归深度为O(1)。</p><img src="https://pic.imgdb.cn/item/6644bb190ea9cb14032a347a.png" alt="数据结构（五）——图——图的DFS时间复杂度.png"><p>时间复杂度分析如上，分析的具体过程上图已说，大体上与BFS相同，有疑问可以去看一下BFS的解释，再回来理解。</p><p>下面看一下深度优先遍历序列：</p><img src="https://pic.imgdb.cn/item/6644bbb30ea9cb14032b20d6.png" alt="数据结构（五）——图——深度优先遍历序列.png"><p>同广度优先搜索一样，根据图的表示方式不同，其深度优先序列的表示也不一定唯一，具体问题还需具体分析。</p><p>接下来看一下深度优先生成树的概念：</p><img src="https://pic.imgdb.cn/item/6644bc3e0ea9cb14032bcafa.png" alt="数据结构（五）——图——深度优先生成树.png"><p>与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树，同样，根据图的表示方式不确定，深度优先生成树的唯一性也不确定。</p><p>另外，连通图调用DFS才能产生深度优先生成树，否则产生的将是深度优先生成森林。</p><p>接下来，总结一下图的遍历与图的连通性的关系，如下图：</p><img src="https://pic.imgdb.cn/item/6644bd640ea9cb14032d2283.png" alt="数据结构（五）——图——无向图的遍历与连通性.png"><p>上面是无向图的遍历与连通性的关系，下面看一下有向图的遍历与连通性的关系。</p><img src="https://pic.imgdb.cn/item/6644bdb40ea9cb14032d821d.png" alt="数据结构（五）——图——有向图的遍历与连通性.png"><p>最后，对本部分做个小结：</p><img src="https://pic.imgdb.cn/item/6644bdf10ea9cb14032dcdf6.png" alt="数据结构（五）——图——DFS小结.png"><h2 id="5-图的应用"><a href="#5-图的应用" class="headerlink" title="5. 图的应用"></a>5. 图的应用</h2><h3 id="5-1-最小生成树"><a href="#5-1-最小生成树" class="headerlink" title="5.1 最小生成树"></a>5.1 最小生成树</h3><h4 id="5-1-1-最小生成树的概念"><a href="#5-1-1-最小生成树的概念" class="headerlink" title="5.1.1 最小生成树的概念"></a>5.1.1 最小生成树的概念</h4><img src="https://pic.imgdb.cn/item/6644c02b0ea9cb140331a3c0.png" alt="数据结构（五）——图——生成树的概念.png"><p>首先回顾一下生成树的概念，如上图。图的生成树不唯一，对于一个带权连通图的生成树，若各边权值之和最小，则称为该带权连通图的最小生成树。如下图：</p><img src="https://pic.imgdb.cn/item/6644c0e40ea9cb140333c3d9.png" alt="数据结构（五）——图——最小生成树的概念.png"><p>注意，只有连通图才有生成树，非连通图只有生成森林。</p><p>最小生成树的性质如下：</p><img src="https://pic.imgdb.cn/item/6644c1740ea9cb1403350a47.png" alt="数据结构（五）——图——最小生成树的性质.png"><p>若求一个图的最小生成树可以有两种算法，分别是Prim算法和Kruskal算法。在考研初试阶段考察代码的可能性不高，所以着重理解这两种算法的手动模拟过程。</p><h4 id="5-1-2-Prim算法"><a href="#5-1-2-Prim算法" class="headerlink" title="5.1.2 Prim算法"></a>5.1.2 Prim算法</h4><img src="https://pic.imgdb.cn/item/6644c28e0ea9cb140336f11a.png" alt="数据结构（五）——图——Prim算法.png"><p>上图给出了Prim算法的核心思想，如果以P城为出发点，则可以得到下面两个最小生成树。所以，Prim算法得到的最小生成树表现形式不唯一，但它一定是权值和最小的。</p><img src="https://pic.imgdb.cn/item/6644c3a20ea9cb1403389dbe.png" alt="数据结构（五）——图——Prim算法示例.png"><p>下面看一下Prim算法的机器实现思想：</p><img src="https://pic.imgdb.cn/item/6644c6960ea9cb14033cdba0.png" alt="数据结构（五）——图——Prim算法实现初始步骤.png"><p>用两个数组来辅助实现Prim算法，其中一个数组用来标记各节点是否已加入树，另一个数组用来记录各节点加入树的最低代价。上面是初始状态，以V<sub>0</sub>为出发点，则V<sub>0</sub>已加入数组。同时更新各节点加入树的最低代价，V4和V5由于不与V0相连，所以它两无法加入树，代价标位无穷。</p><img src="https://pic.imgdb.cn/item/6644c7900ea9cb14033e690e.png" alt="数据结构（五）——图——Prim算法实现第一轮.png"><p>根据最低代价数组，可以发现V3加入代价最小，所以先让V3加入树，同时更新所有可以通过V0或V3加入树的结点的最小代价。接下来，继续选择加入代价最小的点加入树，如下图：</p><img src="https://pic.imgdb.cn/item/6644c8270ea9cb14033f4168.png" alt="数据结构（五）——图——Prim算法实现第二轮.png"><p>往后的步骤都一样，最后一组结果如下：</p><img src="https://pic.imgdb.cn/item/6644c8910ea9cb14033fd89d.png" alt="数据结构（五）——图——Prim算法实现最后一轮.png"><p>接下来分析复杂度：</p><img src="https://pic.imgdb.cn/item/6644c8d50ea9cb1403404dbe.png" alt="数据结构（五）——图——Prim算法实现复杂度.png"><p>每一轮循环都要选择一个新订点放入构建的树中，总共有n个顶点，就需要循环n-1轮，而每一轮循环当中，又需要经历两次遍历（遍历两个数组），所以每一轮复杂度为O(2n)，可以舍弃常数项，总共n-1轮，则总时间复杂度为O(n<sup>2</sup>)。</p><h4 id="5-1-3-Kruskal算法"><a href="#5-1-3-Kruskal算法" class="headerlink" title="5.1.3 Kruskal算法"></a>5.1.3 Kruskal算法</h4><img src="https://pic.imgdb.cn/item/6644c42a0ea9cb1403396011.png" alt="数据结构（五）——图——克鲁斯卡尔算法.png"><p>上图给出了Kruskal算法的核心思想，如果以P城为出发点，则可以得到下图最小生成树。</p><img src="https://pic.imgdb.cn/item/6644c49e0ea9cb14033a000d.png" alt="数据结构（五）——图——克鲁斯卡尔算法示例.png"><p>下面看一下Kruskal算法的机器实现思想：</p><img src="https://pic.imgdb.cn/item/6644c9ee0ea9cb140341d85d.png" alt="数据结构（五）——图——Kruskal算法实现初始步骤.png"><p>Kruskal算法在初始时，将图各边按照权值排序，如上图右，然后从第一行开始，检查该边上两个点是否已经连通，连通则跳过，不连通则选中。下面是第一轮实现：</p><img src="https://pic.imgdb.cn/item/6644ca710ea9cb140342a6c6.png" alt="数据结构（五）——图——Kruskal算法实现第一轮.png"><p>下面是第二轮实现：</p><img src="https://pic.imgdb.cn/item/6644ca9e0ea9cb140342f119.png" alt="数据结构（五）——图——Kruskal算法实现第二轮.png"><p>按照这种方式，到第五轮时出现已连通，则跳过，如下图：</p><img src="https://pic.imgdb.cn/item/6644cac20ea9cb14034327b1.png" alt="数据结构（五）——图——Kruskal算法实现第五轮.png"><p>接下来，按照这种方式遍历到最后，最后实现的结果与Prim算法一致，这里不过多阐述了。</p><p>最后看一下Kruskal的复杂度：</p><img src="https://pic.imgdb.cn/item/6644cb330ea9cb140343b94e.png" alt="数据结构（五）——图——Kruskal算法实现复杂度.png"><p>Kruskal算法要遍历边，所以要循环e轮，而在每一轮过程中，需要使用并查集来判断两个顶点是否属于同一集合，这个判断所需时间开销为O(log<sub>2</sub>e)，所以总体时间开销为O(elog<sub>2</sub>e)。</p><h4 id="5-1-4-Prim和Kruskal比较"><a href="#5-1-4-Prim和Kruskal比较" class="headerlink" title="5.1.4 Prim和Kruskal比较"></a>5.1.4 Prim和Kruskal比较</h4><p>上面两个算法我写的比较简洁，想了解具体过程的，可以点击跳转链接，听视频讲解：<a href="https://www.bilibili.com/video/BV1b7411N798?p=64&vd_source=7fb4b255ed876969a742738d7b84f461">最小生成树</a></p><p>下面看一下两种算法的时间复杂度：</p><img src="https://pic.imgdb.cn/item/6644c5ab0ea9cb14033b8bbd.png" alt="数据结构（五）——图——Prim算法和Kruskal算法比较.png"><p>Prim算法每次选择顶点，时间复杂度只与顶点有关，为O(|V|<sup>2</sup>)。Kruskal算法每次选择边，时间复杂度只与边有关，为O(|E|log<sub>2</sub>|E|)。所以Prim算法适合用于稠密图，Kruskal算法适合用于稀疏图。</p><h3 id="5-2-最短路径问题"><a href="#5-2-最短路径问题" class="headerlink" title="5.2 最短路径问题"></a>5.2 最短路径问题</h3><img src="https://pic.imgdb.cn/item/6644cc4f0ea9cb14034586f0.png" alt="数据结构（五）——图——最短路径问题.png"><p>带权有向图的最短路径可以分为两类，一类是单源最短路径，即求图中某一顶点到其他各顶点的最短路径；另一类是各顶点间的最短路径。</p><p>求单源最短路径可以使用BFS算法和Dijkstra算法，BFS算法适用无权图，Dijkstra适用带权图和无权图。</p><p>求各顶点间的最短路径可以使用Floyd算法，Floyd算法适用于带权图和无权图。</p><p>注意，这里说带权有向图的最短路径可以分为两类，但后面方法中又说该方法适合无权图，这里的无权图并非真正意义上的无权图，而是当成各边权值为1的带权图理解（也可以理解为各边权值相等的带权图，此时权值意义不大）。</p><h4 id="5-2-1-BFS求无权图的单源最短路径"><a href="#5-2-1-BFS求无权图的单源最短路径" class="headerlink" title="5.2.1 BFS求无权图的单源最短路径"></a>5.2.1 BFS求无权图的单源最短路径</h4><img src="https://pic.imgdb.cn/item/6644cec60ea9cb14034cc532.png" alt="数据结构（五）——图——BFS最短路径问题实现.png"><p>上面是BFS求无权图的单源最短路径的代码实现，这里在原BFS的基础上多定义了数组d表示路径长度和数组path表示路径从哪个顶点过来。这里使用这两个数组的核心在于，由于BFS类似树的层序遍历，所以得到的数组d存储的路径长度就是最短路径。而path数组记录一每个点的前驱，是为了方便找到具体的路径。</p><p>比如上面的例子，从顶点2出发，求顶点2与所有顶点的最短路径长度。首先要令d[2]&#x3D;0，表示2到自己的路径为0，由于刚开始，所有顶点还未与顶点2连接，所以所有顶点的d初始为无穷，path初始为-1。第一轮BFS，从2出发，找到1,6，则d[1]&#x3D;d[6]&#x3D;1，表示1,6到2的最短路径为1，这两个点的前驱都为2，即path[1]&#x3D;path[6]&#x3D;2。然后以1,6为顶点使用BFS，找到5,3,7，由于是第二轮，则5,3,7距离顶点2的长度为2，但path分别指的是1,6。按照这样的方式最后得到从2出发到达所有结点的最短路径长度，结果如上图。</p><p>这里有一点易错，那就是数组d[ ]存的是当前结点距离出发点的最短路径，而path[ ]数组存储的则是指向当前结点的上一个结点是谁。</p><p>各个顶点可以通过查找自己的前驱，最终找到一条到出发点2的路径，比如以结点4为例，它到2的路径为4-&gt;3-&gt;6-&gt;2，由于2的前驱是-1，所以可以知道2就是出发点。</p><img src="https://pic.imgdb.cn/item/6644d3140ea9cb140355365c.png" alt="数据结构（五）——图——BFS最短路径问题小结.png"><p>之前也说过，通过BFS可以得到广度优先生成树，不难发现，对于这个生成树，每个结点到底在第几层，也直接反应了从起点2到达这些结点的距离到底是多少。既然BFS得到的是最短路径，其实也就是说以2为根结点，通过BFS得到的生成树的高度一定是最小的。</p><h4 id="5-2-2-Dijkstra算法"><a href="#5-2-2-Dijkstra算法" class="headerlink" title="5.2.2 Dijkstra算法"></a>5.2.2 Dijkstra算法</h4><p>BFS只适用无权图，若想求带权图的某个顶点到其它顶点的最短路径，就需要使用Dijkstra算法</p><p>以一个例子来看Dijkstra算法如何运行：</p><img src="https://pic.imgdb.cn/item/66459c43d9c307b7e931f2be.png" alt="数据结构（五）——图——Dijkstra算法初始.png"><p>假设现在要找到V0到其它各个顶点的最短路径，如上图，要初始化如图的三个数组，第一个数组final表示有没有找到V0到达各个顶点的最短路径，由于V0可以直达自己，所以V0的标记是true。第二个数组dist表示目前为止能找到的最短路径长度，V0到自己的长度为0，V0能直达的是V1和V4，由于别的点都未加入，所以目前来看，V0到V1和V4的最短路径应该是10和5，而V2和V3并不存在从V0直接过来的边，所以该两个点设置的值为无穷，表示暂时没有找到通往该顶点的路。第三个数组path和BFS的path是一个原理，这里就不再介绍，目前V1和V4能确定一个比较好的路径是由V0到达，所以V1和V4的path都设置为0，而V0，V2，V4没有直接前驱就设置为-1。</p><p>进行了一系列初始化以后，要进行第一轮处理：从初始化的dist数组中，选择dist值最小的，即V4加入路径中。然后更新未加入路径的顶点的dist值和path值，比如V1原来的路径长度为10，但是V4连通以后，可以通过V6-&gt;V4-&gt;v1的路径到达，此时路径长度只有8，所以更新dist[1]&#x3D;8，path[1]&#x3D;4。更新完所有的顶点以后，得到下图的第一轮结果。</p><img src="https://pic.imgdb.cn/item/66459c9ed9c307b7e9328bbf.png" alt="数据结构（五）——图——Dijkstra算法第一轮处理.png"><p>按照上述步骤，第二轮处理结果如下：</p><img src="https://pic.imgdb.cn/item/66459ea8d9c307b7e9361be9.png" alt="数据结构（五）——图——Dijkstra算法第二轮处理.png"><p>第三轮处理如下：</p><img src="https://pic.imgdb.cn/item/66459ee1d9c307b7e936711d.png" alt="数据结构（五）——图——Dijkstra算法第三轮处理.png"><p>最后一轮处理如下：</p><img src="https://pic.imgdb.cn/item/66459f10d9c307b7e936c871.png" alt="数据结构（五）——图——Dijkstra算法最后一轮处理.png"><p>得到了最后的数组以后，下面看一下如何处理使用数组信息：</p><img src="https://pic.imgdb.cn/item/66459f71d9c307b7e937739c.png" alt="数据结构（五）——图——Dijkstra信息处理.png"><p>以V0到V2为例，通过查dist数组，可以知道V0到V2的最短路径长度为9，通过查询path数组可以知道V0到V2的路径为：V0-&gt;V4-&gt;V1-&gt;V2。</p><p>接下来分析一下Dijkstra算法的时间复杂度：</p><img src="https://pic.imgdb.cn/item/6645a12bd9c307b7e93b1849.png" alt="数据结构（五）——图——Dijkstra时间复杂度.png"><p>在每一轮循环中，首先要遍历所有结点，找到还没确定最短路径，且dist最小的顶点Vi，这一步的时间复杂度为O(|V|)。找到Vi以后，还要遍历与他相关的所有结点，去修改dist数组和path数组。这一步的时间复杂度也为O(|V|)。也就是说每一轮的处理应是O(2|V|)，但可以舍弃常数项，保留下来就是O(|V|)。一共要经历n-1轮处理，总的时间复杂度O(|V|<sup>2</sup>)。</p><p>Dijkstra算法和Prim算法很类似，只不过Dijkstra算法的dist数组记录的是从当前顶点到某一个指定顶点的最短路径值，而Prim算法的lowCost数组里记录的是某一个顶点加入到生成树里的最小代价。可以对比着学习。</p><p>最后说一下Dijkstra算法失效的例子，如下图：</p><img src="https://pic.imgdb.cn/item/6645a2d8d9c307b7e93e0ea5.png" alt="数据结构（五）——图——Dijkstra失效的例子.png"><p>当带权图边上带有负权值时，Dijkstra算法并不使用。比如上图，以V0为起点到V2，最短路径应是V0-&gt;V1-&gt;V2，路径长度为5，但是使用Dijkstra算法得到的最短路径是V0-&gt;V2，长度为7。</p><h4 id="5-2-3-Floyd算法"><a href="#5-2-3-Floyd算法" class="headerlink" title="5.2.3 Floyd算法"></a>5.2.3 Floyd算法</h4><p>写在开头：我这部分写的比较简陋，主要用来辅助复习的，有问题可以听王道的讲解：<a href="https://www.bilibili.com/video/BV1b7411N798?p=67&vd_source=7fb4b255ed876969a742738d7b84f461">Floyd算法</a></p><img src="https://pic.imgdb.cn/item/6645a408d9c307b7e93fd85c.png" alt="数据结构（五）——图——Floyd算法.png"> <p>Floyd算法思想如上，接下来以一个例子看一下Floyd算法的过程：</p><p>初始化：在初始化时，定义邻接矩阵A来存储带权图，邻接矩阵上存储两个结点间的最短路径长度，path数组存储前驱结点。在初始时，不允许有任何顶点中转，此时可达的两点间的最短路径就是两点间的边的权值。path数组的值全为-1。</p><p>这里注意一点，邻接矩阵存储的横行代表弧的射出，竖行代表弧的射入。</p><img src="https://pic.imgdb.cn/item/6645a9ead9c307b7e94a0b39.png" alt="数据结构（五）——图——Floyd算法初始.png"><p>初始化以后，现在允许V0为中转，检查每两个顶点间的路径是否可以通过V0中转，可以的话路径长度为多少，与原来相比是大是小，如果小则更新最短路径，如果大则保持原来路径。允许V0为中转的两个数组的更新如下：</p><img src="https://pic.imgdb.cn/item/6645ab41d9c307b7e94c7c70.png" alt="数据结构（五）——图——Floyd算法第一轮.png"><p>接下来，允许V0，V1为中转，检查每两个顶点间的路径是否可以通过V0，V1中转，可以的话路径长度为多少，与原来相比是大是小，如果小则更新最短路径，如果大则保持原来路径。允许V0，V1为中转的两个数组的更新如下：</p><img src="https://pic.imgdb.cn/item/6645ac9bd9c307b7e94f1a45.png" alt="数据结构（五）——图——Floyd算法第二轮.png"><p>接下来，允许V0，V1，V2为中转，检查每两个顶点间的路径是否可以通过V0，V1，V2中转，可以的话路径长度为多少，与原来相比是大是小，如果小则更新最短路径，如果大则保持原来路径。允许V0，V1，V2为中转的两个数组的更新如下：</p><img src="https://pic.imgdb.cn/item/6645acd9d9c307b7e94f960f.png" alt="数据结构（五）——图——Floyd算法第三轮.png"><p>经过上面三轮迭代，我们已经把所有结点都考虑进去，此时得到的数组就是最终的数组，A数组里存储了图中任意两点间的最短路径长度，path数组存储了在最短路径中每个点的前驱。对于最终数组的具体分析与使用可以参考下图：</p><img src="https://pic.imgdb.cn/item/6645adbcd9c307b7e9512d4a.png" alt="数据结构（五）——图——Floyd算法数组分析.png"><p><strong>这里补充一点，在Floyd算法里，有n个顶点，在初始化以后，就要经历n轮更新迭代。</strong></p><p>Floyd算法的代码实现如下：</p><img src="https://pic.imgdb.cn/item/6645ae83d9c307b7e952c93c.png" alt="数据结构（五）——图——Floyd算法实现.png"><p>根据上图，很清晰的可以看到时间复杂度为O(|V|<sup>3</sup>)，空间复杂度为O(|V|<sup>2</sup>)。</p><p>最后看一下啊Floyd算法无法处理的情况：</p><p>首先再看一下负权图，上面我们说Dijkstra算法无法用于负权图，所以可以尝试用Floyd算法模拟负权图，最后会发现<strong>Floyd算法是可以用于负权图的</strong>。</p><img src="https://pic.imgdb.cn/item/6645af5cd9c307b7e954f7d9.png" alt="数据结构（五）——图——Floyd算法实现负权图.png"><p>但是Floyd算法也有无法实现的情况，比如下面负权回路图，因为这种图有可能没有最短路径，所以Floyd算法也无法求出最短路径。</p><img src="https://pic.imgdb.cn/item/6645b06ed9c307b7e9571a75.png" alt="数据结构（五）——图——Floyd算法无法实现的情况.png"><p>下面对三个求最短路径问题的方法进行小结：</p><img src="https://pic.imgdb.cn/item/6645b0b6d9c307b7e957a0b2.png" alt="数据结构（五）——图——最短路径问题总结.png"><h3 id="5-3-有向无环图描述表达式"><a href="#5-3-有向无环图描述表达式" class="headerlink" title="5.3 有向无环图描述表达式"></a>5.3 有向无环图描述表达式</h3><p>先看一下什么是有向无环图，如下图：</p><img src="https://pic.imgdb.cn/item/6645b16dd9c307b7e9590a30.png" alt="数据结构（五）——图——有向无环图.png"><p>知道了什么是有无环图，接下来就是本部分重点，用有向无环图来描述表达式。</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240516151314840.png" alt="image-20240516151314840"></p><p>之前的学习说过，算术表达式可以用树的形式来表示，如上图，但仔细观察会发现树中存在重复的部分，比如上图的红色部分和绿色部分，这时候可以采用有向无环图，实现对相同子式的共享，从而节省存储空间。所以可以将其合并成如下图的形式：</p><img src="https://pic.imgdb.cn/item/6645b2b1d9c307b7e95b6c16.png" alt="数据结构（五）——图——树的算术表达式合并.png"><p>注意，这个树依然有许多相同的部分，所以我们可以将其全部合并，最后合并的结果如下图：</p><img src="https://pic.imgdb.cn/item/6645b2ebd9c307b7e95bdbec.png" alt="数据结构（五）——图——树的算术表达式最终合并.png"><p>最后合并出来的结果就是该表达式的有向无环图表示。</p><p>这部分的题很简单，多数都是考察有向无环图描述表达式需要的顶点个数，或绘制有向无环图。但是由于要合并的点可能有很多，导致做题时可能出现遗漏，所以下面提供一种做题方法：</p><img src="https://pic.imgdb.cn/item/6645b4d8d9c307b7e95f70a3.png" alt="数据结构（五）——图——有向无环图的算数表达式.png"><p>按照图中步骤，先构造出如图的表示形式，然后执行第四步，自底向上逐层检查同层的运算符是否可以合并，若可以就合并，最后得到就是有向无环图的描述表达式，如下图：</p><img src="https://pic.imgdb.cn/item/6645b73dd9c307b7e9642656.png" alt="数据结构（五）——图——有向无环图的算数表达式合并.png"><h3 id="5-4-拓扑排序"><a href="#5-4-拓扑排序" class="headerlink" title="5.4 拓扑排序"></a>5.4 拓扑排序</h3><p>先看一下什么是AOV网：</p><img src="https://pic.imgdb.cn/item/6645b7cdd9c307b7e96546ad.png" alt="数据结构（五）——图——AOV网.png"><p>所谓AOV网，就是用有向无环图表示一个过程，顶点表示活动，用有向边&lt;Vi,Vj&gt;表示活动Vi必须先于活动Vj进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，称为AOV网。</p><p>了解AOV网以后，接下来看一下拓扑排序的概念。</p><img src="https://pic.imgdb.cn/item/6645b87ed9c307b7e966a271.png" alt="数据结构（五）——图——拓扑排序.png"><p>简单的理解，拓扑排序就是AOV网里找到做事的先后顺序。</p><p>如上图的番茄炒蛋AOV网，拓扑排序的顺序就可以为：买菜、准备厨具、洗番茄、切番茄、打鸡蛋、下锅炒、吃。当然也可以排序为准备厨具、买菜、洗番茄、切番茄、打鸡蛋、下锅炒、吃。除了这两种，还有其它的排序方式，所以每个AOV网的拓扑排序序列不唯一。</p><p>下面看一下拓扑排序的实现步骤：</p><img src="https://pic.imgdb.cn/item/6645ba37d9c307b7e96a0580.png" alt="数据结构（五）——图——拓扑排序实现步骤.png"><p>需要注意，并不是所有的图都可以进行拓扑排序，比如存在回路的图就无法进行拓扑排序，如下图：</p><img src="https://pic.imgdb.cn/item/6645baa8d9c307b7e96aef4a.png" alt="数据结构（五）——图——拓扑排序不适应的情况.png"><p>接下来看一下拓扑排序的代码实现，拓扑排序的代码实现就是将前面所说的拓扑排序的实现步骤用代码的形式表示出来：</p><img src="https://pic.imgdb.cn/item/6645badcd9c307b7e96b5936.png" alt="数据结构（五）——图——拓扑排序的代码实现.png"><p>上图是拓扑排序的代码实现，右边的才是拓扑排序的代码，左边的是存储结构的描述与定义，注意这里使用邻接表来存储图。</p><p>下面重点看拓扑排序的代码部分：</p><img src="https://pic.imgdb.cn/item/6645bbdad9c307b7e96d0ad2.png" alt="数据结构（五）——图——拓扑排序的代码实现过程.png"><p>拓扑排序的代码，先声明（图中代码没有声明）了两个数组indegree[ ]和print[ ]分别用来记录当前顶点的入度和拓扑排序序列。此外，还定义了一个栈用来存储入度为0的点。</p><p>下面看一下代码实现的过程，首先，由于未开始排序，所以print数组全部初始化为-1。代码里第一个for循环会检查所有入度为0的点，并将入度为0的点放入栈中保存，上例中会把0和2依次压入栈中。接下来用count记录当前已输出的顶点数，由于栈里先弹出2号顶点，所以count指向位置存出2，表示拓扑序列里第一个值为2。接下来的for循环把所有与2相连的结点入度减1，此时与2相连的点没有入度变成0的，所以不需要再次入栈。到此为止完成第一轮循环。</p><p>接下来，由于栈里还有顶点0，所以栈非空，要进行第二轮while循环。同顶点2的操作一样，但是到最后，将0出栈，实现与0相连的结点入度减1时，出现1结点入度为0，所以要把1入度。到此完成第二轮循环。</p><p>第三轮，由于栈里有顶点1，还要接着进入while循环，按照这种方式继续迭代，当出现栈空时，则跳出循环。</p><p>跳出循环的情况有两种，一是出现回路，一是拓扑排序成功，判断是回路还是排序成功的方式是通过比较已被排序的顶点个数和顶点总个数，若相等，则排序成功，若不等，则存在回路。</p><p>接下来分析时间复杂度：</p><img src="https://pic.imgdb.cn/item/6645bf53d9c307b7e97374d4.png" alt="数据结构（五）——图——拓扑排序的代码复杂度.png"><p>由于代码执行过程中，每个顶点都需要处理一次，每个边也都需要处理一次，所以时间复杂度为O(|V|+|E|)。但是要采用邻接矩阵存储，遍历每条边则要访问整个邻接矩阵，时间复杂度为O(|V|<sup>2</sup>)。</p><p>接下来看逆拓扑排序，与拓扑排序很像，只不过逆拓扑排序是选择出度为0的顶点输出。</p><img src="https://pic.imgdb.cn/item/6645bfe2d9c307b7e9748192.png" alt="数据结构（五）——图——逆拓扑排序.png"><p>上图的逆拓扑排序序列就可以为：吃、下锅炒、切番茄、洗番茄、打鸡蛋、准备厨具、买菜。</p><p>下面看一下逆拓扑排序的实现：</p><img src="https://pic.imgdb.cn/item/6645c07fd9c307b7e975925e.png" alt="数据结构（五）——图——逆拓扑排序实现.png"><p>上图给出的是拓扑排序的实现代码，要想改成逆拓扑排序首先需要将拓扑排序里每次将入度为0的点删去改成每次将出度为0的点删去，然后要根据所使用的存储结构来进行程序设计。</p><p>这里要考虑一下存储结构对逆拓扑排序时间复杂度的影响，当实现逆拓扑排序时，由于要找每个点的入度，此时使用邻接表法就不太合适，所以采用邻接矩阵法可以稍微好一点。除了这两种，这里再补充一个逆邻接表法，即每个顶点后面跟的是指向自己的点，如果采用逆邻接表存储，实现逆拓扑排序就会更加方便。</p><p>在考试时，还喜欢出用DFS实现拓扑排序和逆拓扑排序，下面是DFS实现按逆拓扑排序的方法：</p><img src="https://pic.imgdb.cn/item/6645c1ded9c307b7e978233a.png" alt="数据结构（五）——图——DFS实现逆拓扑排序.png"><p>用DFS实现逆拓扑排序的核心就是将被访问完所有邻接点的顶点输出。比如说上面的例子，用栈来存储被访问的顶点，每一个被访问的顶点就做上标记，并压入栈中。当访问到没有邻接点的时候，就意味着访问到最后一个顶点，此时就要进行出栈操作，在每一个顶点出栈前，将顶点输出，就构成了逆拓扑排序序列。另外，DFS可能会出现同级点没有被访问的情况，如上图，在进行完一次DFS后，还要检查是否所有点都被访问，若存在未被访问的，要二次调用DFS。上图经过上述步骤，最后输出逆拓扑排序序列43102。</p><p>补充：DFS实现拓扑排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设图使用邻接表表示  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 100 <span class="comment">// 最大顶点数  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>  </span><br><span class="line">    <span class="type">int</span> vertex;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125; Node;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span>  </span><br><span class="line">    <span class="type">int</span> numVertices;  </span><br><span class="line">    Node** adjLists; <span class="comment">// 邻接表  </span></span><br><span class="line">    <span class="type">int</span>* visited; <span class="comment">// 标记顶点是否被访问过  </span></span><br><span class="line">    <span class="type">int</span>* finishTime; <span class="comment">// 顶点的完成时间（逆后序遍历顺序）  </span></span><br><span class="line">&#125; Graph;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建一个新节点  </span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;  </span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  </span><br><span class="line">    newNode-&gt;vertex = vertex;  </span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">return</span> newNode;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 添加边到图的邻接表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(Graph* graph, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;  </span><br><span class="line">    Node* newNode = createNode(dest);  </span><br><span class="line">    newNode-&gt;next = graph-&gt;adjLists[src];  </span><br><span class="line">    graph-&gt;adjLists[src] = newNode;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// DFS遍历并计算完成时间  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph* graph, <span class="type">int</span> vertex, <span class="type">int</span>* <span class="built_in">stack</span>)</span> &#123;  </span><br><span class="line">    graph-&gt;visited[vertex] = <span class="number">1</span>;  </span><br><span class="line">    Node* temp = graph-&gt;adjLists[vertex];  </span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!graph-&gt;visited[temp-&gt;vertex]) &#123;  </span><br><span class="line">            DFS(graph, temp-&gt;vertex, <span class="built_in">stack</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        temp = temp-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 将当前顶点压入栈中，以获取逆后序遍历（完成时间）  </span></span><br><span class="line">    <span class="built_in">stack</span>[graph-&gt;numVertices - <span class="number">1</span> - graph-&gt;finishTime[vertex]] = vertex;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 拓扑排序函数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">topologicalSort</span><span class="params">(Graph* graph)</span> &#123;  </span><br><span class="line">    graph-&gt;visited = (<span class="type">int</span>*)<span class="built_in">calloc</span>(graph-&gt;numVertices, <span class="keyword">sizeof</span>(<span class="type">int</span>));  </span><br><span class="line">    graph-&gt;finishTime = (<span class="type">int</span>*)<span class="built_in">calloc</span>(graph-&gt;numVertices, <span class="keyword">sizeof</span>(<span class="type">int</span>));  </span><br><span class="line">    <span class="type">int</span>* <span class="built_in">stack</span> = (<span class="type">int</span>*)<span class="built_in">malloc</span>(graph-&gt;numVertices * <span class="keyword">sizeof</span>(<span class="type">int</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化完成时间数组  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;numVertices; i++) &#123;  </span><br><span class="line">        graph-&gt;finishTime[i] = graph-&gt;numVertices;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// DFS遍历每个未访问过的节点  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;numVertices; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!graph-&gt;visited[i]) &#123;  </span><br><span class="line">            DFS(graph, i, <span class="built_in">stack</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 栈中存储的是逆后序遍历，出栈则为拓扑排序  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;拓扑排序结果: &quot;</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;numVertices; i++) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">stack</span>[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">free</span>(graph-&gt;visited);  </span><br><span class="line">    <span class="built_in">free</span>(graph-&gt;finishTime);  </span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>下面思考一个问题，对于上面的DFS实现逆拓扑排序，如果存在回路，则无法进行逆拓扑排序，这里怎么判断有回路存在？</p><p>我的想法是可以使用“递归”和“访问标记”的方法。当一个节点在递归过程中被第二次访问（即它不是当前递归路径的父节点），那么图中就存在回路。<strong>（这是我的想法，答案应该不唯一，能实现就行。）</strong></p><p>最后，对拓扑排序内容进行小结：</p><img src="https://pic.imgdb.cn/item/6645c4dad9c307b7e97db36c.png" alt="数据结构（五）——图——拓扑排序总结.png"><h3 id="5-5-关键路径"><a href="#5-5-关键路径" class="headerlink" title="5.5 关键路径"></a>5.5 关键路径</h3><p>首先，看一下什么是AOE网：</p><img src="https://pic.imgdb.cn/item/6645c590d9c307b7e97ef20a.png" alt="数据结构（五）——图——AOE网.png"><p>与AOV网不同，<strong>AOE网用顶点表示事件，用有向边表示活动，以边上的权值表示完成该活动的开销</strong>。</p><p>AOE网具有两条性质：</p><ol><li>只有某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。但是要注意，如果一个顶点后面有多个事件，则这些事件是可以并行的。</li></ol><p>接下来，看一下源点和汇点的概念：</p><img src="https://pic.imgdb.cn/item/6645c677d9c307b7e980a6e9.png" alt="数据结构（五）——图——AOE的开始与结束顶点.png"><p>AOE网中只有一个入度为0的顶点，称为开始顶点也叫源点。也仅有一个出度为0的顶点，称为结束顶点，也叫汇点。</p><p>到这里，就可以引出关键路径与关键活动的概念：</p><img src="https://pic.imgdb.cn/item/6645c722d9c307b7e981ed8a.png" alt="数据结构（五）——图——关键路径与关键活动.png"><p>从源点到汇点的所有有向路径里，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为关键活动。到这里就可以知道，完成某个工程的最短时间就是关键路径长度，若有关键活动不能按时完成，则整个工程的完成时间就会推迟。</p><p>为了求关键路径与关键活动，需要先引入几个概念：</p><p>(1) 事件的最早发生时间与活动的最早开始时间。</p><img src="https://pic.imgdb.cn/item/6645c7fed9c307b7e98390e1.png" alt="数据结构（五）——图——事件最早发生与活动最早开始.png"><p>(2) 事件的最吃发生时间与活动的晚早开始时间。</p><img src="https://pic.imgdb.cn/item/6645c84ad9c307b7e9842f4d.png" alt="数据结构（五）——图——事件最迟发生与活动最晚开始.png"><p>(3) 时间余量。</p><img src="https://pic.imgdb.cn/item/6645c88bd9c307b7e984b0eb.png" alt="数据结构（五）——图——时间余量.png"><p>将活动的最早开始时间与最迟开始时间放到一起，可以发现，当一个活动的最早开始时间与最迟开始时间相等时，活动就不可以拖延，若最早开始时间小于最迟开始时间，则两者的差值，就是活动可以拖延的时间。如上图的打鸡蛋步骤，就可以推出2分钟开始。</p><p>我们将活动最迟开始时间与活动最早开始时间的差值，叫做活动的时间余量。时间余量表示在不推迟工程完成时间的情况下，某个活动可以拖延的时间。</p><p>了解了这些概念，就可以将关键路径的计算步骤总结如下：<br><img src="https://pic.imgdb.cn/item/6645ca27d9c307b7e987e7d1.png" alt="数据结构（五）——图——关键路径计算.png"></p><p>求关键路径的步骤可以总结为，先求出事件的最早和最迟发生时间，进而可以求得活动的最早和最迟发生时间，最后计算活动余量。活动余量为0的就是关键活动，所有关键活动就构成了关键路径。</p><p>下面分别看一下这些步骤的实现，这部分呢比较简单，我直接贴个图，有重点会说一下：</p><p>(1) 求所有事件的最早发生时间。</p><img src="https://pic.imgdb.cn/item/6645caf2d9c307b7e9897015.png" alt="数据结构（五）——图——求所有事件的最早发生时间.png"><p>(2) 求所有事件的最晚发生时间。</p><img src="https://pic.imgdb.cn/item/6645cb50d9c307b7e98a108a.png" alt="数据结构（五）——图——求所有事件的最晚发生时间.png"><p>(3) 求所有活动的最早发生时间。</p><img src="https://pic.imgdb.cn/item/6645cb8ed9c307b7e98a771c.png" alt="数据结构（五）——图——求所有活动的最早发生时间.png"><p>(4) 求所有活动的最晚发生时间。</p><img src="https://pic.imgdb.cn/item/6645cbc4d9c307b7e98ad9f1.png" alt="数据结构（五）——图——求所有活动的最晚发生时间.png"><p>(5) 求时间余量。</p><img src="https://pic.imgdb.cn/item/6645cbfcd9c307b7e98b3f8c.png" alt="数据结构（五）——图——求时间余量.png"><p>求出了时间余量，就可以将所有时间余量为0的活动组合起来，就构成了关键路径，如图。</p><p>接下来，说一下关键活动与关键路径的特性：</p><img src="https://pic.imgdb.cn/item/6645cc5cd9c307b7e98bf38c.png" alt="数据结构（五）——图——关键活动和关键路径的特性.png"><p>关键活动决定着整个工程工期，如果关键活动耗时增加，则整个工程的工期将增长，所以可以缩短关键活动的时间，进而缩短整个工程的工期。但是当关键活动缩短到一定程度时，可能会出现其他活动的耗时超过这个关键活动，此时关键活动就变成了非关键活动，再缩短时间也不会影响工期。</p><p>另外，由于AOV网可能存在多条路径，所以可能出现下面的情况，即存在两天时间相等的最长路径，则这两条路径都是关键路径，此时缩短其中一条活动的时间，并不一定能缩短整体工期，只有加快那些包括在所有关键路径上的关键活动才能缩短工期。如下图，缩短打鸡蛋并不能缩短活动的工期，但缩短所有关节路径都包含的炒菜就可以缩短工期。</p><img src="https://pic.imgdb.cn/item/6645ccead9c307b7e98d14cd.png" alt="数据结构（五）——图——关键活动和关键路径的特性2.png"><p>最后，对关键路径进行小结：</p><img src="https://pic.imgdb.cn/item/6645cde4d9c307b7e98e9c57.png" alt="数据结构（五）——图——关键路径小结.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（六）——应用层</title>
      <link href="/2024/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2024/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（六）——应用层"><a href="#计算机网络（六）——应用层" class="headerlink" title="计算机网络（六）——应用层"></a>计算机网络（六）——应用层</h1><h2 id="1-导学-应用层概述"><a href="#1-导学-应用层概述" class="headerlink" title="1. 导学&amp;应用层概述"></a>1. 导学&amp;应用层概述</h2><img src="https://pic.imgdb.cn/item/6641a8b90ea9cb1403958ec8.png" alt="计算机网络（六）——应用层——应用层导图.png"><p>本章知识导图如上，可以结合导图进行学习。</p><p>在进行正文学习前，先看一下应用层的概述以及功能介绍：</p><img src="https://pic.imgdb.cn/item/6641a9660ea9cb1403966598.png" alt="计算机网络（六）——应用层——应用层概述.png"><p>传输层给应用进程提供一种端到端的通信服务，但是不同的网络应用进程之间还需要有一些不同的通信规则，因此就在传输层协议之上建立了应用层，所以应用层是来对应用程序的通信提供服务的。</p><p><strong>应用层协议规定：</strong></p><ol><li>应用进程交换的报文类型。</li><li>各种报文类型的语法。</li><li>字段的语义。</li><li>进程何时，如何发送报文，以及对报文进行响应的规则。</li></ol><p><strong>对于这些规定，进而衍生出了下面的几个应用层的功能：</strong></p><ol><li>文件传输、访问和管理。</li><li>电子邮件。在发送和接收电子邮件的过程中就要使用到应用层的相关协议。</li><li>虚拟终端。个人计算机用户可以直接使用他人计算机来和大型计算机进行网络通信，而不必使用一些专门的终端。也就是说，使用虚拟终端可以更方便的使用大型计算机的一些相关功能。</li><li>查询服务和远程作业登录。比如说打开网页时，在百度里搜索哔哩哔哩，点了百度一下，这就是在请求服务的过程，而服务器返回请求就是响应该请求的过程。</li></ol><p><strong>应用层的协议有：FTP、SMTP、POP3、HTTP、DNS等</strong>。</p><h2 id="2-网络应用模型"><a href="#2-网络应用模型" class="headerlink" title="2. 网络应用模型"></a>2. 网络应用模型</h2><p>应用层通常使用的两种模型分别是客户&#x2F;服务器模型和P2P模型。</p><h3 id="2-1-客户-服务器模型"><a href="#2-1-客户-服务器模型" class="headerlink" title="2.1 客户&#x2F;服务器模型"></a>2.1 客户&#x2F;服务器模型</h3><img src="https://pic.imgdb.cn/item/6641ace50ea9cb14039db9ec.png" alt="计算机网络（六）——应用层——客户-服务器模型.png"><p>上图是客户&#x2F;服务器模型，服务器就是提供计算服务的设备，而客户机就是请求计算服务的主机。在导学部分举的搜索哔哩哔哩的例子，就是一个客户&#x2F;服务器模型的应用。</p><p>服务器的特点：</p><ol><li>永久提供服务。服务器24小时保持清醒，永远处于等待客户机发来请求的状态。</li><li>永久性访问地址&#x2F;域名。像百度，就是永久性域名&#x2F;地址，根据这个域名&#x2F;地址可以访问该服务器。</li></ol><p>客户机的特点：</p><ol><li>与服务器通信，使用服务器提供的服务。</li><li>间歇性接入网络。客户机不像服务器一样时刻保持清醒状态，客户机是可以随时进入网络也可以随时退出网络的。</li><li>可能使用动态IP地址。客户的IP地址是不限制的，可以使用动态IP地址，但服务器的IP和域名是要永久性固定的。</li><li>不与其他客户机直接通信。客户机的通信是通过服务器转发的。</li></ol><p>客户&#x2F;服务器模型应用广泛，比如在使用Web、文件传输FTP、远程登录、电子邮件等，都使用的是C&#x2F;S模型。</p><h3 id="2-2-P2P模型（对等模型）"><a href="#2-2-P2P模型（对等模型）" class="headerlink" title="2.2 P2P模型（对等模型）"></a>2.2 P2P模型（对等模型）</h3><img src="https://pic.imgdb.cn/item/6641ad0d0ea9cb14039def3a.png" alt="计算机网络（六）——应用层——P2P模型.png"><p>上图是P2P模型，可以很明显的看到，与客户&#x2F;服务器模型相比，P2P少了服务器设备。所以P2P的思想就是整个网络的传输内容都不会保存在一个中心的服务器上，而是每个结点都具有上传和下载数据的功能，他们的权利和义务大体是对等的，所以也叫对等模型。</p><p>P2P模型的特点：</p><ol><li>不存在永远在线的服务器。</li><li>每个主机既可以提供服务，也可以请求服务。</li><li>任意端系统&#x2F;节点之间可以直接通讯。</li><li>节点间歇性接入网络。</li><li>节点可能改变IP地址（即动态IP）。</li><li>可扩展性好。可扩展性指当网络有大量主机涌入，这些主机之间是否还能够顺利请求服务。P2P模型就可以应对大量主机涌入网络，因为在P2P模型中，每台主机既可以提供服务，也可以请求服务，当主机增多了，虽然请求多了，提供的服务也增多了，因此可以不用担心资源不够用或带宽受限的问题。而C&#x2F;S模型会有响应限制，所以只能接受一定数量的客户请求。</li><li>网络健壮性强。所谓网络健壮就是指网络不容易瘫痪掉，在P2P模型里，任意一台主机退出或坏掉，对整个网络没有任何影响。而在C&#x2F;S模型里，当服务器坏掉了，整个网络都会崩溃，所以C&#x2F;S模型的网络健壮性相对来说是弱一些的。</li></ol><h2 id="3-域名系统（DNS）"><a href="#3-域名系统（DNS）" class="headerlink" title="3. 域名系统（DNS）"></a>3. 域名系统（DNS）</h2><h3 id="3-1-DNS系统"><a href="#3-1-DNS系统" class="headerlink" title="3.1 DNS系统"></a>3.1 DNS系统</h3><p>网民在访问网站的过程当中，就是主机和另一台主机进行远程通信的过程。那当前主机是如何找到对方主机的呢？是通过IP地址，只要当前主机找到对应网站的IP地址，就可以和该网站进行信息的交换。但是人们通过记忆IP地址，根据IP地址去找网站是很麻烦的，所以采用域名来替代IP地址。域名就是网站的名字，比如百度的域名就是<a href="http://www.baidu.com.虽然人们可以通过域名访问网站,但实际上计算机访问网站时,是通过把域名转换为ip地址来实现访问的,而计算机实现域名到ip地址的转换就要通过dns系统./">www.baidu.com。虽然人们可以通过域名访问网站，但实际上计算机访问网站时，是通过把域名转换为IP地址来实现访问的，而计算机实现域名到IP地址的转换就要通过DNS系统。</a></p><p>而DNS实现域名解析的大致流程如下：</p><img src="https://pic.imgdb.cn/item/6641b7450ea9cb1403aab7da.png" alt="计算机网络（六）——应用层——DNS域名解析.png"><p>在计算机里输入要访问网站域名，域名会传给DNS服务器，通过DNS服务器的操作，就会返还给主机要访问网站的IP地址，主机知道IP地址就可以访问这个网站，网站的信息也可以回复回来。如果访问不了网站，则可能是网站崩溃，也可能是DNS服务器域名解析出现问题。</p><p><strong>DNS系统采用客户&#x2F;服务器模型，其协议运行在UDP之上，使用53号端口。</strong></p><p><strong>从概念上可以将DNS分为三部分：层次域名空间、域名服务器和解析器。</strong></p><h3 id="3-2-域名"><a href="#3-2-域名" class="headerlink" title="3.2 域名"></a>3.2 域名</h3><img src="https://pic.imgdb.cn/item/6641b83f0ea9cb1403ad22ba.png" alt="计算机网络（六）——应用层——域名.png"><p><strong>任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名。</strong></p><p>域名由英文字母、数字和点（也是英文当中的句号）组成，每个点分隔开的东西叫做标号，像上图的www就是一个标号，cskaoyan也是一个标号，com也是一个标号。每个标号不能超过63个字符，但为了记忆方便，最好是别超过12个字符，而且标号也是不区分大小写字母的。</p><p>域名当中的每一个标号的级别也不一样，级别的高低是自左向右，由低到高的。所以最右边的标号叫顶级域名，其次为二级域名，再往下就是三级域名，接下来还可以有四级、五级等。</p><p>除了标号以外，域名还有一个根，根就是在顶级域名后面的一个点，但一般写域名都会省略这个点，根过了以后才是顶级域名。</p><p>各级域名的分类及各分类的常见标号如上图所示，可以自己参阅。</p><p>可以发现二级域名有一些和顶级域名重复了，这是因为在顶级域名处可以使用国家顶级域名，接下来的类别域名就可以在国家之下说国家的类，，比如某个网站 xxx.xxx.com.cn，就可以理解为中国的一家企业。</p><p>上图还有一些二级域名没有罗列出来，比如说自己注册的域名，如CCTV。但有一点要注意，自己注册域名一定要全球唯一。</p><p>通常会用如下的域名树的形式来描述整个域名系统：</p><img src="https://pic.imgdb.cn/item/6641bc590ea9cb1403b4b13d.png" alt="计算机网络（六）——应用层——域名树.png"><p>对于一个网站的域名书写，一般都是按域名树自下而上的顺序进行书写。比如上图的华科大网站<a href="http://www.hust.edu.cn./">www.hust.edu.cn。</a></p><h3 id="3-3-域名服务器"><a href="#3-3-域名服务器" class="headerlink" title="3.3 域名服务器"></a>3.3 域名服务器</h3><p>实现域名系统，需要靠分布在各地的域名服务器来实现。DNS服务器是有很多台的，而且还要根据树形结构的域名系统来进行一个层次的划分，也就是把DNS服务器也按照一个层次进行划分为几种不同类型的DNS服务器。</p><p>DNS服务器主要划分为如下的几类：</p><img src="https://pic.imgdb.cn/item/6641be3c0ea9cb1403b7c273.png" alt="计算机网络（六）——应用层——域名服务器.png"><p>本地服务器不属于这样的一个层次结构，但是本地服务器对域名系统又很重要，当一个主机发出DNS查询请求时，这个查询请求报文就会首先发给本地域名服务器。所以，本地域名服务器相对其余三种域名服务器而言，他是离主机最近的（一般不超过几个路由器的距离）。当一台主机要查询的另一台主机是和他属于同样的一个本地ISP时，本地域名服务器就可以立刻将所查询的主机名转换成IP地址，而不需要询问其他主机。所以有了本地域名服务器的存在，可以使整个查询过程变得更加简单快速。</p><p>当一个主机要访问一个网站时，就要先发送一个DNS查询请求，首先发给的是本地域名服务器。如果本地域名服务器的缓存中，不清楚这个主机所发送的DNS请求当中的IP地址和解析，就要先向根域名服务器求助。而**<font color=red>根域名服务器知道所有顶级域名的服务器对应的IP地址</font>**。</p><p>例如主机想访问<a href="http://www.badiu.com,就会先向本地服务器发送dns请求,但由于主机是第一次访问网站,所以本地域名服务器暂时不知道该网站对应的ip地址是多少,/">www.badiu.com，就会先向本地服务器发送DNS请求，但由于主机是第一次访问网站，所以本地域名服务器暂时不知道该网站对应的IP地址是多少，</a> 于是就会向根域名服务器请求帮助。而根域名服务器知道所有顶级域名的服务器对应的IP地址，所以根域名服务器看到这样的IP地址后，就会先看其顶级域名是谁，然后就会把这个顶级域名的IP地址告诉本地域名服务器，或继续向下查询，直到查询到详细的网站地址，再把该网站的IP地址告诉本地域名服务器。</p><p>补充：在因特网上一共会有13个不同IP地址的根域名服务器，它们的名字是用一个英文字母来命名的，从a一直到m，相应的域名就是a.rootservers.net（a可以换成a~m的任意一个字母）。但是要注意，这些根域名服务器并不是由13台主机所构成，这一个域名可以对应好几台主机（即几台主机共用一个域名）。</p><p>**<font color=red>顶级域名服务器负责管理该顶级域名服务器注册的所有二级域名</font>**。也就是说对于顶级域名服务器，他知道他分支的权限域名服务器的IP地址是多少。比如上面的例子，在找寻百度网站时，当根域名服务器找到com时，顶级域名服务器com就可以继续往下找baidu标号。这就找到了权限域名服务器。</p><p><strong><font color=red>权限域名服务器是一个区的域名服务器</font><strong>。区就是对DNS服务器的管辖范围进行了一个区分，它是DNS所实际管辖的一个范围。举个例子，比如说有一家公司叫abc，这个abc公司有两个下属部门分别是x，y。而这x部分下面又分了3个部门，分别是u，v，w；而y下面也有一个直属部门是t部门。如果abc公司只设一个区，也就是abc.com，abc及下面的所有部门都属于这个区。如果abc公司规模扩张了，就会划分两个区或多个区。假设现在abc扩张一个区是y.abc.com。那如何将原来的区进行划分呢？很简单，只需要将原来abc区里的y分支全部分出来充当y区域即可，换句话说，原来的abc区域里有x部门和y部门，但因为y部门要扩充为1个区，所以abc的区里只有x部门及其下属部门u、v、w，它们依然属于abc.com。而y部门被划分出来成为y.abc.com区，那么对应的y部门下的t部门也被划分到了y.abc.com区。到这里不难看出，虽然abc.com和y.abc.com分别对应两级域名和三级域名，但实际上他们俩是对等的两个区，它们都是com域名服务器下的一个分支。而这</strong>两个区对应两个权限域名服务器</strong>。</p><p>如果一个顶级域名服务器还不能够得到域名和IP地址的一个完整解析，就要继续往下请求到权限域名服务器，如果一个权限域名服务器还不能够给出最后的查询回答时，就会告诉发送查询请求的DNS客户，下一步应该找哪一个新的权限域名服务器。比如上例里查询到了abc.org，但实际要找的是y.abc.org，那么abc.org就会告诉DNS客户去找y.abc.org。</p><h3 id="3-4-域名解析过程"><a href="#3-4-域名解析过程" class="headerlink" title="3.4 域名解析过程"></a>3.4 域名解析过程</h3><p>接下来具体看一下域名解析的过程。</p><p>域名解析过程主要有两种类别，一个是递归查询，一个是迭代查询。</p><img src="https://pic.imgdb.cn/item/6641c8170ea9cb1403c736ff.png" alt="计算机网络（六）——应用层——DNS域名解析过程.png"><p>主机和本地域名服务器之间都是递归查询的方式，只不过根据其他服务器之间的查询方式不同，分为了递归和迭代。</p><p>递归查询，就是主机先查询本地域名服务器，如果查不到，本地域名服务器就会作为客户去查询根域名服务器，然后根域名服务器就会作为客户去查询顶级域名服务器，再然后顶级域名服务器就会作为客户去查询权限域名服务器。最终权限域名服务器就能找到对应的IP返回给主机。</p><p>迭代查询，据图也很容易理解，就是主机在本地域名服务器查不到，就会一直由本地域名服务器进行查询，本地域名服务器先查询根域名服务器，根域名服务器告诉本地域名服务器去查询哪个顶级域名服务器，本地域名服务器就会查询顶级域名服务器，像这样最终迭代到权限域名服务器，权限域名服务器告诉本地域名服务器网站IP地址，本地域名服务器再发送给主机。</p><p>可以发现，不论是上述哪一个方式，其过程都比较繁琐，要经历很多次查询，因此为了提高DNS查询效率，就引入了高速缓存。</p><p>高速缓存可以用来存放最近查过的域名已经从哪里获得域名映射信息的记录，比如说在迭代查询过程中，刚刚登录了百度的网站，也就是说实现了百度域名与IP地址的解析，那这个域名与IP地址的映射关系就存储在了本地域名服务器的高速缓存中，这时候要是再次访问百度网站，就会先搜索本地域名服务器的高速缓存中是否这么一个项，如果有这么一个项，就会把对应IP直接返回主机，而不需要经历接下来的迭代。如果这个本地域名服务器中并没有它对应的IP地址，但是有顶级域名服务器的IP地址，就可以直接查询顶级域名服务器获得下一步信息，而不用经历根域名服务器的查询。</p><p>通过高速缓存可以大大减轻域名服务器的负荷，同时也可以使DNS查询的请求和回答报文数量大大减少，可以加快DNS请求的速度。为了保证高速缓存所存内容的正确性，高速缓存就要定期更新，就是为每一项内容设置一个计时器，并且处理超过合理时间的项（**<font color=green>高速缓存能动态更新</font>**）。当然不只本地域名服务器里会高速缓存，许多主机里也有高速缓存，许多主机开机时，就会从本地域名服务器下载域名和主机对应的数据库并放到本机的高速缓存里。也就是说，访问一个网站，最先查的应该是本机的高速缓存，本机高速缓存没有，才会去查本地域名服务器的高速缓存。</p><h2 id="4-文件传输协议FTP"><a href="#4-文件传输协议FTP" class="headerlink" title="4. 文件传输协议FTP"></a>4. 文件传输协议FTP</h2><h3 id="4-1-文件传送协议"><a href="#4-1-文件传送协议" class="headerlink" title="4.1 文件传送协议"></a>4.1 文件传送协议</h3><p>文件传送协议有两种：文件传送协议FTP和简单文件传送协议TFTP。</p><p>TFTP是一个很小且易于实现的文件传送协议，它的优点是非常适用UDP环境。当需要将程序或文件同时向许多个机器下载时，就经常会用到TFTP。另外TFTP代码块所占内存比较小，对于一些比较小的计算机或某些用途的设备就比较重要了。因此TFTP是一个比较容易实现而且比较面向小文件的一种传送协议。</p><p>FTP是这部分的重点，最主机的是它提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力。也就是说文件传输时使用FTP协议，就可以屏蔽不同操作系统之间的差异。</p><p>接下来将重点介绍FTP协议。</p><h3 id="4-2-FTP服务器和用户端"><a href="#4-2-FTP服务器和用户端" class="headerlink" title="4.2 FTP服务器和用户端"></a>4.2 FTP服务器和用户端</h3><img src="https://pic.imgdb.cn/item/6641d34a0ea9cb1403dac897.png" alt="计算机网络（六）——应用层——FTP服务器和用户端.png"><p>FTP是基于C&#x2F;S的协议。客户和服务器是通过一个客户机程序联系在一起，用户通过一个客户机程序连接在远程计算机上运行的服务器程序。</p><p>连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端。</p><p>依照FTP协议提供服务，进行文件传送的计算机就是FTP服务器。</p><h3 id="4-3-FTP工作原理"><a href="#4-3-FTP工作原理" class="headerlink" title="4.3 FTP工作原理"></a>4.3 FTP工作原理</h3><img src="https://pic.imgdb.cn/item/6641d4320ea9cb1403dbdbc1.png" alt="计算机网络（六）——应用层——FTP工作原理.png"><p>前面说过FTP的客户和服务器是通过一个客户机程序联系在一起的，所以使用FTP的第一步是登录，在地址框中输入FTP的地址，就可以开始正式登陆FTP的服务器并进行文件传送。登陆要输入ftp的地址以及用户名和密码，有时候也可以采用匿名登录的方式（匿名登录可以参考上图的讲解注释）。</p><p>登陆以后就可以对文件进行操作，对文件操作其实就是在和服务器进行连接，通常使用TCP进行连接实现可靠传输。</p><p>FTP服务器可以有一个或多个，客户端也可以是一个或多个。而且一个FTP进程可以同时为多个进程提供服务。</p><p>FTP的进程主要分为两大部分，第一部分就是1个唯一的主进程，第二部分就是n个从属进程。</p><p>主进程的作用是负责接收新的请求，它的工作步骤首先是先要打开服务器的一个熟知端口21，这个端口打开后就可以使客户进程成功的连接上，接下来只需要等待客户进程发送一个连接请求，然后再进行数据的连接和传送。接下来就可以启动n个从属进程，每个从属进程都可以处理单个的客户请求。</p><p>接下来结合一个标准图示，再来详细看一下FTP的工作原理：</p><img src="https://pic.imgdb.cn/item/6641d9ff0ea9cb1403e6d252.png" alt="计算机网络（六）——应用层——FTP工作原理2.png"><p>上图中的两个圆柱就代表系统中正在工作的进程，图中的服务器会有两个从属进程，分别是控制进程和数据传送进程（图中展示的是这两个从属进程，但并不是只有他两，另外图中没有画主进程，也并不代表没有主进程，这里画成这样是方便介绍）。客户端这边除了数据传递进程和控制进程之外还有用户界面。</p><p>客户端和服务端的控制进程建立了一个TCP控制连接，数据传递进程建立了一个TCP数据连接。**<font color=red>控制连接在整个文件传送过程中会一直打开，而数据连接在发送完数据以后就会关闭。</font>**FTP客户发出的传送请求都要经过控制连接来发送给服务器端的控制进程。控制连接相当于传送前的一个准备步骤。而数据连接才是实际当中用于传送的连接。服务器端的控制进程在接收到客户端发来的传送请求以后，就创建这样一个数据传送进程，并建立数据连接。因此可以总结为控制连接传送请求，数据连接传送文件。</p><p>注意，FTP协议是一个比较复杂的协议，因为他可以使用多个端口号。可以看到在控制连接处使用端口号21，而在数据连接处，使用端口号20，因此可以看到控制连接和数据连接是分开的，所以也说FTP的控制信息是带外传送的。</p><p>补充一点，数据连接端口号不一定是20，是否为20与传输模式有关，传输模式主要有两种，一种是主动的传输模式，一种是被动的传输模式。如果是主动的，TCP数据连接端口就是20,；如果是被动的，TCP数据连接端口就是由服务器和客户端协商决定，通常该端口大于1024。</p><p>接下来看一下主动和被动这两种传输模式。</p><p>主动模式：当客户进程向服务器发送连接请求时，就要寻找连接服务器进程的数据端口也就是21号端口，同时也要告诉服务器自己进程的端口号码用于建立两个进程间的数据传送连接。接着，服务器端就会使用自己传送数据的这样一个数据端口也就是20号端口，与客户进程刚刚提供的端口号码建立数据传送连接，然后就可以正式传送文件了。</p><p>被动模式：被动模式的前半部分与主动模式一样，不同的是被动模式并不会主动去与客户端建立数据传送连接。当客户端与服务器端建立连接后，会发送一个请求命令，请求服务器端提供一个数据端口号，服务器端收到这个请求后就会返还一个大于1024的端口号码，作为被动方式下的数据连接的端口号，接下来只需要等待客户端来建立连接即可。</p><p>最后补充一个知识点，就是FTP的传输模式：FTP可以以文本模式和二进制模式传输数据。</p><h2 id="5-电子邮件"><a href="#5-电子邮件" class="headerlink" title="5. 电子邮件"></a>5. 电子邮件</h2><h3 id="5-1-电子邮件"><a href="#5-1-电子邮件" class="headerlink" title="5.1 电子邮件"></a>5.1 电子邮件</h3><img src="https://pic.imgdb.cn/item/664223f90ea9cb14034ccd30.png" alt="计算机网络（六）——应用层——电子邮件信息格式.png"><p>上图是我们常用的电子邮件的信息格式，对于电子邮件很多人都用过，这里再贴一下图片，可以更好的辅助学习本节。</p><h3 id="5-2-电子邮件系统的组成结构"><a href="#5-2-电子邮件系统的组成结构" class="headerlink" title="5.2 电子邮件系统的组成结构"></a>5.2 电子邮件系统的组成结构</h3><img src="https://pic.imgdb.cn/item/6642248a0ea9cb14034da03e.png" alt="计算机网络（六）——应用层——电子邮件组成结构.png"><p>电子邮件的组成结构有三部分，分别是用户代理、邮件服务器、协议。</p><p><strong>(1) 用户代理</strong></p><p>用户代理：用户代理就是用户和电子邮件系统的一个接口，通常情况下，用户代理就是运行在电脑当中的一个程序。所以说用户代理又可以称之为是电子邮件的客户端软件。用户代理可以为用户提供一个比较友好的接口，目前就是给用户一个窗口的界面，通过这个界面用户就可以写邮件，并且发邮件和接收邮件。可以使用的用户代理有Foxmail、Outlook等（这些都是具体的客户端软件，现在用的比较少）。</p><p>用户代理有四个功能：</p><ol><li>撰写。给用户提供一个编辑信件的环境。</li><li>显示。用户写完的信可以显示在屏幕上。而且可以看到收来的和发出去的信件内容。</li><li>处理。包括发送邮件和接收邮件，收件人可以根据不同的情况按照不同方式对信件进行处理。</li><li>通信。在写完邮件后，可以利用邮件的一些发送协议，来把邮件发送到所指定的一个邮件服务器当中。同时在接收方，收件人也可以从接收方的邮件服务器当中读取这个收到的邮件。</li></ol><p><strong>(2) 邮件服务器</strong></p><p>邮件服务器会保持24小时的不间断工作，并且它会有大容量的一个邮件信箱来容纳大量的信件。</p><p>邮件服务器的两个主要功能：</p><ol><li>发送和接收邮件。这个发送和接收与上面用户代理里的发送和接收不一样，用户代理的发送邮件是指把邮件从客户端发送给邮件服务器。而邮件服务器的发送邮件是指把邮件从邮件服务器发送到接收方的邮件服务器。接收邮件指的是接收方的邮件服务器来接收发送方邮件服务器传过来的邮件。</li><li>向发件人报告邮件传送结果。即告诉发件人发出的邮件是已经交付了还是被拒绝了等。</li></ol><p>邮件服务器采用客户和服务器的方式，每一个邮件服务器可以同时充当服务器或者是客户。</p><p><strong>(3) 协议</strong></p><p>协议主要包括两类，第一类协议主要以SMTP协议为主，这类协议用在把邮件发出去的情况。第二类协议主要以POP3或IMAP协议为主，这类协议用在接收邮件的情况。</p><p>了解了组成结构之后，就可以把这几个部分整合起来，形成一个电子邮件系统，接下来了解一下电子邮件系统的工作原理：</p><img src="https://pic.imgdb.cn/item/6642294e0ea9cb1403541c2e.png" alt="计算机网络（六）——应用层——电子邮件系统的工作原理.png"><p>工作原理如上图，发送方通过用户代理，把写好的邮件发送给这个发送端的邮件服务器，那就会把这个邮件放到服务器当中的邮件缓存里，如果现在可以发送出去，就会从邮件缓存当中取出信件。并且发送给接收端的邮件服务器。这两个过程都是发送邮件使用的都是SMTP协议。</p><p>接下来，邮件到了接收端的邮件服务器当中，就放入这个服务器的缓存里面，如果这个接收方他现在有时间来阅读邮件，它就会通过用户代理，并且使用POP3协议从接收端邮件服务器当中读取邮件。</p><p>为了保证邮件是可靠传输的，上面三段使用的都是TCP连接。接下来重点了解一下，这几个电子邮件的传送协议。</p><h3 id="5-3-简单邮件传送协议SMTP"><a href="#5-3-简单邮件传送协议SMTP" class="headerlink" title="5.3 简单邮件传送协议SMTP"></a>5.3 简单邮件传送协议SMTP</h3><img src="https://pic.imgdb.cn/item/66422ae40ea9cb140356fe4d.png" alt="计算机网络（六）——应用层——SMTP.png"><p>SMTP协议规定了两个相互通信的SMTP进程之间如何交换信息。</p><p>SMTP协议规定了14条命令（由几个字母组成）和21种应答信息（由三位数字代码+简单文字说明组成）来实现进程之间交换信息的方式。</p><p>SMTP协议建立于TCP之上，使用端口号为25，使用C&#x2F;S方式。</p><p>SMTP通过三个阶段实现通信：连接建立、邮件传送和连接释放。</p><p>接下来，逐一了解SMTP通信三阶段：</p><img src="https://pic.imgdb.cn/item/66422c7d0ea9cb14035a35b3.png" alt="计算机网络（六）——应用层——SMTP通信三阶段.png"><p>连接建立：发送方先写邮件，邮件写好就会发送给发送方的邮件服务器，放到发送方的邮件服务器的发送缓存里。发送方的邮件服务器每隔一定时间，就会对邮件缓存里的邮件进行一个扫描，如果发现有邮件，就要使用SMTP协议准备发送，并且使用熟知端口号25号与接收方的邮件服务器建立TCP连接。连接建立后，接收方的邮件服务器就要发出一个应答信息，也就是”220service ready”来告诉发送方服务就绪，已经可以准备接收了。然后SMTP客户（发送方）就会向SMTP服务（接收方）发送一个HELLO命令，并且会附上发送方的主机名，服务器现在如果有能力接收邮件，就会返回”250 OK”；如果没有能力接收邮件，就会返回”421 Service not available”。如果在一定时间内发不了邮件，邮件服务器就会把这个情况告诉给发件人。</p><p>邮件发送：假设用A和B分别表示发送方的邮件服务器和接收方的邮件服务器。首先，A发送一个”MAIL FROM：用户名”，意思是发送方的电子邮件地址，如果B准备好了就会返回”250 OK”，没有准备好也会返回数字加上英文的信息说明。A收到”250 OK”后就会发送多个RCPT命令，这个RCPT是收件人英文的缩写，RCPT可以有多个命令，因为RCPT表示发给谁，可以选择群发也可以选择发给一个人。每发送一个RCPT命令就会有一个相应的信息从B里返回。上图例子里给的是”RCPT RO: &lt;邮箱名&gt;”意思是把邮件发送给这个邮箱用户，SMTP服务端若有这个邮箱就会返回“250 OK”，若没有就会返回“550 No such user here”。接下来A发送DATA就表示要传输邮件，如上图，待B同意后，A就会开始发送邮件。在发送完毕后要返回&lt;CRLF&gt;.&lt;CRLF&gt;表示传输结束。</p><p>连接释放：邮件发完后，SMTP客户会发送OUT命令，SMTP服务收到后，会返回221，表示同意释放TCP连接。</p><h3 id="5-4-MIME"><a href="#5-4-MIME" class="headerlink" title="5.4 MIME"></a>5.4 MIME</h3><img src="https://pic.imgdb.cn/item/66422ccc0ea9cb14035aa7c4.png" alt="计算机网络（六）——应用层——MIME.png"><p>由于SMTP有上图所示的几个传输上的缺点，所以使用了通用因特网邮件扩充MIME。这个MIME可以理解成一个协议，或者说是在STMP协议上进行扩充的一种手段。工作原理也如上图所示，主要就是把不能被SMTP协议所识别的文件转换成能被SMTP识别的ASCLL码或者把SMTP协议使用的ASCLL转换成可供用户使用的文件。</p><h3 id="5-5-POP3"><a href="#5-5-POP3" class="headerlink" title="5.5 POP3"></a>5.5 POP3</h3><img src="https://pic.imgdb.cn/item/66422cf60ea9cb14035af117.png"><p>POP3就是第三版的POP协议，POP3协议只存在于从接收端的邮件服务器当中读取邮件交付给用户代理这个过程。</p><p>POP3也是建立在TCP连接之上，使用端口号110，是C&#x2F;S方式。</p><p>POP3的工作方式有两种，也就是接收方从服务器当中读取之后，对这个邮件的处理方式有两种：</p><ol><li>下载并保留。用户读取下载完邮件后，邮件仍然保留在接收端缓存中。</li><li>下载并删除。用户读取下载完邮件后，邮件会从接收端缓存中删除。</li></ol><h3 id="5-6-IMAP"><a href="#5-6-IMAP" class="headerlink" title="5.6 IMAP"></a>5.6 IMAP</h3><img src="https://pic.imgdb.cn/item/66422d1a0ea9cb14035b2815.png" alt="计算机网络（六）——应用层——IMAP.png"><p>POP3协议是一种非常简单，功能有限的一种邮件读取协议，因此就有一种新的读取邮件的协议——网际报文存取协议(IMAP)。</p><p>IMAP协议内容如上图，由于IMAP协议是在读取邮件当中所使用的协议，所以它的环节也是从接收端邮件服务器到用户代理这一块所使用的一种协议。</p><h3 id="5-7-基于万维网的电子邮件"><a href="#5-7-基于万维网的电子邮件" class="headerlink" title="5.7 基于万维网的电子邮件"></a>5.7 基于万维网的电子邮件</h3><img src="https://pic.imgdb.cn/item/66422d640ea9cb14035b93b8.png" alt="计算机网络（六）——应用层——基于万维网的电子邮件.png"><p>基于万维网的电子邮件是现在生活中普遍使用的一种发邮件的方式。</p><p>基于万维网的电子邮件就是使用浏览器来登录电子邮箱，然后再写一封电子邮件就可以发送出去。所以这种电子邮件特点就是非常方便。</p><p>注意一点，与前面不同的是，基于万维网的电子邮件与用户代理有关的两个协议SMTP和POP3全都变成了HTTP协议。</p><h2 id="6-万维网和HTTP协议"><a href="#6-万维网和HTTP协议" class="headerlink" title="6. 万维网和HTTP协议"></a>6. 万维网和HTTP协议</h2><h3 id="6-1-万维网的概述"><a href="#6-1-万维网的概述" class="headerlink" title="6.1 万维网的概述"></a>6.1 万维网的概述</h3><img src="https://pic.imgdb.cn/item/664235d50ea9cb140366bf0c.png" alt="计算机网络（六）——应用层——万维网的概述.png"><p>把全球所有的网站统一在一起，就称之为万维网。所以万维网当中存储着非常多的信息、资料和资源。</p><p>如果想获取万维网当中的资源，就需要通过<strong>统一资源定位符URL</strong>来获取。举个例子，如果某个资源的URL是1号，就可以通过在万维网上搜索1号来访问该资源。</p><p><strong>URL可以用来唯一标识资源</strong>。</p><p>URL的一般形式（URL不区分大小写）：&lt;协议&gt;:&#x2F;&#x2F;&lt;主机&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt; 其中协议常用的有http或ftp，主机就是域名或IP地址，端口就是提供访问接口的服务器端口，路径就是该资源在服务器文件里的相对路径，一般情况下端口和路径可以被省略掉。</p><p>用户通过点击超链接获取资源，这些资源通过超文本传输协议HTTP传送给使用者。这个过程就像服务器在为客户提供服务，所以万维网也是以C&#x2F;S方式来工作。</p><h3 id="6-2-超文本传输协议HTTP"><a href="#6-2-超文本传输协议HTTP" class="headerlink" title="6.2 超文本传输协议HTTP"></a>6.2 超文本传输协议HTTP</h3><img src="https://pic.imgdb.cn/item/664236080ea9cb140366fa5f.png" alt="计算机网络（六）——应用层——超文本传输协议HTTP.png"><p>简单来说，HTTP协议就是规定如何上网以及服务器如何提供请求资源的一个过程。上图中是这个过程的图示。</p><p>服务器当中运行着服务器的一些进程，每一个万维网的网点都会有一个服务器的进程，这个进程会不断监听TCP的80端口，以便发现有没有万维网的客户来请求服务，一旦服务器监听到了连接请求并且和客户间建立好了一个TCP连接后，浏览器就可以开始向万维网服务器发出浏览界面的请求了，也就是开始发送一个http的请求报文来请求相关的文档。服务器收到请求报文以后，就会把请求的资源以文档的形式放入这个http响应报文当中，返回给客户端。最后就可以释放TCP连接，并在客户机界面上显示出来。</p><p>用户浏览页面有两种方法，一是输入URL，二是点击超链接。不过不论是点击超链接还是输入URL，访问的本质都是通过URL获取资源。获取资源的具体过程如上图右所示。但要补充一点，最后一步浏览器显示时，浏览器可以只下载文本部分，比如进入网易音乐的网站，进入以后可以看到很多歌曲，但是现在他们不能播放，只有点击播放按钮以后，才能播放，这个点击播放按钮的本质其实就是再次循环了上图的八个步骤。所以浏览器可以不必把界面当中的所有资源全部下载下来，可以只先下载文本部分，至于之后要下载图像、声音。音频等可以通过鼠标点击进行下载获取。</p><img src="https://pic.imgdb.cn/item/6642364c0ea9cb1403675303.png" alt="计算机网络（六）——应用层——HTTP协议特点.png"><p>HTTP协议是无状态的，无状态指同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。也可以说HTTP协议是无记忆的。</p><p>但是在实际工作者，一些万维网站点常常希望能够识别用户，比如淘宝购物时，用户选中物品放入购物车，然后再选购其它物品时，淘宝就要记住用户身份，这样才可使用户接着选购的物品可以放入同一个购物车。为了应对这种需求，就诞生了cookie。</p><p>Cookie是存储在用户主机当中的一种文本文件，记录了一段时间内某用户的访问记录。而用户是通过识别码来标识，这个识别码通常是一连串的数字。因此用户访问的一些历史记录就可以存放在这样一个Cookie当中，这个Cookie就可以放入本地主机当中。所以在访问淘宝的时候，淘宝服务器就可以查看主机当中的记录淘宝搜索的一些历史记录的Cookie，就可以给用户提供一些更加个性化的更优质的服务。</p><p>HTTP采用TCP作为运输层协议，但HTTP协议本身是无连接的。因为通信双方在交换HTTP报文前是不需要建立HTTP连接的。</p><p>HTTP连接的方式有两种，分别是持久连接和非持久连接。在持久连接处还细分成了非流水线式的持久连接和流水线式的持久连接。</p><p>下面看一下具体的连接方式：</p><img src="https://pic.imgdb.cn/item/6642367e0ea9cb1403678f80.png" alt="计算机网络（六）——应用层——HTTP协议连接方式.png"><p>非持久连接：每个网页元素对象的传输都需要单独独立一个TCP连接。如上图左是非持久连接，首先客户要使用TCP和服务器建立连接，当三次握手的前两次完成之后，客户端就可以发送他的请求报文，作为三次握手的第三个部分的数据发给这个万维网的服务器。然后服务器收到请求后，就会返回给万维网的客户一个响应报文。另外，响应报文是有长度的，所以要经历一定时间才能收到完整的报文。所以非持久连接的耗时是2RTT+文档的传输时间。如果万维网客户要再发送一个HTTP请求，还需要再建立以个TCP连接。</p><p>持久连接：当万维网服务器在发送响应后仍然保持这条连接，使同一个客户和该服务器可以继续在这条TCP连接上传送后续的HTTP请求报文。如上图右是持久连接，它相对非持久做了一定的改善，当万维网客户要再发送一个HTTP请求时，不需要重新建立TCP连接，可以使用上一个连接继续发送。</p><p>当然持久连接还分成了非流水线式的持久连接和流水线式的持久连接，上面的例子可以看到是发了一个请求后才会返回给一个响应，等收到响应后，才能再发送一个新的请求，再收到响应，如果还想请求别的东西，只能在收到响应报文之后，才能请求，这就是非流水线式的持久连接。</p><p>而流水线式是可以连续发送的，比如主机有好久请求报文等待发送，那这就给报文就可以同时发送出去，服务器收到后会依次的返回响应的请求，因此使用流水线的方式，客户访问所有的对象，只需要花费大概一个RTT的时间，流水线方式就可以使TCP连接的空闲时间比较少，可以提高文档下载的一个效率。</p><p>下面看HTTP协议的报文结构：</p><img src="https://pic.imgdb.cn/item/664236b00ea9cb140367cda3.png" alt="计算机网络（六）——应用层——HTTP协议的报文结构.png"><p>在HTTP协议当中会使用两种报文，一种是HTTP的请求报文，一种是HTTP的响应报文。</p><p>HTTP报文的特点是面向文本的，因此在报文中的每一个字段都是一些ASCLL码串。可以结合两个报文的形式理解。</p><p>可以看到请求报文由请求行、首部行和请求报文组成。响应报文由状态行、首部行和响应报文组成。</p><p>两个报文的第一行都叫开始行，但他们也有区别，开始行用来区分请求报文和响应报文。可以看到，请求报文开始行由方法、URL、版本和CRLF(回车换行)组成。而响应报文由版本、状态码、短语和CRLF(回车换行)组成。</p><p>在请求报文中，方法字段就是一些命令，用来告诉对所请求的对象进行哪些操作，比如获取、删除等。URL就是标识符。版本则是使用什么版本的HTTP协议。回车换行则是必备的，相当于表示请求行的结束，首部行的开始。</p><p>接下来就是首部行，请求报文和响应报文的首部行一样，都是用来说明浏览器、服务器和报文主体的一些信息。这个首部行可以有很多行，但也可以不用。在每一个首部行当中都有一个首部字段名和它的值，并在每一行结束都有一个回车换行。而且在整个首部行的结束也会有一个回车换行，用来表示首部行的结束，实体主体的开始。</p><p>实体主体在请求报文当中通常是不用的，而在响应报文当中，也有些响应报文不用。</p><p>下面看一下一个具体的请求报文的例子：</p><img src="https://pic.imgdb.cn/item/664236fc0ea9cb140368363a.png" alt="计算机网络（六）——应用层——HTTP协议请求报文的例子.png"> <p>上面是一个浏览器发出的请求报文。</p><p>第一行就是请求报文的请求行，用的是GET命令。后面的index.html就是URL，版本就是HTTP&#x2F;1.1。</p><p>接下来的全是首部行的内容。Host：<a href="http://www.test.edu.cn指的就是现在要请求的html，它是存放于该网址上的。Connection：Close，指具体的连接方式是非持续连接。Cookie：123456，指的是用户的识别码是123456。如果出现Cookie，则说明这个用户曾经访问过这个网站。">www.test.edu.cn指的就是现在要请求的html，它是存放于该网址上的。Connection：Close，指具体的连接方式是非持续连接。Cookie：123456，指的是用户的识别码是123456。如果出现Cookie，则说明这个用户曾经访问过这个网站。</a></p><p>对于响应报文来说，它的版本就是HTTP的版本，通常是HTTP&#x2F;1.1。而状态码是由三个数字构成，一共有五种类型，如上图，但是具体来说一共只有33种状态码。状态码和短语的结合就说明了一个响应报文的特点。</p><p>这里补一个状态码与短语组合的例子：301 Moved Permanently。该段由状态码301和短语Moved Permanently组成，表示当前所请求网页已经转移到新的地址。所以在该段响应报文里的首部行处，就会添加一个转移地址告诉发送端要访问的网站原本地址已经转移到该新地址处，可以使用该新地址访问。</p><p>以上为第六章全部内容。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（五）——传输层</title>
      <link href="/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（五）——传输层"><a href="#计算机网络（五）——传输层" class="headerlink" title="计算机网络（五）——传输层"></a>计算机网络（五）——传输层</h1><h2 id="1-传输层提供的服务"><a href="#1-传输层提供的服务" class="headerlink" title="1. 传输层提供的服务"></a>1. 传输层提供的服务</h2><h3 id="1-1-传输层的功能"><a href="#1-1-传输层的功能" class="headerlink" title="1.1 传输层的功能"></a>1.1 传输层的功能</h3><img src="https://pic.imgdb.cn/item/663df4be0ea9cb1403cf19f9.png" alt="计算机网络（五）——传输层——传输层功能.png"><p>数据链路层提供连路上相邻节点之间的逻辑通信，网络层提供主机之间的逻辑通信。传输层位于网络层之上，应用层之下，它为允许在不同主机上的进程之间提供逻辑通信。</p><p>传输层的功能如上图。</p><h3 id="1-2-传输层的两个协议"><a href="#1-2-传输层的两个协议" class="headerlink" title="1.2 传输层的两个协议"></a>1.2 传输层的两个协议</h3><img src="https://pic.imgdb.cn/item/663df4cf0ea9cb1403cf335d.png" alt="计算机网络（五）——传输层——传输层的两个协议.png"><p>传输层提供两个传输协议，一个是面向连接的可靠传输协议TCP，另一个是无连接的不可靠传输协议UDP。</p><p>由于TCP需要建立连接，提供可靠通信，所以TCP适用于时延大，文件大的传输。</p><p>而UDP不需建立连接，提供的不是不可靠通信，所以UDP适用与时延小，文件小的传输，传输不成功就重新发送。</p><h3 id="1-3-传输层的寻址与端口"><a href="#1-3-传输层的寻址与端口" class="headerlink" title="1.3 传输层的寻址与端口"></a>1.3 传输层的寻址与端口</h3><img src="https://pic.imgdb.cn/item/663df5ad0ea9cb1403d09763.png" alt="计算机网络（五）——传输层——传输层的寻址与端口.png"><p>端口是传输层的服务访问点（SAP），标识主机中的应用进程，用来将报文段中数据分发给相应的进程。</p><p>注意，传输层的端口是逻辑端口（软件端口）要与路由器或交换机上直接被插入的物理端口区分开。</p><p>传输层的每一个端口都用端口号来标识，端口号只有本地意义，不同计算机的相同端口没有任何关系。即使是同一个进程，在不同主机上的端口号也可能不同。</p><p>端口号的长度为16bit，能表示2<sup>16</sup>即65536个不同端口号。</p><p>端口号根据其范围可以分为服务端使用的端口号和客户端使用的端口号。服务端端口号就是服务器使用的端口号。客户端就是使用服务器服务的客户的端口号。</p><p>服务端端口号又可分为熟知端口号和登记端口号。熟知端口号从0到1023，是给TCP&#x2F;IP最重要的一些应用程序，让所有用户都知道。登记端口号的范围是1024~49151，是给没有熟知端口号的应用程序使用的。</p><p>客户端端口号仅在客户进程运行时才动态选择，即只有客户端在使用时，才会分配一个端口号，是操作系统随机分配的，这个进程一旦结束，这个端口号就会被分给新的进程。所以客户端端口号是可以循环利用的。</p><p>下面补充一点，熟知端口号分配给给TCP&#x2F;IP最重要的一些应用程序，是固定不变的，因此要知道一些重要的应用程序的熟知端口号。如下图：</p><img src="https://pic.imgdb.cn/item/663df8fd0ea9cb1403d7c612.png" alt="计算机网络（五）——传输层——传输层的重要程序的熟知端口号.png"><p>最后说一下套接字，如上图，套接字就是主机IP地址和端口号的组合，根据IP可以找到主机，根据端口号可以找到进程，所以套接字唯一标识了网络中的一个主机和它上面的一个进程。</p><h2 id="2-UDP协议"><a href="#2-UDP协议" class="headerlink" title="2. UDP协议"></a>2. UDP协议</h2><h3 id="2-1-UDP概述"><a href="#2-1-UDP概述" class="headerlink" title="2.1 UDP概述"></a>2.1 UDP概述</h3><p>UDP只在IP数据报服务上增加了很少功能，即复用分用和差错检测功能。</p><img src="https://pic.imgdb.cn/item/663e161b0ea9cb140317098e.png" alt="计算机网络（五）——传输层——UDP概述.png"><p>UDP协议使用最大努力交付，即不保证可靠交付，现在知道网络层是不可靠交付，如果传输层使用UDP也是不可靠交付，那可靠交付就要由应用层来保证。</p><p>UDP是面向报文的，意思是UDP对应用层交下来的报文是既不合并也不拆分的，应用层给UDP多长的报文，UDP就在前面添加一个UDP首部，然后直接发送。因此应用层报文就要选择一个大小比较合适的报文。如果报文太长，UDP封装以后交给网络层，因为链路层有MTU的要求，所以网络层要分片，这样就使网络层效率降低；如果应用层报文过小，当把报文传输的网络层，这个数据报文相比于IP首部就要少很多，这样也会降低网络层效率。综上所述，应用层报文长度应当适当，而使用UDP协议是不可靠交付，数据易丢失，所以在适当的基础上，不要传输太多，否则损失会较大。所以UDP适合一次性传输少量数据的网络应用。</p><p>UDP是无拥塞控制的，也就意味着网络即使再拥塞，UDP也不会让发送方速率放缓。正因如此，UDP很适合一些实时性应用，这些实时应用（不允许有太大延迟）就要求原主机用比较恒定的速率发送数据，并且也允许在网络拥塞的情况下丢弃这些数据。比如开视频会议，人数很多可能会导致网络拥塞问题，但使用UDP协议，主持人的说话、视频等数据就会恒定传输，这样每个人都会实时收到数据，如果人数过多，参会者接收到主持人的视频等数据出现丢失也是可以接受的。当然如果拥塞特别严重，也会有补救的措施，比如向前纠错或重传丢失报文等。</p><p>UDP功能要求不多，所以首部只有8B，而TCP是20B。</p><h3 id="2-2-UDP首部格式"><a href="#2-2-UDP首部格式" class="headerlink" title="2.2 UDP首部格式"></a>2.2 UDP首部格式</h3><img src="https://pic.imgdb.cn/item/663e1a290ea9cb14031e9dbb.png" alt="计算机网络（五）——传输层——UDP首部格式.png"><p>如上图UDP首部有8字节，分别是2B的源端口号，2B的目的端口号，2B的UDP长度，2B的UDP校验和。</p><p>源端口号可有可无，如果发送方需要接收方返回确认信息，则要填上自己的源端口号。如果发送方不需要接收方返还确认信息，则可以不填自己的源端口号。</p><p>UDP的长度字段填的是整个UDP用户数据报的长度，即首部+数据。</p><p>UDP检验和用来检测整个UDP数据报是否有错，错就要丢弃。</p><h3 id="2-3-UDP的检验和"><a href="#2-3-UDP的检验和" class="headerlink" title="2.3 UDP的检验和"></a>2.3 UDP的检验和</h3><p>首先，看一下伪首部的概念，如下图：</p><img src="https://pic.imgdb.cn/item/663e1b580ea9cb140322214b.png" alt="计算机网络（五）——传输层——UDP伪首部.png"><p>类似于IP的数据报首部，UDP在进行校验时，会在UDP数据报前面添加一个12B的伪首部，当校验完以后，会删除该首部。注意，伪首部只有在校验时才会添加，校验完就会删除，并不会对数据报产生其它影响。</p><p>伪首部由<strong>4B的源IP地址</strong>，<strong>4B的目的IP地址</strong>，<strong>1B的固定0</strong>（如上图第三个字段，该字段固定为全0），<strong>1B的协议字段</strong>（如上图协议字段的17，表示封装报文的协议是UDP协议），<strong>2B的UDP长度</strong>（该长度包括首部8B和数据部分长度，但不包括伪首部）。</p><p>接下来看一下如何用伪首部进行UDP校验。</p><img src="https://pic.imgdb.cn/item/663e1d1d0ea9cb1403261b20.png" alt="计算机网络（五）——传输层——UDP校验.png"><p>在发送端，UDP要把全0放入检验和字段并添加伪首部，然后把UDP数据（伪首部+首部+数据部分）视为许多16位的字串接起来（这里上图给错了，不应该是4B，应该是2B），然后按二进制反码形式，对这些数据求和，当然也可能出现数据部分最后不足16位的情况，所以在求和前要判断数据部分是否是2B的倍数，若不是则补0凑够2B的倍数。最后对求和所得数据进行求反码，所得结果就是校验和，然后去掉首部，并将所求结果填入校验和字段即可。</p><p>在接收端，同理，添加伪首部，进行二进制反码求和，若数据无错误，最后结果应全为1，若不是全1，则出错，传输层可选择丢弃或将数据报传输给上层并将错误信息一并交付给应用层，由应用层处理。</p><p>注意，在接收端添加伪首部即可，不需要将校验和字段改为0，保留接收到的数据信息即可。用大白话来说，对于接收到的数据，接收端只需要添加伪首部和对数据长度不够的补0，其余的保持不变即可。</p><h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3. TCP"></a>3. TCP</h2><h3 id="3-1-TCP协议特点"><a href="#3-1-TCP协议特点" class="headerlink" title="3.1 TCP协议特点"></a>3.1 TCP协议特点</h3><img src="https://pic.imgdb.cn/item/663e2f400ea9cb140353faa0.png" alt="计算机网络（五）——传输层——TCP协议特点.png"><p>应用程序在使用TCP协议前，必须要建立好一个TCP连接，并在数据传输完毕以后，再释放这个连接。而上图第一点说是虚连接的原因在于它并不是一个实际的物理连接，因为实际上这个连接过程应该是把这个数据报加上各个层次的首部之后，放到链路上传输，然后到接收端进行解封装，这是一个完整的物理连接。但TCP的使用，就好像两个进程之间建立了一个点对点的连接，好像是进程与进程直接连在一起，所以说是虚连接。</p><p>TCP连接只能有两个端点，所以TCP是无法用于广播以及多播的通信方式。</p><p>TCP是面向字节流的，流指的是流入进程或从进程流出的字节序列。面向字节流的含义就是，虽然应用进程和TCP交互是一次发送一个数据块，但这个数据块大小可以是不一样的，但是TCP会把应用程序交下来的数据看程是一连串的无结构的字节流。</p><p>面向字节流的理解有问题的话，可以结合下面的例子看一下：</p><img src="https://pic.imgdb.cn/item/663e31820ea9cb1403592ae8.png" alt="计算机网络（五）——传输层——TCP的字节流.png"><p>如上图，假如发送方要发送一个文件，它会把文件按照字节进行排序编号。在发送时，会把这些字节放入TCP缓存中，这是传输层做的事情。上图是把第一个字节到第十个字节放入缓存等待发送，现在如果开始发送，可能取的是123字节组成一个TCP报文段，然后在报文段上加上TCP头部，形成一个完整报文段，放到链路上传输，当然后面字节个数不固定，受多种因素影响。到这里，就可以看到，TCP是面向字节的或者说是面向字节流的。</p><h3 id="3-2-TCP报文段"><a href="#3-2-TCP报文段" class="headerlink" title="3.2 TCP报文段"></a>3.2 TCP报文段</h3><img src="https://pic.imgdb.cn/item/663e33460ea9cb14035cb2ac.png" alt="计算机网络（五）——传输层——TCP报文段1.png"><p>上图是TCP报文段首部里对序号、确认号和数据偏移的解释。</p><p>序号，指本报文段第一个字节的序号。例如，本报文段包含字节序号1,2,3，那首部的序号字段内容就为1。</p><p>确认号，由于是面向连接的，接收端在接收到发送端的报文段以后，要回复一个确认报文段，这个确认报文段里有确认号字段，表示希望收到对方下一个报文段的第一个数据字节的序号，如果之前收到报文段123，此时确认号字段的值就应该是4。</p><p>数据偏移，该字段以4B为单位，表示数据部分的起始处距离TCP报文段的起始处有多远，由于TCP首部还包含不确定的选项和填充字段，所以需要通过数据偏移的值来确定数据部份的起始位置。如果数据部分从100B开始，那数据偏移字段所填值就应该是100&#x2F;4&#x3D;25。</p><img src="https://pic.imgdb.cn/item/663e33790ea9cb14035d158d.png" alt="计算机网络（五）——传输层——TCP报文段2.png"><p>上图是对TCP报文段首部的6个控制位的介绍。</p><p>紧急位URG：当URG&#x3D;1时，标明此报文段里有紧急数据，那么该报文段可以不用经历缓存的等待，直接发送该报文段。</p><p>确认为ACK：当连接建立后，所有传送的报文段都必须把ACK置为1。</p><p>推送位PSH：当PSH&#x3D;1时，意味着发送方希望该报文段可以尽快被接收方的进程接收，此时接收方接收到报文段，发现PSH&#x3D;1，就会优先交付该报文段到对应的进程。</p><p>复位RST：当TCP连接中出现严重错误，需要释放并重新连接，发送方就会发送RST&#x3D;1的报文段，表示重新连接。</p><p>同步位SYN：当客户端和服务端互相发送连接请求和连接接收报文时，就会将SYN置为1。</p><p>终止位FIN：当FIN&#x3D;1，则表示此报文段发送方数据已发完，要求释放连接。</p><img src="https://pic.imgdb.cn/item/663e33af0ea9cb14035d76f5.png" alt="计算机网络（五）——传输层——TCP报文段3.png"><p>上图是对TCP报文段首部格式剩下的几个字段的介绍。</p><p>窗口，指现在允许对方发送的数据量。例如，接收方返还确认报文段信息时，返回确认号701，窗口1000，这意味着期望发送方的下一个报文段的第一个数据字节编号为701，而且最多只能够发送1000个字节数据。</p><p>检验和，同UDP一样，用做差错检测。</p><p>紧急指针，只有当URG&#x3D;1时，紧急指针才有效，指出本报文段中紧急数据的字节数。当紧急指针为50时，意味着数据部分的前50个字节是紧急数据。</p><p>选项，里面包含一些别的特殊功能，可以有也可以没有。</p><p>填充，由于TCP报文段首部希望为4B的倍数，但是选型字段的长度不确定，所以当加上选项字段的报文首部不是4B的倍数时，剩下的部分将会由填充字段补充，一般填充段全部填0。</p><h3 id="3-3-TCP连接管理"><a href="#3-3-TCP连接管理" class="headerlink" title="3.3 TCP连接管理"></a>3.3 TCP连接管理</h3><p>这部分比较重要，建议重点学习。</p><p>TCP连接传输要经历三个阶段，如下图：</p><img src="https://pic.imgdb.cn/item/663e36a70ea9cb140363f003.png" alt="计算机网络（五）——传输层——TCP连接三个阶段.png"><p>在TCP连接里，虽然连接两方的名称不同，一个叫客户，一个叫服务，但是两者都可以发送数据，是全双工通信。</p><p>下面看一下TCP的连接如何建立，即三次握手：</p><img src="https://pic.imgdb.cn/item/663e36f70ea9cb1403647de5.png"><p>上图是TCP的连接建立，要注意三次握手中，每一次握手里关键变量的赋值改变。</p><p>第一次握手，令SYN&#x3D;1，代表这是一个连接请求报文，同时seq&#x3D;x，这里的seq就是序号，该序号由主机随机产生，可以从1开始，也可以从任意一个随机数开始。至于确认号ACK，在这里是无效的，因为客户端没有收到服务端发送来的报文段，则客户端不知道自己接下来该期待什么，所以确认号是无意义的。</p><p>第二次握手，服务器收到客户端的申请报文，服务器返回确认报文段，同时为该TCP链接分配缓存和变量。这里SYN同样为1，但确认控制位ACK开始发挥作用，所以ACK&#x3D;1，这时ack确认号字段也就开始生效，ack&#x3D;y+1，表示期待对方接下来发送的第一个字节序号。同样，对于确认信号，主机也随机分配一个确认序号y。</p><p>第三次握手，客户端收到服务端的确认报文，要返回一个确认的确认。同时还要为该TCP链接分配缓存和变量。与前两次握手不同的是，这次握手已经可以携带数据。此次握手已经不是发送连接请求，所以SYN&#x3D;0，ACK仍为1。此次握手，发送方已经知道了服务器发送过来的序号，所以他就知道接下来应该期待哪个序号对应的就是ack&#x3D;y+1，seq&#x3D;x+1。</p><p>对于TCP的连接建立，可以知道，第二次和第三次握手，客户端和服务端分别为TCP连接分配了缓存和变量，这样可能会出现下图的SYN洪泛攻击：</p><img src="https://pic.imgdb.cn/item/663e37270ea9cb140364cf60.png" alt="计算机网络（五）——传输层——TCP的SYN洪泛攻击.png"><p>预防SYN洪泛攻击的方法通常是设置SYN cookie（非考点，有兴趣可以自己去找资料）。</p><p>接下来看一下TCP的连接释放：</p><img src="https://pic.imgdb.cn/item/663e37a40ea9cb140365e338.png" alt="计算机网络（五）——传输层——TCP的连接释放.png"><p>TCP连接释放要经历四次握手。</p><p>第一次握手，客户端发送连接释放报文段，主动关闭TCP连接，这个时候要令FIN&#x3D;1，seq指的也是报文段第一个字节的序号，由于这个报文段通常是没数据的，所以这个序号也可以来标识这个报文段。</p><p>第二次握手，服务器收到来自客户端的连接释放请求，服务器就会返回一个释放确认。这时候客户端到服务端的连接就释放了，但这只是个半释放，因为客户停止向服务发送数据，但服务依然可以向客户发送数据。这个时候ACK&#x3D;1，seq&#x3D;v（取决上一个发送的报文段，这里v表示上一个发送的报文段里最后一个字节序号为v-1），确认号ack&#x3D;u+1（返回的是对上一个报文段的期待）。</p><p>第三次握手，服务器经历第二次握手以后，如果还有未发完的数据就继续发送数据，待发完数据会进行第三次握手。如果没有数据就会直接进行第三次握手。这时服务端主动关闭TCP连接，FIN&#x3D;1，ACK&#x3D;1，seq&#x3D;w（w取决于第二次握手以后，服务器发送的数据量，如果没有发送w&#x3D;v），ack&#x3D;u+1（这里第三次握手与第二次握手的ack一样，是因为这段时间内客户端没有发送数据）。</p><p>第四次握手，主机收到服务端的释放报文段，接下来要进行一个回复确认，确认以后，连接还没有结束，要等待2MSL后才可彻底关闭TCP连接。要等待2MSL的原因是，如果客户端发送的确认报文丢失，则在2MSL内，客户端会收到服务端重传的连接释放报文段，客户端要重新确认并刷新计时。如果2MSL内没收到，则说明服务端收到确认报文段，才可顺利释放。</p><h3 id="3-4-TCP可靠传输"><a href="#3-4-TCP可靠传输" class="headerlink" title="3.4 TCP可靠传输"></a>3.4 TCP可靠传输</h3><p>在前面我们学过，网络层提供尽最大努力交付，不保证可靠传输，所以在网络层之上要保证可靠传输，而在传输层可以通过TCP实现可靠传输。所谓可靠，就是保证接收方进程从缓存区读出的字节流与发送方发出的字节流是一样的。</p><p>TCP实现可靠传输的机制：</p><ol><li>校验</li><li>序号</li><li>确认</li><li>重传</li></ol><p>其中TCP的校验机制与UDP一样，所以这里不说了，接下来重点看其它三个。</p><h4 id="3-4-1-序号"><a href="#3-4-1-序号" class="headerlink" title="3.4.1 序号"></a>3.4.1 序号</h4><p>序号就是TCP对文件的字节编号，这个前面已经说过，在这里再说一下两个重点。</p><p><strong>在TCP协议中，一个字节占一个序号。</strong></p><p><strong>序号字段指的是一个报文段第一个字节的序号</strong>。</p><h4 id="3-4-2-确认"><a href="#3-4-2-确认" class="headerlink" title="3.4.2 确认"></a>3.4.2 确认</h4><p>接下来结合一个例子，了解确认的过程：</p><img src="https://pic.imgdb.cn/item/663f7b8a0ea9cb14037263b9.png" alt="计算机网络（五）——传输层——确认.png"><p>发送方给接收方发送第一个报文段，就是1、2、3三个字节构成的报文段。发过去以后，接收方就收到了，并存储在自己的接收缓存中，然后再找个时间，把缓存中的该报文段提交给应用层。</p><p>注意，发送方发送完第一个报文段以后，并不是立即把该报文段删除，因为网络可能会产生问题，导致报文段丢失，这时接收方要重传，直到接收方返回一个确认报文段才会将第一个报文段删除。</p><p>在TCP协议里，接收方接收到报文段以后，会返回确认报文段，这个报文段采用累计确认的方式。另外，当接收方有数据要发送时，也可以通过确认报文段一起发送。</p><p>在上图例子里，假设接收方返回的就是一个不带数据的确认报文段，报文段首部确认号应该为4。发送方收到以后，就知道自己发送的1,2,3三个字节已经被接收，这时候就会把缓存中的1,2,3删去。</p><p>接下来，发送方继续发送，发送4,5,6和7,8这两个报文段，这个时候假设4,5,6的报文段丢失，接收方只收到7,8的报文段。如下图，这时候接收方会使用什么方式来保证可靠传输？</p><img src="https://pic.imgdb.cn/item/663f80480ea9cb14037b8b9d.png" alt="计算机网络（五）——传输层——确认重传.png"><p>接收方会使用累计确认的方式来保护传输，所谓累积确认就是TCP只确认这个数据流当中至第一个丢失为止的字节。如上图，虽然收到7,8报文段，但因4,5,6没到，接收方返回的确认报文的首部的确认号字段仍然是4，虽然7,8的报文段会正常接收，但还会一直告诉发送方需要发送序号4为开头的报文段。接收方收到该字段以后，就会判定4,5,6没到达，继而重传该报文段。接收方收到以后，发现自己已经有了1,2,3,4,5,6,7,8，所以接收方接下来会返回首部序号字段为9的报文段。</p><p>到这里，我们已经开始接触到重传的部分，接下来具体看一下TCP的重传机制。</p><h4 id="3-4-3-重传"><a href="#3-4-3-重传" class="headerlink" title="3.4.3 重传"></a>3.4.3 重传</h4><img src="https://pic.imgdb.cn/item/6640508d0ea9cb1403b37fac.png" alt="计算机网络（五）——传输层——重传.png"><p>在**<font color=red>规定时间</font><strong>内，TCP发送方没有收到接收方的确认报文段，就要重传已发送的报文段，这就是常说的超时重传，这个</strong>规定时间也叫<font color=red>重传时间</font>**。这个重传时间的规定要相对复杂一些，因为TCP下层是一个互联网环境，发送的报文段可能只经历一个高速率的局域网，也可能经历许多低速率的网络，而且每一个IP数据报选择的路由也各不相同，这取决于当时的网络情况，这就导致对于一个发送方，他所发送的很多个报文段所走的路径不一样，所花的时间也不一样。如果把重传时间设置的过短的话，就会引起很多报文段不必要的重传，因为不同报文段传播时间不一样，如果传播时间过短，那些传播时间较长的报文段还没到接收端，就要再次重传，这样就会使网络负荷大大增大；如果把重传时间设置的过长，就会使网络空闲时间增大，降低传输效率。</p><p>对于传输层TCP重传时间的设置，TCP协议采用了自适应的算法，动态的改变重传时间RTTs（RTT表示往返时间，加了s表示加权平均往返时间）。比如，在发送第一个报文段时，RTTs取得就是第一个报文段的RTT（从第一个报文段发送到接收到第一个报文段的确认时间就是第一个报文段的RTT）。接下来在发送第二个报文段时，同样，第二个报文段也有一个RTT，这时就会根据第一个和第二个RTT算出一个RTTs，算作第二个报文段的重传时间。同理，第三个报文段会结合第二个第一个和自己的RTT算出一个RTTs，当做自己的重传时间。使用这样一个自适应算法就可以照顾到每一个报文段，使重传时间既不会太长也不会太短。注，这部分的计算过程不需要掌握，只需要知道这么一个原理就可以。</p><p>根据超时重传的过程可以发现一个问题，这个超时重传要一直在超时重传的时间内等待，等到过了这个时间还没有收到确认，才会超时重传，这个等的时间可能会有点久，所以可以采用下图的冗余ACK的方式，在等待时间到达之前，就知道发送方有没有丢失报文段，然后尽快重传。</p><img src="https://pic.imgdb.cn/item/664050970ea9cb1403b38cee.png" alt="计算机网络（五）——传输层——快速重传.png"><p>冗余ACK的原理就是每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。</p><p>上图给出了一个冗余ACK的例子，发送方发送1,2,3,4,5一个5个报文段，接收方收到报文段1后，返回确认号2，但是第二个报文段丢失，也就意味着，从第2个报文段往后的3,4,5报文段收到的确认报文段的确认号都是2，相当于发送方收到3个对于报文段1的冗余ACK，这时发送方就可以认为报文段2丢失，需要重传2号报文段。像这样的技术通常称之为快速重传技术。</p><p>至此，TCP可靠传输的机制内容就结束了，但正常来说，还要学习TCP的发送缓存和发送窗口，接收缓冲和接收串口，而且还要学习发送过程的一些使用协议，比如停等协议、GBN协议、SR协议等，但这些东西在链路层已经讲过，这些协议在传输层的使用与在链路层的使用大同小异，基本上差不多。所以可以在上面的例子里看到发送方可以连续发送好几个报文段，不需要等2号的确认信号到了以后才能发送3号报文段，也就是说TCP是不常使用停等协议的，它通常使用GBN或SR协议，来一次性发送多个报文段，然后接收方可以使用累积确认方式发送返还确认信号。</p><p>由于上面所说的这些协议内容在链路层已经说过，所以在传输层不过多叙述，但可以自己结合链路层复习一下。接下里说一下TCP的两个重要考点，拥塞控制和流量控制。</p><h3 id="3-5-TCP的流量控制"><a href="#3-5-TCP的流量控制" class="headerlink" title="3.5 TCP的流量控制"></a>3.5 TCP的流量控制</h3><img src="https://pic.imgdb.cn/item/664059f90ea9cb1403c1329b.png" alt="计算机网络（五）——传输层——TCP流量控制.png"><p>在发送数据时，我们都会希望发送速率可以更快一些，但是如果发送速率过快，就会使接收方来不及接收，这样就会导致严重的丢包现象，所以才需要有流量控制。</p><p><strong><font color=green>TCP协议使用滑动窗口协议来实现流量控制。</font><strong>TCP使用滑动窗口的机制和链路层滑动窗口的机制非常类似。在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小。接收方动态调整发送方窗口大小是通过设置确认报文段的窗口字段来将接收窗口rwnd通知给发送方。发送方根据接收方传来的消息与拥塞窗口（拥塞窗口在3.6TCP的拥塞控制里介绍）比较，进而动态调整自己发送窗口的大小。</strong>发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</strong></p><p>上图下给出了一个例子来帮助了解TCP流量控制，在rwnd永远小于cwnd，即不考虑拥塞窗口的情况下，假设在建立连接时，接收方返还发送方的报文段里窗口字段值为6，发送端就会设置自己的发送窗口为6，注意一点，发送窗口大小并不一定一直为6，它的大小是可以动态变化的，这都取决于接收方返还的报文段的窗口字段大小，接收方就是通过这个窗口字段大小，来间接控制了发送方的发送速率。</p><p>当然接收方发送的报文段里的窗口字段值也可以是0，这个时候发送方就没有办法把数据发给接收方。此时接收方做的事情就是把接受缓存里的数据上交给上层的应用层，进行一个数据处理的过程，直到处理一部分或全部处理结束，接收方又会返还给发送方一个报文段，并且把窗口字段设置为接收方可以接受的大小，意味着发送方可以接着发送字段。</p><p>接下来看一个例子：</p><img src="https://pic.imgdb.cn/item/664061070ea9cb1403d05617.png" alt="计算机网络（五）——传输层——TCP流量控制案例.png"><p>如上图，假设有两个主机A和B，发送方是A，接收方是B。在发送数据时采用TCP协议，因此需要先建立连接，在建立连接时，B会告诉A自己的接收窗口为400B，设每一个报文段大小为100B，报文段初始序号值为1。</p><p>接下来，看一下具体发送过程，首先主机A给主机B发送一个报文段，这个报文段从序号1开始，长度为100B，接下里A主机还能发送300B。然后A继续发送第二个报文段从101<del>200，此时还剩200B的发送窗口。接下来，A发送第三个报文段，从201</del>300，但这个报文段丢失了。接下来B发送确认报文，确认报文里的ack确认号是201，表示201之前的数据已经被正确接收，这里要注意的是，由于TCP并不是停等协议，也就是并不是发送一个报文段，必须收到确认才能发送下一个报文段，而是可以连续发送几个报文段，并且接收方采用累计确认的机制把之前全部按序收到的完整的报文段，用一个确认报文段来进行回复确认。</p><p>上例里，201报文段丢失，接收方返回确认报文段里ACK&#x3D;1，ack&#x3D;201，rwnd&#x3D;300，也就是说发送方还可以发送从201<del>500三个报文段，接下来，由于发送方已经发送过201报文段，但是该报文段丢失，发送方并不清楚，然而发送方收到了前两个报文段的确认报文，于是发送方会删除前两个报文缓存，将将缓存窗口覆盖到201</del>500，因为201<del>300已经发过，于是发送方只发送301</del>400,401<del>500两个报文段，此时发送窗口已满，所以发送方要等待接收方的确认报文，在等待期间，发送方不能再发送数据报文。在等待期间，发送方的201</del>300字段的超时重传时间到了，此时发送方A判定B没有收到201<del>300报文段，于是要重新发送201</del>300的报文段。</p><p>接下来主机B返还一个确认信号ack&#x3D;501，rwnd&#x3D;100，意味着主机B成功收到501之前的序号字节，然后希望A再发送501<del>600的报文段。接下来A继续发送501</del>600的报文段，发送窗口再一次充满且没有收到确认报文，则A不能再继续发送。</p><p>接下来主机B又一次返还确认报文，报文里ACK&#x3D;1，ack-6901，rwnd&#x3D;0，意味着601之前的数据全部收到且不允许A再发送报文段。A收到以后，会知道B收到到600为止的数据，且此时没有接收窗口，自己不能再发送数据报文段。这种状态会一直持续到主机B重新发送一个新的窗口值为止，也就是说B主机把接收缓存的一部分数据交付处理以后，才会给A一个报文段里窗口值非0的可以让A继续发送数据的报文段。</p><p>注意，B发送给A的窗口值非0的可以让A继续发送数据的报文段有可能在传输过程中丢失，那么A就会一直处于等待状态，一直等待B发来一个非0窗口的通知，但B由于已经发送了非0通知，也会一直等待A发送数据。如果没有其它措施，A和B就会一直处于相互等待状态（类似于操作系统里的死锁），所以需要采取措施应对这种局面。</p><p>为了应付这种局面，TCP会为每一个连接设有一个持续计时器，只要TCP连接的一方收到对方的零窗口通知，就会启动计时器。若持续计时器设置的时间到期，发送方就发送一个零窗口的探测报文段，接收方收到探测报文段时给出现在的窗口值。若窗口仍然是0，那么发送方就要重新设置持续计时器。</p><h3 id="3-6-TCP的拥塞控制"><a href="#3-6-TCP的拥塞控制" class="headerlink" title="3.6 TCP的拥塞控制"></a>3.6 TCP的拥塞控制</h3><h4 id="3-6-1-拥塞控制基础"><a href="#3-6-1-拥塞控制基础" class="headerlink" title="3.6.1 拥塞控制基础"></a>3.6.1 拥塞控制基础</h4><img src="https://pic.imgdb.cn/item/6640710f0ea9cb1403eaa3de.png" alt="计算机网络（五）——传输层——TCP拥塞控制.png"><p>拥塞就是网络状况不好，网络发生堵塞，导致接收数据和发送数据的速度都降低。</p><p>出现拥塞的原因是对资源需求的总和大于可用资源。这里的资源主要指的是网络当中的一些链路容量，比如说带宽等。如果在某段时间对网络当中某个资源的需求总和，超过这个资源可以提供的可用部分，那么网络性能自然就会变坏，因此就会有许多资源同时呈现供应不足的情况，就会使得网络吞吐量将随输入负荷增大而下降，也就是越多人使用这个网络，这个网络也就越来越瘫痪，性能越来越差。</p><p>拥塞控制的目的就是防止过多的数据注入到网络中。</p><p>注意区分拥塞控制和流量控制，拥塞控制是从全局性看的发送方和接收方，流量控制是点对点的发送方与接收方。拥塞控制控制的是全局的网络资源，通过协调使用网络的各主机来防止有过多数据注入网络当中，进而可以减轻网络的堵塞情况。</p><p>如上图左下，是一个接收方对应多个发送方的示意图，这些发送方都要给接收方发送一个数据，假设发送方都要同时使用网络上的资源，就会使得网络非常繁忙，甚至出现拥塞的情况，此时接收方就会察觉这样的拥塞情况，但是他并不知道这种拥塞情况具体是哪一台主机或哪几台主机发送数据过快或过多所造成。而流量控制示意图如右下的点对点模型，如果接收方来不及接收数据，此时接收方是知道该找谁的。</p><p>总结一下，拥塞控制是全局性问题，而流量控制是点对点的问题。拥塞控制是因为网络发生堵塞，导致很多发送方发送来的数据迟迟到不了接收方；而流量控制是发送方发送速率过快，导致接收方接收缓存不够（来不及接收）。</p><h4 id="3-6-2-拥塞控制四种算法"><a href="#3-6-2-拥塞控制四种算法" class="headerlink" title="3.6.2 拥塞控制四种算法"></a>3.6.2 拥塞控制四种算法</h4><img src="https://pic.imgdb.cn/item/6640713c0ea9cb1403eae025.png" alt="计算机网络（五）——传输层——TCP拥塞控制四种算法.png"><p>拥塞控制有四种算法，如上图，分别是慢开始、拥塞避免、快重传、快恢复。正常情况下，慢开始和拥塞避免放到一起使用户，快重传和快恢复放到一起使用。</p><p>在研究这种四种算法之前，首先要假定几个条件：</p><p>第一个条件，数据是单方向传送，而另一个方向只传送确认。（TCP是全双工通信，所以是可以双方互相通信的，但这要假定主要是为了接下来的研究方便。）</p><p>第二个条件，就是接收方有足够大的缓存空间，即接收方的接收窗口大于拥塞窗口。这个时候发送窗口的大小取决于拥塞窗口大小。</p><p>接下来看4种算法。</p><h5 id="3-6-2-1-慢开始和拥塞避免"><a href="#3-6-2-1-慢开始和拥塞避免" class="headerlink" title="3.6.2.1 慢开始和拥塞避免"></a>3.6.2.1 慢开始和拥塞避免</h5><img src="https://pic.imgdb.cn/item/6640716c0ea9cb1403eb22c1.png" alt="计算机网络（五）——传输层——TCP拥塞控制慢开始和拥塞避免.png"><p>如上图是慢开始和拥塞避免算法的实现过程。首先需要搞清楚横纵坐标的含义。</p><p>纵坐标指拥塞窗口的大小，拥塞窗口的初始值是默认为1的，这里的1不是1个字节，为了讨论方便，这里的1指一个报文段，而这一个报文段的长度是一个最大报文段长度MSS。所以对纵坐标的4,8,12等等，指的就是4个MSS，8个MSS等。</p><p>横坐标是传输轮次，所谓传输轮次就是发送一批报文段并收到它们的确认的时间。假设有主机A和主机B，B的接收窗口很大，在第一个传输轮次里，A发送给B一个报文段M1，B返回一个对报文段M1的确认，这就是第一个传输轮次。现在A看到网络情况很好，就可以继续往下多发几个，所以在第二个传输轮次里，A发送给B两个报文段M2、M3，B收到两个报文段以后，依次返回确认，这就是第二个传输轮次。由于假设接收窗口很大，所以A发现网络情况依然很好，在第三个传输轮次里，A又发送4个报文段，B收到以后会继续依次返回确认报文段。接下里如此循环发送。在考试当中，一个传输轮次也指一个往返时延RTT。当然这个传输轮次也可以指开始发送一批拥塞窗口内的报文段到开始发送下一批拥塞窗口内的报文段的时间。</p><p>如上图，可以看到，在一开始时使用慢开始算法（慢开始就是一开始增长缓慢），传输轮次对应的拥塞窗口是成指数规律增长，但是当拥塞窗口到达16以后，就到达了慢开始门限，意味着从这以后，拥塞窗口增长速度开始减小，就是从慢开始进入到拥塞避免，因为现在注入的报文段有点多，担心以后出现拥塞情况，所有把增长速度降低到每次只在前一个拥塞窗口基础上增加一个拥塞窗口。也就是说到了慢开始门限值，接下来就进入拥塞避免算法过程，这个过程是加法增大，他是一个线性增长的过程。当拥塞窗口增大到了24（实际不一定是24，这里的24是根据上图的例子来说的）出现网络拥塞，所以现在执行的操作是将拥塞窗口从24直接降为1，也就是缩小到一开始的慢开始状态，然后开始执行慢开始算法，接下来的过程都一样。但是可以看到，这一次的门限值与上一次不同，**<font color=blue>这个门限值的确定是在网络拥塞的情况下马上确定的，只要发生了网络拥塞，立刻把当时的拥塞窗口除以2定义为新的轮限值</font>**，这里的12就是在24出现网络拥塞以后除2得到，当拥塞窗口达到12以后，就开始进入拥塞避免的算法过程。当网络再次出现拥塞，拥塞窗口就继续降为1再按上述执行。这就是慢开始和拥塞避免算法的过程。</p><p><strong>最后补充一点，拥塞窗口扩大是在收到确认报文段时进行扩大。</strong></p><h5 id="3-6-2-2-快重传和快恢复"><a href="#3-6-2-2-快重传和快恢复" class="headerlink" title="3.6.2.2 快重传和快恢复"></a>3.6.2.2 快重传和快恢复</h5><img src="https://pic.imgdb.cn/item/664071990ea9cb1403eb59c9.png" alt="计算机网络（五）——传输层——TCP拥塞控制快重传和快回复.png"><p>快重传在前面的TCP流量控制里已经接触过，接收方在收到3个重复的冗余确认后，就会执行快重传算法。</p><p>假设主机A和B通信，A给B发送了报文段M1，M2，M3，M4，M5。M1发过去收到了确认报文段，但M2丢失，M3发过去收到一个返回确认，但这个确认是对M1的确认，也就是期待收到M2，然后A发了M4，M5，B都是返回对M1的确认。</p><p>可以看到在这个过程中，B给A发送了4个M1的确认报文段，而这4个当中，后面3个都是冗余ACK，只要发送方收到3个冗余的ACK就会马上执行快重传算法，这样就可以在超时计时器到期之前，快速执行重传的过程，省下了很多等待时间，这就是快重传算法。</p><p>在快重传之后，进行的就是快恢复算法。<strong>快恢复和之前的区别在于，之前是发生拥塞就会降为初始值1，而<font color=red>快恢复是降到新的门限值</font>，这个新的门限值的确定和之前一样，是发生拥塞窗口的值除2</strong>，接下里执行拥塞避免，也就是线性的加法增大，这就是快重传与快恢复的过程。</p><p>在上图的里快恢复有两个版本，但TCP Tahoe版本已经废弃，考试考的是TCP Reno版本，即降到新的门限值。所以对于考试，知道第二个版本就可以。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（四）——网络层</title>
      <link href="/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（四）——网络层"><a href="#计算机网络（四）——网络层" class="headerlink" title="计算机网络（四）——网络层"></a>计算机网络（四）——网络层</h1><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h2><img src="https://pic.imgdb.cn/item/6629f3500ea9cb1403f27d8c.png" alt="计算机网络（四）——网络层——本章思维框架.png"><p>上面是本章思维框架，在学习完本章以后，可以结合这张思维框架图，进行整体的把握与理解。</p><h2 id="1-网络层的功能"><a href="#1-网络层的功能" class="headerlink" title="1. 网络层的功能"></a>1. 网络层的功能</h2><h3 id="1-1-网络层的基本功能"><a href="#1-1-网络层的基本功能" class="headerlink" title="1.1 网络层的基本功能"></a>1.1 网络层的基本功能</h3><p><strong>网络层提供<font color=red>主机到主机的通信服务</font>，主要任务是将<font color=red>分组</font>从源主机经过多个网络和多段链路传输到目的主机。</strong></p><img src="https://pic.imgdb.cn/item/6629f3d20ea9cb1403f3b618.png" alt="计算机网络（四）——网络层——网络层的基本功能.png"><p>网络层传输单位是<strong>数据报</strong>，注意区分数据报与分组，数据报是个比较长的数据，而分组是把这个数据报进行切割而划分出来的一个片段就叫做分组。</p><p><strong>网络层的功能：</strong></p><p><strong>功能一：路由选择与分组转发。</strong></p><p>路由选择就是通过路由算法找到最佳的传输路径，然后把分组按照路由顺序发送出去。</p><p>注意区分转发与路由选择，转发是路由器内部进行，将一组数据从接收端口转发到发送端口。而路由选择是在路由器外进行的，即在整个路由链路上找到最佳传输路径，将数据从一个路由器发送到另一个路由器。</p><p><strong>功能二：异构网络互联。</strong></p><p>异构网络互联就是指将使用不同寻址方案、网络接入机制、差错处理方法和路由选择机制等的计算机网络（即异构网络），通过一定的方法，用一种或多种通信处理设备相互连接起来，构成更大的网络系统。</p><p>在异构网络互联中，路由器通常用于进行网络互联和路由选择。</p><p><strong>功能三：拥塞控制。</strong></p><p>拥塞控制指所有结点都来不及接受分组，有大量分组会被丢弃，网络就处于拥塞状态。因此要采取一定措施来缓解这种拥塞。</p><p>这里可以看到，拥塞控制与流量控制不是一个概念，拥塞控制是一种全局性概念，是指网络中负载过重，每一结点都在非常忙碌的工作，所以导致分组转发的速率很慢，进而导致大部分分组被丢弃。而流量控制是指发送方发送速率过快，接收方接收不了，所以要告诉发送方发慢点。</p><p>拥塞控制有两种方法，一种静态的开环控制，一种动态的闭环控制。</p><p>开环控制，即网络开始工作前，就把所有能产生拥塞的因素给考虑到，然后进行预先的控制。</p><p>闭环控制，就是预先不去设想，当网络运行起来以后，自动调整控制。</p><h3 id="1-2-网络层提供的两种服务"><a href="#1-2-网络层提供的两种服务" class="headerlink" title="1.2 网络层提供的两种服务"></a>1.2 网络层提供的两种服务</h3><p>分组交换网根据其通信子网向端点系统提供的服务，还可进一步分为面向连接的虚电路服务和无连接的数据报服务。这两种服务方式都是由网络层提供。</p><h4 id="1-2-1-面向连接的虚电路服务"><a href="#1-2-1-面向连接的虚电路服务" class="headerlink" title="1.2.1 面向连接的虚电路服务"></a>1.2.1 面向连接的虚电路服务</h4><img src="https://pic.imgdb.cn/item/6629f87e0ea9cb1403fe7405.png" alt="计算机网络（四）——网络层——面向连接的虚电路服务.png"><h4 id="1-2-2-无连接的数据报服务"><a href="#1-2-2-无连接的数据报服务" class="headerlink" title="1.2.2 无连接的数据报服务"></a>1.2.2 无连接的数据报服务</h4><p>因特网的先驱者并没有采用面向连接的虚电路服务而是采用了无连接的数据报服务。</p><img src="https://pic.imgdb.cn/item/6629f8e60ea9cb1403ff40af.png" alt="计算机网络（四）——网络层——无连接的数据报服务.png"><h4 id="1-2-3-两种服务对比"><a href="#1-2-3-两种服务对比" class="headerlink" title="1.2.3 两种服务对比"></a>1.2.3 两种服务对比</h4><img src="https://pic.imgdb.cn/item/6629f90c0ea9cb1403ffb6b9.png" alt="计算机网络（四）——网络层——网络层服务对比.png"><h3 id="1-3-SDN基本概念"><a href="#1-3-SDN基本概念" class="headerlink" title="1.3 SDN基本概念"></a>1.3 SDN基本概念</h3><img src="https://pic.imgdb.cn/item/6629fabe0ea9cb140303b76b.png" alt="计算机网络（四）——网络层——数据平面&控制平面.png"><p><strong>网络层的主要任务是<font color=red>转发和路由选择</font>。</strong></p><p>可以将网络层抽象地划分为数据平面（也称转发层面）和控制平面，转发是数据平面实现的功能，而路由选择是控制平面实现的功能。</p><p>数据平面主要用于数据处理和转发，只在一个路由器内部进行，所以时间短，通常用硬件解决。</p><p>控制平面主要用于控制和管理网络协议，通常在网络上运行，需要时间长，通常采用软件解决。</p><p><strong>接下里详细的看一下数据平面和控制平面：</strong></p><h4 id="1-3-1-数据平面"><a href="#1-3-1-数据平面" class="headerlink" title="1.3.1 数据平面"></a>1.3.1 数据平面</h4><img src="https://pic.imgdb.cn/item/6629fbab0ea9cb140305d45f.png" alt="计算机网络（四）——网络层——数据平面.png"><p>数据平面就是一个单纯的搬运工，只需要根据转发表将数据转发即可。所以数据平面实现在路由器里，每一个路由器都有一个数据平面。</p><p>但数据平面执行的转发功能非常频繁，因为网络上数据只要一传输，经过路由器时就会有转发的过程。</p><h4 id="1-3-2-控制平面"><a href="#1-3-2-控制平面" class="headerlink" title="1.3.2 控制平面"></a>1.3.2 控制平面</h4><p>控制平面有两种实现方法：传统方法（也称每路由器法）和SDN法。</p><p><strong>传统方法：</strong></p><img src="https://pic.imgdb.cn/item/6629fd530ea9cb140309df97.png" alt="计算机网络（四）——网络层——控制平面（传统方法）.png"><p>传统方法中，每一个路由器既能进行路由选择也能进行转发。所以，传统方法会把路由选择和数据转发集成在每一个路由器当中。</p><p>具体来说，传统方法实现的控制平面是一个路由器中的选择算法与其他路由器中的路由选择算法通信，进而计算出路由表和转发表。</p><p>综合来说，传统方法中，控制平面和数据平面是在一个路由器内进行的。数据平面充当搬运工，控制平面计算转发表。</p><p><strong>SDN方法：</strong></p><p>SDN即软件定义网络是近年流行的一种创新网络架构，它采用集中式的控制平面和分布式的数据平面，两个平面相互分离，控制平面利用控制-数据接口对数据平面上的路由器进行集中控制，方便软件来控制网络。</p><img src="https://pic.imgdb.cn/item/662a07ad0ea9cb140325bc27.png" alt="计算机网络（四）——网络层——控制平面（SDN方法）.png"><p>如上是SDN方法，数据平面和传统方法一样，但是控制平面却差异巨大。</p><p>在SDN方法中，路由器只需要执行转发功能，路由选择功能开始由远程控制器计算并分发转发表以供每台路由器使用。所以远程控制器相当于路由器真正的”大脑”。</p><p>远程控制器计算转发表以及和路由器通信全都是通过软件实现的，而且是可编程的软件实现，所以把SDN方法称为软件定义网络。</p><h4 id="1-3-3-控制平面中的路由选择处理器"><a href="#1-3-3-控制平面中的路由选择处理器" class="headerlink" title="1.3.3 控制平面中的路由选择处理器"></a>1.3.3 控制平面中的路由选择处理器</h4><img src="https://pic.imgdb.cn/item/662a096a0ea9cb14032a2705.png" alt="计算机网络（四）——网络层——控制平面的路由选择处理器.png"><p>在路由器里，会有这么一个模块叫路由选择处理器。</p><p>在传统方法中，路由选择处理器用来执行平面控制的功能，即进行路由选择和维护路由选择表并计算转发表等功能。</p><p>但是在SDN方法里，控制平面的功能由远程控制器执行，路由选择处理器的事情被远程控制器抢了，路由选择处理器就要进行别的工作，所以在SDN方法里，路由选择处理负责与远程控制器通信，来接收转发表和路由选择相关信息。</p><h4 id="1-3-4-SDN控制平面"><a href="#1-3-4-SDN控制平面" class="headerlink" title="1.3.4 SDN控制平面"></a>1.3.4 SDN控制平面</h4><img src="https://pic.imgdb.cn/item/662a0af20ea9cb14032deff9.png" alt="计算机网络（四）——网络层——SDN控制平面.png"><p>SDN的控制平面分成SDN控制器和网络控制应用程序两部分。</p><p>SDN控制器主要维护准确的网络状态信息，并能将这些信息采集传输到网络控制应用程序。（上图里有表述不恰当的地方，上面所有的交换机都应该换成路由器，这里说交换机是想指路由器的）</p><p>网络控制应用程序是控制平面真正的大脑，他可以将SDN控制器采集来的信息进行计算，从而得到转发表和路由选择等信息。</p><p>另外，SDN的可编程性通过为开发者提供强大的编程接口，使得网络具有很好的编程性。对上层应用的开发者，SDN提供的编程接口称为北向接口；SDN控制器和转发设备建立双向会话的接口称为南向接口；SDN控制器集群内部控制器之间的通信接口称为东西向接口。</p><h4 id="1-3-4-SDN控制器的三个层次"><a href="#1-3-4-SDN控制器的三个层次" class="headerlink" title="1.3.4 SDN控制器的三个层次"></a>1.3.4 SDN控制器的三个层次</h4><p>进一步探索SDN控制平面，可以将SDN控制器继续分为网络控制应用程序的接口、网络范围状态管理层、通信层。</p><img src="https://pic.imgdb.cn/item/662a0dc70ea9cb140335256c.png" alt="计算机网络（四）——网络层——SDN控制器的三个层次.png"><p>从上图可以看到，网络控制管理的真正实施者是网络范围状态管理层。</p><p>这里可能会把SDN控制器跟网络控制应用程序的功能出现混淆，所以，我查了点资料，在这里做个辨析。</p><p>在SDN（软件定义网络）架构中，网络控制应用程序和SDN控制器各自扮演着不同的角色，但它们共同协作以实现网络的集中控制和管理。</p><p>网络控制应用程序是基于SDN控制器的应用程序，它们负责实现各种网络服务，比如负载均衡、流量控制、安全管理等。这些应用程序可以基于特定的算法来制定策略，如流量调度算法、安全过滤规则等，以优化网络性能和保障网络安全。</p><p>而SDN控制器是整个SDN架构的核心，它负责管理和控制整个网络。它通过与网络设备进行通信，实现对网络设备的集中化配置、监控和管理。SDN控制器根据网络控制应用程序提供的策略或指令，执行具体的控制操作，如转发决策、流量调度、安全策略实施等。因此，可以说SDN控制器是真正的控制实施者。</p><p>综上所述，网络控制应用程序和SDN控制器在SDN架构中各有分工，前者负责提供策略或算法，后者负责执行具体的控制操作。它们相互协作，共同实现网络的集中控制和管理。</p><h2 id="2-IPv4"><a href="#2-IPv4" class="headerlink" title="2. IPv4"></a>2. IPv4</h2><img src="https://pic.imgdb.cn/item/662a10670ea9cb14033ae8b9.png" alt="计算机网络（四）——网络层——TCP-IP协议栈.png"><p>首先看下TCP&#x2F;IP协议栈的构造，网络层协议主要是ARP、IP、ICMP、IGMP四个。</p><p>从图中不难看出，ARP在最下面，所以ARP要为IP协议服务，而ICMP和IGMP在上面，所以IP协议要为这两个协议服务。而IP协议占领大部分地方，说明IP协议在该层有着举足轻重的作用。</p><h3 id="2-1-IP数据报"><a href="#2-1-IP数据报" class="headerlink" title="2.1 IP数据报"></a>2.1 IP数据报</h3><h4 id="2-1-1-IP数据报格式"><a href="#2-1-1-IP数据报格式" class="headerlink" title="2.1.1 IP数据报格式"></a>2.1.1 IP数据报格式</h4><img src="https://pic.imgdb.cn/item/662a11b00ea9cb14033d640c.png" alt="计算机网络（四）——网络层——IP数据报.png"><p>IP数据报由首部和数据部分组成，数据部分是从传输层交付下来的，在本章不考虑。首部是在网络层添加的，由固定部分和可变部分组成，其中固定部分是每个IP数据报都要有的东西，而可变部分可有可无。</p><p>值得一提的是，在网络层IP数据报和分组是不用太区分的，可以暂时把这两个当成一样的东西，但是要清楚的是，他们两个还是有一定区别的。如果IP数据报过大，就会对其进行分片，而分片下来的小单位就是网络层的传输单元，即分组。</p><p>接下来看一下首部具体有哪些字段：</p><img src="https://pic.imgdb.cn/item/662a12f60ea9cb1403400d8b.png" alt="计算机网络（四）——网络层——IP数据报各部分字段.png"><p>这里我检重点说一下，从上图可以看到，IP数据报的固定部分有五个存储行，每个存储行都是32bit，所以固定部分一共占32bit×5&#x3D;160bit&#x3D;20B的存储空间。而可变部分长度不固定，但是只能在0~40B的范围内。</p><p>首部长度字段内，记录当前首部有多长，单位是4B且最小为5，这个限制可能会无法理解。其实4B就是IP首部的一行，说白了IP首部以存储行为单位，每一行32bit即4B，因为前5行是固定部分，每一个IP数据报都要有，所以首部长度是固定20B，即5行，所以最小为5，单位是4B。另外，首部字段使用4个bit来表示首部长度，也就是说首部字段取值范围是0101<del>1111，这就表明IP数据报首部长度的范围是5×4B</del>15×4B，即20B<del>60B，这也解释了为什么可变部分长度是0</del>40B。根据这种方式，我们也可以通过首部长度字段的数值计算出该IP数据报首部多长，进而可以求出可变部分的长度。</p><p>上面的几个点是我觉得比较重要的，剩下的，我感觉就需要个人去记忆了。</p><h4 id="2-1-2-IP数据报分片"><a href="#2-1-2-IP数据报分片" class="headerlink" title="2.1.2 IP数据报分片"></a>2.1.2 IP数据报分片</h4><img src="https://pic.imgdb.cn/item/662c89610ea9cb140318a538.png" alt="计算机网络（四）——网络层——MTU.png"><p>首先回顾一下最大传送单元的概念，在链路层中每一个数据帧都有一个最大可封装数据的上限，这个上限就是MTU，像以太网的MTU就是1500B。</p><p>如上图，IP分组下送到链路层，经数据链路层封装，在IP分组前添加帧头和帧尾，在这里，IP分组就构成了数据链路层的数据封装部分，这部分数据是有上限的，上限就是该数据链路层的MTU，如果一个IP分组超出了数据链路层可封装数据的上限，就要分片。</p><p>需要注意，IP分组的分片是要看IP分组允不允许被分片，如果不允许，则IP分组是无法往下传递，因此会返回一个ICMP差错报文（ICMP在后面讲）。</p><p>接下来看一下可以分片的IP数据报是如何分片的：</p><img src="https://pic.imgdb.cn/item/662c8b340ea9cb14031c6e96.png" alt="计算机网络（四）——网络层——IP分片.png"><p>在2.1.1里，介绍IP数据报格式的时候，没有介绍标识、标志和片偏移三个字段的作用，这部分来介绍一下，这三个字段是用来做IP数据报分片标记的。</p><p>在介绍这三个字段之前，首先要明确一点，IP分片的结构，当IP数据报过长时，会按一定规则把IP数据报的数据部分进行分片处理，即将一组数据数据部分分成几组。被分出来的组，每一组都会添加一个IP首部，构成一个IP数据报，然后将这些IP数据报发送出去。举个例子，我要发送一组IP数据报过长，就将其分数据部分成三组，每一组都要添加一个IP首部，所以发出去的是三组IP数据报。</p><p>接收方是如何根据自己接收到的多组IP数据报来确定自己接收的是一个完整的，还是分片后的，又或者接收到哪里才算接收完一组IP数据报的呢？这就跟标识、标志和片偏移三个字段有关。</p><p>标识：同一数据报的分片使用同一标识。接收方可根据标识来确定分片属于哪一个数据报。</p><p>标志：标志有三位，但只有后两位有用，中间位是DF，DF&#x3D;1表示该数据报不允许被分片，DF&#x3D;0，则表示该数据报允许被分片。最低位是MF，MF&#x3D;1，表示后面还有分片；MF&#x3D;0，表示后面没有分片。不难看出，当DF&#x3D;1时，就不需要管MF。 </p><p>片偏移：指出较长分组分片后，某片在原分组中的相对位置，以<font color=red><strong>8B</strong></font>为单位。接收方根据片偏移来复原原数据报。</p><p>有了三个标记字段，接收方就可以将接收到的多个IP数据报分组进行分类复原，得到正确的数据。</p><p>这里要注意一点，在片偏移里，单位是8B，如果题目中给出了数据长是多少B，还要除8才可得到正确的片偏移量。</p><p>为了加深理解，下面贴一道例题：</p><img src="https://pic.imgdb.cn/item/662c90230ea9cb1403272abc.png" alt="计算机网络（四）——网络层——IP分片例题.png"><p>可以发现，在IP首部里，每个字段的单位是非常重要的，都是考试时易错的点，这里再汇总一下：</p><ol><li>总长度单位是1B。</li><li>片偏移单位是8B。</li><li>首部长度单位是4B。</li></ol><h3 id="2-2-IPV4地址与NAT"><a href="#2-2-IPV4地址与NAT" class="headerlink" title="2.2 IPV4地址与NAT"></a>2.2 IPV4地址与NAT</h3><h4 id="2-2-1-IPV4地址"><a href="#2-2-1-IPV4地址" class="headerlink" title="2.2.1 IPV4地址"></a>2.2.1 IPV4地址</h4><p>IP地址是给互联网上的每台主机（或路由器）的每个接口分配的一个在全球范围内唯一的32位表示符。IP地址由互联网名字和数字分配机构ICANN进行分配。</p><p>互联网早期采用分类的IP地址，分类如下：</p><img src="https://pic.imgdb.cn/item/662c933b0ea9cb14032d45cd.png" alt="计算机网络（四）——网络层——IP分类.png"><p>上图展示了IP地址的分类编制，可以看到不论是哪类IP地址，都由网络号和主机号两部分组成。上图右显示着注意事项，这些注意事项展示了一些特殊的IP地址，可以参考下面的图。</p><img src="https://pic.imgdb.cn/item/662c93d90ea9cb14032e88c8.png" alt="计算机网络（四）——网络层——特殊IP地址.png"><p>下面，分类看一下常考的A、B、C三类IP地址。</p><p><strong>（1）A类IP地址</strong></p><img src="https://pic.imgdb.cn/item/662c94710ea9cb1403315fb9.png" alt="计算机网络（四）——网络层——A类IP地址.png"><p><strong>（2）B类IP地址</strong></p><img src="https://pic.imgdb.cn/item/662c94aa0ea9cb14033251d4.png" alt="计算机网络（四）——网络层——B类IP地址.png"><p><strong>（3）C类地址</strong></p><img src="https://pic.imgdb.cn/item/662c94cf0ea9cb140332ace2.png" alt="计算机网络（四）——网络层——C类IP地址.png"><p>发现两道知识点考的比较全的例题，拿捏不了，建议进厂：</p><p><strong>例题1：</strong></p><img src="https://pic.imgdb.cn/item/662c950b0ea9cb14033336a7.png" alt="计算机网络（四）——网络层——例题1.png"><p><strong>例题2：</strong></p><img src="https://pic.imgdb.cn/item/662c958a0ea9cb140334663e.png" alt="计算机网络（四）——网络层——例题2.png"><h4 id="2-2-2-网络地址转换NAT"><a href="#2-2-2-网络地址转换NAT" class="headerlink" title="2.2.2 网络地址转换NAT"></a>2.2.2 网络地址转换NAT</h4><p>上面在2.2.1里讲的IP地址分类，其中A类中的10.0.0.0～10.255.255.255，B类中的172.16.0.0～172.31.255.255以及C类中的192.168.0.0～192.168.255.255都属于私有地址，这些IP地址之所以叫私有IP是因为它们只能在本地网络、专用网络使用，而在大的互联网、广域网当中，路由器及其它主机是无法识别这些IP地址的，即<font color=red><strong>路由器对目的地址是私有IP地址的数据报一律不进行转发</strong></font>。</p><p><strong>私有网络要想与因特网进行外部通信就需要借助网络地址转换技术</strong>。</p><img src="https://pic.imgdb.cn/item/662ca2a70ea9cb14035327ac.png" alt="计算机网络（四）——网络层——NAT.png"><p>实现这种网络地址转换技术的方式很简单，只需要在专用网和因特网之间的路由器上安装NAT软件，安装NAT软件的路由器就变声为NAT路由器。这个路由器至少有一个有效的外部全球IP地址，当然也可以有多个。所有使用本地地址的主机和外部进行通信时，都需要经过NAT路由器的地址转换。</p><p>下面结合上图以一个具体的示例，来讲解网络地址转换过程。如上图假设有两台主机A、C。A的IP地址为192.168.0.3，C的IP地址为192.168.0.4。他们俩都处在专用网络192.168.0.0上。在专用网络与因特网之间有一个NAT路由器，其全球IP地址为172.38.1.5，这就是专用网络的代表地址。专用网络上的主机想要与因特网通信，都要借助NAT的全球IP地址作为自己的伪装，用这个地方和外部进行通信。外部网络的主机要想和本地主机通信，也需要把数据发到代表地址上，即发到全球IP地址，再由代表地址分发给专用网络主机。</p><p>实现上述过程的关键就是NAT路由器有一个NAT转换表（如图），转换表分为两列，一列是广域网段，一列是局域网段。每一列信息都包含两段，一段是点分十进制（即IP），另一端是端口号（端口号的概念会在传输层里学，端口号是用来唯一标识主机中的某一进程，在同一主不同进程的端口不同，不同主机的不同进程端口号可能相同）。</p><p>在上图，若现在A主机向B发送一数据报，在传输层先添加端口号，然后在网络层处要封装原IP和目的IP。该数据报到NAT路由器处就会实现网络地址转换，具体转换过程就是NAT路由器根据转换表，将源主机IP和端口号替换成对外的全球IP和端口号，如上图A发送的数据报源IP和端口号若为1982.168.0.3:30000，则NAT路由器会将其替换成172.38.1.5:40001，该组数据报到达B端可以被顺利接收。</p><p>若现在B主机向C主机发送数据，同A向B发送一样，也有源IP和目的IP和端口号。但是在A向B处，在目的IP写的是B的IP，而在B向C处，目的地址里写的不是C的IP，而是NAT路由器的IP。NAT路由器接收到B的数据报，根据转换表，将目的IP和端口号，替换成内部专用网络的IP和端口号。例如B发送到C数据写的目的IP和端口号位172.38.1.5:40002，NAT路由器会根据转发表将其转换成192.168.0.4:30001，然后将数据发送到C主机。</p><h3 id="2-3-划分子网与路由集合"><a href="#2-3-划分子网与路由集合" class="headerlink" title="2.3 划分子网与路由集合"></a>2.3 划分子网与路由集合</h3><h4 id="2-3-1-划分子网"><a href="#2-3-1-划分子网" class="headerlink" title="2.3.1 划分子网"></a>2.3.1 划分子网</h4><p>前面所说的A、B、C类IP地址存在一些弱点。首先，他们的IP地址空间的利用率有时很低，例如一个小公司使用C类网络就可以够用，但公司出于对未来扩充的考虑，所以会申请B类网络，这就导致有很多地址空间被浪费。其次，对于将IP地址划分为网络号和主机号这样的两级IP地址，其不够灵活，比如还是那个小公司，他想在另一个地点马上开通一个新的网络，但是在开通前，要先跟ISP（因特网服务供应商）申请一系列新的IP地址网络号。</p><p>所以为了避免IP空间被浪费，还能随时随地增加自己的网络而不用跟ISP申请新的网络号，就产生了子网划分的方法。</p><img src="https://pic.imgdb.cn/item/662cab6f0ea9cb1403666d10.png" alt="计算机网络（四）——网络层——子网划分.png"><p>上面就是子网划分的结构，在两级IP地址上，将主机号划分为子网号和主机号，进而形成了一个三年级IP地址，而子网号多少位，都是可以由公司自己定。</p><p>根据子网划分就可以看出，网络号表示网络段，而子网号就是在这个网络段上再划分几片区域，主机号则是在区域上的主机标志。用个很贴切的例子来描述就是，使用两级IP地址，就是一个公司直接记录所有员工信息；而使用三级IP地址（子网划分），就是一个公司分成几个部门，几个部门分别记录员工信息。</p><p><font color=green><strong>注意，子网划分以后，对外仍表现原网络号，即外部看不到内部的子网划分。另外，由于主机号全0全1是没有意义的，所以主机号至少要留2位。</strong></font></p><p>题目中还可能会考察子网和主机能不能全0和全1，对于子网号来说，能否全0或全1是要看具体情况的，在最开始时子网是不能全0和全1的，但随着CIDR技术的广泛应用，全0和全1也是可以的，所以要根据题目来解题。主机号就显而易见的不能全0或全1。</p><p>接下来用一个例子介绍子网划分和数据传输。</p><img src="https://pic.imgdb.cn/item/662cae6e0ea9cb14036ca1bd.png" alt="计算机网络（四）——网络层——子网划分过程.png"><p>如上图，假设某单位申请到一个B类地址号145.13.0.0分配到上图的路由器上，现在所有想到达该网络段的数据，都要经过该路由器。从图中可以看到，该单位划分三个子网，假设子网号占8位，则主机号也占8位。即使划分子网，但对外展示的仍然是一个网络145.13.0.0。假设现在有一个数据报，其目的地址是145.13.3.10，但是它是从外部来的，只知道发给路由器，那么该如何传到主机呢？</p><p>这就要先说一下子网掩码：</p><img src="https://pic.imgdb.cn/item/662cb0710ea9cb1403713c62.png" alt="计算机网络（四）——网络层——子网掩码.png"><p>子网掩码是一个与IP地址相对应的二进制串，由一串1和一串0组成，1对应网络号和子网号、0对应主机号。主机和路由器只需将IP地址和其对应子网掩码逐位相与即可得到相应子网的网络地址。</p><p>本例中，路由器根据数据报的目的IP地址，与子网掩码相与，就可以得到该发送哪个子网，先把数据报发到对应子网，进而发到对应主机上。</p><p>现在要考虑一下，从外部来的分组，通过路由器，应该怎么转发，怎么利用子网掩码，才能把数据报正确的送到子网内对应的主机上呢？结合下图，来介绍一下使用子网划分以后，分组转发的过程。</p><p><strong>（这部分内容结合王道25书的147页4.2.4 网络层转发分组的过程）</strong></p><img src="https://pic.imgdb.cn/item/662cb6f10ea9cb1403810830.png" alt="计算机网络（四）——网络层——子网划分以后分组转发.png"><p>这里讲一个前提条件，对于每个路由器都有一个转发表，如果划分了子网，这个路由表里就会包含以下三项，第一个是目的网络地址；第二个是目的网络子网掩码；第三个是下一跳地址，下一跳指的是接下来走哪个接口。</p><img src="https://pic.imgdb.cn/item/662cb6f10ea9cb1403810830.png"><p>如果来了一个外部分组，路由器会提取目的IP地址，然后再判断是否可直接交付（直接交付就是路由器可以直接把这组数据给到当前所连的子网，而间接交付则是当前路由器没有该目的地址，要转到下一个路由器，也有可能要转很多路由器才能到目的主机），就像上面的例子，路由器通过目的地址与子网掩码相与，得到了子网号，发现是自己所连的，就可以直接交付。</p><p>若路由发现相与得出的子网在与自己相连的网段内没有匹配的，就会检查特定主机路由，所谓特定主机路由，就是一些特殊的IP地址。若有匹配的可直接发送。</p><p>若检查特定主机路由仍没有发现匹配的，就会检查路由表当中有没有合适的路径，即使用目的地址和路由表当中的每一行子网掩码进行相与，查看有没有匹配的目的网络，若有匹配的，就按照那一行的下一跳地址进行转发。</p><p>若仍没有发现匹配的，则把分组交给默认路由0.0.0.0，默认路由会把分组交给另一个路由器，然后循环上面的步骤，若找到则直接发送，若仍没有找到，则返还给默认路由，默认路由再转发给另外的路由器。若经过来回转发，达到生存时间仍没有找到，就会丢弃该分组，再报告分组出错。</p><h4 id="2-3-2-无分类编制CIDR"><a href="#2-3-2-无分类编制CIDR" class="headerlink" title="2.3.2 无分类编制CIDR"></a>2.3.2 无分类编制CIDR</h4><p>早期B类地址由于性价比的超高性，很快就被分配完毕。另外伴随着网络普及，越来越多设备加入互联网，所以路由表中的项目急剧增长，对于一个庞大路由表很难维护，所以人们就发明了无分类编址形式CIDR。</p><p>CIDR在子网划分的启发下，将网络号和子网号划分到一起，称为网络前缀，再次回到二级IP地址的形式，看似与之前的二级地址一样，但这个网络前缀是可变长的，所以CIDR可以很灵活的调整网络前缀长度以及主机号长度。</p><p>下图是CIDR相关基础概念：</p><img src="https://pic.imgdb.cn/item/662cb8d60ea9cb1403855afc.png" alt="计算机网络（四）——网络层——CIDR.png"><p>如果想表示一个IP的网络前缀，只需在IP地址后加上”&#x2F;“然后写上数字即可，数字表示网络前缀所占位数。</p><p>对于网络前缀相同的连续的IP地址称为一个”CIDR地址块”。</p><p>主机号全0和全1对应这个地址块的最小地址和最大地址。</p><p>CIDR若想接着进行网络划分，只需要从主机号里取几位放到网络前缀里即可。</p><p>下面看一下CIDR的两个重要应用：</p><p><strong>(1) 构成超网</strong></p><img src="https://pic.imgdb.cn/item/662cbddc0ea9cb1403906a7b.png" alt="计算机网络（四）——网络层——构成超网.png"><p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p><p>如上图，有路由器R1和R2，R2连接两个网络。R1路由器维护一个路由表，路由表里包含两个主要信息目的网络和要传递数据到这个目的网络所要走的接口。到网络1和网络2都要走接口a，这样两个目的网络信息就占了两行，如果还有别的网络信息，那路由表就会向下扩充，当表过长，路由器就不太好维护。这时候就会采用路由聚合方式缩短路由表长。</p><p>路由聚合的方法就是网络地址取交集，本质上就是缩短网络前缀。</p><p>如上图，网络1:206.1.0.0&#x2F;17和网络2:206.1.128.0&#x2F;17的前16位相同，从第17位开始出现差异，所以取交集就是取前16位，而从第17位到32位都写成0，最后得到的网络合体就是206.1.0.0&#x2F;16。</p><p>到这里不难发现，划分子网是一个由少到多的过程。而构成超网则是由多到少的过程。</p><p><strong>(2) 最长前缀匹配</strong></p><img src="https://pic.imgdb.cn/item/662cc48d0ea9cb1403a10de0.png" alt="计算机网络（四）——网络层——最长前缀匹配.png"><p>使用CIDR时，查找路由表，将目的地址与网络掩码相与运算，得到的结果与网络号匹配时，可能会出现几个匹配成功的结果，这时候要取前缀长的路由。、</p><p>至于为什么这么做，说下我的理解，这里基于CIDR的网络前缀，给我的感觉就是子网划分层级的问题。说白了就是一个公司分配了一个网络，其中网络前缀占16位，主机号占16位。但是在此基础上，公司从主机号里取两位用来划分部门，所以对于部门来说，网络前缀就有18位，主机号只有14位。而部门又从主机号里取两位来划分小组，则对于小组来说，网络前缀有20位，主机号有12位，层层向下，那越向下，他的网络前缀就越长。这个时候，若有一组数据要发送到该公司1号部门的1号小组内，那这数组据要想顺利分到位，他肯定要经过公司、部门、小组三个网络号，也就意味着，这组数据的目的地址与公司网络掩码、部门网络掩码相和小组网络掩码相与运算以后，进行匹配操作时，肯定是匹配成功，这时候要发到位，肯定是发到组里，由于组的级别在最低级，所以，要选网络前缀最长的那个。</p><p>下面给道例题：</p><img src="https://pic.imgdb.cn/item/662cc8d80ea9cb1403a9d3f0.png" alt="计算机网络（四）——网络层——最长前缀匹配例题.png"><p>这道题通过计算可以知道，A、B都能匹配成功，所以要选网络前缀最长的，所以本题答案为B。</p><p>另外，注意一下D选项，D是默认路由，如果目的网络里没有任何网络可以匹配，这时候就要走默认路由。所以如果题目里A、B、C都不匹配，就要选D走默认路由。</p><h3 id="2-4-地址解析协议（ARP）"><a href="#2-4-地址解析协议（ARP）" class="headerlink" title="2.4 地址解析协议（ARP）"></a>2.4 地址解析协议（ARP）</h3><p>网络网络层使用什么协议，在实际网络的连路上传送数据帧时，最终必须使用硬件地址。所以需要一种方法来完成IP地址到MAC地址的映射，这就是地址解析协议（ARP）。</p><p>由于每个主机都有一个ARP高速缓存区，里面存储IP地址与MAC地址的映射。但这个高速缓存，存储的表项都是局域网内部的。所以接下来，根据数发送是否在同一个网段内来进行ARP的协议的介绍。</p><p><strong>(1) 在同一网段内</strong></p><img src="https://pic.imgdb.cn/item/662cd3e50ea9cb1403c5acdd.png" alt="计算机网络（四）——网络层——同一网络内ARP.png"><p>如上图，主机1发送文件到同一网段内的主机3，如果文件比较大，在传输层先分段。网络层先取其中一个分段1进行封装，添加IP1和IP3来分别表示源地址和目的地址（目的地址在传输层可以根据DNS获得，具体内容在传输层介绍）。假设网络层的数据报不大于MTU，其在链路层不需要分片。该IP数据报在链路层封装成帧，要在帧头添加源MAC地址（即MAC1）和目的MAC地址（即MAC3），由于在同一个网络内，所以可以直接在主机1的ARP高速缓存里查找到主机3的MAC地址。在帧尾一般添加FCS检验序列。</p><p>如果在ARP高速缓存里未发现主机3的MAC地址，就要广播一个ARP分组请求，如上图右下，目的地址里写全F，代表在局域网内一个有广播效应的帧（这个帧的意思就是：我的IP是IP1，我想给IP3的主机发送信息，我的物理地址是MAC1，3号主机你的物理地址MAC3是多少）。该分组从主机发出，经过集线器到交换机，交换机一般不会随意转发分组，但若是一个广播分组，便会从交换机的所有端口转发出去，2号、3号和路由器的接口都会收到这个分组。由于分组是发给3号的，所以只有3号会响应，这时3号主机返回一个单播ARP响应分组，这个分组只包含两部分，即3号主机的IP地址和物理地址（意思是：我的IP是多少，我的MAC是多少）。1号主机根据3号主机的反馈，将MAC3写入帧里再封装加尾部就构成链路层的传输单元，进而可以放到物理层进行传输。</p><p><strong>(2) 不在同一网络内</strong></p><img src="https://pic.imgdb.cn/item/662cd9a90ea9cb1403d18e76.png" alt="计算机网络（四）——网络层——不在同一网络内ARP.png"><p>还是这个链路，现在1号主机要和5号主机通信，主机1的ARP只映射了本局域网内的主机IP和MAC地址，所以肯定查不到5号主机的MAC。这时候1号主机会用子网掩码和IP5先相与，发现不在同一个网段内，这时候1号主机就会查询自己与外界沟通所经过的路由器的地址，即查询默认网关，然后在目的物理地址处添加默认网关的地址。</p><p>主机1使用ARP协议，即发送广播ARP分组，获得默认网关的物理地址MAC6，然后将数据发送到默认网关处，路由器从MAC6接口收到数据，要从MAC7转发出去，同样使用ARP协议获得与之相连的路由接口的MAC地址MAC8，然后将分组的原物理地址和目的物理地址改称MAC7和MAC8，路由器2从MAC9转发出去，路由器查找到了IP为IP5的5号主机，然后使用ARP协议获得5号主机的MAC地址MAC5，然后把数据传输到5号主机，到此，实现了1号主机和5号主机的通信。</p><p>注意，上图中两个路由器是点对点连接，所以可以使用PPP协议，将目的物理地址MAC8改成全1也可以。</p><p><strong>ARP协议的小结：</strong></p><img src="https://pic.imgdb.cn/item/662cdb080ea9cb1403d5fcdc.png" alt="计算机网络（四）——网络层——ARP小结.png"><p>ARP协议是自动进行的，主机的用户对于这种地址解析的过程是完全不知道的，要是这个主机和路由器跟其他主机进行通信的话，ARP会自动完成这个地址解析过程，然后数据就可以在链路上传输。</p><h3 id="2-5-DHCP协议（动态主机配置协议）"><a href="#2-5-DHCP协议（动态主机配置协议）" class="headerlink" title="2.5 DHCP协议（动态主机配置协议）"></a>2.5 DHCP协议（动态主机配置协议）</h3><p>我们都知道，主机在进行通信时，需要具备一个IP地址，那主机是如何获得IP地址的呢？有两种方法，一种是静态配置，一种是动态配置。</p><p>静态配置IP，也称为静态IP地址或固定IP地址，是长期分配给一台计算机或网络设备使用的IP地址。这种地址是由网络管理员手动配置并固定分配给特定设备的，不会随着网络状态的变化而改变。像学校的机房，每台设备的位置都固定了，就可以采用静态IP的方式分配IP地址。</p><p>动态配置IP，就是这部分要说的DHCP协议，采用DHCP服务器，动态的为主机分配IP。</p><img src="https://pic.imgdb.cn/item/662e285f0ea9cb140372759f.png" alt="计算机网络（四）——网络层——DHCP.png"><p>DHCP服务器和DHCP客户（IP申请方）的交换过程：</p><ol><li>DHCP客户广播”DHCP发现”消息，试图找到网络中的DHCP服务器，以便从DHCP服务器获得一个IP地址。</li><li>DHCP服务器收到”DHCP发现”消息后，广播“DHCP提供”消息，其中包括提供给DHCP客户机的IP地址。</li><li>DHCP客户收到“DHCP提供”消息，若接受该IP地址，则广播”DHCP请求”消息向DHCP服务器请求提供IP地址。</li><li>DHCP服务器广播“DHCP”确认消息，将IP地址分配给DHCP客户。</li></ol><h3 id="2-6-ICMP协议（网际控制报文协议）"><a href="#2-6-ICMP协议（网际控制报文协议）" class="headerlink" title="2.6 ICMP协议（网际控制报文协议）"></a>2.6 ICMP协议（网际控制报文协议）</h3><h4 id="2-6-1-ICMP报文结构"><a href="#2-6-1-ICMP报文结构" class="headerlink" title="2.6.1 ICMP报文结构"></a>2.6.1 ICMP报文结构</h4><p>为了有效地转发IP数据报和提高交付成功的机会，在网络层使用了网际控制报文协议(ICMP)，让主机或路由器报告差错和异常情况。</p><p>首先看下ICMP结构：</p><img src="https://pic.imgdb.cn/item/662e29fe0ea9cb140375d0fb.png" alt="计算机网络（四）——网络层——ICMP.png"><p>ICMP协议，支持主机或路由器实现一个差错或异常的报告以及网络的探询，因为在实际过程中，总会有一些分组出错，对于出错的分组，在网络层的处理就是将其丢弃掉，但是仅丢弃不行，还要发送一个ICMP的差错报告报文。</p><p>根据上面ICMP报告告文可以看到，ICMP报文是装在IP数据报的数据部分，所以ICMP是网络层的协议，ICMP报文加上首部就可以形成一个ICMP差错报告告文进行发送。</p><p>ICMP报告报文有1字节的类型，1字节的代码和两字节的检验和，中间4个字节取决于ICMP报文的类型，最后面是ICMP数据部分，其长度也取决于类型。</p><p>前面的1字节类型，决定着ICMP属于哪一类。代码字段是为了进一步区分某种类型当中一些不同的情况。检验和字段是用来检验整个ICMP报文。注意在IP数据报首部里也有检验和，但那个检验和只用来检验首部，并不检验数据报的数据部分，所以首部的检验和无法保证数据部分一定没错，因此数据部分要有自己的检验和。</p><p>ICMP分为ICMP差错报文和ICMP询问报文。接下来分别看一下这两种分类。</p><h4 id="2-6-2-ICMP差错报文"><a href="#2-6-2-ICMP差错报文" class="headerlink" title="2.6.2 ICMP差错报文"></a>2.6.2 ICMP差错报文</h4><img src="https://pic.imgdb.cn/item/662e2cc40ea9cb14037d8041.png" alt="计算机网络（四）——网络层——ICMP差错报文.png"><p>上图第二点是源点抑制类型。不过ICMP标准在不断更新，最新的ICMP标准已不再使用“源点抑制报文”。</p><p>下面看一下，ICMP差错报告告文数据字段具体是什么样的。</p><img src="https://pic.imgdb.cn/item/662e2d510ea9cb14037eda6a.png" alt="计算机网络（四）——网络层——ICMP差错报文结构.png"><p>所有的ICMP差错报告报文的数据字段的格式都是一样的，要把收到的需要进行差错报告的IP数据报的首部以及前8个字节取出来，做为ICMP的数据字段，再加上ICMP差错报告报文的前8个字节，就构成了一个完整的ICMP差错报告报文。接下来再加上IP数据报的首部，就构成了一个完整的数据报。这就是形成ICMP差错报告报文以及装入IP数据报的过程。</p><p>需注意，不是所有出错的情况都要返回一个ICMP差错报告报文，下面列举几个不需要返回的情况：</p><img src="https://pic.imgdb.cn/item/662e2f260ea9cb1403830b53.png" alt="计算机网络（四）——网络层——不需返回ICMP差错报文的情况.png"><h4 id="2-6-3-ICMP询问报文"><a href="#2-6-3-ICMP询问报文" class="headerlink" title="2.6.3 ICMP询问报文"></a>2.6.3 ICMP询问报文</h4><img src="https://pic.imgdb.cn/item/662e2f440ea9cb1403834ae8.png" alt="计算机网络（四）——网络层——ICMP询问报文.png"><p>ICMP询问报文有以上四种，但是掩码地址请求和回答报文、路由器询问和通告报文已经不再使用。</p><h4 id="2-6-4-ICMP应用"><a href="#2-6-4-ICMP应用" class="headerlink" title="2.6.4 ICMP应用"></a>2.6.4 ICMP应用</h4><img src="https://pic.imgdb.cn/item/662e2faf0ea9cb140384324f.png" alt="计算机网络（四）——网络层——ICMP应用.png"><p>ICMP两个常见的应用是分组网间探测PING和Traceroute。</p><p>这里说一下Traceroute的工作过程，假设有两台主机（源主机和目的主机），中间连接着很多路由器。源主机会发送一连串的数据报，这些数据报的差别在于他们的TTL（生存时间）设置不一样，假设第一个报文的TTL&#x3D;1，当第一个数据报到达路径上的第一个路由器，这个路由器就会先把第一个报文收下，然后再把TTL的值减1，减完1以后，第一个数据报文的TTL就变为0。当第一个数据报的TT;&#x3D;0时，路由器就会把这个报文丢弃，然后返还主机一个时间超过的ICMP差错报告报文。第二个数据报TTL设置为2，则该报文在第二个路由器处会被丢弃，并收到一个返回的时间超过的ICMP差错报告报文。通过这样的方式，当收到目的主机返回的差错报告报文时，就可以测算出源点到终点的距离。</p><h2 id="3-IPv6"><a href="#3-IPv6" class="headerlink" title="3. IPv6"></a>3. IPv6</h2><p>目前广泛使用的IPv4在2011年2月，已经被耗尽，为了解决“IP地址耗尽”问题，采取了以下三种措施：</p><ol><li>采用无分类编制CIDR。</li><li>采用网络地址转换（NAT）方法以节省全球IP地址。</li><li>采用具有更大地址空间的新版本的IPv6。</li></ol><p>前两种方法只是延长路IPv4使用寿命，只有第三种方法能从根本上解决IP地址耗尽问题。</p><h3 id="3-1-IPv6数据报"><a href="#3-1-IPv6数据报" class="headerlink" title="3.1 IPv6数据报"></a>3.1 IPv6数据报</h3><img src="https://pic.imgdb.cn/item/662f1bd10ea9cb140331c9a5.png" alt="计算机网络（四）——网络层——IPv6数据报格式.png"><p>上面是IPv6数据报格式，与IPv4不同，IPv6的数据报分为首部和有效载荷，其中首部固定为40B，有效载荷又分为选项和数据部分。选项里是有编号的扩展首部，扩展首部里存放着一些对数据报的新的要求，例如一些对数据报的扩展功能就是放到扩展首部里。</p><p>接下来看一下IPv6数据报中具体的字段。</p><img src="https://pic.imgdb.cn/item/662f1d9b0ea9cb140334e908.png" alt="计算机网络（四）——网络层——IPv6数据报具体字段.png"><p>这里说一下流标签，这个字段类似于IPv4里的标识位，但是IPv4的标识位，是对这个数据报进行分片以后，每个分片都有同一个标识位。而这里的流是指，一连串的IPv6数据报，都有同一个流标签，注意，不是一个IPv6数据报分片，而是几个IPv6数据报属于一个流。</p><p>这里补充一个知识点，IPv6只有源主机才能分片，是端到端的，不允许类似IPv4传输路径中的路由分片。</p><p>再说一下下一个首部字段，这个字段在每一个首部里都有（包括IPv6数据报首部和扩展首部），用来标识下一个扩展首部或上层协议首部，说白了就是看有没有扩展首部，如果有则标识下一个扩展首部的类型，没有就指向数据，标识数据是何种协议单元。举个例子，假设一个IPv6数据报有3个扩展首部，则首部的下一个首部标识字段标识扩展首部1的类型；扩展首部1的下一个首部标识字段标识扩展首部2的类型；扩展首部2的下一个首部标识字段标识扩展首部3的类型；扩展首部3的后面由于没有扩展首部了，所以他的下一个首部标识字段标识数据的协议。（下一个首部字段标识数据时，类似于IPv4里的协议字段）</p><p>跳数限制就是IPv4里的TTL，即生存时间。 </p><p>下面看一下IPv6和IPv4的区别：</p><img src="https://pic.imgdb.cn/item/662f236f0ea9cb140340d77a.png" alt="计算机网络（四）——网络层——IPv6和IPv4.png"><h3 id="3-2-IPv6地址表示形式"><a href="#3-2-IPv6地址表示形式" class="headerlink" title="3.2 IPv6地址表示形式"></a>3.2 IPv6地址表示形式</h3><img src="https://pic.imgdb.cn/item/662f239b0ea9cb1403412489.png" alt="计算机网络（四）——网络层——IPv6地址表示形式.png"><p>IPv4地址采用点分十进制的方式表示，但是IPv6的地址有128位，采用点分十进制表示会很长，所以使用冒号十六进制来表示。即把IPv6的二进制地址串，按照每4位转换成1个十六进制的方法，将128位二进制，转换成32位十六进制，两4个十六进制加一个冒号，用于划分间隔，这就是冒号十六进制，也是IPv6地址的一般形势。</p><p>一般形式可以压缩，就是4个一组的十六进制里，如果前面出现0，则可把0省去，如果一组里的四个十六进制全是0，则要保留一个0，这就是压缩形式。</p><p>如果IPv6的一般形式里连续几组都是0，则可以把这连续的几组都省略掉，用两个冒号表示，这就是零压缩。</p><p>各种压缩过程与方法可参考上图。</p><h3 id="3-3-IPv6基本地址类型"><a href="#3-3-IPv6基本地址类型" class="headerlink" title="3.3 IPv6基本地址类型"></a>3.3 IPv6基本地址类型</h3><p>IPv6数据报的目的地址有以下三种基本类型：</p><img src="https://pic.imgdb.cn/item/662f23cd0ea9cb1403417eb1.png" alt="计算机网络（四）——网络层——IPv6地址基本类型.png"><p>这里提一下任播，任播很容易理解，就是和多个目标中的一个进行通信。</p><h3 id="3-4-IPv4和IPv6的过渡策略"><a href="#3-4-IPv4和IPv6的过渡策略" class="headerlink" title="3.4 IPv4和IPv6的过渡策略"></a>3.4 IPv4和IPv6的过渡策略</h3><img src="https://pic.imgdb.cn/item/662f24580ea9cb1403426d38.png" alt="计算机网络（四）——网络层——IPv6和IPv4的过渡策略.png"><p>由于IPv4和IPv6不兼容，所以需要通过特殊的方法来进行两者间的过渡。这里的特殊方法就是上图的双栈协议和隧道技术。</p><p>双栈协议很好理解，所以说一下隧道技术。</p><p>隧道技术，就是将接收到的数据报重新封装再发送。如上图的例子，左主机给右主机发送信息，与路由器1接口连接，使用的是IPv6的协议，但路由器1发给路由器2的接口使用的是IPv4协议，所以路由器1要把IPv6数据报当成数据，前面再添加一个IPv4的首部进行重新封装，然后发给路由器2，路由器2把数据转给路由器3，路由器3发现路由器4的接口是IPv6，所以把IPv4首部去掉，重新转换成IPv6数据报发送出去，路由器4将接收到的IPv6数据报发给右主机。</p><h3 id="3-5-IPv6小结"><a href="#3-5-IPv6小结" class="headerlink" title="3.5 IPv6小结"></a>3.5 IPv6小结</h3><img src="https://pic.imgdb.cn/item/662f24a00ea9cb140342f3b9.png" alt="计算机网络（四）——网络层——IPv6小结.png"><h2 id="4-路由算法与路由协议"><a href="#4-路由算法与路由协议" class="headerlink" title="4. 路由算法与路由协议"></a>4. 路由算法与路由协议</h2><h3 id="4-1-路由算法"><a href="#4-1-路由算法" class="headerlink" title="4.1 路由算法"></a>4.1 路由算法</h3><img src="https://pic.imgdb.cn/item/6634daa30ea9cb14030bc528.png" alt="计算机网络（四）——网络层——路由算法引言.png"><p>如图，路由器本身会有一个路由表&#x2F;转发表，通过这个表，我们会知道分组经过这个路由器之后，接下来该往哪里走，路由表中的每一行是通过路由算法得到的。</p><p>一个路由器可能会连着很多个路由器，那么它的下一跳也有很多种方向，那如何决定是哪个方向呢，这也是路由算法决定的事，路由算法会选择一个最佳路由添加到表项里，在网络层这章，最佳路由往往都是基于路径最短而选择的。</p><p>接下来看一下路由算法的分类：</p><img src="https://pic.imgdb.cn/item/6634dc310ea9cb14030f8b7d.png" alt="计算机网络（四）——网络层——路由算法分类.png"><p>路由算法分为静态路由算法和动态路由算法，而动态路由算法又可以分为全局性的链路状态路由算法和分散性的距离向量路由算法。</p><p>我们现在的因特网规模很大，如果让所有的路由器都知道每个网络怎么样到达的话，路由表就会很庞大，处理起来也很花时间。另外，有一些公司不想让外界知道自己使用的是什么路由协议，但又想连入因特网。结合这两个原因，就产生了分层次的路由选择协议。</p><img src="https://pic.imgdb.cn/item/6634dd150ea9cb140311c475.png" alt="计算机网络（四）——网络层——分层次路由协议.png"><p>分层次的路由协议，具体来说，就是把因特网分为了许多个小的团体，每一个小团体都称为一个自治系统AS，一个自治系统内的协议外部是不知道的，这样就可以减少每一个路由器的表项，还能让公司内部的协议对外界透明。</p><p>路由选择协议分为内部网关协议和外部网关协议。对应的就是应用在自治系统内部分和自治系统外部。</p><p>内部网关协议IGP由RIP和OSPF，外部网关协议EGP有BGP。</p><p>这里补充一下路由算法和路由选择的概念：</p><p>路由算法：路由算法是指在计算机网络中，根据网络拓扑结构和路由策略，计算出数据包从源节点到目的节点的最佳路径的算法。</p><p>路由选择：路由选择是指选择通过互连网络从源节点向目的节点传输信息的通道，而且信息至少通过一个中间节点。路由选择工作在OSI参考模型的网络层。</p><h3 id="4-2-RIP协议与距离向量算法"><a href="#4-2-RIP协议与距离向量算法" class="headerlink" title="4.2 RIP协议与距离向量算法"></a>4.2 RIP协议与距离向量算法</h3><p>从前面我们知道，RIP协议是内部网关协议，主要用于自治系统内部。</p><p>RIP协议具体内容如下图：</p><img src="https://pic.imgdb.cn/item/6634e3fa0ea9cb1403266cb6.png" alt="计算机网络（四）——网络层——RIP协议.png"><p>如上图，介绍了什么RIP协议，RIP协议的优点以及适用于小互联网。上图右下是根据RIP协议建立的R2路由表，里面有目的网络，距离以及下一跳路由器，通过路由表，R2路由器可以将分组转发至对应网络。</p><p>这里有一个问题，R2的路由表是如何建立的呢？R2路由表的建立是通过与其它路由器之间交换信息才逐渐完善起来的，这里就又牵扯出了一些更深的问题，R2路由器和哪些路由器交换信息？在什么时候交换信息？交换什么信息？这就是接下来要讨论的问题。</p><img src="https://pic.imgdb.cn/item/6634e6190ea9cb14032cf62e.png" alt="计算机网络（四）——网络层——RIP协议的路由表建立.png"><p>上图回答了前面遗留的三个问题，即路由器仅和相邻路由器交换信息，信息内容是自己的路由表，每30秒交换一次。</p><p>除了回答上面三个问题，上图中间还解释了收敛的过程。举个例子来说，如上图有5个路由器，对其编号为1~5，假设这5个路由器是5个人，1号有5亿资产，2号有2亿资产，3号有1亿资产，4号有3亿资产，5号有4亿资产。以2和3号为例，一开始2号知道1号和3号的资产，3号知道2和4号的资产，通过交换信息，2号从3号得知4号的资产，3号从2号得知1号的资产。同理，2号也可以和1号交换，3号也可以和4号交换，4号也可以和5号交换，最后每一个都知道别的人的资产。</p><p>所以，经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址。这里有个很重要的问题，最短距离是怎么通过交换信息得到的，换句话说，路由表是怎么更新的？这里要结合距离向量算法深入了解。</p><p>在了解距离向量算法之前，首先要知道有一种报文叫RIP报文，**<font color=blue>RIP报文所包含的信息，就是前面所说的路由表的全部信息</font>**。也就是说相邻两个路由器交换信息的实质就是交换RIP报文。</p><p>RIP报文如下：</p><img src="https://pic.imgdb.cn/item/6634ea140ea9cb1403384047.png" alt="计算机网络（四）——网络层——RIP报文.png"><p>RIP报文有很多字段，但考研不要求记忆。但根据这个报文格式可以知道，RIP报文是首部和路由部分装到了UDP用户数据报里，而UDP是传输层协议，所以UDP的数据单元就是由高层传下来的，所以RIP是应用层协议，这一点要知道。</p><p>除了上面那一点，还要知道一个RIP报文最多可传送25个路由表项信息，也就是25个路由，如果一个路由表有好几十个路由信息，就要发送几个报文进行传输。</p><p>接下来看距离向量算法的过程：</p><img src="https://pic.imgdb.cn/item/6634e9880ea9cb140336e217.png" alt="计算机网络（四）——网络层——距离向量算法.png"><p>下面给两道例题来辅助理解距离向量算法的过程：</p><p>例题1：</p><img src="https://pic.imgdb.cn/item/6634eb620ea9cb14033c22bc.png" alt="计算机网络（四）——网络层——距离向量算法练习1.png"><p>例题2：</p><img src="https://pic.imgdb.cn/item/6634ebbe0ea9cb14033d31c6.png" alt="计算机网络（四）——网络层——距离向量算法练习2.png"><p><strong>最后看一下RIP协议的特点，即好消息传得快，坏消息传的慢。</strong></p><img src="https://pic.imgdb.cn/item/6634ecae0ea9cb14034008db.png" alt="计算机网络（四）——网络层——RIP协议特点.png"><p>RIP 路由器每隔 30 秒（默认设置）就会向邻居路由器发送一次完整的路由表更新。这种定期更新的机制确保了当网络发生变化时，好的路由信息（例如新路径的出现）能够快速地传播到整个网络。此外，RIP 使用跳数作为度量值来确定到达目的地的最佳路径。默认情况下，最大跳数限制为 15。当某个路由器检测到新的、更短的路径时，它会立即向邻居广播这个“好消息”。</p><p>好消息传播的快，但是坏消息传播的很慢，以上图为例，假设网1出现故障，R1自然就到不了网1，便把路由表更新为“1，16，-”表示到网1距离是16（无法到达）是直接交付。但是很可能这样更新好的报文，要经过30s后才能发给R2。而R2可能已经先把自己的有关网1的报文“1，2，R1”先给到R1，即在R2收到R1的更新报文前，还发送原来的报文，因为这时R2并不知道R1发生了故障。</p><p>R1收到R2的更新报文后，误认为可经过R2到达网1，于是更新自己的路由表为“1，3，R2”，R2收到该路由信息，又会把自己的路由表更新为“1，4，R1”，诸如此循环，这样不断更新下去，直到R1和R2到网1的距离都增大到16时，R1和R2才知道网1是不可到达的，这就是坏消息传递慢的原因。</p><h3 id="4-3-OSPF协议与链路状态算法"><a href="#4-3-OSPF协议与链路状态算法" class="headerlink" title="4.3 OSPF协议与链路状态算法"></a>4.3 OSPF协议与链路状态算法</h3><h4 id="4-3-1-OSPF相关概念"><a href="#4-3-1-OSPF相关概念" class="headerlink" title="4.3.1 OSPF相关概念"></a>4.3.1 OSPF相关概念</h4><img src="https://pic.imgdb.cn/item/6634f0840ea9cb14034bae02.png" alt="计算机网络（四）——网络层——OSPF相关概念.png"><p>补充一下，与RIP适合小型网络不同，OSPF适应于大型网络。</p><p>RIP协议基于距离向量，而OSPF基于链路状态，链路状态则是指本路由器都和那些路由器相邻，以及相应链路的代价。</p><p>这里的代价用来表示费用、距离、时延等，这些都由网络管理人员来决定。</p><p>下面以思科路由器为例，看一下思科路由器的OSPF计算代价的方法：</p><img src="https://pic.imgdb.cn/item/6634f1820ea9cb14034e4379.png" alt="计算机网络（四）——网络层——OSPF代价计算举例.png"><h4 id="4-3-2-OSPF的工作原理"><a href="#4-3-2-OSPF的工作原理" class="headerlink" title="4.3.2 OSPF的工作原理"></a>4.3.2 OSPF的工作原理</h4><p>OSPF协议中，相邻路由器之间通过交互问候分组，建立和维护邻居关系，如下图：</p><img src="https://pic.imgdb.cn/item/6634f28c0ea9cb1403516927.png" alt="计算机网络（四）——网络层——OSPF的问候分组.png"><p>问候分组被封装在IP数据报中，发往组播地址224.0.0.5，其中IP首部的协议号字段取值应为89，来表明IP数据报的数据载荷为OSPF分组。</p><p>问候分组发送周期为10s，若40s未收到来自邻居路由器的问候分组，则认为该邻居路由器不可达，若收到，则重新开启40s计时。</p><p>使用OSPF的每个路由器都会产生链路状态通告，如下图：</p><img src="https://pic.imgdb.cn/item/6634f3ee0ea9cb140355ae5b.png" alt="计算机网络（四）——网络层——OSPF的链路状态通告.png"><p>使用OSPF的每个路由器还都有一个链路状态数据库用于存储链路状态通告，如下图：</p><img src="https://pic.imgdb.cn/item/6634f4900ea9cb14035793ee.png" alt="计算机网络（四）——网络层——OSPF的链路状态数据库.png"><p>各路由器有了LSDB以后，便可基于LSDB进行最短路径优先SPF计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。</p><img src="https://pic.imgdb.cn/item/6634f5400ea9cb14035991e4.png" alt="计算机网络（四）——网络层——OSPF的最短路径.png"><p>对于一个比较简单的网络拓扑，人类可以很轻松找到每个路由器到达其它路由器的最短路径。但是如果网络拓扑比较复杂，该项工作对人类而言就比较复杂，因此可以使用Dijkstra最短路径优先算法编制程序，让路由器执行该程序。</p><h4 id="4-3-3-OSPF的五种分组类型"><a href="#4-3-3-OSPF的五种分组类型" class="headerlink" title="4.3.3 OSPF的五种分组类型"></a>4.3.3 OSPF的五种分组类型</h4><img src="https://pic.imgdb.cn/item/6634f6fa0ea9cb14035e8abb.png" alt="计算机网络（四）——网络层——OSPF的五种分组类型.png"><h4 id="4-3-4-举例说明OSPF的工作过程"><a href="#4-3-4-举例说明OSPF的工作过程" class="headerlink" title="4.3.4 举例说明OSPF的工作过程"></a>4.3.4 举例说明OSPF的工作过程</h4><img src="https://pic.imgdb.cn/item/6634f7970ea9cb140360860d.png" alt="计算机网络（四）——网络层——OSPF的工作过程.png"><p>上图举例说明OSPF的工作过程，首先，相邻路由器周期性发送问候分组，以便建立和维护邻居关系。</p><p>建立邻居关系后，给邻居路由器发送数据库描述分组，也就是将自己的链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器。例如，R1收到R2的数据库描述分组后，发现自己缺少其中的某些链路状态项目，于是就给R2发送链路状态请求分组。R2收到后，将R1缺少的链路状态项目的详细信息封装在链路状态更新分组中发送给R1。R1收到后，将缺少的信息添加到自己的链路数据库里，并且向R2发送链路状态确认分组。当然R2也可以向R1请求自己链路状态缺少的信息。最终R1和R2的链路状态数据库达到一致，也就是链路状态数据库达到同步。</p><p>每30分钟或链路状态发送变化时，路由器都会发送链路状态更新分组，收到该分组的其它路由器将洪泛转发该分组，并给该路由器发回链路状态确认分组，这又称为新情况下的链路状态数据库同步。</p><h4 id="4-3-5-OSPF在多点接入网络中路由器邻居关系的建立"><a href="#4-3-5-OSPF在多点接入网络中路由器邻居关系的建立" class="headerlink" title="4.3.5 OSPF在多点接入网络中路由器邻居关系的建立"></a>4.3.5 OSPF在多点接入网络中路由器邻居关系的建立</h4><img src="https://pic.imgdb.cn/item/6634f7f60ea9cb140361820e.png" alt="计算机网络（四）——网络层——OSPF的邻居关系建立.png"><p>OSPF路由器在多点接入网络建立邻居关系时，如果不采用其他机制，将会产生大量的多播分组。</p><p>如上图，5台路由器接入多播网络，它们周期性地发送问候分组以建立和维护邻居关系，这些路由器中的任意两个路由器都互为邻居关系。如图右下所示，邻居关系数据为n(n-1)&#x2F;2，其中n是路由器数量，这样每个路由器要向其他（n-1）个路由器发送问候分组和链路状态更新分组。</p><p>为了减少发送分组的数量，OSPF采用选举指定路由器DR和备用的指定路由器BDR的方法。</p><p>如图左下，假设两台路由器被选为DR和BDR，所有的非BD&#x2F;BDR只与BR&#x2F;BDR建立邻居关系，邻居关系数量可降为2(n-2)+1。非BR&#x2F;BDR之间不能直接交换信息，需通过DR&#x2F;BDR交换。若DR出现问题，则由BDR顶替DR。</p><p>实现DR和BDR的选举就是各路由器之间交换一些选举参数，例如优先级、ID、接口等，然后根据选取规则选取BD&#x2F;BDR。</p><h4 id="4-3-6-OSPF的区域划分"><a href="#4-3-6-OSPF的区域划分" class="headerlink" title="4.3.6 OSPF的区域划分"></a>4.3.6 OSPF的区域划分</h4><img src="https://pic.imgdb.cn/item/6634f8440ea9cb14036246a1.png" alt="计算机网络（四）——网络层——OSPF的区域划分.png"><p>如图，在该自治系统内，所有路由器都采用OSPF协议，OSPF将该自治系统再划分为4个更小的区域，每个区域都有一个32比特的标识符，可以用点分十进制表示，例如主干区域的标识符必须为0，也可以表示成0.0.0.0。</p><p>主干区域用于连通其他区域，其他区域的标识符不能为0且互不相同。</p><p>每个区域规模不宜太大，一般所包含的路由器不宜超过200个。</p><p>划分区域的好处是，把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个自治系统，这样举减少了整个网络上的通信量。</p><p>如果路由器的所有接口都在一个区域内，则该路路由器称为区域内路由器。</p><p>用于实现区域连通的路由器称为区域边界路由器，该路由器一个接口用于连接自身所在区域，另一个接口用于连接主干区域。</p><p>主干区域内的路由器称为主干路由器，也可以把区域边界路由器看做是主干路由器。</p><p>在主干区域内还有一个路由器在专门和自治系统外的其它自主系统交换路由信息，这个路由器称为自治系统边界路由器。</p><p>采用分层次划分区域的方法，虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了，但这样做却能使每一个区域内部，交换路由信息的通信量大大减少，因而使OSPF协议能够用于规模很大的自治系统重。</p><h3 id="4-4-边界网关协议BGP"><a href="#4-4-边界网关协议BGP" class="headerlink" title="4.4 边界网关协议BGP"></a>4.4 边界网关协议BGP</h3><img src="https://pic.imgdb.cn/item/6634f9070ea9cb1403642ca3.png" alt="计算机网络（四）——网络层——BGP的提出1.png"><p>在不同的自治系统内，可以通过不同协议，通过不同的方式确定最佳路径，因此，在不同自治系统内，度量路由的代价可能不同，这就导致对于自治系统之间的路由选择，使用代价作为度量来寻找最佳路由是不行的。如下图：</p><img src="https://pic.imgdb.cn/item/663596d90ea9cb140393c786.png" alt="计算机网络（四）——网络层——代价度量.png"><p>AS4到AS5可以有很多路径，但这些路径由于没有统一的度量，所以找不到最佳路由。</p><p>除此以外，自治系统之间的路由选择还必须考虑相关策略（如政治、经济、安全等），如下图：</p><img src="https://pic.imgdb.cn/item/663597a00ea9cb140395c55d.png" alt="计算机网络（四）——网络层——自治系统选择路径策略.png"><p>上图左AS4想到达AS5，最好的路径肯定是走国内的自治系统。</p><p>而上图右，由于AS3不允许通过，所以只能走通过AS2的路。</p><p>由以上可以看出，BGP只能是力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。</p><p>下面来看BGP：</p><img src="https://pic.imgdb.cn/item/66359e120ea9cb1403a44a2a.png" alt="计算机网络（四）——网络层——BGP发言人.png"><p>在配置BGP时，首先要至少确定一个BGP发言人，一般来说两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是BGP边界路由器。</p><p>不同自治系统发言人要交换路由信息。BGP发言人除了运行BGP外，还必须运行自己所在自治系统所能使用的内部网关协议IGP。</p><img src="https://pic.imgdb.cn/item/66359ef10ea9cb1403a700e5.png" alt="计算机网络（四）——网络层——BGP自治系统连通图.png"><p>BGP发言人交换网络可达性的信息，当BGP发言人互相交换了网络可达性信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构，不存在回路的自治系统连通图，如上图右下，是自治系统AS1的某个BGP发言人构造的自治系统连通图。</p><p>BGP适用于多级结构的因特网，下面给出一个BGP发言人交换路径向量的例子：</p><img src="https://pic.imgdb.cn/item/6635a2b90ea9cb1403aff81b.png" alt="计算机网络（四）——网络层——路径交换例子.png"><p>如上图，AS2的BGP发言人告诉AS1要到达N1,N2,N3,N4可经过AS2，AS1收到以后其发言人告诉AS3要到达N1,N2,N3,N4可沿路径（AS1,AS2），这里的（AS1,AS2）就是路径向量。AS3收到这条路径信息后，如果AS3也包含在其中，则不能采用这条路径，否则会兜圈子。</p><p>接下来介绍比较常用的BGP-4（BGP版本4）中规定的四种报文：</p><img src="https://pic.imgdb.cn/item/6635a3990ea9cb1403b28028.png" alt="计算机网络（四）——网络层——BGP-4报文.png"><p>这里贴一道比较有结合性的考研真题：</p><img src="https://pic.imgdb.cn/item/6635a3c30ea9cb1403b2d294.png" alt="计算机网络（四）——网络层——例题.png"><p>下面对BGP进行总结：</p><img src="https://pic.imgdb.cn/item/6635a4380ea9cb1403b3c84b.png" alt="计算机网络（四）——网络层——BGP相关知识总结.png"><h2 id="5-IP多播"><a href="#5-IP多播" class="headerlink" title="5. IP多播"></a>5. IP多播</h2><h3 id="5-1-IP多播技术的相关基本概念"><a href="#5-1-IP多播技术的相关基本概念" class="headerlink" title="5.1 IP多播技术的相关基本概念"></a>5.1 IP多播技术的相关基本概念</h3><img src="https://pic.imgdb.cn/item/6635b78f0ea9cb1403e65d2a.png" alt="计算机网络（四）——网络层——IP数据报的三种传输方式.png"><p>多播是一种实现一对多通信的技术，与传统单播一对一通信相比，多播可以极大地节省网络资源。</p><p>在因特网上进行的多播称为IP多播。</p><p>多播与单播和广播不同，单播是一对一，广播是一对多的全部，而多播则是一对多的部分。</p><p>下图给出多播的示例：</p><img src="https://pic.imgdb.cn/item/6635b85d0ea9cb1403e89d77.png" alt="计算机网络（四）——网络层——多播例子.png"><p>上图左为单播通信的方式，上图右为多播通信的方式，从图中不难看出，当多播组的成员数量很大时，采用多播方式可以显著地减少网络中各种资源的消耗。</p><p>接下来介绍一下IP多播地址和多播组：</p><img src="https://pic.imgdb.cn/item/6635b97e0ea9cb1403ebbabe.png" alt="计算机网络（四）——网络层——IP多播地址和多播组知识点.png"><p>多播地址就是IPv4中的D类地址，根据D类地址的规则，我们可以得出IP多播地址的范围与最大多播地址和最小多播地址，如下图：</p><img src="https://pic.imgdb.cn/item/6635b9f10ea9cb1403ecb14c.png" alt="计算机网络（四）——网络层——IP多播地址的范围.png"><p>对于IPv4多播地址，还可以分为以下几类：</p><img src="https://pic.imgdb.cn/item/6635ba5a0ea9cb1403edcc88.png" alt="计算机网络（四）——网络层——IPv4多播地址的分类.png"><p>对于IP的多播，可以分为只在本局域网上进行的硬件多播和在因特网上进行的多播，如下：</p><img src="https://pic.imgdb.cn/item/6635ba9e0ea9cb1403ee955a.png" alt="计算机网络（四）——网络层——IP多播.png"><p>但是在因特网进行的多播，在把多播数据报交付给多播组成员时，最后阶段还是要经过硬件多播，所以接下来着重看一下硬件多播的问题。</p><h3 id="5-2-在局域网上进行硬件多播"><a href="#5-2-在局域网上进行硬件多播" class="headerlink" title="5.2 在局域网上进行硬件多播"></a>5.2 在局域网上进行硬件多播</h3><img src="https://pic.imgdb.cn/item/6635bc070ea9cb1403f28229.png" alt="计算机网络（四）——网络层——硬件多播.png"><p>硬件多播的概念如上图，封装过程就是把IP多播数据报交给链路层添加一个帧头和帧尾，使之封装成一个多播MAC帧。IP多播数据报首部中的目的IP地址字段的值，是某个IP多播地址。多播MAC帧帧头中的目的MAC地址，就是由该IP多播地址映射而来的某个多播MAC地址。</p><p>接下来看一下多播MAC地址的构成：</p><img src="https://pic.imgdb.cn/item/6635bdea0ea9cb1403f7c36e.png" alt="计算机网络（四）——网络层——多播MAC地址.png"><p>多播MAC地址由48比特组成，第一个字节发送1表示是多播MAC地址，前24位固定为01-00-5E，第25位也固定为0。剩余23个比特可任意变化，全取0，可以得到最小多播MAC地址01-00-5E-00-00-00，全取1，可以得到最大多播MAC地址01-00-5E-7F-FF-FF。</p><p>下面，介绍一下把32bit的IPv4地址映射成48bit的多播MAC地址的具体方法。</p><img src="https://pic.imgdb.cn/item/6635cf550ea9cb14032b8020.png" alt="计算机网络（四）——网络层——32bitIP映射成48bitMAC.png"><p>32bitIP映射成48bitMAC的方式如上图，D类IP一共32位，前4位固定为1110，剩余28位可变化，而MAC一共48位，前25位固定，所以剩23位可变化，将IP映射成MAC就是将IP的后23位放到MAC的后23位里。</p><p>由于IP多播地址可变化的28比特前5个比特无法映射到MAC多播地址，这会造成IP多播地址与多播MAC地址的映射关系并不是唯一的。比如下面的例子：</p><img src="https://pic.imgdb.cn/item/6635d0b40ea9cb14032fb563.png" alt="计算机网络（四）——网络层——多个IP映射成一个MAC.png"><p>从上面可以看到，如果两个IP多播地址仅在未映射的5位有变化，则两个IP多播地址映射成的多播MAC地址是一样的。这也说明了，<font color=green><strong>IP多播地址与多播MAC地址的映射关系不是唯一的</strong></font>，因此收到IP多播数据报的主机还要在网际层利用软件进行过滤。如下面的例子：</p><img src="https://pic.imgdb.cn/item/6635d2540ea9cb1403343291.png" alt="计算机网络（四）——网络层——硬件多播处理同MAC.png"><p>如图，假设有一个封装有IP多播数据报的多播MAC帧传送到了这些多播组所在的局域网，该多播数据报的目的IP地址是226.128.9.26，多播MAC帧的目的MAC地址就是该IP多播地址映射出的多播MAC地址01-00-5E-00-09-1A。当该多播MAC帧到达各主机后，先匹配多播MAC地址，上图左和中的主机匹配成功，MAC层接受该MAC帧，右主机匹配失败，MAC层丢弃MAC帧。匹配成功的主机将MAC帧里封装的IP多播数据报交付上层网际层处理，网际层根据多播数据报的目的IP地址为IP多播地址226.128.9.26再次进行匹配处理，匹配成功网际层接受；匹配失败，网际层丢弃。</p><h3 id="5-3-在因特网上进行IP多播需要的两种协议"><a href="#5-3-在因特网上进行IP多播需要的两种协议" class="headerlink" title="5.3 在因特网上进行IP多播需要的两种协议"></a>5.3 在因特网上进行IP多播需要的两种协议</h3><p>要在因特网上进行IP多播，就必须要考虑<strong>IP多播数据报经过多个多播路由器进行转发</strong>的问题。<strong>多播路由器</strong>必须根据IP多播数据报首部中的<strong>IP多播地址</strong>，将其转发到有该多播组成员的局域网。</p><p>这里就产生了疑问，路由器如何知道自己各接口所在局域网中是否有某个多播组的成员？这就需要使用网际组管理协议IGMP。</p><p>IGMP相关概念如下：</p><img src="https://pic.imgdb.cn/item/6635dbc50ea9cb14034e7132.png" alt="计算机网络（四）——网络层——IGMP协议.png"><p>仅使用IGMP并不能在因特网上进行IP多播，还需要使用多播路由选择协议。</p><p>多播路由选择协议的工作原理如下：</p><img src="https://pic.imgdb.cn/item/6635dc390ea9cb14034fca12.png" alt="计算机网络（四）——网络层——多播路由选择协议.png"><p>经过对IGMP和多播路由选择协议的初步了解，不难发现，多播源先通过多播路由选择协议，找到拥有该多播组成员的路由器，然后路由器通过IGMP协议将多播数据报发给网段内对应的多播组成员。具体例子可以参考下图下半部分。</p><img src="https://pic.imgdb.cn/item/6635dd4d0ea9cb14035484cd.png" alt="计算机网络（四）——网络层——多播路由选择协议和IGMP结合的例子.png"><p>对于多播路由选择和IGMP实现的IP多播，有一点要说一下，为了覆盖多播组的所有成员，多播转发树可能要经过一些没有多播组成员的路由器，如上图R2，所以题目里如果出现类似R2的路由器，不要怀疑题目出错了。</p><h3 id="5-4-网际组管理协议IGMP"><a href="#5-4-网际组管理协议IGMP" class="headerlink" title="5.4 网际组管理协议IGMP"></a>5.4 网际组管理协议IGMP</h3><h4 id="5-4-1-IGMP报文"><a href="#5-4-1-IGMP报文" class="headerlink" title="5.4.1 IGMP报文"></a>5.4.1 IGMP报文</h4><img src="https://pic.imgdb.cn/item/6635ed2c0ea9cb14037f765f.png" alt="计算机网络（四）——网络层——IGMP报文.png"><p>IGMP应用于网段内，路由器通过IGMP协议将报文发送到该网段内的对应的组员处。</p><p>接下来，举例看一下IGMP的工作原理。</p><h4 id="5-4-2-加入多播组"><a href="#5-4-2-加入多播组" class="headerlink" title="5.4.2 加入多播组"></a>5.4.2 加入多播组</h4><img src="https://pic.imgdb.cn/item/6635ee240ea9cb140381b634.png" alt="计算机网络（四）——网络层——IGMP加入多播组.png"><p>一开始主机C属于多播组228.1.1.1，在R1的多播组列表里已经记录有该多播组，主机D不属于任何多播组。现在主机A和B都希望加入多播组226.0.9.26。假设主机B首先向以太网发送IGMP成员报告报文，其内有所希望加入的多播组的IP多播地址、IP数据报的目的地址及以太网多播帧的目的地址。</p><p>以太网中A、C、D和R1都会收到该多播帧。</p><p>D不属于任何多播组，所以会直接将该帧丢弃。</p><p>C发现多播MAC地址不匹配也会直接丢弃。</p><p>A发现该多播帧的目的地址与自己希望加入的IP多播组的多播MAC地址相同，因此在MAC层接受该帧，并将其所封装的IP数据报交付上层的网际层处理，网际层发现该多播数据报的目的地址与自己希望加入的多播组的IP多播地址相同，因此接受该多播数据报，并将其所封装的IGMP成员报告报文交付IGMP进行解析。这样A就知道这是来自同一IP多播组的另一个成员的IGMP成员报告报文，于是取消自己准备发送的IGMP成员报告报文。</p><p>R1收到该多播帧后，提出其中的IGMP成员报告报文，解析该报文后就知道了自己所直连网络中，有一个新的IP多播组226.0.9.26。因此将IP多播组地址226.0.9.26添加到自己的多播组列表中。</p><h4 id="5-4-3-监视多播组成员的变化"><a href="#5-4-3-监视多播组成员的变化" class="headerlink" title="5.4.3 监视多播组成员的变化"></a>5.4.3 监视多播组成员的变化</h4><img src="https://pic.imgdb.cn/item/6635f94d0ea9cb1403a10b8d.png" alt="计算机网络（四）——网络层——IGMP监视多播组的成员变化.png"><p>多播路由器每隔125秒就向其直连网络发送一个封装有IGMP成员查询报文的IP多播数据报。IGMP成员查询报文内主要是要查询的特定多播组的IP多播地址，这里以IP多播地址226.0.9.26为例，当然也可以是0.0.0.0，这表示查询全部多播组。IP数据报的目的地址是224.0.0.1，这是一个特殊的IP多播地址，在本网络中所有参加多播的主机和路由器的网际层都会接受该多播数据报。以太网多播帧的目的地址是由IP多播数据报的目的地址224.0.0.1映射而来的多播MAC地址。</p><p>以太网中A、B、C、D都会收到该多播帧，由于D不属于任何多播组会直接丢弃该帧。</p><p>主机A、B、C发现该多播帧的目的地址是01-00-5E-00-00-01，其可能对应的IP多播地址为224.0.0.1这个特殊的IP多播地址，于是在MAC层接受该多播帧，在网际层接受该多播帧所封装的IP多播数据报，并将IP多播数据报所封装的IGMP成员查询报文交付IGMP进行解析。</p><p>这时主机B就知道这是来自多播路由器的IGMP成员查询报文，由于查询的多播组与自己的多播组是同一个多播组，于是决定2s后进行响应。</p><p>同理主机A就知道这是来自多播路由器的IGMP成员查询报文，由于查询的多播组与自己的多播组是同一个多播组，于是决定8s后进行响应。</p><p>主机C就知道这是来自多播路由器的IGMP成员查询报文，由于查询的多播组与自己的多播组不是同一个多播组，于是决定不响应。</p><p>收到IGMP成员查询报文的被查询多播组的任何成员，将会发送IGMP成员报告报文作为应答，为了减少不必要的重复应答，每个多播组只需要有一个成员应答即可，因此采用了一种延迟响应的策略，那就是收到IGMP成员查询报文的主机，并不是立即响应，而是在1~10s的范围内，等待一段随机时间后再进行响应，如果在这段随机时间内，收到了同组其他成员发送的IGMP成员报告报文就取消响应。</p><p>在本例中，主机B决定在2秒后响应，主机A决定在8秒后响应，大约2s后，主机B发送IGMP成员报告报文，下面的过程与加入多播组的情况一致，主机A收到后，取消相应。R1收到后，会更新对226.0.9.26的125s计时。</p><p>下面假设一下，主机C不再是多播组228.1.1.1的成员，该如何进行呢？</p><img src="https://pic.imgdb.cn/item/6635fafa0ea9cb1403a46c2f.png" alt="计算机网络（四）——网络层——IGMP监视多播组的成员不再属于多播组.png"><p>如上，当C不是228.1.1.1的成员，每隔125s，多播路由器会发送查询报文，当发送对228.1.1.1的查询报文时，主机C、D的MAC层丢弃该帧，主机A、B的MAC层接受该帧，网际层接受该多播帧封装的IP多播数据报，并将IP多播数据报所封装的IGMP成员查询报文交付IGMP进行解析，发现是查询228.1.1.1的，与自己无关，因此不响应。R1由于长时间收不到该多播组的响应，于是将其从多播列表中删除。</p><p>这里有几点需要说明一下，如下图：</p><img src="https://pic.imgdb.cn/item/6635fc1d0ea9cb1403a6c48e.png" alt="计算机网络（四）——网络层——IGMP监视多播组的说明.png"><h4 id="5-4-4-退出多播组"><a href="#5-4-4-退出多播组" class="headerlink" title="5.4.4 退出多播组"></a>5.4.4 退出多播组</h4><img src="https://pic.imgdb.cn/item/6635fccd0ea9cb1403a8e453.png" alt="计算机网络（四）——网络层——IGMP退出多播组.png"><p>下面举例说明退出多播组的过程：</p><img src="https://pic.imgdb.cn/item/6635fd470ea9cb1403aa647c.png" alt="计算机网络（四）——网络层——IGMP退出多播组工作过程.png"><p>假设主机C要退出该多播组，可以主动发送一个IGMP离开组报文，而不必等待多播路由器R1的查询。IGMP离开组报文的封装细节如上图右上，离开祖报文的内容要包含主机要退出的多播组的地址，封装离开组报文的IP多播数据报的目的地址位224.0.0.2，这也是一个特殊的IP多播地址，在本网络中的所有多播路由器的网际层都会接受该多播数据报。</p><p>以太网里的A、B、D、R1都会收到封装有IGMP离开组报文的多播帧，主机D的MAC层丢弃。主机A、B的MAC层接受，但根据其封装的IP多播数据报的目的地址与自己的不一样，会在网际层丢弃。R1收到后就知道有成员离开了，但暂时不删除该多播组，而是重新会发送一个该多播组的查询报文，查看是否还有其他主机属于该多播组成员，如果没有响应，就会删除该多播组。</p><h3 id="5-5-多播路由选择协议"><a href="#5-5-多播路由选择协议" class="headerlink" title="5.5 多播路由选择协议"></a>5.5 多播路由选择协议</h3><p>写在开头：这部分在王道里没有细讲，只看王道很难理解，所以这部分的知识是在湖科大的课里学的，这里把视频链接贴在这，不懂的可以跳转视频：</p><p><a href="https://www.bilibili.com/video/BV16f4y1Z7bS/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.1~4.7.2 IP多播技术的相关基本概念、IP多播地址和多播组_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1pV4y1n7wG/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.3 在局域网上进行硬件多播_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1dv4y1T7oH/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.4 在因特网上进行IP多播需要的两种协议_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1cU4y1D797/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.5 网际组管理协议IGMP_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1YB4y1e7NV/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.6 多播路由选择协议_哔哩哔哩_bilibili</a></p><h4 id="5-5-1-多播路由器协议基础"><a href="#5-5-1-多播路由器协议基础" class="headerlink" title="5.5.1 多播路由器协议基础"></a>5.5.1 多播路由器协议基础</h4><img src="https://pic.imgdb.cn/item/6635ff280ea9cb1403af64a0.png" alt="计算机网络（四）——网络层——多播路由选择基础.png"><p>目前有两种方法构建多播转发树，一个是基于源树，另一个是组共享树。</p><h4 id="5-5-2-基于源树多播路由选择"><a href="#5-5-2-基于源树多播路由选择" class="headerlink" title="5.5.2 基于源树多播路由选择"></a>5.5.2 基于源树多播路由选择</h4><img src="https://pic.imgdb.cn/item/663600500ea9cb1403b1a982.png" alt="计算机网络（四）——网络层——基于源树多播路由选择.png"><p>要建立广播转发树，除了使用反向路径广播算法还可以使用洪泛法，如下图：</p><img src="https://pic.imgdb.cn/item/663600c70ea9cb1403b2d269.png" alt="计算机网络（四）——网络层——洪泛法.png"><p>上图是使用洪泛法构建广播转发树的情况，在无环路网络中，R1向R3发送广播分组，R3收到后，复制该广播分组，并向自己的所有下游邻居路由器转发，即向除R1外的所有路由器转发，以此类推，这种方法最终可将广播分组的副本传送到网络中的所有结点。</p><p>但是，如果网络中存在环路，使用洪泛法会产生严重的问题，即广播分组的一个或多个副本会在环路中永久兜圈，如上图右，这种无休止的广播分组和转发，最终将导致该网络中产生大量的广播分组，使得网络带宽被完全占用。</p><p>利用反向路径广播RPB算法生成的广播转发树，就不会存在环路。</p><img src="https://pic.imgdb.cn/item/663602570ea9cb1403b7f6fd.png" alt="计算机网络（四）——网络层——RPB.png"><p>下面举例说明反向路径多播（RPM）算法：</p><p>源点向R1发送一个广播分组，R1收到后向其邻居路由器R2，R3转发，如下图：</p><img src="https://pic.imgdb.cn/item/6636048f0ea9cb1403bd8814.png" alt="计算机网络（四）——网络层——RPM1.png"><p>R2，R3互相丢弃彼此收到的分组：</p><img src="https://pic.imgdb.cn/item/663604e50ea9cb1403be4740.png" alt="计算机网络（四）——网络层——RPM2.png"><p>R4，R5转发：</p><img src="https://pic.imgdb.cn/item/663605200ea9cb1403bebfec.png" alt="计算机网络（四）——网络层——RPM3.png"><p>R4，R5互相丢弃彼此收到的分组：</p><img src="https://pic.imgdb.cn/item/6636054c0ea9cb1403bf1e3a.png" alt="计算机网络（四）——网络层——RPM4.png"><p>有多个最短路径时，选择IP小的做最短路径：</p><img src="https://pic.imgdb.cn/item/663605790ea9cb1403bfa722.png" alt="计算机网络（四）——网络层——RPM5.png"><p>得到广播转发树：</p><img src="https://pic.imgdb.cn/item/663605f10ea9cb1403c13b9d.png" alt="计算机网络（四）——网络层——RPM6.png"><p>判断非成员路由器，准备进行剪出：</p><img src="https://pic.imgdb.cn/item/663606340ea9cb1403c2216e.png" alt="计算机网络（四）——网络层——RPM7.png"><p>非成员路由器向上层发送剪枝报完，将自己剪除，形成多播转发树：</p><img src="https://pic.imgdb.cn/item/663606810ea9cb1403c32ba8.png" alt="计算机网络（四）——网络层——RPM8.png"><p>如果被剪除的路由器通过IGMP又发现了新的多播组成员，则会向上游路由器发送一个嫁接报文，并重新加入到多播转发树中：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240504175902622.png" alt="image-20240504175902622"></p><p>这里有一点要说明一下，尽管R2没有多播组成员，但也要保留R2以确保多播转发树的连通性。</p><h4 id="5-5-3-组共享树多播路由选择"><a href="#5-5-3-组共享树多播路由选择" class="headerlink" title="5.5.3 组共享树多播路由选择"></a>5.5.3 组共享树多播路由选择</h4><img src="https://pic.imgdb.cn/item/663607b40ea9cb1403c93785.png" alt="计算机网络（四）——网络层——组共享树多播路由选择过程.png"><p>上面是组共享树多播路由选择的工作过程，下面给个例子：</p><img src="https://pic.imgdb.cn/item/66360bb60ea9cb1403d3f1bf.png" alt="计算机网络（四）——网络层——基于核心的生成树的建立过程.png"><p>生成树的建立过程很简单，便不说了，根据上面的步骤可以自己推导，有问题可以去5.5开头的地方跳转视频。</p><p>这里讲一下假设源主机给该多播组发送了一个多播分组，当R1收到后，会将该多播分组封装到目的地址为核心路由器R5的单播分组中，将该单播分组发送给R5，R5收到后，将被封装在单播分组中的多播分组解封出来，在多播转发树上洪泛转发。</p><h4 id="5-5-4-因特网的多播路由选择协议"><a href="#5-5-4-因特网的多播路由选择协议" class="headerlink" title="5.5.4 因特网的多播路由选择协议"></a>5.5.4 因特网的多播路由选择协议</h4><img src="https://pic.imgdb.cn/item/66360c400ea9cb1403d5c40c.png" alt="计算机网络（四）——网络层——因特网的多播路由选择协议.png"><h2 id="6-移动IP"><a href="#6-移动IP" class="headerlink" title="6. 移动IP"></a>6. 移动IP</h2><p>首先，据下图，了解一下有关移动IP的相关概念：</p><img src="https://pic.imgdb.cn/item/6634f97c0ea9cb1403655644.png" alt="计算机网络（四）——网络层——移动IP概念.png"><p>上面的概念，用一个例子来说，就是某个用户在A地买了个手机，办理了相关上网服务，那这个手机就具有了永久IP地址，永久居所为A地，所以A地为本地代理。当该用户去了B地，那该设备就要暂时归属B地代理，因为该手机的永久居所不是B地，所以此时B地就是外部代理，由于手机在B地，手机通信需要通过B地的网络，此时B地给手机转发信息的地址就是转交地址。</p><p>下面通过一个移动IP通信过程实例，来加深理解：</p><img src="https://pic.imgdb.cn/item/6634f9ba0ea9cb140365efad.png" alt="计算机网络（四）——网络层——移动IP通信过程.png"><h2 id="7-网络层设备"><a href="#7-网络层设备" class="headerlink" title="7. 网络层设备"></a>7. 网络层设备</h2><p>网络层的主要设备是路由器，如下图：</p><img src="https://pic.imgdb.cn/item/6634fc1a0ea9cb14036ea2a2.png" alt="计算机网络（四）——网络层——路由器.png"><p>上图是路由器的内部结构图，可以看到主要由路由选择和分组转发两部分组成。</p><p>路由选择部分也叫控制部分，这部分的核心组件是路由选择处理机，其功能是根据路由选择协议构造路由表毛病定期维护和更新。</p><p>分组转发部分又包含三个部分，分别是多个输入端口，交换接口，多个输出端口。这部分核心的结构是交换结构，其可以根据转发表对分组进行转发。</p><p>这里再次区分一下转发和路由选择，转发是在路由器内部，决定从哪个端口转发，而路由选择则是宏观的，决定着走哪条路径，把信息从源站发往目的站。</p><p>注意，路由器收到不同的分组，其处理过程不一样，如果是RIP、OSPF等分组，会把分组交由路由选择处理机处理，若收到数据分组，则查找转发表直接输出。</p><p>接下来看一下输入端口和输出端口的详细信息：</p><img src="https://pic.imgdb.cn/item/6634fc530ea9cb14036f56e4.png" alt="计算机网络（四）——网络层——路由器的输入端口.png"><p>上面是输入端口的详细信息，首先会从线路上接收分组，交由物理层处理，物理层只进行比特接受。接下里到链路层，链路层按照协议，接收数据帧，然后把帧头帧尾去掉，交由网络层。网络层会对分组进行判断，决定着把分组直接转发还是交付处理机。</p><p>从上图，还可以看到，在网络层处理时，会有分组排队，这是因为有时延产生，因为第一个分组到此处，会决定着交付处理机还是转发，转发还需要查表，在这段延迟时间内，会有接二连三的分组来到这里等待处理，所以需要排队。</p><p>下面看输出端口是怎么对分组进行处理的：</p><img src="https://pic.imgdb.cn/item/6634fc7e0ea9cb14036fd36e.png" alt="计算机网络（四）——网络层——路由器的输出端口.png"><p>输出端口会先从交换结构处获得分组，然后再通过链路层和物理层向线路发送分组。</p><p>上图也不难看出，在网络层处依然设计了一个分组排队缓存区，如果交换结构传过来的分组速度超出链路发送速度，就会有一些分组在缓存处排队。当缓存处溢出，就会丢弃后面再进入队列的分组，所以说路由器中的输入输出队列产生溢出是造成分组丢失的重要原因。</p><p>下面可以看一下，路由器与其他两层设备的区别：</p><img src="https://pic.imgdb.cn/item/6634fca10ea9cb1403703b24.png" alt="计算机网络（四）——网络层——三层设备的区别.png"><p>接下来看最后一个知识点，路由表和路由转发，如下图：</p><img src="https://pic.imgdb.cn/item/6634fcdf0ea9cb140370f192.png" alt="计算机网络（四）——网络层——路由表和路由转发.png"><p>总结一下，路由表根据路由选择算法得到，转发表根据路由表得到。路由表主要选择下一跳走哪个路由器或下一跳IP地址是什么，转发表还要根据主机的具体信息，确定输出的端口。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（四）——指令系统</title>
      <link href="/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（四）——指令系统"><a href="#计算机组成原理（四）——指令系统" class="headerlink" title="计算机组成原理（四）——指令系统"></a>计算机组成原理（四）——指令系统</h1><p>写在开头：在第一章计算机组成的系统里，我们说过控制器有两个功能，第一种功能就是控制器去解析各种各样的指令，然后根据不同的指令去指挥其他部件来协调着工作，所以这一章，重点探讨控制器需要支持的指令如何设计。下一章重点探讨控制器如何协调着不同的部件来配合着工作。</p><h2 id="1-指令系统"><a href="#1-指令系统" class="headerlink" title="1. 指令系统"></a>1. 指令系统</h2><h3 id="1-1-指令格式"><a href="#1-1-指令格式" class="headerlink" title="1.1 指令格式"></a>1.1 指令格式</h3><h4 id="1-1-1-指令的定义"><a href="#1-1-1-指令的定义" class="headerlink" title="1.1.1 指令的定义"></a>1.1.1 指令的定义</h4><img src="https://pic.imgdb.cn/item/6628b4cf0ea9cb1403cb9b41.png" alt="计算机组成原理（四）——指令系统——指令的定义.png"><h4 id="1-1-2-指令的格式"><a href="#1-1-2-指令的格式" class="headerlink" title="1.1.2 指令的格式"></a>1.1.2 指令的格式</h4><img src="https://pic.imgdb.cn/item/6628b5f10ea9cb1403cdd82b.png" alt="计算机组成原理（四）——指令系统——指令的格式.png"><p>指令由操作码（OP）和地址码（A）组成，操作码决定着用户要干什么，地址码决定着对谁干，所以根据不同的操作码，对应的地址码的数目也可能出现变化。如加减运算指令，就需要两个地址码，而停机指令，就不需要地址码。</p><p>根据一条指令可能包含几个地址码，可以将指令分为零地址指令、一地址指令、二地址指令、三地址指令、四地址指令等。</p><h4 id="1-1-3-零地址指令"><a href="#1-1-3-零地址指令" class="headerlink" title="1.1.3 零地址指令"></a>1.1.3 零地址指令</h4><img src="https://pic.imgdb.cn/item/6628b9790ea9cb1403d41bb1.png" alt="计算机组成原理（四）——指令系统——零地址指令.png"><p>零地址指令，顾名思义，这类指令只需要给出一个操作码，而不需要给地址码。像空操作、停机、关中断等指令都是零地址指令。</p><p>这里有一类比较特殊，就是堆栈计算机，两个操作数隐含在栈顶和次栈顶，计算结果压回栈顶。这里以数据结构里学的后缀表达式为例，如图，先把A压入栈，再把B压入栈，当扫描到运算符时，就代表着扫描到零地址指令，将栈顶与次栈顶元素出栈做运算，运算完再压回栈。在这段过程中，扫描到一个运算符就相当于扫描到了一个零地址指令，而操作数隐含在栈里，并非显示指明。</p><h4 id="1-1-4-一地址指令"><a href="#1-1-4-一地址指令" class="headerlink" title="1.1.4 一地址指令"></a>1.1.4 一地址指令</h4><img src="https://pic.imgdb.cn/item/6628bc5d0ea9cb1403da5a49.png" alt="计算机组成原理（四）——指令系统——一地址指令.png"><p>一地址指令有两种情况：</p><p>第一种，只需要单操作数，指令OP(A<sub>1</sub>) -&gt; A<sub>1</sub>的含义是从 A<sub>1</sub>地址上取出数据，经过OP操作（即操作运算）后，再把数据存入 A<sub>1</sub>地址内。完成这样的一条指令要经历3次访存，第一次从主存里取出地址，第二次从主存里取出该地址上的数据，第三次，将操作以后的数据写入该地址里。</p><p>第二种，虽然需要两个操作数，但其中一个操作数隐含在某个寄存器里。这里以隐含在ACC里为例，指令(ACC)OP( A<sub>1</sub>) -&gt; ACC的含义是取出ACC寄存器里的数据与 A<sub>1</sub>地址里的数据，两个操作数进行OP操作，操作果写入ACC寄存器。这条指令执行过程中经历2次访存，第一次，从主存里取出 A<sub>1</sub>地址，第二次， 从主存里取出 A<sub>1</sub>地址里的数据。注意，放到ACC里是不需要访问主存的，因为ACC在运算器里而不是在主存里。</p><h4 id="1-1-5-二、三地址指令"><a href="#1-1-5-二、三地址指令" class="headerlink" title="1.1.5 二、三地址指令"></a>1.1.5 二、三地址指令</h4><img src="https://pic.imgdb.cn/item/6628bf130ea9cb1403dfa959.png" alt="计算机组成原理（四）——指令系统——二、三地址指令.png"><p><strong>二地址指令常用于需要两个操作数的算数运算、逻辑运算相关指令。</strong></p><p>指令(A<sub>1</sub>)OP(A<sub>2</sub>) -&gt; A<sub>1</sub>的含义是取出A<sub>1</sub>和A<sub>2</sub>地址上的操作数进行OP运算，运算结果存入A<sub>1</sub>地址。这里A<sub>1</sub>也称为目的操作数，A<sub>2</sub>也称为源操作数。</p><p>对于二地址指令，完成一条指令需要访存4次，第一次，取出A<sub>1</sub>和A<sub>2</sub>地址；第二次读A<sub>1</sub>地址上数据；第三次读A<sub>2</sub>地址上数据，第四次将数据写入A<sub>1</sub>地址内。</p><p><strong>三地址指令也常用于需要两个操作数的算数运算、逻辑运算相关指令。</strong></p><p>指令(A<sub>1</sub>)OP(A<sub>2</sub>) -&gt; A<sub>1</sub>的含义是取出A<sub>1</sub>和A<sub>2</sub>地址上的操作数进行OP运算，运算结果存入A<sub>1</sub>地址。这里A<sub>1</sub>也称为目的操作数，A<sub>2</sub>也称为源操作数。</p><p>对于三地址指令，完成一条指令需要访存4次，第一次，取出A<sub>1</sub>和A<sub>2</sub>地址；第二次读A<sub>1</sub>地址上数据；第三次读A<sub>2</sub>地址上数据，第四次将数据写入A<sub>3</sub>地址内。</p><p>到这里可以发现三地址指令和二地址指令基本一致，不同的点在于最后写入数据的地方，三地址指令明确规定了最后要把数据写到哪个地址上。</p><h4 id="1-1-6-四地址指令"><a href="#1-1-6-四地址指令" class="headerlink" title="1.1.6 四地址指令"></a>1.1.6 四地址指令</h4><img src="https://pic.imgdb.cn/item/6628bfa60ea9cb1403e0ca72.png" alt="计算机组成原理（四）——指令系统——四地址指令.png"><p>四地址指令又和三地址指令一样，所以这里说下不同的地方，四地址指令比三地址指令多了一个地址A<sub>4</sub>，这个地址指向下一条指令，在第一章里，我们说过每条指令结束以后，PC会自加1，在四地址指令里，PC不是自加1，而是指向A<sub>4</sub>地址上指令。</p><p>到这里可以思考一个问题，地址码的位数会产生什么影响呢？</p><p>一个n位地址码，说明它的直接寻址范围是2<sup>n</sup>，所以一个地址码位数越长，说明它的寻址范围、寻址能力也就越强。</p><p>若规定指令总长度固定不变，则地址码数量越多，每个地址码的位数就越短，寻址能力就越差。</p><h4 id="1-1-7-按指令长度对指令分类"><a href="#1-1-7-按指令长度对指令分类" class="headerlink" title="1.1.7 按指令长度对指令分类"></a>1.1.7 按指令长度对指令分类</h4><img src="https://pic.imgdb.cn/item/6628c05e0ea9cb1403e23c93.png" alt="计算机组成原理（四）——指令系统——按指令长度分类.png"><p>对于指令字长，首先要区分指令字长、机器字长和存储字长的概念。</p><p>根据指令字长还可以将指令分为半字长指令、单字长指令、双字长指令，这里的指令长度指的是机器字长的几倍。显然，指令字长会影响机器取指令的时间。</p><p>有的计算机系统中，所以指令的长度都相等，采用这种策略的指令系统称为定长指令字结构系统。</p><p>而有的计算机系统中，所以指令的长度不一定相等，采用这种策略的指令系统称为变长指令字结构系统。</p><h4 id="1-1-8-按操作码长度对指令分类"><a href="#1-1-8-按操作码长度对指令分类" class="headerlink" title="1.1.8 按操作码长度对指令分类"></a>1.1.8 按操作码长度对指令分类</h4><img src="https://pic.imgdb.cn/item/6628c0cd0ea9cb1403e2ff64.png" alt="计算机组成原理（四）——指令系统——按操作码长度分类.png"><p>按操作码长，可将指令分为定长操作码和可变长操作码。</p><p>对于定长操作码来说，控制器的译码电路设计简单，但灵活性不够；而可变长操作码，控制器的译码电路设计复杂，但灵活性高。</p><p>对于定长操作码，如果操作码长n位，则可以确定可以设计2<sup>n</sup>条指令；但对于可变长操作码来说，指令条数不好确定。</p><p>将定长指令字结构和可变长操作码相结合，可以扩展操作码，即不同地址数的指令使用不同长度的操作码。</p><h4 id="1-1-9-按操作类型分类"><a href="#1-1-9-按操作类型分类" class="headerlink" title="1.1.9 按操作类型分类"></a>1.1.9 按操作类型分类</h4><p>​</p><img src="https://pic.imgdb.cn/item/6628c1640ea9cb1403e40f92.png" alt="计算机组成原理（四）——指令系统——按操作类型分类.png"><h4 id="1-1-10-指令格式小结"><a href="#1-1-10-指令格式小结" class="headerlink" title="1.1.10 指令格式小结"></a>1.1.10 指令格式小结</h4><img src="https://pic.imgdb.cn/item/6628c18d0ea9cb1403e45ed9.png" alt="计算机组成原理（四）——指令系统——指令格式小结.png"><h3 id="1-2-扩展操作码指令格式"><a href="#1-2-扩展操作码指令格式" class="headerlink" title="1.2 扩展操作码指令格式"></a>1.2 扩展操作码指令格式</h3><p><strong>在这部分介绍的扩展操作码指令格式采用的是<font color=red>定长指令字结构和可变长操作码相结合</font>。</strong></p><img src="https://pic.imgdb.cn/item/6628cb6a0ea9cb1403f7cce1.png" alt="计算机组成原理（四）——指令系统——扩展操作码.png"><p>扩展操作码的步骤如上，假设指令字长为16位，每个地址码占4位。如果设计三地址指令就意味着地址码要占12位，操作码要占4位。这样三地址指令最多可以设置2<sup>4</sup>&#x3D;16条，但要还想设计二地址指令就至少要留出一条1111充当扩展操作码用，也就是说最多只能有15条三地址指令。</p><p>对于二地址指令也一样，二地址指令由于要扩展一地址指令，也需要空出1111 1111充当扩展操作码。</p><p>一地址同理，留出1111 1111 1111充当零地址扩展操作码。</p><p>上面是扩展操作码的其中一种设计方法，即从多地址一步一步向少地址扩展，下面还会说另一种扩展操作码的设计方式。</p><p>在设计扩展操作码指令格式时，必须注意以下两点：</p><ol><li><font color=red><strong>不允许短码是长码的前缀</strong></font>，即短操作码不能与长操作码的前面部分的代码相同。如上面的例子，三地址指令操作码的前缀是0000~1110是短地址，而二地址操作码的前面是1111开头，如果三地址前面也是1111，则无法区分三地址和二地址。这里和数据结构里哈夫曼树编码如出一辙。</li><li>各指令的操作码一定不能重复。</li></ol><p>通常情况下，对使用频率较高的指令，分配较短的操作码；对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。</p><p>下面是扩展操作码的另一种设计方式，就是根据各地址指令有多少条，从而设计出合理的扩展操作码。</p><img src="https://pic.imgdb.cn/item/6628cd040ea9cb1403fabd69.png" alt="计算机组成原理（四）——指令系统——扩展操作码的另一种设计方式.png"><p>这里可以总结出一条规律，设地址长度为n，上一层留出m种状态，下一层可扩展出m×2<sup>n</sup>种状态。</p><p>结合本部分操作码的扩展，下面对操作码进行一个小结：</p><img src="https://pic.imgdb.cn/item/6628d2ac0ea9cb1403048017.png" alt="计算机组成原理（四）——指令系统——指令操作码.png"><p>扩展操作码相较于定长操作码，由于指令操作码长度的不确定，所以在指令字长有限的情况下，仍具备丰富的指令种类。但定长操作码相较于扩展操作码，由于操作码字段长的确定性，所以其对计算机硬件要求较低，同时也能具备更高的指令译码和识别速度。</p><h2 id="2-指令的寻址方式"><a href="#2-指令的寻址方式" class="headerlink" title="2. 指令的寻址方式"></a>2. 指令的寻址方式</h2><p>寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为指令寻址和数据寻址两大类。</p><p><strong>寻找下一条将要执行的指令地址称为指令寻址；寻找本条指令的数据地址称为数据寻址。</strong></p><h3 id="2-1-指令寻址"><a href="#2-1-指令寻址" class="headerlink" title="2.1 指令寻址"></a>2.1 指令寻址</h3><p>指令寻址方式有两种：一种是顺序寻址方式，另一种是跳跃寻址方式。</p><h4 id="2-1-1-顺序寻址"><a href="#2-1-1-顺序寻址" class="headerlink" title="2.1.1 顺序寻址"></a>2.1.1 顺序寻址</h4><p>顺序寻址就是通过**程序计数器PC加1<font color=red>（1条指令的长度）</font>**，自动形成下一条指令的地址。</p><p>这里注意标红处，PC加1，这里的1是指一条指令长度，主存编码的不同或指令结构的不同，都会影响指令的长度，所以这里的1要理解为1条指令的长度。</p><p>下面举几个例子加深一下印象：</p><img src="https://pic.imgdb.cn/item/662f68bd0ea9cb1403d7b797.png" alt="计算机组成原理（四）——指令系统——指令寻址按字编址.png"><p>上面是指令字长&#x3D;存储字长&#x3D;2B，主存按<font color=red><strong>字</strong></font>编址的情况。这个时候一条指令占一行，即长度为1个字，因为按字编址，所以每一行的起始地址只需加1，所以PC+1。</p><img src="https://pic.imgdb.cn/item/662f696c0ea9cb1403d90c3b.png" alt="计算机组成原理（四）——指令系统——指令寻址按字节编址.png"><p>上面是指令字长&#x3D;存储字长&#x3D;2B，主存按<font color=red><strong>字节</strong></font>编址的情况。这个时候一条指令仍占一行，即长度为1个字，但是因为按字节编址，所以每一行其实是两个字节，对应下来每一行的起始地址需要加2，所以PC+2。</p><p>不难看出，上面两个例子都是定长指令结构，下面看一下变长指令字结构。</p><img src="https://pic.imgdb.cn/item/662f90520ea9cb140327e9ef.png" alt="计算机组成原理（四）——指令系统——变长指令字结构.png"><p>上面的指令系统采用变长指令字结构，这里的指令字长就不在是固定的，所以上图右边的指令字长&#x3D;存储字长&#x3D;16bit&#x3D;2B可忽略。主存按字节编址。这个时候读入一个字，CPU要根据其操作码判断这条指令的总字节数n，然后再修改PC的值。</p><p>由于CPU每次只读一行，即1个字，所有指令如果有几个字的话，CPU可能还要进行多次访存，才能把指令读完。</p><p>补充一下，这里CPU根据操作码判断指令长度，具体怎么判断的，王道没有说，我去查了一下，大体可分为以下五步：</p><ol><li><strong>预取指令</strong>：CPU从内存或缓存中预取一定数量的字节，这些字节可能包含一条或多条指令。</li><li><strong>解析操作码</strong>：CPU开始分析预取的字节，寻找操作码。由于操作码的长度是可变的，CPU需要逐个字节地进行解析，直到确定完整的操作码。</li><li><strong>查找指令长度</strong>：一旦操作码被识别，CPU会查阅其内部的指令集表或类似的数据结构，以确定与该操作码相关联的指令长度。这个表通常包含了所有可能的操作码及其对应的指令长度信息。</li><li><strong>计算总字节数</strong>：基于查找到的指令长度，CPU可以计算出这条指令的总字节数。这可能涉及读取额外的字节来确定操作数的数量和长度，因为指令的总字节数不仅包括操作码本身，还可能包括操作数和其他附加信息。</li><li><strong>更新程序计数器</strong>：最后，CPU会根据计算出的指令总字节数来更新程序计数器（PC）的值，以便指向下一条指令的起始地址。</li></ol><h4 id="2-1-2-跳跃寻址"><a href="#2-1-2-跳跃寻址" class="headerlink" title="2.1.2 跳跃寻址"></a>2.1.2 跳跃寻址</h4><img src="https://pic.imgdb.cn/item/662f93160ea9cb14032dde60.png" alt="计算机组成原理（四）——指令系统——跳跃寻址.png"><p>跳跃寻址，顾名思义，就是指由本条指令给出下条指令地址的计算方式，指令之间执行的不是顺序关系，不能通过PC+1的方式来查找下一条执行的指令。跳跃寻找需要通过转移类指令实现。如上图，在主存的第四个存储块里，存储着JMP 7的指令，JMP就是无条件跳转指令，此时PC不应该加1指向4，而应该指向7，这就是跳跃寻址。</p><h4 id="2-1-3-指令寻址小结"><a href="#2-1-3-指令寻址小结" class="headerlink" title="2.1.3 指令寻址小结"></a>2.1.3 指令寻址小结</h4><img src="https://pic.imgdb.cn/item/662f943b0ea9cb1403307e68.png" alt="计算机组成原理（四）——指令系统——指令寻址小结.png"><p>注意，每一条指令的执行都分为取指令和执行指令两个过程，如果题目里要计算访存次数，注意是从取指令开始，还是只算执行指令。</p><h3 id="2-2-数据寻址"><a href="#2-2-数据寻址" class="headerlink" title="2.2 数据寻址"></a>2.2 数据寻址</h3><h4 id="2-2-1-数据寻址基本概念"><a href="#2-2-1-数据寻址基本概念" class="headerlink" title="2.2.1 数据寻址基本概念"></a>2.2.1 数据寻址基本概念</h4><img src="https://pic.imgdb.cn/item/662f9e1a0ea9cb140347980e.png" alt="计算机组成原理（四）——指令系统——数据寻址.png"><p>数据寻址，就是确定本条指令的地址码指明的真实地址，但是注意，数据寻址的方式有多种，所以，对于同一个指令，在不同寻址方法里有不同的意思；同样，查找同一个地址，也有不同的指令描述方法。</p><p>下面给出数据寻址的多种方法：</p><img src="https://pic.imgdb.cn/item/662f9ef50ea9cb1403497cfe.png" alt="计算机组成原理（四）——指令系统——数据寻址方法.png"><p>上面是数据寻址常用的10种方法，为了区分使用的是何种方式，我们要在原指令结构里添加几个比特位做寻址特征字段，用来表示使用的是何种方法。</p><p>从上图的指令结构里，不难发现，我们把最后一个地址码字段具象化为形式地址字段(A)。所以这里也稍微讲一下什么是形式地址。</p><p>形式地址(A)：指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址(A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，这种地址称为有效地址(EA)。</p><p>下面来具体说一下几种寻址方式，为了方便说明，假设下面所有的寻址方式的指令字长&#x3D;机器字长&#x3D;存储字长。</p><h4 id="2-2-2-直接寻找"><a href="#2-2-2-直接寻找" class="headerlink" title="2.2.2 直接寻找"></a>2.2.2 直接寻找</h4><img src="https://pic.imgdb.cn/item/662fa0c50ea9cb14034d7b77.png" alt="计算机组成原理（四）——指令系统——直接寻址.png"><h4 id="2-2-3-间接寻址"><a href="#2-2-3-间接寻址" class="headerlink" title="2.2.3 间接寻址"></a>2.2.3 间接寻址</h4><img src="https://pic.imgdb.cn/item/662fa13c0ea9cb14034e837a.png" alt="计算机组成原理（四）——指令系统——间接寻址.png"><p>这里说一下两次间址，就是根据形式地址去主存里找到的该地址上的数据，并不是操作数，而是操作数在主存里的地址，需要通过这个地址，再去主存里找操作数。一般情况下，两次及多次间址会在主存里的每一条数据前留一个比特位用来判断根据当前存储单元存储的数据找到的是操作数还是操作数的地址，如果为1说明根据这个存储单元里的数据找到的是存储在主存里的操作数的地址，如果为0说明根据这个存储单元里的数据找到的是存储在主存里的操作数，具体可以参考上图的两次间址。</p><p>通过间接寻址可以扩大寻址范围，而通过多次间址，可以将寻址范围以几何级数的方式扩大到很大。</p><h4 id="2-2-4-寄存器寻址"><a href="#2-2-4-寄存器寻址" class="headerlink" title="2.2.4 寄存器寻址"></a>2.2.4 寄存器寻址</h4><img src="https://pic.imgdb.cn/item/662fa31f0ea9cb140352a532.png" alt="计算机组成原理（四）——指令系统——寄存器寻址.png"><p>寄存器寻址和直接寻址一样，只不过操作数不是存储在主存里而是存储在寄存器内。</p><h4 id="2-2-5-寄存器间接寻址"><a href="#2-2-5-寄存器间接寻址" class="headerlink" title="2.2.5 寄存器间接寻址"></a>2.2.5 寄存器间接寻址</h4><img src="https://pic.imgdb.cn/item/662facae0ea9cb14036a95cd.png" alt="计算机组成原理（四）——指令系统——寄存器间接寻址.png"><h4 id="2-2-6-隐含寻址"><a href="#2-2-6-隐含寻址" class="headerlink" title="2.2.6 隐含寻址"></a>2.2.6 隐含寻址</h4><img src="https://pic.imgdb.cn/item/662facf30ea9cb14036b3380.png" alt="计算机组成原理（四）——指令系统——隐含寻址.png"><h4 id="2-2-7-立即寻址"><a href="#2-2-7-立即寻址" class="headerlink" title="2.2.7 立即寻址"></a>2.2.7 立即寻址</h4><img src="https://pic.imgdb.cn/item/662fad3d0ea9cb14036bde57.png" alt="计算机组成原理（四）——指令系统——立即寻址.png"><p>立即寻址要与直接寻址区分开来，立即寻址把要读的操作数直接写在指令的形式地址字段，而直接寻址，要通过形式地址去找操作数存储的位置。</p><h4 id="2-2-8-基址寻址"><a href="#2-2-8-基址寻址" class="headerlink" title="2.2.8 基址寻址"></a>2.2.8 基址寻址</h4><img src="https://pic.imgdb.cn/item/662fae0a0ea9cb14036da438.png" alt="计算机组成原理（四）——指令系统——基址寻址.png"><p>基址寻址，用大白话来说，就是以程序在主存里存储的起始地址为基准，根据这个基准去找有效地址。</p><p>基址寻址需要基址寄存器，基址寄存器可以是专用寄存器BR，也可以是通用寄存器。</p><p>如果使用专用寄存器，则专用寄存器里存储程序的首地址，想找到操作数，就需要通过基地址加上偏移量来查找，即BR里存储的基地址加上A里存储的形式地址得到有效地址。</p><p>但是有的CPU里没有基址寄存器，就会使用某一个通用寄存器作为基址寄存器。这个时候，就需要多花费几个比特位来确定哪个通用寄存器作为基址寄存器。剩下的具体查找操作数的方式与专用寄存器一样，只需要把专用寄存器改成通用寄存器即可。</p><p>这里面要思考一个问题，要用几个bit指明寄存器，这就需要根据寄存器总数判断，如果有8个通用寄存器，就需要3个bit位。</p><img src="https://pic.imgdb.cn/item/662fb1f30ea9cb1403768f6a.png" alt="计算机组成原理（四）——指令系统——基址寻址的作用.png"><p>由于程序存储在主存里的起始地址并不一定是0，可以是10,100或1000等等，所以可以用基址寻址的方式来确定操作数的位置，这样即使改动整段程序的存储位置，也只需要更改基址寄存器里存储的基地址，而不需要更改大片操作数地址。</p><p>对于基址寻址还有以下几个事项需要注意一下：</p><img src="https://pic.imgdb.cn/item/662fb3270ea9cb14037937fb.png" alt="计算机组成原理（四）——指令系统——基址寻址的注意事项.png"><h4 id="2-2-9-变址寻址"><a href="#2-2-9-变址寻址" class="headerlink" title="2.2.9 变址寻址"></a>2.2.9 变址寻址</h4><img src="https://pic.imgdb.cn/item/662fb37e0ea9cb140379ef1c.png" alt="计算机组成原理（四）——指令系统——变址寻址.png"><p>变址寻址，就是用指令中的形式地址作为基准，然后每次改动变址寄存器里的值，再通过变址寄存器和形式地址相加得到有效地址。</p><p>这里可能有些难以理解，可以参考下面变址寻址的作用里的例子，结合理解。</p><img src="https://pic.imgdb.cn/item/662fb4260ea9cb14037b5515.png" alt="计算机组成原理（四）——指令系统——变址寻址作用.png"><p>从上面的例子里可以看到，主存单元2里，地址码上存储数组a的首位a[0]的形式地址，在执行循环时，可以通过改变IX里的值，来改变存储单元2里的地址码上的形式地址，这样就可以用简短的几行指令，实现重复的循环操作。如果这里采用基址寻址，则需要增加很多行来执行数组的加法操作。</p><p>可以说变址寻址的最大作用就是循环的应用。</p><p>这里有个知识需要补充一下，就是主存地址4的地方，这个地方是比较(IX)与立即寻址10谁大，但是注释里写的比较方式确是比较10-(IX)，这个地方可能会有疑惑，所以补充一下这个地方硬件层面实现的方式：</p><img src="https://pic.imgdb.cn/item/662fb89d0ea9cb140387d3b9.png" alt="计算机组成原理（四）——指令系统——硬件如何实现数的比较.png"><p>下面看一下变址寻址的注意点：</p><img src="https://pic.imgdb.cn/item/662fb6250ea9cb140382370b.png" alt="计算机组成原理（四）——指令系统——变址寻址的注意点.png"><p>这里再拓展一下复合寻址的概念：</p><img src="https://pic.imgdb.cn/item/662fb6690ea9cb140382d0ae.png" alt="计算机组成原理（四）——指令系统——符合寻址.png"><p>所谓复合寻址，就是将多种寻址方式结合，上面给出的例子是基址和变址的复合寻址，这个时候要先根据基址去找到程序地址然后计算基于起始地址的实际形式地址存储位置，再根据形式地址去找到使用变址寻址的方式找到有效地址。总结下来，就一个公式：EA&#x3D;(IX)+((BR)+A)。</p><p>注意，复合寻址很容易被考到，不能死寂，要学会理解，考试时应具体问题具体分析。</p><h4 id="2-2-10-相对寻址"><a href="#2-2-10-相对寻址" class="headerlink" title="2.2.10 相对寻址"></a>2.2.10 相对寻址</h4><img src="https://pic.imgdb.cn/item/662fb8d80ea9cb140388561d.png" alt="计算机组成原理（四）——指令系统——相对寻址.png"><p>相对寻址就是基于当前PC的值加上形式地址A而形成操作数的有效地址。</p><p>注意这里PC在取完指令以后，会自动+1指向下一条指令的地址，这时候执行本条指令，但PC指的是下一条指令，所以形式地址相对的应当是下一条指令地址的偏移量，而不是当前指令地址的偏移量。</p><p>接下来看一下相对寻址的作用：</p><img src="https://pic.imgdb.cn/item/662fba840ea9cb14038bf516.png" alt="计算机组成原理（四）——指令系统——相对寻址作用.png"><p>上图是与上面复合寻址同样的例子，可以看到for循环在程序中是按顺序一连串存储的，随着程序的扩充，这段执行循环的指令地址向后移动，如果还是按照基址寻址的方式来处理，那条件跳转指令让循环从头开始的地址码也要改动，可以发现使用基地址寻址，只要循环指令的第一步地址改动，就需要改动条件跳转指令的地址码才可再次指向正确位置。相较之下，相对寻址的优越性就体现出来了，只要运行到条件跳转处，就基于当前PC值进行偏移，这样即使整段循环指令的开始地址再怎么改动，也不用改动跳转到开始处的地址。</p><p>下面是对相对寻址的一个小总结：</p><img src="https://pic.imgdb.cn/item/662fbe570ea9cb14039434e9.png" alt="计算机组成原理（四）——指令系统——相对寻址注意事项.png"><h4 id="2-2-11-堆栈寻址"><a href="#2-2-11-堆栈寻址" class="headerlink" title="2.2.11 堆栈寻址"></a>2.2.11 堆栈寻址</h4><img src="https://pic.imgdb.cn/item/662fbed90ea9cb14039546dc.png" alt="计算机组成原理（四）——指令系统——堆栈寻址.png"><p>堆栈寻址就是用寄存器组里一块特定的按“后进先出”原则管理的存储区存储数据，然后用堆栈指针SP来指向栈顶。栈里存储着每条指令的操作数，执行指令时，直接从栈顶取出每一条指令的操作数，所以，操作数也可以看成隐式的存储在栈里。</p><img src="https://pic.imgdb.cn/item/662fbf4e0ea9cb14039631c5.png" alt="计算机组成原理（四）——指令系统——软堆栈.png"><p>前面所说的是硬堆栈，即把操作数存在寄存器里这样成本太高，所以又发明了软堆栈，即在主存里划分一段存储空间用栈表示，然后把数据存储到主存的栈里。</p><h4 id="2-2-12-数据寻址小结"><a href="#2-2-12-数据寻址小结" class="headerlink" title="2.2.12 数据寻址小结"></a>2.2.12 数据寻址小结</h4><img src="https://pic.imgdb.cn/item/662fbf850ea9cb1403969b21.png" alt="计算机组成原理（四）——指令系统——数据寻址小结.png"><h2 id="3-程序的机器级代码表示"><a href="#3-程序的机器级代码表示" class="headerlink" title="3. 程序的机器级代码表示"></a>3. 程序的机器级代码表示</h2><h3 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h3><img src="https://pic.imgdb.cn/item/6631b05d0ea9cb14034713c0.png" alt="计算机组成原理（四）——指令系统——高级&汇编&机器语言.png"><p>我们用高级语言写的程序经过编译器会翻译成汇编语言的程序，而汇编语言的程序经过汇编器会翻译成机器语言程序。机器语言是由二进制的0、1组成，可以直接交由CPU执行。</p><p>高级语言当中的一条代码可能会对应好几个汇编语言指令，而汇编语言指令和机器语言指令之间是一一对应的关系。</p><p><strong><font color=red>汇编语言指令表示的代码和机器语言表示的代码都属于机器级代码。</font></strong></p><p>机器级代码是2022年考研大纲新增考点，重点关注x86语言，如果考到其它语言，卷子上是会提供注释的。</p><p>其余可能的考点以及掌握程度参考上图。</p><h3 id="3-2-x86汇编语言指令基础"><a href="#3-2-x86汇编语言指令基础" class="headerlink" title="3.2 x86汇编语言指令基础"></a>3.2 x86汇编语言指令基础</h3><img src="https://pic.imgdb.cn/item/6631b2c00ea9cb14034bc680.png" alt="计算机组成原理（四）——指令系统——x86基础.png"><p>一条指令有改变程序执行流和处理数据两个功能。</p><p>现在先看第二个功能，一条指令要处理数据，那这个指令有两部分构成，首先是操作码，其次是地址码。操作码说明了要对这个数据进行什么处理，地址码说明了数据在什么地方。而数据存储的地方有三个：寄存器、主存、指令。</p><p>一条指令要处理的数据在寄存器里，那如何解决在指令当中指明数据在哪这个问题呢？很简单，只要给出寄存器名字即可，所以我们需要知道基于x86架构下的CPU有哪些寄存器。</p><p>一条指令要处理的数据在主存里，那如何解决在指令当中指明数据在哪这个问题呢？同理，只要给出主存地址即可，但是不同的存储类型占用不同的存储大小的存储空间，所以我们还需要知道基于x86架构下的CPU是怎么在指令中指明读写长度的。</p><p>一条指令要处理的数据在指令里，只要直接在指令里写要操作的数即可，也就是立即寻址。</p><p>下面以MOV指令为例，对指令要处理的数据分别在寄存器、主存和指令里进行读写演示：</p><img src="https://pic.imgdb.cn/item/6631b5460ea9cb1403510c7d.png" alt="计算机组成原理（四）——指令系统——x86操作举例.png"><p>通过上面的MOV指令示例，我们可以清晰的看到汇编语言指令是如何对存储在寄存器、主存和指令里的数据进行操作的。</p><p>如果是数据存储在寄存器里，直接写寄存器名即可；如果是数据存储在主存里，要在主存地址外加中括号，前面可以注明读写长度，如果不注明，会默认为32bit；如果是数据存储在指令里，直接写立即数就行。</p><p>主存地址和立即数我们都知道，但是在x86架构里，寄存器有哪些我们还不是很清楚，所以下面说一下x86架构下的寄存器：</p><img src="https://pic.imgdb.cn/item/6631b6780ea9cb1403535845.png" alt="计算机组成原理（四）——指令系统——x86寄存器.png"><p>如图是x86下的寄存器，<font color=red><strong>每个寄存器的长度是32bit</strong></font>。</p><p><strong><font color=green>EAX、EBX、ECX、EDX是通用寄存器。</font></strong></p><p><strong><font color=blue>ESI、EDI是变址寄存器。</font></strong></p><p><strong><font color=purple>EBP、ESP是堆栈寄存器。</font></strong></p><img src="https://pic.imgdb.cn/item/6631b7c00ea9cb1403560518.png" alt="计算机组成原理（四）——指令系统——x86通用寄存器的16bit使用.png"><p>对于x86寄存器里的通用寄存器，我们可以只使用用低16位，如上图，但是变址寄存器和堆栈寄存器只能固定使用32bit。</p><img src="https://pic.imgdb.cn/item/6631b8320ea9cb140356d8d5.png" alt="计算机组成原理（四）——指令系统——x86通用寄存器的8bit使用.png"><p>当然，也可以更灵活的使用通用寄存器，即只使用8bit，如上图。</p><p>为了考试时能更能正确的认识各指令的含义，下面多给出一些例子（需要能看懂下面每一条指令）：</p><img src="https://pic.imgdb.cn/item/6631b8800ea9cb1403576b0b.png" alt="计算机组成原理（四）——指令系统——x86指令使用例子.png"><p>下面对x86汇编语言基础做个总结：</p><img src="https://pic.imgdb.cn/item/6631b8e00ea9cb1403581c07.png" alt="计算机组成原理（四）——指令系统——x86基础总结.png"><h3 id="3-3-常用的x86汇编语言指令"><a href="#3-3-常用的x86汇编语言指令" class="headerlink" title="3.3 常用的x86汇编语言指令"></a>3.3 常用的x86汇编语言指令</h3><h4 id="3-3-4-常见的算数运算指令"><a href="#3-3-4-常见的算数运算指令" class="headerlink" title="3.3.4 常见的算数运算指令"></a>3.3.4 常见的算数运算指令</h4><img src="https://pic.imgdb.cn/item/6631d9820ea9cb14039ae023.png" alt="计算机组成原理（四）——指令系统——常见的算数运算指令.png"><p>乘法和除法指令有两种指令，前面不带i的是无符号数的运算，有i的是有符号数的运算。</p><p>在除法里，可以看汇编指令后仅有一个操作数，这个操作数代表除数，而被除数会被提前放到edx:eax里，所以除法指令的被除数是采用了隐含寻找，在进行除法指令时，会默认被除数已经被放到了edx和eax两个寄存器当中。</p><p>这里对edx:eax解释一下，在进行除法运算之前，需要把被除数进行位扩展，比如32bit被除数除32bit除数，需要先把被除数扩展为64bit，用64bit被除数除32bit除数，而放64bit被除数就需要两个寄存器。更高的32bit放到edx，更低的32bit放到eax。最后运算的结果，商会放在eax，余数会放到edx。（这里如果有疑问的，可以去第二章看下除法运算的过程。）</p><p>这里再补充一点吗，<font color=red><strong>在x86汇编语言当中，不允许两个操作数都来自主存</strong></font>。</p><h4 id="3-3-5-常见的逻辑运算指令"><a href="#3-3-5-常见的逻辑运算指令" class="headerlink" title="3.3.5 常见的逻辑运算指令"></a>3.3.5 常见的逻辑运算指令</h4><img src="https://pic.imgdb.cn/item/6631dc400ea9cb1403a32427.png" alt="计算机组成原理（四）——指令系统——常见的逻辑运算指令.png"><h4 id="3-3-6-其它指令"><a href="#3-3-6-其它指令" class="headerlink" title="3.3.6 其它指令"></a>3.3.6 其它指令</h4><img src="https://pic.imgdb.cn/item/6631dc760ea9cb1403a38e97.png" alt="计算机组成原理（四）——指令系统——其它指令.png"><h3 id="3-4-AT-T格式和Intel格式"><a href="#3-4-AT-T格式和Intel格式" class="headerlink" title="3.4 AT&amp;T格式和Intel格式"></a>3.4 AT&amp;T格式和Intel格式</h3><p>前面所学x86汇编语言格式全是intel格式，但还有一种各大教材常见的格式AT&amp;T，为了以防考试使用AT&amp;T格式，这部分补充一下AT&amp;T格式的x86汇编语言。</p><p>Intel格式是windows常用的格式，而AT&amp;T格式则是Unix和Linux常用的格式。</p><img src="https://pic.imgdb.cn/item/6631ddaa0ea9cb1403a5f24b.png"><p>mov eax,[ebx+ecx*32+4]可能比较难以理解，但这个汇编程序计算地址其实很常用，下面解释一下：</p><img src="https://pic.imgdb.cn/item/6631e0a80ea9cb1403ac80e1.png" alt="计算机组成原理（四）——指令系统——地址计算.png"><p>对这个计算地址的方式其实就可以看成，对结构体的使用。假设我们定义了一个学生信息结构体，然后创建一个数组来保存学生信息，数组的首地址存放在eax寄存器里，每个学生结构体大小占32B。现在要找第4个学生的信息，就是找到数组下标为3的起始地址。因为数组是按顺序存储的，所以下标为3的数组起始地址为变址*3（变址数据存储在ecx寄存器里，该变址寄存器里的数据表示是数组第几个元素），如上图。假设结构体里按顺序存储着学生姓名年龄等信息，每个信息占4B，现在要想查找该学生的年龄，就要再数组下标为3的起始地址处在偏移4B才可找到学生年龄信息的起始地址。</p><p>所以mov eax,[ebx+ecx*32+4]这个指令按照上述例子就可以理解为，从数组存放的起始地址ebx处，通过ecx*32+4找到第四个学生的年龄信息，然后把找到的数据放到eax寄存器里。</p><p>由此可见，在进行项目开发时，像mov eax,[ebx+ecx*32+4]这样计算地址的指令是很常见的。</p><h3 id="3-5-选择语句的机器级表示"><a href="#3-5-选择语句的机器级表示" class="headerlink" title="3.5 选择语句的机器级表示"></a>3.5 选择语句的机器级表示</h3><h4 id="3-5-1-无条件跳转指令"><a href="#3-5-1-无条件跳转指令" class="headerlink" title="3.5.1 无条件跳转指令"></a>3.5.1 无条件跳转指令</h4><img src="https://pic.imgdb.cn/item/6631e3b20ea9cb1403b330b4.png" alt="计算机组成原理（四）——指令系统——选择语句.png"><p><font color=blue><strong>先补充一个知识点，在x86处理器中，程序计数器PC也常被称为IP(寄存器)，如果做题时看到题目里说IP寄存器，要知道IP就是程序计数器PC。</strong></font></p><p>如图，选择语句就是我们C语言中常用的选择判断句，根据选择语句的逻辑执行顺序可以看出，里面包含很多跳跃性执行指令，而我们正常执行指令时，PC只会自动1，这显然无法实现选择语句。这个时候就要借助一个可以实现PC跳跃性指向的指令——jmp指令。</p><img src="https://pic.imgdb.cn/item/6631e5660ea9cb1403b73f0e.png" alt="计算机组成原理（四）——指令系统——无条件转移指令.png"><p>据上图，当PC执行到108时，先从主存里取出jmp 128指令，此时PC+1指向下一条指令起始地址112，但是执行jmp 128时，会发现是jmp指令，此时PC要无条件指向128处准备执行指令8。当然，这个是把操作数放在指令里的，也可以把操作数放在主存和寄存器里，可以参考上图右下角。</p><p>但是，如果只能通过指定地址的方式来确定PC的指向的话，如果更改了这段程序在主存里的位置，那jmp后跟的操作数也要更改，这对程序员来说，无疑是很难受的，所以，就有了下面的标号法。</p><img src="https://pic.imgdb.cn/item/6631eef30ea9cb1403cd41b4.png" alt="计算机组成原理（四）——指令系统——无条件转移指令的标号.png"><p>jmp后面可以跟着一个标号，当执行jmp指令时，会跳到标号处，这样无论程序地址怎么改，只要逻辑不变，都能顺利执行。</p><p>如上图将jmp 116改成jmp NEXT（这里的标号为NEXT，并非只能是NEXT，可以程序员自己定义），这样PC依然会指向mov ecx,eax，但是当该段程序地址更改时，就不需要改动jmp后的跳转位置。</p><p>这里有一点注意一下，jmp指令跳转到标号处，并不是PC指向标号，而是PC指向标号位置的第一条指令。如上图jmp NEXT执行以后，PC不是指向NEXT，而是指向mov ecx,eax。这种方法很类似于C语言里的goto语句。</p><h4 id="3-5-2-条件跳转指令"><a href="#3-5-2-条件跳转指令" class="headerlink" title="3.5.2 条件跳转指令"></a>3.5.2 条件跳转指令</h4><p>除了jmp指令，汇编语言还提供了一些执行复杂过程的条件转移指令。如下：</p><img src="https://pic.imgdb.cn/item/6631f0a90ea9cb1403d11deb.png" alt="计算机组成原理（四）——指令系统——条件转移指令.png"><p>条件转移指令jxxx（这里的jxxx是代指，代指je、jne等以j开头的条件转移指令），常与cmp指令一起使用。</p><p>使用的方式如上图最下面，先使用cmp指令做判断，然后使用条件转移指令jxxx，根据判断结果做出对应操作。</p><p>具体的使用方法可以结合下面的图：</p><img src="https://pic.imgdb.cn/item/6631f1550ea9cb1403d2a54c.png" alt="计算机组成原理（四）——指令系统——条件转移指令示例1.png"><p>这里使用汇编语言写的条件跳转指令，他的else逻辑部分在前if逻辑在后，与我们C语言的执行顺序相反，但是效果一样，如果想要和C语言的执行顺序一样，也可以参考如下图的写法：</p><img src="https://pic.imgdb.cn/item/6631f1da0ea9cb1403d3c22b.png" alt="计算机组成原理（四）——指令系统——条件转移指令示例2.png"><p>从这个例子里可以看出，对于同一段高级语言写的程序，他的汇编程序写法并不是固定的，对于我个人来说，我更偏向第一种写法，这样写可以很大程度上避免因为更改判断条件不完全而出错的问题。</p><p>接下里，看下下面的这道真题：</p><img src="https://pic.imgdb.cn/item/6631f29a0ea9cb1403d53d48.png" alt="计算机组成原理（四）——指令系统——真题.png"><p>通过上面对汇编语言的学习，这道题里有很多指令我们都可以看出是什么意思，即使不知道的，也可以结合题目提供的程序猜出意思，这是我们考试时必须要具备的能力。</p><p>对于这道题，有一点要说一下，汇编程序员在写汇编指令时，一般都会以函数名作为标号，标注该函数指令的起始地址。所以在题目里有这么一段汇编程序jie f1+35h，看似操作数使用的16进制的立即数，实则是指在函数的起始地址上偏移35h，因为这段函数的名字为f1，所以这里的f1代表着该函数的起始地址。</p><h4 id="3-5-3-扩展——cmp指令执行的底层原理"><a href="#3-5-3-扩展——cmp指令执行的底层原理" class="headerlink" title="3.5.3 扩展——cmp指令执行的底层原理"></a>3.5.3 扩展——cmp指令执行的底层原理</h4><p>在2.2.9变址寻址里，已经初步介绍过cmp指令的执行原理，这部分对其再进行一个细化：</p><img src="https://pic.imgdb.cn/item/6631f4180ea9cb1403d8636e.png" alt="计算机组成原理（四）——指令系统——cmp指令执行的底层原理.png"><p>cmp指令的执行，本质是两个数进行减法运算并生成标志位的过程，两个数的运算通过ALU进行（减法运算的详细过程可以参考第二章），计算得到的标志位会被放到程序状态寄存器PSW中。其余的指令执行相关操作时，会去程序状态寄存器里查询标志位，进而推出自己该执行何种操作。</p><p>上图左上给出了intel的8086CPU里的16bit程序状态寄存器，其中第0bit存储CF标志位，第6bit存储ZF标志位，第7bit存储SF标志位，第11bit存储OF标志位。条件转移指令jxxx执行时，会去查询这些标志位，进而确定该不该执行跳转操作。</p><p>由于1个CPU通常只有1个PSW程序状态寄存器，所以每次运算的标志位都会放到该PSW里，将上次运算的结果覆盖掉，所以cmp指令后通常会跟着jxxx指令，这是为了防止中间出现其他的运算将标志位覆盖掉，导致jxxx判断的不是原本cmp指令执行的结果。</p><h3 id="3-6-循环语句的机器级表示"><a href="#3-6-循环语句的机器级表示" class="headerlink" title="3.6 循环语句的机器级表示"></a>3.6 循环语句的机器级表示</h3><p>循环语句的机器级表示和条件跳转语句的机器级表示都一样，都是借助jxxx指令的跳转特性来实现。有了条件跳转的机器级表示基础，来实现循环语句的机器级表示是件很容易的事情。</p><img src="https://pic.imgdb.cn/item/6631f7520ea9cb1403e1336d.png" alt="计算机组成原理（四）——指令系统——jxxx实现循环.png"> <p>除了上面所说的jmp结合cmp的方式实现循环以外，我们还可以通过特地的指令实现循环，比如loop指令。</p><img src="https://pic.imgdb.cn/item/6631fc4e0ea9cb1403eba934.png" alt="计算机组成原理（四）——指令系统——loop实现循环.png"><p>与jxxx指令不同，看到jxxx的第一反应，这是个分支结构，并不一定是循环，但看到loop指令，大家的第一感就应该是循环的执行。</p><p>如上图的for循环程序，可以通过loop实现，loop指令就等价于先令ecx寄存器里的数据执行自减操作，再与0比较，若不等于0，则跳转到程序的开始处。</p><p>注意，loop指令是一些列操作的集合，所以它也规定了所使用的寄存器ecx，换句话说，loop指令是对ecx进行操作的，所以要用loop执行实现循环时，要把判断数据放到ecx寄存器里。</p><p>loop指令同jmp指令一样，也有许多扩展形式loopx，可以参考上图左下角。</p><p>从这里，不难看出，x86语言有很多种，我们是不可能花费大量时间去把所有语言学完，这就要求我们具备在考试时如果遇到不会的汇编指令，要能根据程序推出指令的含义的能力。</p><h3 id="3-7-函数调用的机器级表示"><a href="#3-7-函数调用的机器级表示" class="headerlink" title="3.7 函数调用的机器级表示"></a>3.7 函数调用的机器级表示</h3><h4 id="3-7-1-call和ret指令"><a href="#3-7-1-call和ret指令" class="headerlink" title="3.7.1 call和ret指令"></a>3.7.1 call和ret指令</h4><img src="https://pic.imgdb.cn/item/6631fe4a0ea9cb1403efb6b6.png" alt="计算机组成原理（四）——指令系统——函数调用.png"><p>上面是我们基于高级语言视角实现函数调用的运行过程，就是通过开辟一段函数调用栈空间，通过不断往里入栈出栈函数的栈帧实现函数的调用。函数的栈帧的含义可以看上图底部。</p><p>下面，着眼与caller和add函数看一下汇编语言视角是如何执行的。</p><img src="https://pic.imgdb.cn/item/6631feee0ea9cb1403f12aab.png" alt="计算机组成原理（四）——指令系统——call和ret.png"><p>函数的调用在汇编语言视角使用call和ret指令。</p><p>在caller函数里使用call指令调用add函数，在add函数里使用ret指令返回caller函数，然后caller继续往下执行。这里就有一个问题，在汇报语言执行函数调用过程中，是如何返回到原先调用的地方，然后继续往下执行的，这里就牵扯到对IP保存的问题。</p><p>以上图为例，当取出call add指令时，IP+1会指向下一条指令，即mov [ebp-4],eax，此时执行call add指令发现是函数调用，这时PC会指向add函数起始处，并将add函数栈帧压入栈，但为了保证等会执行完add指令，能正确回到mov [ebp-4],eax处，就要求在将add压入栈前，先将PC指向mov [ebp-4],eax处的值压入栈里，这个值我们称之为IP旧值，也是add函数执行完返回的地址。当add函数执行完以后，就add函数出栈，此时再将IP旧值出栈，PC就会重新指向mov [ebp-4],eax处。</p><p>在上面，我们只说了函数怎么过去怎么回来的问题，但实际中，我们还会执行传递参数，使用函数里的数据等操作。所以，接下来要考虑一下，如何传递参数？如何访问栈帧里的数据？栈帧内可能包含哪些内容？</p><h4 id="3-7-2-如何访问栈帧"><a href="#3-7-2-如何访问栈帧" class="headerlink" title="3.7.2 如何访问栈帧"></a>3.7.2 如何访问栈帧</h4><img src="https://pic.imgdb.cn/item/6632077f0ea9cb140305c15b.png" alt="计算机组成原理（四）——指令系统——栈的画法原因.png"><p>先解释一下，为什么在画函数调用栈时不是像数据结构里一样，把栈底画在下面而是把栈底画在上面。</p><p>在32位系统中，系统会为每个进程分配一个4GB的虚拟地址空间，地址范围从0000 0000~FFFF FFFF，总共4GB。高地址的1GB属于操作系统内核区。而低地址的3GB可以由用户进行使用，而函数调用栈的栈底在C000 0000处，栈顶在地址变小的方向，因此大多数教材在画函数调用栈时会把栈底画在上面，栈顶画在下面，因为上面是高地址方向，下面是低地址方向。</p><p>知道了函数调用栈为什么把栈底画在上面以后，接下来看一下如何用汇编语言操作栈里的数据。</p><img src="https://pic.imgdb.cn/item/663209730ea9cb140309e504.png" alt="计算机组成原理（四）——指令系统——ESP和EBP.png"><p>在x86里，我们学过有两个堆栈寄存器EBP和ESP，EBP里存储当前栈帧帧的底部地址，ESP里存储当前栈帧的顶部地址。在EBP和ESP之间，就是当前栈帧的范围。</p><p>上图展示的是caller函数的栈帧，采用x86系统，默认栈里以4字节为操作单位。EBP和ESP两个寄存器里存储的本质上就是内存地址。所以我们可以通过EBP和ESP对栈里的数据进行操作。</p><p>下面看一下如何对栈帧里数据进行操作：</p><img src="https://pic.imgdb.cn/item/66320cae0ea9cb1403111282.png" alt="计算机组成原理（四）——指令系统——PUSH和POP.png"><p>上面是通过push和pop指令对栈帧里数据进行操作，由于esp指向栈顶，在低地址，所以入栈时，需要让esp减去一个栈的操作单位长度再入栈（相当于扩充一个操作长度的存储空间，才能让数据入栈）；出栈时，需要先把数据出栈再让esp加上一个栈的操作单位长度（相数据出栈以后，释放数据的存储空间）。</p><p>上图里对栈的操作单位是4B，所以push和pop指令偏移的地址应是4B的倍数，入栈时先让esp-4再入栈；出栈时先出栈再让esp+4。</p><p>除此以外，还可以以ebp和esp为基准，通过对两个ebp和esp的偏移，可以访问其他元素的数据，比如上图左下的例子push[ebp+8]和pop[ebp+8]就是以ebp为基准，访问向上8个偏移量处的数据。</p><p>除了使用push和pop指令外，还可以通过mov指令访问栈帧里数据，如下。</p><img src="https://pic.imgdb.cn/item/66320f890ea9cb140316dbe9.png" alt="计算机组成原理（四）——指令系统——mov访问栈.png"><p>使用mov指令和push与pop不同，push与pop只能将数据放入栈顶或从栈顶取出，但是mov指令可以对栈内每一个操作单位的数据进行读写操作。</p><p>下面对如何访问栈帧进行一个小结：</p><img src="https://pic.imgdb.cn/item/6632104e0ea9cb14031893be.png" alt="计算机组成原理（四）——指令系统——访问栈帧数据小结.png"><h4 id="3-7-3-如何切换栈帧"><a href="#3-7-3-如何切换栈帧" class="headerlink" title="3.7.3 如何切换栈帧"></a>3.7.3 如何切换栈帧</h4><img src="https://pic.imgdb.cn/item/66325ae60ea9cb1403c63807.png" alt="计算机组成原理（四）——指令系统——函数调用切换栈帧.png"><p>函数调用时，会先执行push ebp和mov ebp,esp指令(这两指令合一起等价于enter指令)，将上一层函数的栈帧基址保存下来，并设置当前函数的栈帧基址。</p><p>看上图的例子，caller函数调用add函数时，执行call指令，call指令我们都知道，会将IP旧址压入栈里，此时esp指向IP旧址处。调用add以后，会执行enter指令，先将ebp值入栈，即把caller栈帧基址记录下来，再让ebp指向esp处，确定了add函数的基址。</p><p>同理，我们在caller函数，发现他的基址处也存储着上一层函数的栈帧基址。这个栈帧基址的作用是为了保证我们执行完当前被调用的函数以后，能正确的回到上一个函数。而每个函数调用的最后，又都存储着IP旧址，为了保证PC能接下继续运行。</p><p>所以，<font color=red><strong>每个函数调用栈帧里，都必有上一层函数栈帧基址和IP旧址</strong></font>。</p><p>上面是关于函数调用时，如何切换。下面看一下函数返回时，如何切换。</p><img src="https://pic.imgdb.cn/item/66325d5a0ea9cb1403cb405d.png" alt="计算机组成原理（四）——指令系统——函数返回切换栈帧.png"><p>函数返回时，使用mov esp,ebp和pop ebp指令切换栈帧，即让当前栈帧的栈顶指向栈底，此时栈顶就指向上一层函数栈帧基址，然后让栈顶所指元素出栈并放到ebp里，即将上一层函数栈帧基址出栈，并让ebp指向上一层栈帧基址。此时esp经过出栈操作，会自动进行偏移1个操作长度，指向上一层函数的IP旧值。可以参考下面该例继续运行的结果：</p><img src="https://pic.imgdb.cn/item/66325eda0ea9cb1403ce6ada.png" alt="计算机组成原理（四）——指令系统——函数返回切换栈帧举例.png"><p>mov esp,ebp和pop ebp等价于leave指令。</p><p>当ebp和esp执行leave指令以后，就再次指向caller函数的栈底和栈顶。此时add函数再次执行ret指令，就会出栈IP旧值，让PC指向caller里调用指令之后的下一条指令。</p><p>上面就是我们切换栈帧的过程，下面看一下如何传递参数和返回值。</p><h4 id="3-7-4-如何传递参数和返回值"><a href="#3-7-4-如何传递参数和返回值" class="headerlink" title="3.7.4 如何传递参数和返回值"></a>3.7.4 如何传递参数和返回值</h4><img src="https://pic.imgdb.cn/item/66325ff80ea9cb1403d08719.png" alt="计算机组成原理（四）——指令系统——栈帧内包含的内容.png"><p>通过前面的学习，我们知道，一个栈帧内部肯定会包含上一层栈帧基址和IP返回旧值。但是除了包含这两个以后，栈帧里还会包含局部变量和调用参数。<strong>通常会将局部变量集中存储在栈帧底层区域，而将调用参数集中存储在栈帧顶部区域。</strong></p><p>如上图，caller函数的调用栈里，就包含了上一层栈帧基址、局部变量、调用参数和IP旧值。通过观察不难发现，在caller函数里，越早定义的变量，其存储在栈帧里就越靠近栈顶。而在调用参数时，在参数列表里越靠前的参数也越靠近栈顶。</p><p>除了这些以外，我们还可以发现，caller函数的栈帧里，还有一段空间未使用，这是因为x86系统将每个栈帧大小设置为16B的整数倍，所以当函数栈帧内区域用不完时，就会出现空闲未使用区域。</p><p>单独把栈帧拿出来，可以看到栈帧内部结构如下：</p><img src="https://pic.imgdb.cn/item/6632619a0ea9cb1403d46fb4.png" alt="计算机组成原理（四）——指令系统——栈帧内包含的内容详细.png"><p>从上图可以知道，栈帧一定有上一层栈帧基址和IP返回地址。其余的区域如局部变量和调用参数等，都不一定存在，具体原因上图也已给出。</p><p>下面看一下如何传参：</p><img src="https://pic.imgdb.cn/item/663262730ea9cb1403d65e01.png" alt="计算机组成原理（四）——指令系统——传参.png"><p>在前面我们说过，一般将局部变量存储在栈帧底层，将调用参数放在栈帧顶层，所以可以通过使用ebp和esp的偏移来实现传参。</p><p>我们可以参考上面的例子，先看caller的汇编指令，他先把temp1和temp2放到ebp-12和ebp-8两个局部变量存储处，然后再把他两的值放到参数调用处，这里发现，在把变量temp2从ebp-8放到esp+4处使用了eax寄存器做中转，即先用mov eax,[ebp-8]，再使用mov [esp+4],eax，那为什么不直接使用mov[esp+4],[ebp-8]呢？原因就是我们前面说过，在x86里mov后面不能跟两个存储在主存里的操作数，所以需要寄存器做中转。</p><p>上图中在caller里调用函数add，执行到add eax,edx处，最后将edx里的数据放到eax里是因为，我们通常使用eax作为函数返回结果的寄存器，所以一个函数如果有返回值，我们通常都要将他放入eax寄存器里。</p><p>函数返回值的执行可以参考下图的上例继续运行：</p><img src="https://pic.imgdb.cn/item/6632653c0ea9cb1403dc8154.png" alt="计算机组成原理（四）——指令系统——传返回值.png"><p>当add函数执行完add eax,edx以后就会执行leave指令，然后ret指令回到caller函数里，我们会发现，caller函数里直接使用mov [ebp-4],eax指令，读取函数的返回值，也就是说，我们将被调用函数的返回值放到eax寄存器里，当回到上一级函数以后，可以直接通过读取eax寄存器里的值，获得函数返回函数。</p><p>下面对这部分内容来个小结：</p><img src="https://pic.imgdb.cn/item/663267510ea9cb1403e21c1a.png" alt="计算机组成原理（四）——指令系统——函数调用的机器表示.png"><p>上面可以作为阅读汇编代码的一个分析框架，涵盖了函数调用的全部过程，需要注意一点，由于有时候函数里面已经使用寄存器存储了数据，这个时候调用函数，被调用的函数可能会覆盖上一层函数的寄存器值，所以对于上一层函数，如果有些寄存器里数据需要保存的，可以保存在栈帧里，然后等函数调用执行完以后，可以通过栈帧复原。</p><h4 id="3-7-5-函数调用小结"><a href="#3-7-5-函数调用小结" class="headerlink" title="3.7.5 函数调用小结"></a>3.7.5 函数调用小结</h4><img src="https://pic.imgdb.cn/item/663268250ea9cb1403e3ca8b.png" alt="计算机组成原理（四）——指令系统——函数调用小结.png"><p>写在最后，这部分有关函数调用的东西，里面牵扯到很多动态执行的过程，所以光看文字理解不了的，可以看一下视频，这里把视频贴在下面：</p><p><a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=56&vd_source=7fb4b255ed876969a742738d7b84f461">4.3_6_1_Call和ret指令(函数调用的机器级表示)_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=57&vd_source=7fb4b255ed876969a742738d7b84f461">4.3_6_2_如何访问栈帧(函数调用的机器级表示)_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=58&vd_source=7fb4b255ed876969a742738d7b84f461">4.3_6_3_如何切换栈帧(函数调用的机器级表示)_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=59&vd_source=7fb4b255ed876969a742738d7b84f461">4.3_6_4_如何传递参数和返回值(函数调用的机器级表示)_哔哩哔哩_bilibili</a></p><h2 id="4-CISC和RISC"><a href="#4-CISC和RISC" class="headerlink" title="4. CISC和RISC"></a>4. CISC和RISC</h2><img src="https://pic.imgdb.cn/item/6634b49f0ea9cb1403a2eeb2.png" alt="计算机组成原理（四）——指令系统——CISC和RISC.png"><p>CISC的设计思想就是一条指令完成一个复杂的基本功能。</p><p>RISC的设计思想则是一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能。</p><p>相较于RICS，CISC由于提供许多复杂的基本功能，所以CISC对应的电路设计起来也复杂的多。</p><p>随着CISC指令集越来越多，越来越复杂，有人就发现了80-20规律。在复杂指令集系统当中，有很多指令可能被使用的频率非常低，并且这些功能复杂的指令可以通过软件由多条功能简单的指令实现。但是硬件与软件不一样，硬件对于这些复杂指令可能要设计很多复杂的硬件电路来实现，这可能会导致成本迅速上升。</p><p>如上图下，站在硬件角度觉得例子，CISC思路会提供所有的复杂指令，但RICS思路只会提供普通的整数加减乘指令，然后由这些简单指令去实现矩阵的加减乘。</p><p>由于许多复杂指令通过硬件实现起来很困难，所以就采用存储程序的思想，由一个比较通用的电路配合存储部件完成一条指令，这就是微程序的概念(微程序的内容会在下一章，即第五章详细介绍)。</p><p>RISC技术只提供简单指令，所以电路设计相对简单，功耗低，被广泛应用于手机、平板等。此外，RISC只提供简单指令，所以这些指令执行时间都差不多，这个特性很容易实现并行技术和流水线技术（并行和流水线的含义也会在第五章细说）。</p><p>下面对CISC和RISC做一个对比：</p><img src="https://pic.imgdb.cn/item/6634b8320ea9cb1403ae8f67.png" alt="计算机组成原理（四）——指令系统——CISC和RISC对比.png"><p>这里有几点要说明一下，在CISC系统里，指令访存是没有限制的，但是在RISC里，只有Load&#x2F;Store指令可以进行访存操作。所以对于下面这个我们经常使用的例子来说，因为乘法指令可以直接访问主存，所以该系统一定是CISC复杂指令系统。</p><img src="https://pic.imgdb.cn/item/6634b8dc0ea9cb1403b0130f.png" alt="计算机组成原理（四）——指令系统——CISC系统.png"><p>由上面这个例子也可以看出，CISC可以把需要相乘的数取到某一寄存器紧接着就完成乘法操作，不会过多占用寄存器。而对于RISC来说，执行乘法指令，一定要先把数据读到某一个寄存器然后再用一条乘法指令对两个寄存器的值进行相乘操作。所以CISC的通用寄存器数量较少，而RISC的通用寄存器数量多。</p><p>这里还留下几个术语，什么是控制方式，什么是指令流水线，什么是微程序控制，什么是组合逻辑控制，这些知识会在第五章介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（四）——树与二叉树</title>
      <link href="/2024/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2024/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构（四）——树与二叉树"><a href="#数据结构（四）——树与二叉树" class="headerlink" title="数据结构（四）——树与二叉树"></a>数据结构（四）——树与二叉树</h1><h2 id="1-树的基本概念"><a href="#1-树的基本概念" class="headerlink" title="1. 树的基本概念"></a>1. 树的基本概念</h2><h3 id="1-1-树的定义"><a href="#1-1-树的定义" class="headerlink" title="1.1 树的定义"></a>1.1 树的定义</h3><p>树的定义：树是n（n&gt;&#x3D;0）个结点的有限集。当n&#x3D;0时，称为空树。</p><p>在任意一棵非空树中应满足：</p><ol><li>有且仅有一个特定的称为根的结点。</li><li>当n&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集T<sub>1</sub>，T<sub>2</sub>，……，T<sub>m</sub>，其中每个集合本身又是一棵树，并且称为根的子树。</li></ol><p>这里第二点不太好理解，其实就是一棵树去掉根结点以后，剩下的几个分支，每个分支都可以构成一个新的树（有点森林的意思）。</p><p>显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p><ol><li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。</li><li>树中所有结点都可以有零个或多个后继。</li></ol><h3 id="1-2-树的基本术语"><a href="#1-2-树的基本术语" class="headerlink" title="1.2 树的基本术语"></a>1.2 树的基本术语</h3><img src="https://pic.imgdb.cn/item/661d187e68eb935713f5b368.png" alt="数据结构（四）——树与二叉树——树的基本术语.png"><p>树的基本术语很简单，建议参考上面的图自己回想，这些基础知识没啥理解难度，重点要记住。如果有不清楚的，可以跳转看视频的介绍：<a href="https://www.bilibili.com/video/BV1b7411N798?p=41&vd_source=7fb4b255ed876969a742738d7b84f461">树的定义和基本术语</a></p><h3 id="1-3-树的性质"><a href="#1-3-树的性质" class="headerlink" title="1.3 树的性质"></a>1.3 树的性质</h3><p><strong>第一条：</strong></p><img src="https://pic.imgdb.cn/item/661d15ae68eb935713eeed8b.png" alt="数据结构（四）——树与二叉树——树的性质1.png"><p><strong>第二条：</strong></p><img src="https://pic.imgdb.cn/item/661d15e668eb935713ef59ed.png"><p><strong>第三条：</strong></p><img src="https://pic.imgdb.cn/item/661d163a68eb935713f00d5f.png" alt="数据结构（四）——树与二叉树——树的性质3.png"><p><strong>第四条：</strong></p><img src="https://pic.imgdb.cn/item/661d168268eb935713f0b268.png" alt="数据结构（四）——树与二叉树——树的性质4.png"><p><strong>第五条：</strong></p><img src="https://pic.imgdb.cn/item/661d16d968eb935713f1a2b7.png" alt="数据结构（四）——树与二叉树——树的性质5.png"><p><strong>第六条：</strong></p><img src="https://pic.imgdb.cn/item/661d175368eb935713f382d6.png" alt="数据结构（四）——树与二叉树——树的性质6.png"><h2 id="2-二叉树的概念"><a href="#2-二叉树的概念" class="headerlink" title="2. 二叉树的概念"></a>2. 二叉树的概念</h2><h3 id="2-1-二叉树的定义及其主要特性"><a href="#2-1-二叉树的定义及其主要特性" class="headerlink" title="2.1 二叉树的定义及其主要特性"></a>2.1 二叉树的定义及其主要特性</h3><h4 id="2-1-1-二叉树的定义"><a href="#2-1-1-二叉树的定义" class="headerlink" title="2.1.1 二叉树的定义"></a>2.1.1 二叉树的定义</h4><p><strong>二叉树的基本概念：</strong></p><img src="https://pic.imgdb.cn/item/661d19c268eb935713f797eb.png" alt="数据结构（四）——树与二叉树——二叉树的概念.png"><p>二叉树是树的一种，所以二叉树也是一种递归结构。</p><p>由于二叉树是有序树，所以二叉树有以下5种基本形态：</p><img src="https://pic.imgdb.cn/item/661d1a6968eb935713f93554.png" alt="数据结构（四）——树与二叉树——二叉树的5种状态.png"><h4 id="2-2-2-几种特殊的二叉树"><a href="#2-2-2-几种特殊的二叉树" class="headerlink" title="2.2.2 几种特殊的二叉树"></a>2.2.2 几种特殊的二叉树</h4><p><strong>(1) 满二叉树与完全二叉树</strong></p><p>满二叉树：除了最下面一层的叶子结点外，其余每一层的结点都长满了两个分支。即满二叉树就是每层都含有最多的结点的二叉树。</p><p>完全二叉树：当且仅当二叉树每个结点都与满二叉树的编号对应时，称为完全二叉树。对于完全二叉树来说，如果某结点只有一个孩子的话，那一定是左孩子。</p><img src="https://pic.imgdb.cn/item/661d1fad68eb935713fe266b.png" alt="数据结构（四）——树与二叉树——满二叉树与完全二叉树.png"><p><strong>(2) 二叉排序树</strong></p><img src="https://pic.imgdb.cn/item/661d208468eb935713feb1cd.png" alt="数据结构（四）——树与二叉树——二叉排序树.png"><p><strong>(3) 平衡二叉排序树</strong></p><img src="https://pic.imgdb.cn/item/661d212968eb935713ff98fe.png" alt="数据结构（四）——树与二叉树——平衡二叉树.png"><p>平衡二叉树与二叉排序树组合起来，构成平衡二叉排序树结构，这样的结构搜索效率会大大提高，可以利用此结构，来实现经常要进行搜索的算法。</p><h3 id="2-2-二叉树与完全二叉树的性质"><a href="#2-2-二叉树与完全二叉树的性质" class="headerlink" title="2.2 二叉树与完全二叉树的性质"></a>2.2 二叉树与完全二叉树的性质</h3><p><strong>第一条：</strong></p><img src="https://pic.imgdb.cn/item/661e6a9e0ea9cb140397fc2d.png" alt="数据结构（四）——树与二叉树——二叉树性质1.png"><p><strong>第二条：</strong></p><img src="https://pic.imgdb.cn/item/661e6ab00ea9cb140398261e.png" alt="数据结构（四）——树与二叉树——二叉树性致2.png"><p><strong>第三条：</strong></p><img src="https://pic.imgdb.cn/item/661e6abc0ea9cb1403984078.png" alt="数据结构（四）——树与二叉树——二叉树性质3.png"><p><strong>完全二叉树的性质：</strong></p><p><strong>第一条：</strong></p><img src="https://pic.imgdb.cn/item/661e69380ea9cb14039380c6.png" alt="数据结构（四）——树与二叉树——完全二叉树性质1-1.png"><img src="https://pic.imgdb.cn/item/661e6bbe0ea9cb14039a93cb.png" alt="数据结构（四）——树与二叉树——完全二叉树性质1-2.png"><p>这里给出了完全二叉树两种知道结点数求高度的公式推导过程：</p><p>第一种是依据h层完全二叉树的结点数大于h-1层满二叉树的结点数，小于等于h层满二叉树结点数来求解。</p><p>第二种是依据h层完全二叉树比h-1层满二叉数至少多1个结点，但小于等于h层满二叉树，但为了求解方便，所以可以认为比h层满二叉树的结点数+1小（即h+1层有一个结点）。</p><p>注意理解两种推导方法的区别。</p><p><strong>第二条：</strong></p><img src="https://pic.imgdb.cn/item/661e6c090ea9cb14039b48c5.png"><h3 id="2-3-二叉树的存储结构"><a href="#2-3-二叉树的存储结构" class="headerlink" title="2.3 二叉树的存储结构"></a>2.3 二叉树的存储结构</h3><h4 id="2-3-1-二叉树的顺序存储"><a href="#2-3-1-二叉树的顺序存储" class="headerlink" title="2.3.1 二叉树的顺序存储"></a>2.3.1 二叉树的顺序存储</h4><p>二叉树的存储结构同我们前面所学的几种结构的存储方式一样，都分为顺序存储和链式存储。</p><p>首先看二叉树的顺序存储：</p><img src="https://pic.imgdb.cn/item/661f7b280ea9cb140318be24.png" alt="数据结构（四）——树与二叉树——二叉树的顺序存储.png"><p>在二叉树的顺序存储中，将二叉树看成一连串地址连续的数组，根据二叉树的结点编号，将其一层一层存入数组中，如上图，为了后续操作方便，可以将数组首位空出，让二叉树的第一个结点从数组第2位开始存储，这样可以令二叉树的结点编号与数组下标相同。从这里，不难看出，二叉树的顺序存储，本质上还是建立数组，所以，二叉树的顺序存储结构和表很类似，进而可以将二叉树的存储程序描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的顺序存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSzie 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树初始化，每个结点赋0</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitTree</span><span class="params">(TreeNode &amp;t)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)</span><br><span class="line">        t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    TreeNode t[Maxsize];<span class="comment">//定义一个树结构数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将二叉树的存储结构描述完以后，就应该考虑，如何实现二叉树的基本操作，首先我们可以考虑一下，有哪几种常用的操作。</p><p>第一种，假设，我们现在知道结点i，那该如何通过i去查找i的左孩子，右孩子，父节点以及i的所在层次呢？</p><p>第二种，假设，若<font color=red><strong>完全二叉树</strong></font>中共有n个结点，则怎么判断第i个结点是否有左孩子，右孩子以及如何判断i是叶子还是分支节点？</p><p>那基于这些问题总结的结论就如下：</p><img src="https://pic.imgdb.cn/item/661f7fee0ea9cb1403300f0b.png" alt="数据结构（四）——树与二叉树——完全二叉树的基本操作.png"><p>不难发现，我们上面所说的每一条结论，都是基于完全二叉树的，那对于普通的二叉树又是怎么样的呢？</p><img src="https://pic.imgdb.cn/item/661f80ae0ea9cb1403343b59.png" alt="数据结构（四）——树与二叉树——二叉树的基本操作.png"><p>如上图，是二叉树进行存储的样子，其中我们会发现，用数组存储普通二叉树时，会出现很多地址上没有存储数据，这是什么原因造成的呢？</p><p>原因很简单，当我们把二叉树按照顺序存储进数组时，如果为了节省地址空间，而将图中1,2,3,4,5,6,7,8,按照t[1]~t[8]存储，就无法反映二叉树中，各节点间的关系。为了保持结点间的关系，就要在二叉树的顺序存储中，把二叉树的结点编号与完全二叉树对应起来。如上面图中所示，这样才能体现二叉树的存储结构。</p><p>基于这种存储模式，前面提到的两种基础操作类型，第一种我们仍可以通过完全二叉树的手段进行左孩子、右孩子及父结点查找。但是判断是否有孩子和是否为叶子结点时，就不能沿用上面操作，需要通过我们一开描述存储结构时，所设计的IsEmpty判空指针进行判断。</p><p>当然，通过上面的图，我们还可以发现，若二叉树不是完全二叉树，会导致有大量空间浪费。若高度为h且只有h个结点单支树（所有结点只有右孩子），也至少需要2<sup>h</sup>-1个存储单元。所以，我们可以得出结论，二叉树的顺序存储结构，只适合存储完全二叉树。</p><p>若想描述二叉树的结构（不仅有完全二叉树）又不想浪费地址，就需要通过链式存储的方式来实现。</p><h4 id="2-3-2-二叉树的链式存储"><a href="#2-3-2-二叉树的链式存储" class="headerlink" title="2.3.2 二叉树的链式存储"></a>2.3.2 二叉树的链式存储</h4><p>二叉树的链式存储结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><p>对二叉树进行链式存储，我们就可以对每个树结点加上左右孩子指针，类似于表的前驱和后继一样，我们可以使用结点的左孩子指针指向左孩子，右孩子指针指向右孩子，依次类推，将所有结点串到一起。使用这种方式，我们可以很容易查找一个结点的左右孩子结点。</p><p>注意，使用链式存储时，如果有n个结点，则一共就会有2n个指针域，但是其中只有n-1个指针域是有只向的，剩下的n+1个指针域全为NULL，而这些空的指针域可以用于构造线索二叉树（线索二叉树在下面，这里做个铺垫）。</p><p>说完二叉树的结点存储结构如何描述，接下来就该考虑如何构建一个二叉树，二叉树的构建过程如下图：</p><img src="https://pic.imgdb.cn/item/661f838a0ea9cb140343afcd.png" alt="数据结构（四）——树与二叉树——二叉树的链式操作.png"><p>对于链式二叉树，我们只说了他对于查找左孩子与右孩子会很方便，那这里就产生了一个疑问，我们要是想找父结点该怎么办？很显然，想找父结点，只能通过遍历的方式查找，但是对于树这种地址不连续且复杂的结构，如何通过遍历去查找到我们想要的信息呢？这就是我们下面要说的树的遍历问题。</p><p>补充：除了遍历还有第二种方法，在描述二叉树链式存储结构时添加父结点指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">father</span>;</span><span class="comment">//父结点指针</span></span><br></pre></td></tr></table></figure><h3 id="2-4-二叉树的遍历"><a href="#2-4-二叉树的遍历" class="headerlink" title="2.4 二叉树的遍历"></a>2.4 二叉树的遍历</h3><p>遍历：就是按照某种次序把所有结点都访问一遍。</p><p>由二叉树的递归定义可知，遍历一棵二叉树便要决定对根节点N、左子树L和右子树R的访问顺序，按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）、后序（LRN）三种遍历算法。</p><h4 id="2-4-1-先序"><a href="#2-4-1-先序" class="headerlink" title="2.4.1 先序"></a>2.4.1 先序</h4><p>先序遍历步骤：</p><ol><li>访问根结点；</li><li>先序遍历左子树；</li><li>先序遍历右子树；</li></ol><img src="https://pic.imgdb.cn/item/661f88ea0ea9cb140369efa6.gif" alt="先序遍历.gif"><p>根据上面的动图，我们可以轻而易举的看出先序遍历的执行过程，所以，可以写出上面二叉树的先序遍历顺序为：A B D H I E J C F K G。</p><p>先序代码实现如下：</p><img src="https://pic.imgdb.cn/item/661f92a70ea9cb1403b0da84.png" alt="数据结构（四）——树与二叉树——先序遍历代码.png"><p>这里主要是递归算法的进行结点遍历，说白了根据思想，摆正访问根结点位置就行，有不明白，可以看下视频里讲解的算法递归过程，我感觉这个东西写多了程序就很容易理解，所以我给个视频链接，就不写递归过程了。<a href="https://www.bilibili.com/video/BV1b7411N798?p=46&spm_id_from=pageDriver&vd_source=7fb4b255ed876969a742738d7b84f461">先序中序后序遍历</a>（11~16分钟讲执行过程）</p><h4 id="2-4-2-中序"><a href="#2-4-2-中序" class="headerlink" title="2.4.2 中序"></a>2.4.2 中序</h4><p>中序遍历步骤：</p><ol><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树；</li></ol><img src="https://pic.imgdb.cn/item/661f89e00ea9cb140370a16d.gif" alt="中序遍历.gif"><p>根据上面的动图，我们可以轻而易举的看出中序遍历的执行过程，所以，可以写出上面二叉树的中序遍历顺序为：H D I B E J A F K C G。</p><p>中序代码实现如下：</p><img src="https://pic.imgdb.cn/item/661f92f90ea9cb1403b32849.png" alt="数据结构（四）——树与二叉树——中序遍历代码.png"><h4 id="2-4-3-后序"><a href="#2-4-3-后序" class="headerlink" title="2.4.3 后序"></a>2.4.3 后序</h4><p>先序遍历步骤：</p><ol><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点；</li></ol><img src="https://pic.imgdb.cn/item/661f8a410ea9cb14037350f8.gif" alt="后序遍历.gif"><p>根据上面的动图，我们可以轻而易举的看出后序遍历的执行过程，所以，可以写出上面二叉树的后序遍历顺序为：H I D J E B K F G C A。</p><p>后序代码实现如下：</p><img src="https://pic.imgdb.cn/item/661f93700ea9cb1403b6dad6.png" alt="数据结构（四）——树与二叉树——后序遍历代码.png"><h4 id="2-4-4-二叉树的层序遍历"><a href="#2-4-4-二叉树的层序遍历" class="headerlink" title="2.4.4 二叉树的层序遍历"></a>2.4.4 二叉树的层序遍历</h4><p>二叉树的层序遍历就是按照从上到下，从左到右的顺序进行遍历，有了这个思想，就可以查看下面的算法思想：</p><img src="https://pic.imgdb.cn/item/661f8bf90ea9cb14037efab3.png"><p>根据上面的算法思想，自己模拟一下运行过程，进而我们可以设计如下的算法：</p><img src="https://pic.imgdb.cn/item/661f8dae0ea9cb14038c11ce.png"><p>在这个算法中有一点要注意，我们保存的是结点的指针而非结点本身，因为结点指针所占用的空间要比结点本身少很多，所以我们可以通过保存结点指针缩短占用空间。 </p><h4 id="2-4-5-补充知识"><a href="#2-4-5-补充知识" class="headerlink" title="2.4.5 补充知识"></a>2.4.5 补充知识</h4><p>对一个算术表达式进行先中后序遍历，可以分别得到这个表达式的前缀、中缀、后缀。但是中缀表达式没有界限符，所以需要我们自己添加界限符。</p><img src="https://pic.imgdb.cn/item/661f91f70ea9cb1403ab6a83.png" alt="数据结构（四）——树与二叉树——二叉树与算术表达式.png"><p>遍历应用——求树的深度：</p><img src="https://pic.imgdb.cn/item/661f9fb80ea9cb140312eab7.png" alt="数据结构（四）——树与二叉树——遍历应用.png"><h3 id="2-5-由遍历序列构造二叉树"><a href="#2-5-由遍历序列构造二叉树" class="headerlink" title="2.5 由遍历序列构造二叉树"></a>2.5 由遍历序列构造二叉树</h3><p>二叉树的遍历有前序遍历、中序遍历、后序遍历和层序遍历，若只知道其中一种的遍历序列，不能唯一确定一棵二叉树。所以要想由遍历序列确定二叉树，至少要知道其中两种的遍历序列。</p><p><font color=red><strong>要注意的是，这两种遍历序列的组合，其中的一种必须是中序遍历序列，不能是另外三种遍历序列两两组合。</strong></font></p><p>这里给个例子：</p><img src="https://pic.imgdb.cn/item/662782380ea9cb1403d27e09.png" alt="数据结构（四）——树与二叉树——三种遍历组合.png"><p>接下来看由中序遍历序列与其他的遍历序列组合如何确定二叉树。</p><h4 id="2-5-1-前序-中序遍历序列"><a href="#2-5-1-前序-中序遍历序列" class="headerlink" title="2.5.1 前序+中序遍历序列"></a>2.5.1 前序+中序遍历序列</h4><img src="https://pic.imgdb.cn/item/662782cb0ea9cb1403d3bc31.png" alt="数据结构（四）——树与二叉树——前序+中序遍历序列.png"><p>根据前序遍历的方式可以知道前序遍历序列第一个一定是整棵二叉树的根结点，然后根据上图的对应方式，可以找到中序遍历序列里的根节点，在中序遍历序列里，根节点左边是左子树，右边是右子树。然后在前序遍历序列里，找到左子树与右子树，这时候前序遍历序列里的左子树和中序遍历序列里的左子树可以看成一个树的前序遍历和中序遍历，原树的左子树的结点就可以看成当前树的根结点，照着这样的方式往下套娃，最后可以确定一个只有一层左右结点的根结点，这样就可以确定根节点的左子树结构。右子树结构使用同样方式确定。</p><p>下面给道例题：</p><img src="https://pic.imgdb.cn/item/662785da0ea9cb1403d9a432.png" alt="数据结构（四）——树与二叉树——前序+中序遍历序列例题.png"><h4 id="2-5-2-后序-中序遍历序列"><a href="#2-5-2-后序-中序遍历序列" class="headerlink" title="2.5.2 后序+中序遍历序列"></a>2.5.2 后序+中序遍历序列</h4><img src="https://pic.imgdb.cn/item/662786560ea9cb1403da8624.png" alt="数据结构（四）——树与二叉树——后序+中序遍历序列.png"><p>原理同前序+中序遍历序列。下面给例题：</p><img src="https://pic.imgdb.cn/item/662786810ea9cb1403dad27d.png" alt="数据结构（四）——树与二叉树——后序+中序遍历序列例题.png"><h4 id="2-5-3-层序-中序遍历序列"><a href="#2-5-3-层序-中序遍历序列" class="headerlink" title="2.5.3 层序+中序遍历序列"></a>2.5.3 层序+中序遍历序列</h4><img src="https://pic.imgdb.cn/item/662786bc0ea9cb1403db4a69.png" alt="数据结构（四）——树与二叉树——层序+中序遍历序列.png"><p>层序与中序遍历序列确定二叉树与前面不同，前面的通过中序序列可以确定左右子树，而左右子树在前序遍历和后序遍历里是连续的。但是在层序遍历里，它的遍历是一层一层的，所以只能通过中序遍历序列和层序遍历序列来确定每一层根结点的左子树的根和右子树的根，进而到最后一层可以确定一整棵二叉树。</p><p>下面给出一道例题，加深理解：</p><img src="https://pic.imgdb.cn/item/662786d50ea9cb1403db7993.png" alt="数据结构（四）——树与二叉树——层序+中序遍历序列例题.png"><h4 id="2-5-4-由遍历序列确定二叉树总结"><a href="#2-5-4-由遍历序列确定二叉树总结" class="headerlink" title="2.5.4 由遍历序列确定二叉树总结"></a>2.5.4 由遍历序列确定二叉树总结</h4><img src="https://pic.imgdb.cn/item/6627881c0ea9cb1403de36e2.png" alt="数据结构（四）——树与二叉树——由遍历确定树总结.png"><p>写在最后，贴个连接，这部分光靠文字和图片描述可能不易理解，可以去视频里看看动态的例题解题过程，进而加深理解：<a href="https://www.bilibili.com/video/BV1b7411N798?p=48&vd_source=7fb4b255ed876969a742738d7b84f461">由遍历序列构造二叉树</a></p><h2 id="3-线索二叉树"><a href="#3-线索二叉树" class="headerlink" title="3. 线索二叉树"></a>3. 线索二叉树</h2><h3 id="3-1-线索二叉树的概念"><a href="#3-1-线索二叉树的概念" class="headerlink" title="3.1 线索二叉树的概念"></a>3.1 线索二叉树的概念</h3><img src="https://pic.imgdb.cn/item/662789630ea9cb1403e0ea74.png" alt="数据结构（四）——树与二叉树——二叉树的中序遍历.png"><p>二叉树可以通过前序遍历、中序遍历和后序遍历。上面的二叉树经过中序遍历，可以得到中序遍历序列为DGBEAFC。在二叉树中，数据元素之间呈现的是非线性的关系，而在遍历序列里，数据元素之间呈现的是线性关系，每个元素有一个与之对应的前驱和后继，而且同线性表一样，第一个元素没有前驱，最后一个没有后继。而从树本身来说，一个结点会有一个前驱，但可能有多个后继。所以，这里要区分一下说结点前驱与后继的角度是从树本身来说，还是从遍历序列来说。</p><p>对于普通的二叉树，我们知道结点的左右孩子，是无法从中间的某个结点进行遍历的。如上图我们无法从G点开始进行之后的中序遍历，得到GBEAFC。</p><p>除此以外，如果给了指定结点的指针，能否找到该结点的遍历前驱和后继呢？答案是可以的，但是需要从根节点出发，重新遍历一遍才可以。这样做起来很麻烦。</p><p>如果在某些场合需要频繁找遍历前驱后继的话，普通的二叉树就显得太麻烦，所以就有人提出了线索二叉树的概念。</p><img src="https://pic.imgdb.cn/item/66278c170ea9cb1403e603c1.png" alt="数据结构（四）——树与二叉树——中序遍历线索二叉树.png"><p>所谓线索二叉树，就是让二叉树里的空链域记录前驱和后继的信息。说白了，就是一个结点的左孩子如果为NULL，则让它的左孩子指向前驱；如果右孩子为NULL，则让右孩子指向后继。如上图就是中序线索二叉树。</p><p>有了线索二叉树，我们就很容易找到遍历序列里一个结点的前驱和后继，也可以从某个结点开始往后进行遍历。</p><p>由此，我们可以进一步推广线索二叉树的存储结构。</p><img src="https://pic.imgdb.cn/item/66278dc50ea9cb1403e92ade.png" alt="数据结构（四）——树与二叉树——中序线索二叉树存储结构.png"><p>如图，是线索二叉树的存储结构，相比较于普通二叉树，我们在里面添加了ltag和rtag，来分别表示左孩子指针和右孩子指针指向孩子还是前驱和后继。如果ltag&#x3D;1，则左孩子指向前驱结点；如果ltag&#x3D;0，则左孩子指针指向左孩子结点，rtag同理。</p><p>之前说，二叉树是二叉链表，现在改成线索二叉树也可以称之为线索链表。</p><p>下面看一下线索二叉树的存储结构，以前序为例（前面的中序线索二叉树展示的是逻辑结构，下面是具体的存储结构）：</p><img src="https://pic.imgdb.cn/item/66278ed90ea9cb1403eb4911.png" alt="数据结构（四）——树与二叉树——中序线索二叉树的存储结构.png"><p>既然有中序线索二叉树的存储结构，就肯定也有先序和后序的，可以自己去画一下，这里就不多说。下面看三种线索二叉树的对比：</p><img src="https://pic.imgdb.cn/item/66278fb20ea9cb1403ed1421.png" alt="数据结构（四）——树与二叉树——三种线索二叉树对比.png"><p>从图中可以看到，中序线索二叉树存在结点前驱指针为NULL和后继指针为NULL的结点，但是先序线索二叉树只存在后继指针为NULL的结点，而后序线索二叉树只存在前驱为NULL的结点。</p><p>下面是对线索二叉树基本概念总结：</p><img src="https://pic.imgdb.cn/item/6627903c0ea9cb1403edf3df.png" alt="数据结构（四）——树与二叉树——线索二叉树小结.png"><h3 id="3-2-二叉树的线索化"><a href="#3-2-二叉树的线索化" class="headerlink" title="3.2 二叉树的线索化"></a>3.2 二叉树的线索化</h3><h4 id="3-2-1-中序二叉树线索化"><a href="#3-2-1-中序二叉树线索化" class="headerlink" title="3.2.1 中序二叉树线索化"></a>3.2.1 中序二叉树线索化</h4><img src="https://pic.imgdb.cn/item/662791a40ea9cb1403f0af72.png" alt="数据结构（四）——树与二叉树——中序线索化完整程序.png"><p>中序二叉树的线索化思想就是先中序遍历二叉树，一边遍历，一边线索化。在遍历之前，要先建立一个全局变量树节点pre用来指向当前访问结点的前驱。</p><p>在遍历的时候，线索化执行在访问当前结点函数里，如果当前访问结点的左孩子为NULL，说明左孩子指针应当指向前驱，即指向pre结点。若当前结点右孩子为NULL，由于没有指向下一个后继的指针，所以应当让pre以及当前访问结点指针向下遍历，指向下一个结点（pre指向当前访问节点，当前访问结点指针指向后继结点），此时让pre指向当前访问结点指针。这里算法思想需要注意一下。</p><p>当指到最后一个结点时，由于其后没有结点，所以我们要对其单独做处理，这里由于定义了全局变量pre，而pre最后会指向遍历的最后一个结点，所以对最后一个结点做操作很方便，但记住一定要处理。</p><h4 id="3-2-2-先序二叉树线索化"><a href="#3-2-2-先序二叉树线索化" class="headerlink" title="3.2.2 先序二叉树线索化"></a>3.2.2 先序二叉树线索化</h4><img src="https://pic.imgdb.cn/item/662791e60ea9cb1403f136b0.png"><p>先序二叉树线索化与中序二叉树线索化一样，只是将中序遍历改为先序遍历。</p><p>其余线索化以及对最后一个结点的操作没有改变。</p><p>但是这里有个易错点，在先序遍历时，要加上左孩子指针指向的不是前驱的判断，如上图，这样做是为了避免出现在原地转圈的情况。</p><p>举个例子，如下图结构，采用先序遍历，定义全局变量pre指向当前结点前驱，p指向当前访问结点。假设p指向D，pre指向B，根据线索化程序可以看到会先让p的左孩子指向pre，再让pre等与q，此时如果对于先序遍历的访问左孩子递归不做判断，由于在上一步访问结点线索化时让p左孩子指向pre，此时再次访问左孩子，p会往回指向B，而pre又跟回去指向B，p接着又一次指向D，这时就会发现，我们的先序遍历在次绕圈，所以需要在遍历时对左孩子指针进行判断。这个地方容易出错，也是先序遍历算法与其他两种算法不一样的地方。</p><img src="https://pic.imgdb.cn/item/662795390ea9cb1403f720c8.png" alt="数据结构（四）——树与二叉树——转圈的例子.png"><h4 id="3-2-3-后序二叉树线索化"><a href="#3-2-3-后序二叉树线索化" class="headerlink" title="3.2.3 后序二叉树线索化"></a>3.2.3 后序二叉树线索化</h4><img src="https://pic.imgdb.cn/item/662792440ea9cb1403f1e488.png" alt="数据结构（四）——树与二叉树——后序线索化完整程序.png"><p>后序二叉树线索化同中序一样，只是遍历使用的是后序遍历。</p><h4 id="3-2-4-二叉树线索化总结"><a href="#3-2-4-二叉树线索化总结" class="headerlink" title="3.2.4 二叉树线索化总结"></a>3.2.4 二叉树线索化总结</h4><img src="https://pic.imgdb.cn/item/662792180ea9cb1403f194d8.png" alt="数据结构（四）——树与二叉树——二叉树线索化总结.png"><h3 id="3-3-在线索二叉树里找前驱和后继"><a href="#3-3-在线索二叉树里找前驱和后继" class="headerlink" title="3.3 在线索二叉树里找前驱和后继"></a>3.3 在线索二叉树里找前驱和后继</h3><h4 id="3-3-1-中序线索二叉树找后继"><a href="#3-3-1-中序线索二叉树找后继" class="headerlink" title="3.3.1 中序线索二叉树找后继"></a>3.3.1 中序线索二叉树找后继</h4><img src="https://pic.imgdb.cn/item/6627980b0ea9cb1403fc9019.png" alt="数据结构（四）——树与二叉树——中序线索二叉树找后继.png"><p>对于中序线索二叉树查找后继next，如果该结点的rtag&#x3D;&#x3D;1，则next直接等于右孩子指针。如果该结点的rtag&#x3D;&#x3D;0，则一定可以确定该结点有右孩子结点，由于采用中序遍历，所有可以按照上图右下角的规律，找到该结点的后继就是右子树的最下面一层的最左结点。算法程序设计如上图左。</p><h4 id="3-3-2-中序线索二叉树找前驱"><a href="#3-3-2-中序线索二叉树找前驱" class="headerlink" title="3.3.2 中序线索二叉树找前驱"></a>3.3.2 中序线索二叉树找前驱</h4><img src="https://pic.imgdb.cn/item/662799430ea9cb1403ff6128.png" alt="数据结构（四）——树与二叉树——中序线索二叉树找前驱.png"><p>同理，对于中序线索二叉树查找前驱pre，如果该结点的ltag&#x3D;&#x3D;1，则pre直接等于左孩子指针。如果该结点的ltag&#x3D;&#x3D;0，则一定可以确定该结点有左孩子结点，由于采用中序遍历，所有可以按照上图右下角的规律，找到该结点的前驱就是左子树的最下面一层的最右结点。算法程序设计如上图左。</p><h4 id="3-3-3-先序线索二叉树找后继"><a href="#3-3-3-先序线索二叉树找后继" class="headerlink" title="3.3.3 先序线索二叉树找后继"></a>3.3.3 先序线索二叉树找后继</h4><img src="https://pic.imgdb.cn/item/662799a10ea9cb1403000fdc.png" alt="数据结构（四）——树与二叉树——先序线索二叉树找后继.png"><p>对于先序线索二叉树查找后继next，如果该结点的rtag&#x3D;&#x3D;1，则next直接等于右孩子指针。如果该结点的rtag&#x3D;&#x3D;0，则一定可以确定该结点有右孩子结点，由于采用先序遍历，所有可以按照上图右下角的规律，找到该结点的后继结点。这里发现，采用先序遍历的话，后继结点与该结点有没有左孩子有关，若有左孩子，则后继结点为左孩子；若无左孩子，则后继结点为右孩子。这里王道没有说算法程序设计，等我有时间再补。</p><h4 id="3-3-4-先序线索二叉树找前驱"><a href="#3-3-4-先序线索二叉树找前驱" class="headerlink" title="3.3.4 先序线索二叉树找前驱"></a>3.3.4 先序线索二叉树找前驱</h4><img src="https://pic.imgdb.cn/item/662799f10ea9cb140300a5c1.png" alt="数据结构（四）——树与二叉树——先序线索二叉树找前驱.png"><p>对于先序线索二叉树查找前驱pre，我们会发现，ltag&#x3D;&#x3D;1时，前驱就是左孩子指针。但是ltag&#x3D;&#x3D;0，采用先序遍历的话，我们发现某个结点只能做根或根的后继，无法做前驱，要想找前驱只能用土方法就是从头遍历。这里我们可以添加一个父指针，指向结点的父结点，将二叉树变成三叉树。这个时候前驱就会有如下四种情况：</p><img src="https://pic.imgdb.cn/item/66279aa60ea9cb140301efd7.png"><h4 id="3-3-5-后序线索二叉树找后继"><a href="#3-3-5-后序线索二叉树找后继" class="headerlink" title="3.3.5 后序线索二叉树找后继"></a>3.3.5 后序线索二叉树找后继</h4><img src="https://pic.imgdb.cn/item/66279aca0ea9cb1403023c0a.png" alt="数据结构（四）——树与二叉树——后序线索二叉树找后继.png"><p>后序线索二叉树找后继和先序线索二叉树找前驱一样，当rtag&#x3D;&#x3D;0时，后序线索二叉树只能是根的前驱，不能是根的后继，所以无法查找后继。要查找只能采用后序遍历或像先序线索二叉树一样添加父指针。</p><p>下面是添加了父指针以后，后序线索二叉树查找后继的四种情况。</p><img src="https://pic.imgdb.cn/item/66279b4e0ea9cb1403034302.png"><h4 id="3-3-6-后序线索二叉树找前驱"><a href="#3-3-6-后序线索二叉树找前驱" class="headerlink" title="3.3.6 后序线索二叉树找前驱"></a>3.3.6 后序线索二叉树找前驱</h4><img src="https://pic.imgdb.cn/item/66279a5a0ea9cb14030167e9.png" alt="数据结构（四）——树与二叉树——后序线索二叉树找前驱.png"><p>对于后序线索二叉树查找前驱pre，如果该结点的ltag&#x3D;&#x3D;1，则pre直接等于左孩子指针。如果该结点的ltag&#x3D;&#x3D;0，则一定可以确定该结点有左孩子结点，由于采用后序遍历，所有可以按照上图右下角的规律，找到该结点的前驱结点。这里发现，采用后序遍历的话，前驱结点与该结点有没有右孩子有关，若有右孩子，则前驱结点为右孩子；若无右孩子，则前驱结点为左孩子。这里王道没有说算法程序设计。</p><h4 id="3-3-7-在线索二叉树里找前驱和后继小结"><a href="#3-3-7-在线索二叉树里找前驱和后继小结" class="headerlink" title="3.3.7 在线索二叉树里找前驱和后继小结"></a>3.3.7 在线索二叉树里找前驱和后继小结</h4><img src="https://pic.imgdb.cn/item/66279bc40ea9cb1403040fdd.png"><p>这里说一下，我对几个线索二叉树后继与前驱查找可行性的理解，在我看来，一个结点能不能查找前驱或后继，关键在于看该结点作为根结点时，采用的遍历方式中，它放在什么位置，我们知道三种遍历方式无外乎就是左孩子、根节点、右孩子的排列，如果根节点放在中间，则可以查找前驱和后继，对应的就是中序遍历。如果根结点放在左边就只能查找后继，对应的是先序遍历。如果根结点放在右边，则只能查找前驱，对应的就是后序遍历。</p><p>说的再直白点，就是该结点作为根结点只能向下层查找，不能往上层查找，在先序遍历里，根结点下层的全是他的前驱，上层的全是他的后继。后序遍历里，根节点下层的全是他的后继，上层的全是他的前驱。而在中序遍历里，根结点的左子树全是它的前驱，右子树全是它的后继。</p><h2 id="4-树、森林"><a href="#4-树、森林" class="headerlink" title="4. 树、森林"></a>4. 树、森林</h2><h3 id="4-1-树的存储结构"><a href="#4-1-树的存储结构" class="headerlink" title="4.1 树的存储结构"></a>4.1 树的存储结构</h3><h4 id="4-1-1-树的逻辑结构"><a href="#4-1-1-树的逻辑结构" class="headerlink" title="4.1.1 树的逻辑结构"></a>4.1.1 树的逻辑结构</h4><img src="https://pic.imgdb.cn/item/6629ac770ea9cb1403616287.png" alt="数据结构（四）——树与二叉树——树的逻辑结构.png"><h4 id="4-1-2-树的存储方法一——双亲表示法（顺序存储）"><a href="#4-1-2-树的存储方法一——双亲表示法（顺序存储）" class="headerlink" title="4.1.2 树的存储方法一——双亲表示法（顺序存储）"></a>4.1.2 树的存储方法一——双亲表示法（顺序存储）</h4><img src="https://pic.imgdb.cn/item/6629ad130ea9cb1403624221.png" alt="数据结构（四）——树与二叉树——双亲表示法.png"><p>在双亲表示法里，定义了一个数组来存储各个结点数据，同时定义了int类型的parent变量用来指向双亲结点在数组中的存储位置下标，如上图右。</p><p>下面看下使用这种结构怎么进行增删改查操作。</p><p>首先，看下添加的操作：</p><img src="https://pic.imgdb.cn/item/6629ae1b0ea9cb140363c0ca.png" alt="数据结构（四）——树与二叉树——双亲表示法添加.png"><p>使用双亲表示法进行添加操作时，只需要在数组里的data域里写上数据，并在parent里指明父结点位置即可。如上图，先添加M结点，就在11的data里写M，parent里写7；再添加L结点时，就继续往数组里添加数据。这里会发现，右边的数组看似按一行一行的逻辑顺序排列存储，其实并不需要，就像我们添加的M、L，就不是按次序存储的。</p><p>接下来，看删除的操作：</p><img src="https://pic.imgdb.cn/item/6629b06e0ea9cb14036721ba.png"><p>如上图，删除有两种方案，第一种删除该结点，并将该位置的双亲指针改为-1；第二种删除该结点，然后将数组最后一个存储的结点移到被删除的结点位置。</p><p>上面演示的是删除叶子结点G的方案，但是如果删除的不是叶子结点呢？假设删除D结点，如果删除D结点，意味着删除了以D为根的整棵子树，因此，还要找到D下的其他子孙结点，把所有子孙结点都给删除。这就涉及到从一个结点找到其孩子结点的操作，也就是查询的操作。如下图：</p><img src="https://pic.imgdb.cn/item/6629cb7a0ea9cb14039c712f.png" alt="数据结构（四）——树与二叉树——双亲表示法删除根节点.png"><p>根据双亲表示法，找到一个结点的双亲结点很简单，但要想找到它的孩子就要从头到尾依次遍历，查看所有结点的双亲结点指针是否指向当前结点。所以，使用双亲表示法查找孩子很不方便。</p><p>同时，这个地方也暴露了删除方案的第一种方案的问题，如果没有用最后一个元素来填充被删除的元素，这时候进行遍历操作就意味着要多判断一个无效的结点。所以会导致遍历速度更慢。</p><h4 id="4-1-3-树的存储方法二——孩子表示法（顺序-链式存储）"><a href="#4-1-3-树的存储方法二——孩子表示法（顺序-链式存储）" class="headerlink" title="4.1.3 树的存储方法二——孩子表示法（顺序+链式存储）"></a>4.1.3 树的存储方法二——孩子表示法（顺序+链式存储）</h4><p>孩子表示法：顺序存储各个节点，每个结点中保存孩子链表头指针。</p><img src="https://pic.imgdb.cn/item/6629cc030ea9cb14039d76a7.png" alt="数据结构（四）——树与二叉树——孩子表示法.png"><h4 id="4-1-4-树的存储方法三——孩子兄弟表示法（链式存储）"><a href="#4-1-4-树的存储方法三——孩子兄弟表示法（链式存储）" class="headerlink" title="4.1.4 树的存储方法三——孩子兄弟表示法（链式存储）"></a>4.1.4 树的存储方法三——孩子兄弟表示法（链式存储）</h4><img src="https://pic.imgdb.cn/item/6629cc660ea9cb14039e426e.png" alt="数据结构（四）——树与二叉树——孩子兄弟表示法.png"><p>孩子兄弟表示法就是用左指针指向第一个孩子，右指针指向该结点右边的第一个兄弟。根据孩子兄弟表示法的思路就可以将一个树转换成二叉树，如上图的转换。同理，既然可以将树转换成二叉树，也可以将二叉树逆向转换成树。</p><h4 id="4-1-5-森林与二叉树的转换"><a href="#4-1-5-森林与二叉树的转换" class="headerlink" title="4.1.5 森林与二叉树的转换"></a>4.1.5 森林与二叉树的转换</h4><p><strong>森林：是m棵互不相交的树的集合。</strong>一棵树，去掉根结点，剩下的所有互不相连的子树的集合就是森林。</p><p>森林转化为二叉树：</p><img src="https://pic.imgdb.cn/item/6629e6670ea9cb1403d3f97c.png" alt="数据结构（四）——树与二叉树——森林转换为二叉树.png"><p>二叉树转化为森林：</p><img src="https://pic.imgdb.cn/item/6629e69b0ea9cb1403d46e68.png" alt="数据结构（四）——树与二叉树——二叉树转换为森林.png"><h4 id="4-1-6-树的存储结构小结"><a href="#4-1-6-树的存储结构小结" class="headerlink" title="4.1.6 树的存储结构小结"></a>4.1.6 树的存储结构小结</h4><img src="https://pic.imgdb.cn/item/6629e71e0ea9cb1403d5a0c6.png" alt="数据结构（四）——树与二叉树——树的存储结构小结.png"><h3 id="4-2-树和森林的遍历"><a href="#4-2-树和森林的遍历" class="headerlink" title="4.2 树和森林的遍历"></a>4.2 树和森林的遍历</h3><h4 id="4-2-1-树的先根遍历"><a href="#4-2-1-树的先根遍历" class="headerlink" title="4.2.1 树的先根遍历"></a>4.2.1 树的先根遍历</h4><img src="https://pic.imgdb.cn/item/6629e7780ea9cb1403d65d44.png" alt="数据结构（四）——树与二叉树——树的先根遍历.png"><p>树的先根遍历就是先访问根结点，然后对每棵子树进行先根遍历，注意先根遍历完第一课子树才会遍历第二课子树，这是一个递归遍历的结构。</p><p><strong>树的先根遍历序列与将这棵树转换为相应的二叉树的先序遍历序列相同。</strong></p><h4 id="4-2-2-树的后根遍历"><a href="#4-2-2-树的后根遍历" class="headerlink" title="4.2.2 树的后根遍历"></a>4.2.2 树的后根遍历</h4><img src="https://pic.imgdb.cn/item/6629e8560ea9cb1403d825ed.png" alt="数据结构（四）——树与二叉树——树的后根遍历.png"><p>树的后根遍历就是先对每棵子树进行后根遍历，然后再访问根结点。</p><p><strong>树的后根遍历序列与这棵树对应的二叉树的中序遍历序列相同。</strong></p><h4 id="4-2-3-树的层次遍历"><a href="#4-2-3-树的层次遍历" class="headerlink" title="4.2.3 树的层次遍历"></a>4.2.3 树的层次遍历</h4><img src="https://pic.imgdb.cn/item/6629e99b0ea9cb1403dae55b.png" alt="数据结构（四）——树与二叉树——树的层次遍历.png"><p>到这里，不难发现，前面探索树的先根和后根遍历，是尽可能的往树的深处钻；而树的层次遍历，则是尽可能的横向探索。所以对树的层次遍历也可以称为对树的广度优先遍历，而对树的先根和后根遍历也可以称为对树的深度优先遍历。</p><h4 id="4-2-4-森林的先序遍历"><a href="#4-2-4-森林的先序遍历" class="headerlink" title="4.2.4 森林的先序遍历"></a>4.2.4 森林的先序遍历</h4><img src="https://pic.imgdb.cn/item/6629ea9a0ea9cb1403dcd58e.png" alt="数据结构（四）——树与二叉树——森林的先序遍历.png"><p>森林的先序遍历，就可以看成从左到右对每棵树进行先根遍历。</p><p>当然也可以将森林转换为二叉树，这时对森林的先序遍历就是对二叉树的先序遍历，如下图。</p><img src="https://pic.imgdb.cn/item/6629eb090ea9cb1403ddc4b8.png" alt="数据结构（四）——树与二叉树——森林的先序遍历与二叉树.png"><h4 id="4-2-5-森林的中序遍历"><a href="#4-2-5-森林的中序遍历" class="headerlink" title="4.2.5 森林的中序遍历"></a>4.2.5 森林的中序遍历</h4><img src="https://pic.imgdb.cn/item/6629eb540ea9cb1403de7552.png" alt="数据结构（四）——树与二叉树——森林的中序遍历.png"><p>森林的中序遍历，就可以看成从左到右对每棵树进行后根遍历。</p><p>同先序遍历一样，也可以将森林转换为二叉树，这时对森林的中序遍历就是对二叉树的中序遍历，如下图。</p><img src="https://pic.imgdb.cn/item/6629eba50ea9cb1403df326f.png" alt="数据结构（四）——树与二叉树——森林的中序遍历与二叉树.png"><h4 id="4-2-6-树和森林的遍历小结"><a href="#4-2-6-树和森林的遍历小结" class="headerlink" title="4.2.6 树和森林的遍历小结"></a>4.2.6 树和森林的遍历小结</h4><img src="https://pic.imgdb.cn/item/6629ec150ea9cb1403e02709.png" alt="数据结构（四）——树与二叉树——树和森林遍历小结.png"><p>树的先根遍历与森林的先序遍历和二叉树的先序遍历在效果上是等价的。</p><p>树的后根遍历与森林的中序遍历和二叉树的中序遍历在效果上是等价的。</p><p>在考408考试里，一般只考到求树或森林或二叉树的遍历序列。所以上面三种会其中一种的遍历序列求法即可，这样可以通过互相转换的方式进行求解。</p><p>但是外一考遍历到算法，可以将树和森林的存储结构转换为二叉树的存储结构，然后对二叉树进行算法遍历。</p><p>所以，在这里，我个人推荐掌握二叉树，毕竟二叉树本身就是很重要的考点，而且前面也对二叉树的遍历算法进行过很详细的说明，如果考试时连二叉树的都不会，我的评价，洗洗睡吧，明年再考。</p><h3 id="4-3-哈夫曼树"><a href="#4-3-哈夫曼树" class="headerlink" title="4.3 哈夫曼树"></a>4.3 哈夫曼树</h3><h4 id="4-3-1-哈夫曼树"><a href="#4-3-1-哈夫曼树" class="headerlink" title="4.3.1 哈夫曼树"></a>4.3.1 哈夫曼树</h4><img src="https://pic.imgdb.cn/item/662d106e0ea9cb140358c058.png" alt="数据结构（四）——树与二叉树——带权路径长度的定义.png"><p>根据上图，先了解结点的权，结点的带权路径长度和树的带权路径长度三个概念。</p><p>了解完这三个概念以后，就可以接着介绍什么是哈夫曼树。</p><img src="https://pic.imgdb.cn/item/662d11610ea9cb14035b1c24.png" alt="数据结构（四）——树与二叉树——哈夫曼树.png"><p>哈夫曼树也称最优二叉树，就是在含有n个带权叶结点的二叉树中，其中带权路径长度最小的二叉树就是哈夫曼树。</p><p>注意，从上图也能看出来，哈夫曼树不唯一。</p><p>接下来看一下哈夫曼树的构造：</p><img src="https://pic.imgdb.cn/item/662d11dd0ea9cb14035c9d7b.png" alt="数据结构（四）——树与二叉树——哈夫曼树的构造.png"><p>哈夫曼树的构造过程如上，这里说几个要注意的地方。</p><p>将n个结点分别作为n棵仅含一个结点的二叉树，构造成一个哈夫曼树，则这个哈夫曼树的结点总数为2n-1，因为每两个结点会构成1个新结点，新结点与另一个结点又会构成一个新结点，往下递推，n个结点就可以产生n-1个新结点作为连接。</p><p>从哈夫曼树的构造中不难看出，每次构造都需要两个结点，所以不存在度为1的结点，只有度为0和2的结点。</p><p>另外，哈夫曼树的构造不唯一，例如上图构造哈夫曼树的图例里，从第二个图到第三个图，是将新产生的权为3的结点和权为2的结点结合，但也可以将权为2的结点与另一个权为3的结点结合。这时产生的就是另一个哈夫曼树。但哈夫曼树不论结构怎么样，他们的WPL必然相同且为最优。</p><p>另外哈夫曼树的构造并不分左右顺序，即左右顺序任意，一般情况下，我们把权值小的结点写在左边，权值大的结点写在右边。</p><h4 id="4-3-2-哈夫曼编码"><a href="#4-3-2-哈夫曼编码" class="headerlink" title="4.3.2 哈夫曼编码"></a>4.3.2 哈夫曼编码</h4><p>接下来看一下哈夫曼树的应用，哈夫曼编码。</p><img src="https://pic.imgdb.cn/item/662d15c40ea9cb140368b546.png" alt="数据结构（四）——树与二叉树——哈夫曼编码.png"><p>先看上图的引例，假设小渣向老渣传送100个选择题答案，对于答案选项可以通过两个二进制bit位进行编码，对应关系也在上图，基于这种编码，要传输完100个选择题的答案，需要二进制长度位200bit。</p><p>到这里，我们可以将这个引例转化为一个二叉树，树的接结点向左的路径为0，向右为1，根据A、B、C、D的编码值，就可以构造上图左的二叉树，而80题选C，10题选A等这些数据，就可以代表结点的权值。我们所求的二进制长度，就是这个树的WPL。</p><p>既然牵扯到WPL了，就可以想到最短的WPL，即将这棵树转换成哈夫曼树，是不是就可以使用更短的长度进行传输？</p><p>基于此思想，就可以按照权值，将A、B、C、D构造成如图右的哈夫曼树，依然按照左为0，右为1的原则，在路径上标上值。这时候就可以重新得到A、B、C、D的编码，<font color=red><strong>基于哈夫曼树得出的编码就是哈夫曼编码</strong></font>。根据哈夫曼编码，得出WPL&#x3D;130，这也就表示，小渣向老渣传送100个选择题答案，只需要发送长为130bit的二进制串就可以实现，并不需要传送200bit。</p><p>像上面使用哈夫曼树得出的编码，由于各个字符长度不同，所以也叫可变长度编码。</p><p>上面的例子里，A的频率也很高，那能不能仅用1表示A，来进一步缩短长度呢？答案是不可以，具体原因参考下图。</p><img src="https://pic.imgdb.cn/item/662d18ed0ea9cb1403704c1f.png" alt="数据结构（四）——树与二叉树——哈夫曼编码易错点.png"><p>若将A编码为1，此时若传送CAAABD，转换成二进制就是0111111110，但接收方可能解码为CBBD，这就出现了差错。</p><p>所以，这里就可以总结出一个结论，对于一个字符集，<font color=red><strong>要设计一个可变长度编码，所有这些字符集中的字符，对应到编码树里，只能当做叶子结点，而不能当做分支节点。从另一个角度来说，就是任何一个字符的编码不能是另一个字符的编码的前缀。</strong></font></p><p>到这里，可以将哈夫曼树的知识点总结如下图：</p><img src="https://pic.imgdb.cn/item/662d1aea0ea9cb14037506aa.png" alt="数据结构（四）——树与二叉树——哈夫曼编码小结.png"><p>求哈夫曼树本质上就是求最短WPL，所以，采用<font color=green><strong>哈夫曼树</strong>可以应用于<strong>实现数据的压缩</strong></font>，这也是哈夫曼树最常用的地方。</p><h4 id="4-3-3-哈夫曼树小结"><a href="#4-3-3-哈夫曼树小结" class="headerlink" title="4.3.3 哈夫曼树小结"></a>4.3.3 哈夫曼树小结</h4><img src="https://pic.imgdb.cn/item/662d1be10ea9cb140377d6df.png" alt="数据结构（四）——树与二叉树——哈夫曼树小结.png"><h2 id="5-并查集"><a href="#5-并查集" class="headerlink" title="5. 并查集"></a><strong>5. 并查集</strong></h2><h3 id="5-1-并查集"><a href="#5-1-并查集" class="headerlink" title="5.1 并查集"></a>5.1 并查集</h3><img src="https://pic.imgdb.cn/item/662de5850ea9cb1403d93b64.png" alt="数据结构（四）——树与二叉树——集合.png"><p>集合这个概念，在初中数学里就已经接触，集合是指具有某种特定性质的具体的或抽象的对象汇总而成的集体。在数据结构里，我们可以把几个不相干的元素，放到一个整体里，这个整体就是集合。</p><p>如上图，就是将各个元素划分为3个互不相干的子集。那基于此，可以思考一下，如何用代码表示这种逻辑关系呢？联系前面所学树、森林的结构，发现可以用树、森林来表示集合间的关系。</p><p>同一个集合内的元素，在物理上可以把他们组织成一个树状的结构，不同集合的元素就放到不同的树里，如下图，这也是我们用代码表示集合关系的思路。</p><img src="https://pic.imgdb.cn/item/662deaad0ea9cb1403e5a5be.png" alt="数据结构（四）——树与二叉树——集合树查找.png"><p>接下里，我们要考虑一下集合的两个基本操作——查与并。</p><p>首先看查操作，所谓查操作就是查找一个元素到底属于哪一个集合。思想就是从指定元素开始出发，一路向根结点查找，找到根结点，就可以知道该元素属于哪一个集合。</p><p>基于查找的思想，我们可以实现判断两个元素是否属于同一集合，只要分别查找到两个元素所属集合的根结点，然后对根结点进行判断，如果根结点相同，说明是同一个集合；不同，则不属于一个集合。</p><p>如何实现集合的并操作呢？如下图：</p><img src="https://pic.imgdb.cn/item/662deb430ea9cb1403e6d9c1.png" alt="数据结构（四）——树与二叉树——集合树并.png"><p>若要实现集合的并操作，只需要让一棵树成为另一棵树的子树即可。</p><p>知道两个操作的基本思想，接下来就要考虑怎么实现代码。既然集合使用树的结构表示，那就回忆一下树的存储方法有双亲表示法、孩子表示法和孩子兄弟表示法，结合并查集的操作，可以发现，使用双亲表示法会更合适方便一些。</p><img src="https://pic.imgdb.cn/item/662dee080ea9cb1403ec6316.png" alt="数据结构（四）——树与二叉树——并查集的存储结构及基本操作.png"><p>上图为使用双亲表示法来实现并查集，可以看到，将A~M结点划分为对应的数组下标，数组里存储该结点的父结点下标，根结点对应的数组里存储-1，表示没有父结点。基于这种存储结构，我们要想实现并、查操作就很容易了。</p><p><strong>查，只需要从当前结点开始，查找其对应数组下标里的父结点下标，一值往上查，直到查找的数组里存储-1的下标，即可确定根结点。</strong></p><p><strong>并，只需要将另一棵树的根结点，将其对应数组下标里的数据从-1改成另一棵树根结点的下标即可。</strong></p><p>下面来看一下代码实现：</p><p><strong>(1) 并查集初始化</strong></p><img src="https://pic.imgdb.cn/item/662def420ea9cb1403eeca3c.png" alt="数据结构（四）——树与二叉树——并查集的初始化.png"><p>首先，对一些散开的数据元素，我们要先进行初始化操作，即将所有结点的数组内容都初始化为-1，表示各个元素之间各成一派，每个元素都是一个子集。初始化以后，就可以根据实际需求，将各个元素合并成几个互不相交的子集。</p><p><strong>(2) 并查集的并与查操作</strong></p><img src="https://pic.imgdb.cn/item/662deff90ea9cb1403f04b34.png" alt="数据结构（四）——树与二叉树——并查集的并查.png"><p>根据上面所说的并与查的思想，我们来看下代码。</p><p>并操作Union，传入存储数组 S [ ] 和两棵树的根结点Root1和Root2，判断Root1和Root2是否相同，相同则说明一个集合，不需要合并；不同，则将Root2的根结点从无改为Root1。</p><p>查操作Find，循环找到根，先判断当前结点的父结点数组下标是否小于0，小于0，则说明当前结点就是根结点，直接返回自己的下标位置即可，若不是，则查找自己父结点的父结点的数组下标，看是否小于0，若不小于0则继续往下查找，直到找到小于0的，返回当前父结点下标小于0的结点的下标。</p><p>注意，若想将两个存储元素的集合合并，要先通过Find找到两个元素对应的根结点，然后通过union将两个集合合并。</p><h3 id="5-2-并查集的优化"><a href="#5-2-并查集的优化" class="headerlink" title="5.2 并查集的优化"></a>5.2 并查集的优化</h3><p>接下来分析一下上面两个算法的时间复杂度：</p><img src="https://pic.imgdb.cn/item/662df2450ea9cb1403f4638d.png" alt="数据结构（四）——树与二叉树——并查集代码的时间复杂度.png"><p>不难发现，Union操作不涉及循环，所以时间复杂度仅有O(1)，而Find操作，由于树的结构不确定性，所以，可能出现上图右最坏的情况，这个时候，时间复杂度就是O(n)。</p><p>而为了避免出现右边这种最坏情况，我们在构造时，就要尽可能的让树的高度小，这就是我们的优化思路，即每次Union操作构建树的时候，尽量让树不要太高。</p><img src="https://pic.imgdb.cn/item/662df8fb0ea9cb140304ca53.png" alt="数据结构（四）——树与二叉树——并查集Union优化.png"><p>上面便是对Union操作的优化，让根结点对应数组下标的数组里存储结点数，由于正值会与数组下标产生歧义，所以用负值表示，其绝对值表示当前集合有多少结点。如上面A结点里存储-6，其绝对值为6，就表示以A为根结点的树有6个结点。用结点数区分大树和小树，在合并时，让小树合并到大树里，就可以尽可能的缩短树的高度。</p><p>注意，合并以后别忘了改变根结点数组里的结点总数数据。</p><p>这里我感觉有个疑问，在王道课里，咸鱼说通过结点数判断大树小树，但是目的是尽可能缩短树的高度，所以我感觉应该是判断树的深度，但不得不说，树的深度并不好判断。结合咸鱼说的构造时就要让树尽可能矮，所以我感觉，应该是在还是散列集就时就向最矮树构造，当构造的结点越多，构造树的深度应该就越大。但这里面其实还存在一个问题，就是在构造时为了让树矮，可能会出现我每次构造都向根结点添加，导致树只有2层深度，却很宽的问题。所以，这里我也有点疑惑，感觉还是结合具体题目，具体分析比较好。</p><img src="https://pic.imgdb.cn/item/662e09400ea9cb14032bd05f.png" alt="数据结构（四）——树与二叉树——并查集Union优化复杂度.png"><p>通过Union优化算法，构造的树高不会超过[log<sub>2</sub>n]+1，这也就是说Find操作最坏时间复杂度为：O(log<sub>2</sub>n)。</p><p>上面说的是Union的优化算法，接下里，说一下Find的优化算法。</p><img src="https://pic.imgdb.cn/item/662e0a3b0ea9cb14032e1181.png" alt="数据结构（四）——树与二叉树——Find优化.png"><p>Find优化就是压缩路径，即从当前结点，向上查找到根结点，把这条路上查找所遍历的每一个结点，都挂到根结点下，具体过程如上图左。从L到A要经历L、E、B，所以把这三个全都挂到A下，并改变这三个对应数组下标里的值，让他们全都指向A的下标。</p><img src="https://pic.imgdb.cn/item/662e0b9b0ea9cb1403312ac7.png" alt="数据结构（四）——树与二叉树——Find优化时间复杂度.png"><p>使用Find优化算法，可以使树高度不超过O(α(n))。至于α(n)是什么不用管，只需要知道他是一个增长很慢的函数，比log<sub>2</sub>n还慢。对于常见的n值，如n&#x3D;1000，通常α(n)&lt;4。这也就意味着，对于常见的n值来说，Find操作的时间复杂度小于等于O(4)，几乎可以使用常数级的O(1)时间，就完成Find操作。</p><h3 id="5-3-并查集小结"><a href="#5-3-并查集小结" class="headerlink" title="5.3 并查集小结"></a>5.3 并查集小结</h3><p><strong>并查集思维图：</strong></p><img src="https://pic.imgdb.cn/item/662e0d7b0ea9cb140335773f.png" alt="数据结构（四）——树与二叉树——并查思维图.png"><p><strong>优化算法描述小结：</strong></p><img src="https://pic.imgdb.cn/item/662e0cf60ea9cb1403344096.png" alt="数据结构（四）——树与二叉树——Find优化&Union优化.png"><p><strong>优化时间复杂度小结：</strong></p><img src="https://pic.imgdb.cn/item/662e0d2c0ea9cb140334bc30.png" alt="数据结构（四）——树与二叉树——对应优化的时间复杂度.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（三）——数据链路层</title>
      <link href="/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（三）——数据链路层"><a href="#计算机网络（三）——数据链路层" class="headerlink" title="计算机网络（三）——数据链路层"></a>计算机网络（三）——数据链路层</h1><h2 id="1-数据链路层功能概述"><a href="#1-数据链路层功能概述" class="headerlink" title="1. 数据链路层功能概述"></a>1. 数据链路层功能概述</h2><h3 id="1-1-数据链路层的基本概念"><a href="#1-1-数据链路层的基本概念" class="headerlink" title="1.1 数据链路层的基本概念"></a>1.1 数据链路层的基本概念</h3><img src="https://pic.imgdb.cn/item/6616405d68eb93571324f390.png" alt="计算机网络（三）——数据链路层——数据链路研究思想.png"><p>当从A主机向B主机发送数据时，会经过自上而下的封装以及自下而上的解封装过程。而当我们去研究数据链路层时，很多情况下，我们只去关注协议栈中水平方向的数据链路层，所以当A向B发送数据时，我们就可以想象，数据从A的链路层水平向右发送的。这就是我们这一章研究数据链路层的思想。</p><p>注意，这部分的研究思想很重要，说白了，这个思想就是抛去了下面的物理层，把数据链路层当成最底层来进行相互的数据传输。一定要搞明白这个思想，我一开始也没注意这个研究思想，但后来发现后面的很多东西要想理解，必须先搞清楚这个思想，不然就会感觉怪怪的，或者有疑惑。</p><img src="https://pic.imgdb.cn/item/66163fb768eb9357132393de.png" alt="计算机网络（三）——数据链路层——数据链路层基本概念.png"><p>上图给出了数据链路层的基本概念，<strong>注意区分链路和数据链路</strong>。</p><p>数据链路层的主要任务是实现帧在一段链路上或一个网络中进行传输。数据链路层的协议有很多种，但有三个基本问题则是共同的，<font color=red><strong>即封装成帧、透明传输和差错检测</strong></font>。这三个问题，我们会在接下来的介绍中进行细说。</p><h3 id="1-2-数据链路层的基本功能"><a href="#1-2-数据链路层的基本功能" class="headerlink" title="1.2 数据链路层的基本功能"></a>1.2 数据链路层的基本功能</h3><img src="https://pic.imgdb.cn/item/6616400868eb9357132446a2.png" alt="计算机网络（三）——数据链路层——数据链路层基本功能.png"><p>数据链路层有如上图所述的五种功能。这里简单说一下功能一。</p><ol><li>无确认无连接服务：源主机发送帧时不需要先建立链路连接，目的主机收到帧时不需要发回确认。数据传输的可靠性由高层负责。<font color=FFB3FF><strong>适用于误码率较低的信道</strong></font>，如以太网。</li><li>有确认无连接服务：源主机发送帧时不需先建立链路连接，但目的主机收到帧时必须发回确认。源主机在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。<font color=FFB3FF><strong>该服务适用于误码率较高的信道</strong></font>，如无线通信。</li><li>有确认面向连接服务：帧传输过程分为三个阶段：建立链路、传输帧、释放链路。目的主机对收到的每一个帧都要返回确认。<font color=FFB3FF><strong>该服务适用于可靠性要求较高的场合</strong></font>。</li></ol><h2 id="2-组帧"><a href="#2-组帧" class="headerlink" title="2. 组帧"></a>2. 组帧</h2><h3 id="2-1-封装成帧"><a href="#2-1-封装成帧" class="headerlink" title="2.1 封装成帧"></a>2.1 封装成帧</h3><img src="https://pic.imgdb.cn/item/6616442268eb9357132d627e.png" alt="计算机网络（三）——数据链路层——封装成帧.png"><p>封装成帧就是在数据头部和尾部添加一组信息数据，这组数据包含控制信息，目标地址等信息。在数据传输时，每一组数据都会添加帧信息，这就导致，数据的传输会有大量无效数据，为了提高数据的传输效率，我们要尽可能的保证帧的数据部分足够大。因此每种链路层协议里都规定了帧的数据部分的长度上限，即最大传送单元。</p><h3 id="2-2-透明传输"><a href="#2-2-透明传输" class="headerlink" title="2.2 透明传输"></a>2.2 透明传输</h3><img src="https://pic.imgdb.cn/item/6616447d68eb9357132dee06.png" alt="计算机网络（三）——数据链路层——透明传输.png"><h3 id="2-3-组帧的三种方法"><a href="#2-3-组帧的三种方法" class="headerlink" title="2.3 组帧的三种方法"></a>2.3 组帧的三种方法</h3><h4 id="2-3-1-字符计数法"><a href="#2-3-1-字符计数法" class="headerlink" title="2.3.1 字符计数法"></a>2.3.1 字符计数法</h4><img src="https://pic.imgdb.cn/item/661644fc68eb9357132f2a33.png" alt="计算机网络（三）——数据链路层——字符计数法.png"><p>字符计数法在每一个帧的首部使用一个计数字段，来记录当前帧里有多少位字符，如上图，这样就能确定帧结束位置，又因为帧与帧之间是连续传输的，所以也能确定下一帧的开始位置。但是字符计数法将所有数据放到了一起，一旦其中一组的帧边界划分出现错误，数据的传输就会出现灾难性错误。</p><h4 id="2-3-2-字节填充法"><a href="#2-3-2-字节填充法" class="headerlink" title="2.3.2 字节填充法"></a>2.3.2 字节填充法</h4><img src="https://pic.imgdb.cn/item/6616459768eb935713308032.png" alt="计算机网络（三）——数据链路层——字符填充法.png"><p>字符填充法使用特定的字节来界定帧的开始与结束，如上图，使用SOH代表帧开始，EOT代表帧结束。但这样做的话会出现一个问题，如果中间数据存在于帧头或帧尾一样的数据，就可能会出现帧边界误判的情况。为了避免这种情况出现，我们可以通过加转义字符的方式来进行处理，在数据里如果出现与帧头或帧尾相同的数据，就在其前面加上ESC，这样在进行检测时，检测到ESC时，不管ESC下一位是什么，都当成数据进行传输。</p><p>具体的字符填充法过程如下图所示：</p><img src="https://pic.imgdb.cn/item/661645d668eb9357133109ea.png" alt="计算机网络（三）——数据链路层——字符填充法运行过程.png"><p>发送端先使用字符填充法将原始数据里与帧头帧尾相同的字符进行转义处理，然后发送给接收方，接收方收到数据以后，再去掉数据里的ESC，就得到了原始数据。</p><h4 id="2-3-3-零比特填充法"><a href="#2-3-3-零比特填充法" class="headerlink" title="2.3.3 零比特填充法"></a>2.3.3 零比特填充法</h4><img src="https://pic.imgdb.cn/item/6616461768eb935713318669.png"><p>零比特填充法和字节填充法一样，都有帧头和帧尾，不同的是零比特填充法的帧头帧尾一样，都为01111110。但零比特填充法会将数据中扫描到的5个连续的1后面添0。这样做的目的是，将数据中连续5个1后面补0，那数据中出现1的连续最大值只能为5，就不会与帧头帧尾连续6个1相同。通过这样的设计，传送的比特流就可以任意组合，不会出现帧边界的判断错误。</p><p>接收方接收到数据以后，会对数据进行还原，即每5个1后面删去1个0。</p><h4 id="2-3-4-违规编码法"><a href="#2-3-4-违规编码法" class="headerlink" title="2.3.4 违规编码法"></a>2.3.4 违规编码法</h4><img src="https://pic.imgdb.cn/item/6616463b68eb93571331d13f.png" alt="计算机网络（三）——数据链路层——违规编码法.png"><p>违规编码法就是通过使用违规的数来充当帧头帧尾。例如上方曼彻斯特编码，将数据1和0分别编码成高-低或低-高（也可能相反）的样式。这个时候对于曼彻斯特编码来说，高-高或低-低就是违规的编码方式，所以可以使用高-高和低-低来充当帧头帧尾。</p><h2 id="3-差错控制"><a href="#3-差错控制" class="headerlink" title="3. 差错控制"></a>3. 差错控制</h2><h3 id="3-1-差错产生的原因"><a href="#3-1-差错产生的原因" class="headerlink" title="3.1 差错产生的原因"></a>3.1 差错产生的原因</h3><img src="https://pic.imgdb.cn/item/661646ed68eb935713336016.png" alt="计算机网络（三）——数据链路层——差错产生原因.png"><p>差错产生的原因不是重点，可以用来扩充知识面。</p><h3 id="3-1-检错编码"><a href="#3-1-检错编码" class="headerlink" title="3.1 检错编码"></a>3.1 检错编码</h3><h4 id="3-1-1-奇偶校验码"><a href="#3-1-1-奇偶校验码" class="headerlink" title="3.1.1 奇偶校验码"></a>3.1.1 奇偶校验码</h4><img src="https://pic.imgdb.cn/item/6616474768eb9357133470dc.png" alt="计算机网络（三）——数据链路层——奇偶校验.png"><p>奇偶校验很简单，在计组里有比这还详细的记录，可以去计算机组成原理（二）——数据的表示和运算中的8.奇偶校验里查看。</p><h4 id="3-1-2-CRC冗余码"><a href="#3-1-2-CRC冗余码" class="headerlink" title="3.1.2 CRC冗余码"></a>3.1.2 CRC冗余码</h4><img src="https://pic.imgdb.cn/item/6616478568eb93571334daf3.png" alt="计算机网络（三）——数据链路层——CRC校验.png"><p>CRC循环冗余码是比较重要的一部分，这部分很简单，但一定要做几道题，熟悉一下，不然考试时估计会出现漏子。</p><p>CRC编码里有三个核心地方，分别是要传的数据、生成多项式、FCS帧检验序列&#x2F;冗余码。</p><p><font color=red><strong>冗余码等于待传数据与比生成多项式小一位的0串组成的数据除生成多项式所产生的余数。</strong></font></p><p>发送的数据就是要传数据加上冗余码。</p><p>接收方检验数据时，将收到的数据除生成多项式，查看余数，余数为0，接收正确；不为0，接收错误，丢弃。</p><p>具体的传输与接收过程可以参考上图与文字进行理解。不理解的，也可以联系下面的例题进行学习。</p><img src="https://pic.imgdb.cn/item/661647d668eb935713353668.png" alt="计算机网络（三）——数据链路层——CRC校验示例.png"><p>上面为发送方数据生成，下面为接收方数据检验。</p><img src="https://pic.imgdb.cn/item/661647fb68eb9357133599c2.png" alt="计算机网络（三）——数据链路层——CRC接收端检错.png"><p>这里补充一个知识点，CRC差错检测技术，只能做到对帧的无差错接收（帧中数据比特无差错），但并不是可靠传输，因为中间还存在数据出错，被丢弃的情况。而可靠传输是指数据链路层发送端发什么，接收端就收什么，很显然CRC差错检测技术并不符合。</p><img src="https://pic.imgdb.cn/item/6616482268eb93571335c679.png" alt="计算机网络（三）——数据链路层——CRC知识补充.png"><h3 id="3-2-纠错编码"><a href="#3-2-纠错编码" class="headerlink" title="3.2 纠错编码"></a>3.2 纠错编码</h3><p>在3.1里说了奇偶校验码和CRC冗余码，但两种都是检错编码，只能检查出错误，而不能进行改正。而这部分讲的海明码则可以实现检错纠错功能。</p><p>这里关于海明码的课，王道讲的不咋地，湖科大也没讲，所以我看的书，感觉书上的例子很好，跟着做一遍就知道怎么做海明码，所以贴在这里。</p><img src="https://pic.imgdb.cn/item/66264a470ea9cb1403c45050.jpg" alt="计算机网络（三）——数据链路层——海明码.png"><p>这里再分享两个我做题时回来找的学习课，第一个做题的好方法，直接套就行，第二个天勤的，讲的比较偏原理一点。</p><p><a href="https://www.bilibili.com/video/BV1tL4y1h7Fd/?spm_id_from=333.337.search-card.all.click&vd_source=7fb4b255ed876969a742738d7b84f461">最通俗的海明码计算方法，不需记公式，套步骤即可（可能都不需要理解）</a></p><p><a href="https://www.bilibili.com/video/BV1Wd4y1z7ck/?spm_id_from=333.337.search-card.all.click">【天勤考研】十分钟搞定海明码</a></p><h2 id="4-流量控制与可靠传输"><a href="#4-流量控制与可靠传输" class="headerlink" title="4. 流量控制与可靠传输"></a>4. 流量控制与可靠传输</h2><h3 id="4-1-数据链路层的流量控制"><a href="#4-1-数据链路层的流量控制" class="headerlink" title="4.1 数据链路层的流量控制"></a>4.1 数据链路层的流量控制</h3><p>由<strong>较高的发送速度和较低的接收能力</strong>的不匹配，会造成传输出错。因此流量控制也是数据链路层的一项重要工作。</p><p>在第一章里我们说过，拥有流量控制功能的协议层有两个，一个是数据链路层，一个是传输层。但前面我们也说过，<font color=red><strong>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</strong></font></p><p>在这里稍微解释一下，点到点与端到端。在物理层里讲解传输时，我们说过，当主机与主机进行通信时，中间作为转发结点的设备只有三层协议，即物理层、数据链路层、网络层，但两边传输的主机却又七层协议。所以这里的点对点是相邻结点的通信，即相邻结点间数据链路层的通信。而端到端通信，由于中间转发结点没有传输层，所以端到端指的是两台主机之间的通信。</p><p>这里再补充一下两层控制流量手段的不同：</p><p><font color=blue><strong>数据链路层流量控制手段：</strong></font>接收方如果接收下，就会返回一个确认指令（这个指令不包含任何数据），如果收不下，这个确认指令就不会发送，发送方收不到确认指令就不会进行下一次传输。</p><p><font color=blue><strong>传输层流量控制手段：</strong></font>接收端给发送端发送一个窗口公告，这个窗口公告告诉发送方，当前窗口还有多少，缓冲区还有多大，让发送方根据当前缓冲区控制发送速度。</p><h3 id="4-2-可靠传输的基本概念"><a href="#4-2-可靠传输的基本概念" class="headerlink" title="4.2 可靠传输的基本概念"></a>4.2 可靠传输的基本概念</h3><p>这部分全是基础概念，没什么好讲的，有问题跳转视频：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=24&vd_source=7fb4b255ed876969a742738d7b84f461">可靠传输的基本概念</a></p><img src="https://pic.imgdb.cn/item/66194acd68eb935713e2f4a2.png" alt="计算机网络（三）——数据链路层——可靠传输.png"><img src="https://pic.imgdb.cn/item/66194b2168eb935713e3c8fa.png" alt="计算机网络（三）——数据链路层——可靠传输2.png"><h3 id="4-3-实现流量控制与可靠传输的三种协议"><a href="#4-3-实现流量控制与可靠传输的三种协议" class="headerlink" title="4.3 实现流量控制与可靠传输的三种协议"></a>4.3 实现流量控制与可靠传输的三种协议</h3><p>上面讲述了流量控制与可靠传输，接下来讲解一下实现数据链路层流量控制与可靠传输的三种协议，分别是停止-等待协议、后退N帧协议（GBN）、选择重传协议（SR）。</p><p><font color=red>需要注意的是，这三种<strong>可靠传输</strong>实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中。</font></p><h4 id="4-3-1-停止-等待协议"><a href="#4-3-1-停止-等待协议" class="headerlink" title="4.3.1 停止-等待协议"></a>4.3.1 停止-等待协议</h4><h5 id="4-3-1-1-停止-等待协议基础"><a href="#4-3-1-1-停止-等待协议基础" class="headerlink" title="4.3.1.1 停止-等待协议基础"></a>4.3.1.1 停止-等待协议基础</h5><img src="https://pic.imgdb.cn/item/661a358a68eb935713330037.png" alt="计算机网络（三）——数据链路层——停止-等待协议1.png"><p>首先介绍一下停止-等待协议，如图所示，双方基于互联网通信，纵坐标为时间。发送方给接收方发送数据分组，接收方收到后，对其进行差错检测，若没有误码，则接收该数据分组，并给发送方发送确认分组，简称为<font color=red>ACK</font>。假设这个数据分组在传输过程中出现了误码，接收方收到后对其进行差错检测，发现了误码，则丢弃该数据分组，并给发送方发送否认分组，简称为<font color=red>NAK</font>。发送方收到对所发送数据分组的否认分组后，就知道之前自己发送的分组出现了差错而被接收方拒绝，于是会立刻重传分组，因此发送方每发送完一个数据分组后，并不能立刻将数据分组从缓存中删除，只有在收到针对该数据分组的确认分组后，才能将其从缓存中删除。</p><p><strong>发送方每发送一个分组后，都会停下来等待来自接收方的确认，若收到确认，则会发送下一个数据分组，若收到否认，则会重传上一个分组，这种发送协议就是<font color=blue>停止-等待协议。</font></strong></p><p>上面说的只是理想情况，实际情况还会更复杂一点，比如下面的这种情况：发送方发送的数据分组在传输过程中丢失（这种情况在数据链路层的点对点之间不易出现，但对多个网络通过多个路由器互连的复杂互联网环境而言，这种情况是会经常出现的。</p><img src="https://pic.imgdb.cn/item/661a38f068eb935713390e4e.png" alt="计算机网络（三）——数据链路层——超时重传.png"><p>说了上面这种情况，其实还可以再考虑一下，既然发送会丢失，那接收方向发送方传输的确认信息会不会丢失呢？答案是肯定的。如果出现了这种情况，就会出现上面的那样，发送方接收不到接收方的确认信息，待重传时间到达以后，仍没有收到确认或否认分组信息，就会进行重传。此时接收方接收到新分组后，就无法确认该分组是重复传输上一个的，还是新的分组，为了避免这种情况，在发送时会给每个数据分组编号。接收方发现重复分组信息以后，就会丢弃该分组，并返还发送方针对于该分组的确认分组信息。</p><img src="https://pic.imgdb.cn/item/661a3b5468eb9357133d77f4.png" alt="计算机网络（三）——数据链路层——发送编号.png"><p>这里可以思考一下，既然发送分组需要编号，那么确认分组是否也需要编号呢？</p><img src="https://pic.imgdb.cn/item/661a3c3268eb9357133efc6d.png" alt="计算机网络（三）——数据链路层——确认迟到.png"><p>根据上图，不难发现，当接收方收到数据以后，返还分组确认信息时，可能会出现网络延迟等问题，导致发送方接收到的确认分组信息是在重传以后，这时候发送方已经发了重复分组DATA0，再收到ACK后，会发送下一个分组DATA1。当DATA1发送以后，接收方会收到重复的DATA0，此时接收方会前面所讲，将DATA0丢弃，并返还ACK，这个时候，如果我们不对ACK进行编号的话，发送方就不会知道这个ACK是对应DATA0还是DATA1的。当编号以后，接收方收到ACK0知道DATA0数据已确认，将不会再传输DATA0，并将DATA0从缓存删除。紧接着，接收方收到DATA1的确认分组信息ACK1时，会传输下一个数据分组DATA0，注意这个新传的DATA0和前面的DATA0并不是一组数据，这里编号为0，是因为上一个0号分组已经被确认，这是新的编号为0的分组（类似循环队列的从头开始插入），这样做是为了保证分组编号的有限性，否则分组序号会越来越大。</p><p>这里补充一下，对于数据链路层的点对点信道来说，往返时间比较固定，不会出现确认迟到的情况，因此只在数据链路层实现停止-等待协议，可以不用给确认分组编号。</p><p>接下来做个小结：</p><img src="https://pic.imgdb.cn/item/661a3f1268eb935713424d68.png" alt="计算机网络（三）——数据链路层——停止-等待协议小结.png"><h5 id="4-3-1-2-停止-等待协议的信道利用率"><a href="#4-3-1-2-停止-等待协议的信道利用率" class="headerlink" title="4.3.1.2 停止-等待协议的信道利用率"></a>4.3.1.2 停止-等待协议的信道利用率</h5><img src="https://pic.imgdb.cn/item/661a3fce68eb93571342e67c.png" alt="计算机网络（三）——数据链路层——停止-等待协议信道利用率.png"><p>停止-等待协议的信道利用率如图所示，其中：</p><p>T<sub>D</sub>：发送方发送数据分组所耗费的发送时延。</p><p>T<sub>A</sub>：接收方发送确认分组所耗费的发送时延。</p><p>RTT：收发双方之间的往返时间。</p><p>注意，这里忽略了接收方对数据分组的处理时延，以及发送方对确认分组的处理时延。</p><p>发送方从发送一个数据开始，到可以发送下一个数据经历的总时间为：T<sub>A</sub>+T<sub>D</sub>+RTT。</p><p>信道利用率可以用图中所给的公式计算，T<sub>A</sub>一般远小于T<sub>D</sub>，可以忽略。当RTT远大于T<sub>D</sub>时，信道利用率会很低。这里举个例子看一下：</p><img src="https://pic.imgdb.cn/item/661a41da68eb93571345ad30.png" alt="计算机网络（三）——数据链路层——停止-等待协议信道利用率举例.png"><p>当往返时延RTT远大于发送时延时，信道利用率就会很低，为了克服这种情况，就产生了GBN和SR协议。</p><h5 id="4-3-1-3-停止-等待协议小结"><a href="#4-3-1-3-停止-等待协议小结" class="headerlink" title="4.3.1.3 停止-等待协议小结"></a>4.3.1.3 停止-等待协议小结</h5><p>补充一道例题：</p><img src="https://pic.imgdb.cn/item/661a432668eb93571348025b.png" alt="计算机网络（三）——数据链路层——停止-等待协议信道利用率题目.png"><img src="https://pic.imgdb.cn/item/661a437c68eb93571348a309.png" alt="计算机网络（三）——数据链路层——停止-等待协议总结.png"><p>这里再补充一下，像停止-等待协议这种通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ，意思是重传的请求是自动的进行的，因为不需要接收方显示的请求发送方出错的某个分组。</p><h4 id="4-3-2-回退N帧协议GBN"><a href="#4-3-2-回退N帧协议GBN" class="headerlink" title="4.3.2 回退N帧协议GBN"></a>4.3.2 回退N帧协议GBN</h4><img src="https://pic.imgdb.cn/item/661a566c68eb9357135f078b.png" alt="计算机网络（三）——数据链路层——停止-流水线.png"><p>在4.3.1里讲的停止-等待协议内，我们知道停止-等待协议的利用率很低，若出现超时重传时，信道利用率更低。但是，如果我们采用流水线的传输方式，在发送方收到确认分组信息前，发送多个数据分组，这样与停止-等待协议比较起来，相同时间内的发送的数据分组就会大大提升，信道利用率也会大大提高。</p><p><font color=red><strong>在这部分讲的回退N帧协议GBN就是在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数。</strong></font></p><p>下面以一个例子贯穿该部分内容：</p><img src="https://pic.imgdb.cn/item/661a584a68eb93571362d091.png" alt="计算机网络（三）——数据链路层——回退N帧协议GBN.png"><p><strong>如图所示，上面有两组分组序号，分别属于发送方和接收方，当序号增加到7时，下一个序号又从0开始。</strong></p><p><strong>发送方要维持一个发送窗口，序号落在发送窗口内的数据分组可被连续发送，而不必等收到接收方的相应确认分组后再发送，如上图落在WT内的序号就可以连续发送。</strong></p><p><strong>发送窗口的尺寸记为WT，对于本例来说，1&lt;WT&lt;&#x3D;2<sup>3</sup>-1。其中3是构成分组序号的比特数量。本例取WT的值为5。如果WT的取值为1，则是我们前面所说的停止-等待协议。如果WT的取值超过取值范围上限，则会造成严重错误。</strong></p><p><strong>接收窗口尺寸记为WR，对与回退N帧协议，WR只能取一，这一点和停止-等待协议一样。如图，序号落在接收分组内的数据可以接收，而不在范围内的，不可以接收。</strong></p><p><strong>接下来，同停止-等待协议一样，我们也说一下对于回退N帧协议数据传输过程中可能产生的几种情况：</strong></p><h5 id="4-3-2-1-第一种情况：无差错情况"><a href="#4-3-2-1-第一种情况：无差错情况" class="headerlink" title="4.3.2.1 第一种情况：无差错情况"></a><strong>4.3.2.1 第一种情况：无差错情况</strong></h5><img src="https://pic.imgdb.cn/item/661a8af268eb9357139a5593.png" alt="计算机网络（三）——数据链路层——无差错情况.png"><p>首先发送方将落在发送窗口内的0<del>4号分组依次连续发送出去，它们经过互联网的传输，正确到达了接收方（即没有出现乱序和误码）。接收方正确接收以后，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组。0</del>4号确认分组经过互联网的传输正确到达了发送方。发送方每接收一个，发送窗口就向前滑动一个位置，这样就有新的序号落入窗口，此时发送方就可以将收到确认的数据分组从缓存中删除。而接收方可以择机将已接收到的数据分组交付上层处理。</p><p><strong>接下来，我们来说一下累计确认的概念：</strong></p><img src="https://pic.imgdb.cn/item/661a8c7168eb9357139b3ba3.png" alt="计算机网络（三）——数据链路层——累计确认.png"><p>所谓累计确认，就是接收方不一定要对接收的数据分组逐个发送确认，而是可以在收到几个数据分组后，<font color=red><strong>对按序到达的最后一个数据分组发送确认</strong></font>。</p><p>如上图例子，发送方将落在发送窗口内的0<del>4号分组依次连续发送出去，经过互联网传输到接收方，接收方按序接收，当接收完0和1号分组以后，给接收方返回了一个累计确认ACK1，当接收完2</del>4号分组以后，又给发送方发送了一个累计确认ACK4。</p><p>在这里，如果我们假设ACK1丢失，ACK4正确达到接收方，接收方接收ACK4就知道序号为4及之前的数据分组都被接收方正确接收，于是将发送窗口向前滑动5个位置，这样就有新的序号落入了发送窗口。此时发送方就可以将收到确认的数据分组从缓存中删除。而接收方可以择机将已接收到的数据分组交付上层处理。</p><p>此时我们可以知道累积确认的优点：即使确认分组丢失，发送方也可能不必重传。除此以外，累积确认还可以减小接收方的开销，减少对网络资源的占用。</p><p>使用累计确认也有缺点：不能向发送方及时反映出接收方已经正确接收的数据分组信息。</p><h5 id="4-3-2-2-第二种情况：有差错情况"><a href="#4-3-2-2-第二种情况：有差错情况" class="headerlink" title="4.3.2.2 第二种情况：有差错情况"></a><strong>4.3.2.2 第二种情况：有差错情况</strong></h5><img src="https://pic.imgdb.cn/item/661a8fa268eb9357139df929.png" alt="计算机网络（三）——数据链路层——有差错情况.png"><p>假设如图，发送方将56701序列的数据分组发送至接收方，接收方经过差错检测，发现5号分组数据出现差错，于是将其丢弃。而后序到达的4个数据分组的序号，与接收窗口中的序号不匹配，接收方同样也不能接收它们，将它们丢弃，并对之前按序接收的最后一个分组进行确认（即发送ACK4），每丢弃一个分组就要发送一个ACK4，这里发送4个是丢弃4个分组，大家可能会好奇为什么不是5个，原因是5号数据分组是由于差错丢弃的，而非序号匹配失败丢弃，这里返还ACK4的个数是接收窗口序号不匹配丢弃的数据个数。</p><p>接收方接收到重复的确认就知道之前发送的分组有差错，就会不等超时重传而立刻发送。但至于收到几个重复确认就立刻重传，得由具体实现决定。</p><p>在上面这个例子里，我们还可以假设这4个重复的确认并不会触发发送方立刻重传，一段时间后，超时计时器出现超时，发送方将发送窗口内已发送过的这些数据分组全部重传。<font color=red><strong>在本例中，尽管序号为6，7，0，1的数据分组正确到达接收方，但由于5号数据分组误码不被接受，它们也“受到牵连”而不被接受。发送方还要重传这些分组数据，这就是所谓的回退N帧。</strong></font></p><p><font color=red><strong>可见，当通信线路质量不好时，回退N帧协议的信道利用率并不比停止-等待协议高。</strong></font></p><h5 id="4-3-2-3-第三种情况：发送窗口WT超过取值上限"><a href="#4-3-2-3-第三种情况：发送窗口WT超过取值上限" class="headerlink" title="4.3.2.3 第三种情况：发送窗口WT超过取值上限"></a><strong>4.3.2.3 第三种情况：发送窗口WT超过取值上限</strong></h5><img src="https://pic.imgdb.cn/item/661a9a1468eb935713a9645a.png" alt="计算机网络（三）——数据链路层——超出上限.png"><p>上图是WT超出上限的情况，可以发现，如果发送窗口最大为7，而WT的取值超过7为8，此时发送方将数据发送给接收方，接收方收到数据以后，返回ACK7，但确认分组信息在传输过程中丢失，此时发送发超时重传，接收方收到数据以后，无法辨别此次数据是旧的重复分组还是新的数据分组。所以WT不能超过上限。</p><h5 id="4-3-2-4-GBN小结"><a href="#4-3-2-4-GBN小结" class="headerlink" title="4.3.2.4 GBN小结"></a>4.3.2.4 GBN小结</h5><img src="https://pic.imgdb.cn/item/661a9b6068eb935713aacbd1.png" alt="计算机网络（三）——数据链路层——GBN小结.png"><p>注意，回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议。且在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为<font color=blue><strong>滑动窗口协议</strong></font>。</p><h4 id="4-3-3-选择重传协议SR"><a href="#4-3-3-选择重传协议SR" class="headerlink" title="4.3.3 选择重传协议SR"></a>4.3.3 选择重传协议SR</h4><img src="https://pic.imgdb.cn/item/661b3f9068eb9357137150d2.png" alt="计算机网络（三）——数据链路层——选择重传协议引出.png"><p>选择重传协议相较于回退N帧协议，把接收窗口扩大，进而可以解决回退重传协议中，某位出现误码，则要连该误码位以后的数据一起重发的问题。而将接收窗口扩大，就可以实现对每组数据的判断返回确认，而发送方只需对没有进行确认的分组重传即可。</p><p><strong>说到这里，其实可以知道三种可靠传输协议最基本的区别：</strong></p><p>​停止-等待协议中WT&#x3D;WR&#x3D;1，由于这样规定导致信道利率低，于是基于流水线式的传输协议回退N帧协议出现，回退N帧协议中WT已经不局限于1位，而是以窗口的形式实现多组传输，但WR&#x3D;1仍不变。这样的通讯协议会导致接收方只能按序接受正确到达的分组，一位出现差错，它以后的数据都要重传。进而提出了改进的选择传输协议，选择传输协议将WR也扩充为多位，解决了只能按序接收的问题。</p><p>这部分有个关于选择传输协议的工作过程，我在这里就不写了，因为过程较多，我只说和贴图的话，比较难理解，所以推荐大家看视频，视频里动画演示简单易懂，视频13分钟，只看工作原理的话，看2~7分钟就好：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=27&vd_source=7fb4b255ed876969a742738d7b84f461">选择重传协议</a></p><p>接下来我们再来讨论下窗口上限的问题：</p><img src="https://pic.imgdb.cn/item/661b425268eb935713764690.png" alt="计算机网络（三）——数据链路层——SR的窗口上限.png"><p>从上图里，可看到发送窗口范围1&lt;WT&lt;&#x3D;2<sup>n-1</sup>，接收窗口范围1&lt;WR&lt;&#x3D;WT，注意这里的发送窗口取值范围，是与回退N帧协议不一样的，回退N帧的发送窗口取值范围是1&lt;WT&lt;&#x3D;2<sup>n</sup>-1，至于回退N帧协议的取值范围我们前面已经说过了，是为了避免新旧分组重复而设置的。那这里选择传输协议为什么是这个范围内，答案同回退N帧协议一样，也是为了避免新旧分组重复而设置的。</p><p>如上图，这里n&#x3D;3，所以WT取值范围是（1,4]，如果我们令WT&#x3D;WR&#x3D;5，此时发送方发送0,1,2,3,4，接收方收到数据以后，确认无误返回每一个分组的分组确认信息，同时，接收方的接收窗口向前滑动5个，将5,6,5,0,1包含在内。此时，在返还过程中，序号0的分组的确认分组信息丢失，此时发送方未收到0的分组确认信息，待超时以后，会重传0分组的分组数据，这时接收方收到0分组，无法分辨这是上一个0分组的重传信息，还是这个分组的新的数据分组。</p><p>所以，这里WT的取值范围是为了避免新旧分组无法辨别的问题。我的理解就是将数据最多按一半一半传输，这样两次传完一整个分组的所有序号，实质上就是让下一次传输的数据分组序号与上一组不出现存在某位相同的情况。</p><p><strong>下面对SR进行一个小结：</strong></p><img src="https://pic.imgdb.cn/item/661b473d68eb9357137e8f66.png" alt="计算机网络（三）——数据链路层——SR的小结.png"><h2 id="5-介质访问控制"><a href="#5-介质访问控制" class="headerlink" title="5. 介质访问控制"></a>5. 介质访问控制</h2><p>先介绍一个知识点——传输数据使用的两种链路。</p><ol><li>点对点链路：两个相邻节点通过一个链路相连，没有第三者。应用：PPP协议，常用于<font color=red><strong>广域网</strong></font>。</li><li>广播式链路：所有主机共享通信介质。应用：早期的总线以太网、无线局域网，常用于<font color=red><strong>局域网</strong></font>。</li></ol><p>广播式链路典型的拓扑结构有总线型、星型等，这些结构有一个共同点，就是信号的传输不只目标主机会接收到，在该网络内其它主机也会接收到，只是其它主机接收到以后，发现信号里的目标地址不是本机以后会选择丢弃。</p><p>另外，对于广播式链路的通信，一个链路连接多台主机，如果一个主机发送信号的同时，别的主机也发送，则两个节点之间的通信可能会因为相互干扰而失败。<font color=red><strong>为了避免这种问题的产生，于是设计了一个用来决定广播信道中信道分配的协议，该协议属于数据链路层的一个子层，称为介质访问控制（MAC）子层。</strong></font></p><p><strong>常见的介质访问控制方法有：信道划分介质访问控制、随机访问介质访问控制和轮询访问介质访问控制。其中，第一种是静态划分信道的方法，后两种是动态分配信道的方法。</strong></p><p>动态分配信道也叫动态媒体接入控制&#x2F;多点接入，特点是信道并非在用户通信时固定分配给用户。</p><p><strong>下面用一种图来概述本部分的知识：</strong></p><img src="https://pic.imgdb.cn/item/661b705c68eb935713c163ce.png" alt="计算机网络（三）——数据链路层——介质访问控制.png"><h3 id="5-1-信道划分介质访问控制"><a href="#5-1-信道划分介质访问控制" class="headerlink" title="5.1 信道划分介质访问控制"></a>5.1 信道划分介质访问控制</h3><p>信道划分介质访问控制将使用同一传输介质的多个设备的通信隔离开来，把时域和频域资源合理地分配给这些设备。</p><p>信道划分介质访问控制通过复用技术实现。所谓复用，就是在发送端把多个发送方的信号组合在一条物理信道上传输，在接收端把收到的复用信号分离出来，并发送给对应的接收方。</p><img src="https://pic.imgdb.cn/item/661b71e368eb935713c5227a.png" alt="计算机网络（三）——数据链路层——信道划分介质访问控制.png"><p>信道划分介质访问控制有以下4种：频分复用（FDM）、时分复用（TDM）、波分复用（WDM）、码分复用（CDM）</p><h4 id="5-1-1-频分复用（FDM）"><a href="#5-1-1-频分复用（FDM）" class="headerlink" title="5.1.1 频分复用（FDM）"></a>5.1.1 频分复用（FDM）</h4><p>频分复用就是将信道的总频带划分为多个子频带，每个子频带作为一个子信道，每对用户使用一个子信道进行通信。相邻信道间还要加入“隔离频带”。</p><img src="https://pic.imgdb.cn/item/661b730b68eb935713c77743.png" alt="计算机网络（三）——数据链路层——频分复用.png"><h4 id="5-1-2-时分复用（TDM）"><a href="#5-1-2-时分复用（TDM）" class="headerlink" title="5.1.2 时分复用（TDM）"></a>5.1.2 时分复用（TDM）</h4><img src="https://pic.imgdb.cn/item/661b742068eb935713c84730.png" alt="计算机网络（三）——数据链路层——TDM.png"><p>时分复用（TDM），将信道的传输时间划分为一段段等长的时间片，称为TDM帧。每个用户在TDM帧中占用固定序号的时隙，每个用户占用的时隙周期性地出现，所有用户在不同的时间占用同样的信道资源。</p><p>由于时分复用是按固定次序给用户分配时隙的，当用户在某段时间暂无数据传输时，其他用户也无法使用这个暂时空闲的线路资源，所以时分复用后的信道利用率不高。进而提出了统计时分复用（STDM），又称异步时分复用。</p><img src="https://pic.imgdb.cn/item/661b756a68eb935713c908f7.png" alt="计算机网络（三）——数据链路层——STDM.png"><p>STDM按需分配时隙，可以大大提高传输效率。如果一条线路可以传输8000b&#x2F;s，使用TDM，则每个用户分到的最高速度只有2000b&#x2F;s；如果私用STDM，则每个用户的最高传输速率可以达到惊人的8000b&#x2F;s。</p><h4 id="5-1-3-波分复用（WDM）"><a href="#5-1-3-波分复用（WDM）" class="headerlink" title="5.1.3 波分复用（WDM）"></a>5.1.3 波分复用（WDM）</h4><img src="https://pic.imgdb.cn/item/661b768368eb935713c9aa29.png" alt="计算机网络（三）——数据链路层——波分复用.png"><h4 id="5-1-4-码分复用（CDM）"><a href="#5-1-4-码分复用（CDM）" class="headerlink" title="5.1.4 码分复用（CDM）"></a>5.1.4 码分复用（CDM）</h4><p>码分复用是采用不同的编码来区分各路原始信号的一种复用方式，与FDM和TDM不同，它既共享信道的频率，又共享时间。</p><p><strong>下面是CDM相关基础知识概念：</strong></p><img src="https://pic.imgdb.cn/item/661b773968eb935713ca17d3.png" alt="计算机网络（三）——数据链路层——CDM基础1.png"><img src="https://pic.imgdb.cn/item/661b77f068eb935713ca9656.png" alt="计算机网络（三）——数据链路层——CDM基础2.png"><img src="https://pic.imgdb.cn/item/661b788068eb935713cb00f7.png" alt="计算机网络（三）——数据链路层——CDM基础3.png"><p>这里有个重点知识需要知道，就是码片以及码片序列，在考试中，常会考到码片序列相关比特发送的知识，如上图中的例子。顺带提一下，这种通信方式称为直接序列扩频DSSS。</p><p>码片序列的挑选原则如下：</p><img src="https://pic.imgdb.cn/item/661b79dc68eb935713ccb89e.png" alt="计算机网络（三）——数据链路层——码片序列挑选原则.png"><p>这里给个例题加深对码片选取加深理解：</p><img src="https://pic.imgdb.cn/item/661b7a8168eb935713cd6a5e.png" alt="计算机网络（三）——数据链路层——码片序列挑选原则例题.png"><p>下面是CDM的应用：</p><img src="https://pic.imgdb.cn/item/661b7b7b68eb935713ce8c6e.png" alt="计算机网络（三）——数据链路层——CDM应用举例.png"><h3 id="5-2-随机访问介质访问控制"><a href="#5-2-随机访问介质访问控制" class="headerlink" title="5.2 随机访问介质访问控制"></a>5.2 随机访问介质访问控制</h3><p>使用随机访问介质访问控制，则所有用户可随机发送信息，反送信息时占全部带宽，当然这种随机性也会导致不协调。比如多个用户在发送信息时，如果不协调就会导致可能同时发送，这样又回到了我们前面说的冲突问题，所以我们需要通过协议来解决这种问题。</p><p>随机访问介质访问控制协议有四种，分别是ALOHA协议、CSMA协议、CSMA&#x2F;CD协议、CSMA&#x2F;CA协议。</p><h4 id="5-2-1-ALOHA协议"><a href="#5-2-1-ALOHA协议" class="headerlink" title="5.2.1 ALOHA协议"></a>5.2.1 ALOHA协议</h4><p>ALOHA协议有两种，一种是纯ALOHA协议，一种是时隙ALOHA协议。</p><p><strong>(1) 纯ALOHA协议</strong></p><img src="https://pic.imgdb.cn/item/661b8b7268eb935713e05c7c.png" alt="计算机网络（三）——数据链路层——ALOHA协议.png"><p>在纯ALOHA协议中，帧长不用比特而用发送这个帧所需的时间来表示，如图中T<sub>0</sub>，这个T<sub>0</sub>既包括传输时间，也包括传播时间。</p><p>纯ALOHA协议的思想：想发就发。</p><p>由于纯ALOHA的思想，所以纯ALOHA协议的数据传输成功率很低。所以提出了改进的时隙ALOHA协议。</p><p><strong>(2) 时隙ALOHA协议</strong></p><p>时隙ALOHA协议就是纯ALOHA协议的基础上，控制了发送的随意性，用户想发送帧只能在当前时隙片开始时发送，若当前时隙片开始时没有发送，只能等到下一个时隙片开始，才能进行发送。</p><img src="https://pic.imgdb.cn/item/661b8e1e68eb935713e63022.png" alt="计算机网络（三）——数据链路层——时隙ALOHA协议.png"><p>到这里，小结一下ALOHA协议：</p><ol><li>纯ALOHA比时隙ALOHA吞吐量更低，效率更低。</li><li>纯ALOHA想发就发，时隙ALOHA只有在时间片开始时才能发。</li></ol><h4 id="5-2-2-CSMA协议"><a href="#5-2-2-CSMA协议" class="headerlink" title="5.2.2 CSMA协议"></a>5.2.2 CSMA协议</h4><img src="https://pic.imgdb.cn/item/661b9ea068eb935713fd50e1.png" alt="计算机网络（三）——数据链路层——CSMA.png"><p>CSMA就是载波监听多路访问，相比ALOHA协议，CSMA站点在发送前会先监听公用信道，发现公用信道空闲后才会发送数据。</p><p>对于监听结果有两种，若信道空闲，则站点发送完整帧；若信道忙，则站点推迟发送。至于信道空闲，站点是立即发送帧还是等待；信道忙，站点推迟发送要推迟多久，有三种协议规定。</p><p>三种协议：1-坚持CSMA、非坚持CSMA、p-坚持CSMA。</p><p><strong>(1)1- 坚持CSMA</strong></p><img src="https://pic.imgdb.cn/item/661ba07468eb935713005870.png" alt="计算机网络（三）——数据链路层——1-坚持CSMA.png"><p>这里对缺点解释一下，两个及两个以上的站点在监听的话，就会一直处于监听状态，一旦信道空闲下来了，两个站点都会发送信息，那冲突就必然会产生了。</p><p><strong>(2) 非坚持CSMA</strong></p><img src="https://pic.imgdb.cn/item/661ba54668eb93571309f4db.png" alt="计算机网络（三）——数据链路层——非坚持CSMA.png"><p><strong>(3) p-坚持CSMA</strong></p><img src="https://pic.imgdb.cn/item/661ba66368eb9357130c5a52.png" alt="计算机网络（三）——数据链路层——p-坚持CSMA.png"><p><strong>(4) 三种CSMA比较</strong></p><img src="https://pic.imgdb.cn/item/661ba6f768eb9357130d7967.png" alt="计算机网络（三）——数据链路层——三种CSMA比较.png"><p>值得注意的是，这部分说的CSMA都只在发送方对信道进行监听，而发送方处于信道之上，无法对冲突进行检测，所以如果产生了冲突，发送方发现不了，就还是会坚持把数据帧发送完，这就造成了资源浪费。为了解决这个问题，就需要下面所说的CSMA&#x2F;CD协议来解决了。</p><h4 id="5-2-3-CSMA-CD协议"><a href="#5-2-3-CSMA-CD协议" class="headerlink" title="5.2.3 CSMA&#x2F;CD协议"></a>5.2.3 CSMA&#x2F;CD协议</h4><p>CSMA&#x2F;CD协议，就是在CSMA的基础上，多了一个<font color=red><strong>边发边监听</strong></font>的功能。</p><img src="https://pic.imgdb.cn/item/661baed768eb9357131b0d5a.png" alt="计算机网络（三）——数据链路层——CS、MA、CD.png"><p>这里补充一个96比特时间的概念，96比特时间是指发送96比特所耗费的时间，也称为帧间最小间隔，其作用是使接收方可以检测出一个帧的结束。同时也使得所有其他站点都能有机会平等竞争信道并发送帧。</p><p><strong>这里再解释一下产生碰撞产生的原因：</strong></p><p>产生碰撞的原因是因为电磁波在总线上总是以有限的速率传播的（碰撞原因也可以理解为受传播时延影响），当某主机A向主机B发送帧时，B主机由于距离A主机较远，此时A主机发送的信号还没有传播到B，所以B还未检测到A的信号，然后B就也开始发送数据，之后A的数据与B的数据在信道上某个点相遇，就产生了碰撞。</p><p><strong>下面对信道发生冲突进行分析：</strong></p><img src="https://pic.imgdb.cn/item/661bb0e068eb9357131f2d7f.png" alt="计算机网络（三）——数据链路层——信道冲突的时间分析.png"><p>如图，在t&#x3D;0时，A检测信道空闲，便发送帧，一段时间后，数据还在传输中，但D发现信道也是空闲的，于是在t&#x3D;τ-δ时（<strong>这里，τ指以太网单程端到端的传播时延，δ指A的信号传播到D的时间与D开始发送的时间的差</strong>），D向信道传输帧。此时A的数据与B的数据在某个时刻发生如图所示的碰撞，碰撞以后原本的信号就产生了叠加变形，进而继续传送，在t&#x3D;τ时，A的信号传播到D，D经过检测发现出现碰撞，于是停止发送帧。在t&#x3D;2τ-δ时，D的信号传输到A，A经过检测，也发现数据出现碰撞，此时A也会停发。</p><p>在这个过程中，我们可以发现，若δ&#x3D;0时，则A的数据分组刚好的D，而D才开始发送数据，所以我们可以知道A若想知道发生碰撞，最迟要在2τ时知道，换句话说，<strong>只要经过往返传播时延2τ时间还没有检测到碰撞，就能肯定这次发送不会发生碰撞。</strong></p><p>以太网把端到端往返传播时延2τ称为<font color=red><strong>争用期</strong></font>或<font color=red><strong>碰撞窗口</strong></font>。</p><p>下面便对这部分的知识点进行一个提炼：</p><img src="https://pic.imgdb.cn/item/661bb45668eb93571323d6d4.png" alt="计算机网络（三）——数据链路层——信道冲突提炼.png"><p>从上面的了解中，不难看出，CSMA&#x2F;CD中的站不可能同时进行发送和接收，因此采用CSMA&#x2F;CD协议的以太网只能进行半双工通信。</p><p><strong>了解CSMA&#x2F;CD的原理后，就可以说一下最短帧长的问题：</strong></p><p>设想一下，A站发送了一个很短的帧，但发生了碰撞，不过碰撞的产生是在帧发送完毕以后的，这个时候就会出现一种很尴尬的情况，我们的CSMA&#x2F;CD协议里，是数据帧在发送时产生碰撞才可以暂停，现在A的数据帧已经发送完了，这个时候即使产生了碰撞，A也没法暂停了。为了避免这种情况，使A站能及时控制局面，所以要定义一个最短帧长，即检测到碰撞时，帧还没有发送完毕。</p><p>通过这样的分析，就可以知道，要想检测到碰撞时，帧还没有发送完毕，就要求帧的传输时延至少要两倍于信号在总线的传播时延。</p><p>所以我们可以得到公式：帧长&#x2F;数据传输速率&gt;&#x3D;2τ</p><p>即：<font color=red><strong>最短帧长&#x3D;2×总线传播时延×数据传输速率</strong></font></p><img src="https://pic.imgdb.cn/item/661bd15168eb9357133d2fe5.png" alt="计算机网络（三）——数据链路层——最小帧长.png"><p>同样的，既然有最小帧长，那相对于也应当存在最大帧长。</p><img src="https://pic.imgdb.cn/item/661bd1d868eb9357133d8004.png" alt="计算机网络（三）——数据链路层——最大帧长.png"><p>如图，当A传送很大的帧时，就会一直占用总线，这会导致总线上其它主机占用不了总线，另外由于数据帧很长，还可能导致D的接收缓存区无法装下该帧而产生溢出。所以，以太网的帧长应该有上限，具体上限多少应取决于以太网的传输协议。</p><p>在前面，还遗留了一个问题，就是在两站发生冲突以后，两站都会停止数据发送，那两站的数据何时再次发送呢？若参与冲突的两个结点紧接着再次发送，就会陷入无休止的冲突中，为了避免这种情况，就可以使用截断二进制指数退避算法来确定冲突后的退避时间（即下次重传的时机），具体如下：</p><img src="https://pic.imgdb.cn/item/661bd3f968eb9357133ebdb5.png" alt="计算机网络（三）——数据链路层——截断二进制指数退避算法.png"><p><strong>CSMA&#x2F;CD的信道利用率：</strong></p><img src="https://pic.imgdb.cn/item/661bd54b68eb9357133f71a5.png" alt="计算机网络（三）——数据链路层——CSMA-CD信道利用率.png"><p><strong>CSMA&#x2F;CD部分小结：</strong></p><p><strong>CSMA&#x2F;CD的帧发送流程：</strong></p><img src="https://pic.imgdb.cn/item/661bd5fd68eb9357133ff87d.png" alt="计算机网络（三）——数据链路层——CSMA-CD帧发送.png"><p><strong>CDMA&#x2F;CD协议的帧接收流程：</strong></p><img src="https://pic.imgdb.cn/item/661bd63668eb935713402ed7.png" alt="计算机网络（三）——数据链路层——CSMA-CD帧接收.png"><h4 id="5-2-4-CSMA-CA协议"><a href="#5-2-4-CSMA-CA协议" class="headerlink" title="5.2.4 CSMA&#x2F;CA协议"></a>5.2.4 CSMA&#x2F;CA协议</h4><img src="https://pic.imgdb.cn/item/661bd8cd68eb93571341c4f8.png" alt="计算机网络（三）——数据链路层——CSMA-CA.png"><p>前面说了在有线广播域内可以使用CSMA&#x2F;CD协议进行载波监听，碰撞检测。但是在无线局域网内虽然可以使用CSMA协议，但不能通过CD进行碰撞检测，理由如上图。这时候可以，又提出了CA（碰撞避免）协议，来实现无线局域网的载波监听、碰撞避免。</p><p>这里补充一个隐蔽站的知识点：比如A、B、C三个站点在一条线上，A、B相距500米，B、C相距500米。若无线范围覆盖600米，显然，A可以覆盖B，C也可以覆盖B。但是A、C却不能彼此覆盖，所以A、C就互为彼此的隐蔽站。</p><p><strong>802.11标准：</strong></p><img src="https://pic.imgdb.cn/item/661bdca768eb93571343c5e5.png" alt="计算机网络（三）——数据链路层——CSMA-CA基础1.png"><p><strong>帧间间隔：</strong></p><img src="https://pic.imgdb.cn/item/661bdd3868eb935713441024.png" alt="计算机网络（三）——数据链路层——帧间间隔.png"><p>这里再补充一个帧间间隔，PIFS（点协调IFS）：中等长度的IFS，在PCF操作中使用。</p><p><strong>CSMA&#x2F;CA工作原理：</strong></p><img src="https://pic.imgdb.cn/item/661bdeb568eb93571344c7e9.png" alt="计算机网络（三）——数据链路层——CSMA-CA的工作原理.png"><p>CSMA&#x2F;CA工作原理如上图，这里有几个问题需要讨论：</p><p>​1. 源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</p><p>这样做的目的是考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送。</p><p>​2. 目的站为什么正确接收到数据帧后还要等待一段时间SIFS才能发送ACK帧？</p><p>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式。</p><p>​3. 信道由忙转为空闲且经过DIFS时间后，为什么还要退避一段随机时间才能使用信道？</p><p>这是为了防止多个站点同时发送数据而产生碰撞。</p><p><strong>同CSMA&#x2F;CD一样，CSMA&#x2F;CA也有自己的退避算法，退避算法使用场景如下：</strong></p><img src="https://pic.imgdb.cn/item/661be28968eb93571346fc56.png" alt="计算机网络（三）——数据链路层——CSMA-CA的注意点.png"><p><strong>CSMA&#x2F;CA协议的退避算法内容如下：</strong></p><img src="https://pic.imgdb.cn/item/661be35668eb9357134797ac.png" alt="计算机网络（三）——数据链路层——CSMA-CA的退避算法.png"><p><strong>下面对CSMA&#x2F;CA的工作过程进行举例：</strong></p><img src="https://pic.imgdb.cn/item/661be45a68eb935713484707.png" alt="计算机网络（三）——数据链路层——CSMA-CA工作举例.png"><p>假设A、B、C、D、E是5个无线站点，如上图。A先占用无线信道发送数据帧，在A的发送过程中，B、C、D也要发送帧，这里用向上的箭头表示。于是B、C、D进行载波监听，发现信道忙，要进行退避，并根据退避算法选择一个要退避的时间，并在每一个时隙对信道进行一个检测。当检测到信道由忙状态转变为空闲状态，且经过帧间间隔DIFS后，退避计时器开始倒计时，假设C的退避时间最短，当C的退避时间到时后，C立即开始发送帧，此时信道再次由空闲状态转变为忙状态。当B，D检测到信道忙以后，就各自冻结自己剩余的退避时间，等待C传完以后再解冻计时，上图后面的工作过程我就不继续说了，可以根据我前面的介绍自己往后推，这样更能加深自己的理解，有问题的可以跳转视频10~14分钟，<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=32&vd_source=7fb4b255ed876969a742738d7b84f461">CSMA-CA协议</a>。</p><p><strong>接下来介绍CSMA&#x2F;CA协议的信道预约和虚拟载波监听：</strong></p><img src="https://pic.imgdb.cn/item/661be88068eb9357134d6043.png" alt="计算机网络（三）——数据链路层——CSMA-CA协议的信道预约和虚拟载波监听1.png"><img src="https://pic.imgdb.cn/item/661be8b868eb9357134dba4d.png" alt="计算机网络（三）——数据链路层——CSMA-CA协议的信道预约和虚拟载波监听2.png"><img src="https://pic.imgdb.cn/item/661be8ff68eb9357134e1518.png" alt="计算机网络（三）——数据链路层——CSMA-CA协议的信道预约和虚拟载波监听3.png"><p>对于虚拟载波监听机制带来的减少隐蔽站碰撞问题，这里稍微说一下。如图，A、C互为隐蔽站，彼此收不到对方的信号，但是A发送给B一个RTS帧以后，B会发送CTS帧，C虽然收不到A的RTS帧，却可以收到B的CTS帧，这样C就知道了信道会被占用，占用多久，这段时间内C就不不会送帧，即A向B发送信道时，不会受到C的干扰。</p><p>这里有道题感觉很好，能把这部分几个易混淆的协议总结一下，所以贴在这里分享一下：</p><img src="https://pic.imgdb.cn/item/661bea1068eb93571350012f.png" alt="计算机网络（三）——数据链路层——CSMA-CA例题.png"><h3 id="5-3-轮询访问介质访问控制"><a href="#5-3-轮询访问介质访问控制" class="headerlink" title="5.3 轮询访问介质访问控制"></a>5.3 轮询访问介质访问控制</h3><img src="https://pic.imgdb.cn/item/661cc61668eb9357137677cd.png" alt="计算机网络（三）——数据链路层——轮询访问介质访问控制.png"><p><strong>轮询访问介质访问控制有两种主要的协议：轮询协议和令牌传递协议，其中令牌传递协议比较重要。</strong></p><p><strong>轮询协议：</strong></p><p>在轮询协议中，在总线上，把某一台主机当做当前总线的主结点（主结点只能有一台），由该主结点去发送询问帧，询问每台主机是否要进行数据传输，被询问的主机如果要发送数据，则可以发送；而未被询问的主机，即使有数据也不可以发送。当主结点的主机询问当前的某台机器以后，才会继续询问下一台，若询问完一圈，则从头再询问。</p><img src="https://pic.imgdb.cn/item/661cc69b68eb93571376c792.png"><p>这种传输协议会有以下几个缺点：</p><ol><li>轮询开销。总线上会产生大量主结点对其余主机发送询问帧的开销。</li><li>等待延迟。未被问到的主机如果有数据要发送，则不得不等待，就会产生等待延迟。</li><li>单点故障。若主结点出现故障，则整条链路都会崩溃，不过一般会设置辅助结点去代替崩溃的主结点。</li></ol><img src="https://pic.imgdb.cn/item/661cc6bf68eb93571376e446.png" alt="计算机网络（三）——数据链路层——令牌传递协议.png"><p>令牌传递协议与轮询协议很类似，不同的是，在令牌传递协议中，是通过一个令牌（特殊格式的MAC帧）来确定谁进行数据发送。该令牌在令牌环上传输，令牌在谁手里，谁就可以发数据，若发数据就会更改令牌中的设置，让当前信道处于忙状态，进而进行数据传输。但是需要注意的是，每个结点拥有令牌进行数据分组发送时，并不是发送完以后，才把令牌传给下一个主机。而是令牌会有令牌持有时间，一旦持有时间到达，即使拥有令牌的主机数据未发送完，也会停止数据发送，进而把令牌传给下一台主机。</p><p>这里有一点要说一下，在令牌传递协议中，若某主机拥有令牌但不发送数据，主机的行为取决于协议的具体实现和设定。</p><p>通常，如果主机拥有令牌但不发送数据，它应该主动将令牌传递给下一台主机，以便其他主机有机会发送数据。这种设计是为了确保网络资源的有效利用，避免因为某台主机长时间持有令牌而不发送数据导致的资源浪费和通信延迟。</p><p>然而，也存在一些令牌传递协议的实现中，令牌在主机持有一定时间后会自动跳转到下一台主机。这种设计可以防止因为主机故障或程序错误导致令牌无法被正确传递的情况。</p><p>因此，具体是主机会主动把令牌传输给下一台主机，还是等待令牌在当前主机的持有时间到达后自己跳转到下一台主机，取决于所使用的令牌传递协议的具体实现和设定。在实际应用中，需要根据网络环境和通信需求来选择合适的令牌传递协议，并进行相应的配置和管理。</p><h2 id="6-局域网"><a href="#6-局域网" class="headerlink" title="6. 局域网"></a>6. 局域网</h2><h3 id="6-1-局域网的基本概念和体系结构"><a href="#6-1-局域网的基本概念和体系结构" class="headerlink" title="6.1 局域网的基本概念和体系结构"></a>6.1 局域网的基本概念和体系结构</h3><img src="https://pic.imgdb.cn/item/661cdb7f68eb93571396339d.png" alt="计算机网络（三）——数据链路层——局域网.png"><p><strong>局域网的特性主要由三个要素决定：<font color=red>拓扑结构、传输介质、介质访问控制方式</font>。</strong></p><p>首先介绍一下局域网的拓扑结构，如下：</p><img src="https://pic.imgdb.cn/item/661cdb9a68eb935713967db6.png" alt="计算机网络（三）——数据链路层——局域网拓扑结构.png"><p>常见的局域网拓扑结构主要有以上4大类，其中总线型拓扑相较于其他几种更有优势，且造价也不昂贵，所以总线型拓扑是我们现在局域网中比较常用的一种拓扑结构。</p><p>接下来说一下局域网的传输介质：</p><p>局域网分为有线局域网和无线局域网，在有线局域网中，常用介质为双绞线、同轴电缆、光纤，其中双绞线为主流传输介质。</p><p>在无线局域网里，常用介质为电磁波。</p><p>说完了拓扑结构、传输介质，还剩一个介质访问控制方式，如下：</p><img src="https://pic.imgdb.cn/item/661ce02f68eb9357139f6629.png" alt="计算机网络（三）——数据链路层——局域网介质访问控制方式.png"><p>接下里对局域网进行一个分类：</p><img src="https://pic.imgdb.cn/item/661ce08168eb9357139ff713.png" alt="计算机网络（三）——数据链路层——局域网分类.png"><p>这里要解释一下逻辑拓扑与物理拓扑。物理拓扑是实际上的接线结构。而逻辑拓扑则是数据传输时的真实路径（即逻辑上的数据是如何传输的）。</p><p><strong>注意，同一段局域网的物理拓扑与逻辑拓扑并不一定相同。</strong></p><p>这里贴一篇我感觉比较好的CSDN有关拓扑的资料：<a href="https://blog.csdn.net/weixin_37171673/article/details/109558929">物理拓扑与逻辑拓扑</a></p><p>这里还剩下最后一个知识点——IEEE 802标准。</p><p>IEEE 802系列标准是IEEE 802 LAN&#x2F;MAN 标准委员会制定的局域网、城域网技术标准。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。</p><p>这里说几个在考研中比较重要的标准：</p><ol><li>IEEE 802.3：以太网介质访问控制协议（CSMA&#x2F;CD）及物理层技术规范。</li><li>IEEE 802.5：令牌环网的介质访问控制协议及物理层技术规范。</li><li>IEEE 802.8：光纤技术咨询组，提供有关光纤联网的技术咨询。</li><li>IEEE 802.11：无线局域网（WLAN）的介质访问控制协议及物理层技术规范。</li></ol><p>IEEE 802.3标准将数据链路层拆分成MAC子层和LLC子层。</p><img src="https://pic.imgdb.cn/item/661ce39968eb935713a302f8.png" alt="计算机网络（三）——数据链路层——MAC和LLC.png"><h3 id="6-2-以太网与IEEE-802-3"><a href="#6-2-以太网与IEEE-802-3" class="headerlink" title="6.2 以太网与IEEE 802.3"></a>6.2 以太网与IEEE 802.3</h3><img src="https://pic.imgdb.cn/item/661ce42a68eb935713a3cf5e.png" alt="计算机网络（三）——数据链路层——以太网概述.png"><p>以太网是目前最流行的有线局域网技术。<font color=red><strong>以太网逻辑上采用总线型拓扑结构，物理上采用星型拓扑结构。</strong></font>所有计算机共享同一条总线，信息以广播方式发送，以太网使用CSMA&#x2F;CD方式对总线进行访问控制。</p><p>以太网采用两项措施来简化通信，即采用无连接的工作方式和发送的数据都采用曼彻斯特编码。</p><img src="https://pic.imgdb.cn/item/661ce54c68eb935713a573bb.png" alt="计算机网络（三）——数据链路层——以太网提供的服务.png"><p>上图有需要注意的地方，无差错接收不等于可靠传输。无差错接收，只是数据帧发来以后，没有差错才接收，若有，则丢弃。但可靠传输不一样，可靠传输是发来啥收啥，而这数据里的误码，重复等问题，应由可靠传输来解决。可靠传输一般由运输层（传输层）实现，而无差错接收，主要是由负责物理层和数据链路层的以太网实现。</p><p>接下来举个以太网中非常常见的以太网结构例子——10BASE-T以太网（10指标准传输速率为10MB&#x2F;S；BASE指基带以太网；T指双绞线，除了T可能还会遇到F，F指光纤）</p><img src="https://pic.imgdb.cn/item/661ce72268eb935713a7cee3.png" alt="计算机网络（三）——数据链路层——10BASE-T以太网.png"><p><strong>接下介绍适配器及以太网中的MAC地址相关知识：</strong></p><img src="https://pic.imgdb.cn/item/661ce75668eb935713a81d23.png" alt="计算机网络（三）——数据链路层——以太网的MAC地址.png"><p><strong>在了解完MAC地址以后，可以对以太网中的MAC进一步探索——以太网的MAC帧：</strong></p><img src="https://pic.imgdb.cn/item/661ce91a68eb935713aaf1c5.png" alt="计算机网络（三）——数据链路层——以太网的MAC帧.png"><p>MAC帧由6字节目的地址、6字节源地址、2字节类型、数据和4字节检验码（FCS）组成。</p><p>其中源地址有三种情况，第一种情况是单播地址（专有的MAC地址），记录目的主机的MAC地址。第二种情况，是广播地址，目的地址里全1，这种情况会把数据发给所有主机，所有主机看到这样的地址都会接收下来。第三种是多播地址。</p><p>类型里指明上层使用哪种协议，以便把MAC帧地址上交给上层协议。</p><p>数据段范围是46~1500，承载上层的协议数据单元。</p><p>这里有两点注意的地方：</p><ol><li>在以太网中，将数据打包到物理层，会在MAC帧前加上8字节的前导码。前导码分为两个字段：第一个字段是7字节的前同步码，用来实现MAC帧的比特同步；第二个字段是1字节的帧开始定界符，表示后面信息就是MAC帧。</li><li>以太网不需要帧结束定界符，因为当以太网传送帧时，各帧之间必须有一定的间隙，接收方只要找到帧开始定界符，其后面连续到达的比特流就都属于同一帧。实际上，以太网采用违规编码的思想，因为以太网使用曼彻斯特编码，所以每个码元中间都有一次电压的跳变。发送完一个帧后，发送方网络接口上的电压不再变化，这样接收方就能很容易地找到帧结束位置，这个位置往前数4字节就是FCS字段，于是就能确定帧结束位置。</li></ol><p><strong>最后介绍一下高速以太网的知识点：</strong></p><img src="https://pic.imgdb.cn/item/661ced7868eb935713b25e72.png" alt="计算机网络（三）——数据链路层——高速以太网.png"><h3 id="6-3-IEEE-802-11无线局域网"><a href="#6-3-IEEE-802-11无线局域网" class="headerlink" title="6.3 IEEE 802.11无线局域网"></a>6.3 IEEE 802.11无线局域网</h3><p>IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无限网络通信的标准。</p><p>注意WIFI与无线局域网是不一样的，无线局域网的覆盖范围要比wifi大的多，而只有满足IEEE 802.11b和IEEE 802.11g所定义的标准才能称为wifi。13</p><h4 id="6-3-1-802-11局域网的MAC帧"><a href="#6-3-1-802-11局域网的MAC帧" class="headerlink" title="6.3.1 802.11局域网的MAC帧"></a>6.3.1 802.11局域网的MAC帧</h4><p>接下来看802.11的MAC帧帧头格式：</p><img src="https://pic.imgdb.cn/item/662605ad0ea9cb14033d0364.png" alt="计算机网络（三）——数据链路层——802.11MAC帧头格式.png"><p>如图，是802.11MAC帧的帧头格式，其中最为重要的是4个地址及其含义。</p><p>地址1：RA接收端。</p><p>地址2：TA发送端。</p><p>地址3：DA目的地址。</p><p>地址4：SA源地址。</p><p>现在以一个例子来了解这四个地址，假设主机A和B要进行通信。A附近有个基站是AP<sub>1</sub>，B附近也有个基站是AP<sub>2</sub>。（AP是无线接入点，也称为基站，设备想要通过无线访问网络就需要通过基站。）</p><p>现在A和B进行无线通信，A就要将其信息通过电磁波发给AP1，然后AP1再发给AP2(AP1和AP2之间可以有线也可以无线)，最后AP2再以电磁波形式将信号传给B。这就是A和B通过接入点进行通信的过程。</p><p>由于全国各地有非常多的基站，所以手持的手机设备，在行走过程中，手机号也要在基站的数据库中有更新。说白了，就是人在江苏时，手机号是存入江苏的基站中，而人到北京了，手机号就要更新到北京的基站中，所以每当我们去外地旅游时，手机上总会收到某某城市欢迎你，这就说明我们手机接入的基站更新了。</p><p>现在回到例子，A和B通信，现在离A近的基站是AP<sub>1</sub>，离B近的基站是AP<sub>2</sub>。A发送信息给B，则帧里目的地址DA就是B的MAC地址，源地址SA就是A的MAC地址，接收端RA就是AP<sub>2</sub>的MAC地址，发送端TA就是AP<sub>1</sub>的MAC地址。</p><p>上面所说的只是802.11标准当中的一种帧类似，实际上在802.11中会把帧类型分为以下4类：</p><img src="https://pic.imgdb.cn/item/662609250ea9cb140342eaf0.png" alt="计算机网络（三）——数据链路层——802.11MAC4类帧头格式.png"><p>前面所说的帧格式就属于WDS，另外三种类型的帧格式只有三个地址，具体对应字段参考上表。其中BSSID就是基站的地址。SA和DA与前面所说一下，分别是源地址和目的地址。</p><h4 id="6-3-2-无线局域网的组成（分类）"><a href="#6-3-2-无线局域网的组成（分类）" class="headerlink" title="6.3.2 无线局域网的组成（分类）"></a>6.3.2 无线局域网的组成（分类）</h4><p>无线局域网分为<strong>有固定基础设施无线局域网和无固定基础设施无线局网的自组织网络</strong>两类。</p><p>(1) 有固定基础设施无线局域网</p><img src="https://pic.imgdb.cn/item/66260df20ea9cb14034dd661.png" alt="计算机网络（三）——数据链路层——有固定基础设施的无限局域网.png"><p>如图，是有固定基础设施无线局域网络结构，图中有两个基站，其作用是实现区域内以及区域间的数据通信（区域间数据通信也叫漫游）。</p><p>一个基站及其覆盖范围就构成了一个基本服务集BSS，所有站在本服务集内都可以进行直接通信。在上图左边基本服务集里，主机与基站之间很宽阔，通信信号强度足够，但是如果有障碍物阻挡，通信信号强度就会大大衰弱，因为AP的无线转发信号受到阻碍。举个例子，现在A与AP之间无障碍物，信号传输就不会受到阻碍，信号强度就会很高；但如果A与AP之间有一面很高的墙，AP与A之间传输的无线信号就会受到阻碍，信号强度就会丢失，接收信号就会出现不稳定。</p><p>如果两个基本服务集进行通信，就需要接入分配系统DS，这个分配系统就相当于把无线和有线结合在一起。假设上图左A和右A’进行通信，两者之间距离很远，A想发送信号给A’，A就会先把它的数据发送给基站AP<sub>1</sub>，然后基站就会接入一个有线的线缆上，接入线缆就进入了一个有线的分配系统当中，进行有线通信。此时数据可以通过线路进入AP<sub>2</sub>，AP2把数据发送给A‘。这就实现了有线和无线结合的通信过程。</p><p>几个基本服务集组合在一起就形成了一个扩展的服务集。</p><p>(2) 无固定基础设施无线局域网的自组织网络</p><img src="https://pic.imgdb.cn/item/662612d50ea9cb1403573e9c.png" alt="计算机网络（三）——数据链路层——无固定基础设施无线局域网的自组织网络.png"><p>无固定基础设施就是指没有任何的转发器、集线器、路由器和基站等，只有主机它们自己组成一个网络，这里每台主机都可以充当主机及路由器功能。</p><h3 id="6-4-VLAN基本概念与基本原理"><a href="#6-4-VLAN基本概念与基本原理" class="headerlink" title="6.4 VLAN基本概念与基本原理"></a>6.4 VLAN基本概念与基本原理</h3><h4 id="6-4-1-传统局域网的局限性"><a href="#6-4-1-传统局域网的局限性" class="headerlink" title="6.4.1 传统局域网的局限性"></a>6.4.1 传统局域网的局限性</h4><img src="https://pic.imgdb.cn/item/662614d30ea9cb14035c5ef9.png" alt="计算机网络（三）——数据链路层——传统局域网的局限性.png"><p>这里对上图三个局限问题做个具象的说明：</p><ol><li>缺乏流量隔离：在上图右边网络结构中，左上角的组流量交互即使局域化在左上角的交换机中，但流量信号也会贯穿整个网络结构。</li><li>管理用户不便：如果想把左上角组里的用户移动右上角组里，需要改动物理布线才可以。</li><li>路由器成本较高：因为有很多广播帧在线路上传输，这时就希望能把数据隔离，诞生多个广播域，这就需要路由器来支持。如果一个很大的组想要隔离开来，所需要的路由器数量也会翻倍增多。</li></ol><p>为了解决这些问题，就诞生了VLAN。</p><h4 id="6-4-2-VLAN基本概念"><a href="#6-4-2-VLAN基本概念" class="headerlink" title="6.4.2 VLAN基本概念"></a>6.4.2 VLAN基本概念</h4><img src="https://pic.imgdb.cn/item/6626166b0ea9cb14035f1ac1.png" alt="计算机网络（三）——数据链路层——VLAN基本概念.png"><p>使用了VLAN技术，就可以将局域网内的设备划分为与物理位置无关的逻辑组，只有在同一个VLAN下的设备才能进行相互通信。</p><h4 id="6-4-3-VLAN的实现"><a href="#6-4-3-VLAN的实现" class="headerlink" title="6.4.3 VLAN的实现"></a>6.4.3 VLAN的实现</h4><img src="https://pic.imgdb.cn/item/662624180ea9cb14037c4526.png" alt="计算机网络（三）——数据链路层——基于接口的VLAN.png"><p>交换机上生成的各VLAN是互不相通的，若想实现不同VLAN间的通信需要借助路由器或三层交换机。</p><p>那么同VLAN下各主机是如何进行通信的呢？</p><p>这是因为交换机上有转发表，基于MAC和端口会有一个相互映射。又因为交换机上配置了虚拟局域网，所以会附加一个VLAN表，VLAN表里表名哪个端口处在何VLAN下。</p><p>如果上图A主机发送一个广播帧，交换机通过转发表可以知道A主机对应的是1号端口，再通过VLAN表，可以知道1号端口在VLAN1下，所以交换机进行广播帧转发时，会先查看VLAN表，查找里面所有VLAN1下的端口，然后将A的广播帧转发到所有VLAN1下的端口。</p><p>如果A只给B发送数据帧，交换机仍会先通过转发表知道A主机对应的是1号端口，再通过VLAN表，知道1号端口在VLAN1下，然后通过转发表知道B端口为2，再通过VLAN表确认端口2在VLAN1下。</p><p>到现在我们说的都是基于接口技术的VLAN。</p><p>下面说一下基于MAC地址的VLAN技术。</p><img src="https://pic.imgdb.cn/item/662624630ea9cb14037cd6df.png" alt="计算机网络（三）——数据链路层——基于MAC的VLAN.png"><p>基于MAC地址的VLAN技术与基于接口技术的VLAN都一样，只是把VLAN表里的端口号改为MAC地址。不过基于MAC的方式相对于基于端口的方式来说做的更死，使用基于MAC地址的VLAN技术相当于固定了通信的主机，即使该主机换个端口，它也属于该VLAN ID下，而基于端口的，只要主机换个端口就不属于该VLAN ID下了。</p><p>讨论完同一个交换机下的VLAN内通信，现在要讨论在不同交换机下同VLAN的通信。</p><img src="https://pic.imgdb.cn/item/662628920ea9cb140385f069.png" alt="计算机网络（三）——数据链路层——不同交换机下的VLAN通信.png"><p>如图假设A主机想发送信息给E主机，首先A会准备一个帧（这个帧就是之前在链路层学过的普通的以太网帧），到了交换机这，交换机会知道这是从VLAN1传输过来的，因此会在该帧上添加一个标记字段（标签tag，当tag&#x3D;1时表示来自vlan1）。然后交换机1会通过链路发给交换机2（交换机与交换机之间的连接常用trunk端口，trunk端口会把包含标签的数据直接发送到交换机2）。交换机2识别标签以后知道该数据是VLAN1下的，然后会结合其他MAC地址字段等将数据发送至主机E。</p><p>提到了标签的概念，接下来对贴标签进行一个介绍：</p><img src="https://pic.imgdb.cn/item/66262b490ea9cb14038aa9e7.png" alt="计算机网络（三）——数据链路层——802.1Q帧.png"><p>对于普通的以太网MAC帧，在经过交换机转发时，会被插入VLAN标价，形成802.1Q帧，帧格式如上图。</p><p>这个VLAN标记由4个字节组成，前两个字节表情是IEEE 802.1Q帧，接下里4位没用，后面12位是VLAN标识符，表面该以太网帧属于哪个VLAN。</p><p>另外，IEEE 802.1Q帧是由交换机来处理的，而不是由用户主机处理的，这意味着，在主机和交换机之间还是用普通的以太网MAC帧通信，而交换机与交换机之间是使用有VLAN标记的802.1Q帧。所以当交换机知道要把数据传给主机时，会把VLAN标记去掉，将802.1Q帧转换为以太网帧，再发送给主机。</p><h2 id="7-广域网及相关协议"><a href="#7-广域网及相关协议" class="headerlink" title="7. 广域网及相关协议"></a>7. 广域网及相关协议</h2><h3 id="7-1-广域网"><a href="#7-1-广域网" class="headerlink" title="7.1 广域网"></a>7.1 广域网</h3><img src="https://pic.imgdb.cn/item/662632b80ea9cb140397e6b2.png" alt="计算机网络（三）——数据链路层——广域网.png"><p>广域网可以看成是由多个局域网组建而成的一个大型网络。</p><p>从上图中，可以看到广域网中间有许多结点交换机，结点交换机是链路层设备，属于交换机，但是和路由器的功能很像，都是用来转发分组的。不同于路由器，结点交换机只能在单个网络中转发分组，而路由器可以在多个网络之间转发分组。</p><p>在广域网当中除了交换机，也可以有集线器，更可以有网络层的路由器，所以广域网和局域网的一大区别就是，广域网可以覆盖物理层、链路层、网络层，而局域网只能覆盖链路层和物理层。</p><p><font color=green><strong>局域网当中普遍采用多点接入技术，广域网普遍采用点对点的通信方式。</strong></font></p><p>另外，广域网的数据传输速率要比局域网的高，因为广域网要实现远距离通信，所以速度不能太慢，但又因为通信距离远，所以导致广域网的传播延迟要比局域网的传播延迟更长。因此广域网强调<font color=red><strong>数据共享</strong></font>，而局域网强调<font color=red><strong>数据传输</strong></font>。</p><h3 id="7-2-PPP协议"><a href="#7-2-PPP协议" class="headerlink" title="7.2 PPP协议"></a>7.2 PPP协议</h3><p>发现一个写的挺好的PPP协议笔记，贴一下：<a href="https://blog.csdn.net/HinsCoder/article/details/130781224">网络协议讲解-PPP协议</a></p><h4 id="7-2-1-PPP协议概念"><a href="#7-2-1-PPP协议概念" class="headerlink" title="7.2.1 PPP协议概念"></a>7.2.1 PPP协议概念</h4><p>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议。</p><p>注意，<font color=red><strong>PPP协议只支持全双工链路</strong></font>。</p><img src="https://pic.imgdb.cn/item/662638040ea9cb1403a1d1a3.png" alt="计算机网络（三）——数据链路层——PPP.png"><p>PPP由三部分组成：</p><ol><li>一个链路控制协议LCP。</li><li>一套网络控制协议NCP。</li><li>一种将IP数据报封装到串行链路的方法。</li></ol><p>从网络体系结构的角度看，PPP是数据链路层协议，它将上层交付下来的数据单元封装成PPP帧。</p><p>为了支持不同的网络层协议，PPP协议包含了一套网络控制协议NCP，其中的每一个协议支持不同的网络层协议。</p><p>链路控制协议LCP，用于建立、配置以及测试数据链路的连接。PPP协议能够在多种类型的点对点链路上运行，例如，面向字节的异步链路，面向比特的同步链路。</p><p>接下来讨论PPP协议的帧格式。</p><h4 id="7-2-2-PPP协议帧格式"><a href="#7-2-2-PPP协议帧格式" class="headerlink" title="7.2.2 PPP协议帧格式"></a>7.2.2 PPP协议帧格式</h4><img src="https://pic.imgdb.cn/item/66263a4b0ea9cb1403a61d33.png" alt="计算机网络（三）——数据链路层——PPP帧.png"><p>注意，在PPP帧里，地址字段和控制字段暂时没有作用，只有固定表示0xFF和0x03，并没有含义。</p><h4 id="7-2-3-PPP协议的透明传输"><a href="#7-2-3-PPP协议的透明传输" class="headerlink" title="7.2.3 PPP协议的透明传输"></a>7.2.3 PPP协议的透明传输</h4><img src="https://pic.imgdb.cn/item/66263c4c0ea9cb1403a9778d.png" alt="计算机网络（三）——数据链路层——PPP协议透明传输.png"><p>当PPP帧的数据部分出现帧首和帧尾中的标志字段时，如果不采取措施，则会造成接收方对PPP帧是否结束的误判。这里就需要PPP协议采用透明传输来解决误判问题。PPP协议实现透明传输的方法取决于所使用的链路类型，如果是面向字节的异步链路，则使用字节填充法；如果是面向比特的同步链路，则采用比特填充法。</p><p>接下来分别举例展示字节填充法和比特填充法：</p><p>字节填充法：</p><img src="https://pic.imgdb.cn/item/66263e4a0ea9cb1403ace59b.png" alt="计算机网络（三）——数据链路层——PPP字节填充法.png"><p>比特填充法：</p><img src="https://pic.imgdb.cn/item/66263e5e0ea9cb1403ad0ac2.png" alt="计算机网络（三）——数据链路层——PPP比特填充法.png"><h4 id="7-2-4-PPP协议的差错检测"><a href="#7-2-4-PPP协议的差错检测" class="headerlink" title="7.2.4 PPP协议的差错检测"></a>7.2.4 PPP协议的差错检测</h4><img src="https://pic.imgdb.cn/item/66263fca0ea9cb1403af8dd2.png" alt="计算机网络（三）——数据链路层——PPP差错检测.png"><h4 id="7-2-5-PPP协议工作状态"><a href="#7-2-5-PPP协议工作状态" class="headerlink" title="7.2.5 PPP协议工作状态"></a>7.2.5 PPP协议工作状态</h4><img src="https://pic.imgdb.cn/item/662641e80ea9cb1403b3421e.png" alt="计算机网络（三）——数据链路层——PPP协议工作状态.png"><p>PPP链路的开始和结束状态都是“静止”状态，这时并不存在物理层的连接。当检测到调制解调器的载波信号，并建立物理层连接后，PPP就进入链路的“建立”状态。这是链路控制协议LCP开始协商一些配置选项，若协商成功，则进入“鉴别”状态；若协商失败，则退回到“静止状态”。所协商的配置选项包括最大帧长、鉴别协议等，可以不使用鉴别，也可以使用口令鉴别协议PAP或挑战握手鉴别协议CHAP。若通信双方无需鉴别或鉴别身份成功，则进入”网络“状态；若鉴别失败，则进入”终止“状态。进入网络状态后，进行NCP配置，配置完成后，就进入”打开“状态，PPP链路两端通过互相交换网络层特定的NCP分组来进行NCP配置，如果PPP链路上运行的是IP协议，则使用IP控制协议IPCP来对PPP链路的每一端配置IP模块。只要链路处于”打开“状态就可以进行数据通信，当出现故障或链路的一端发出终止请求时，就进入”终止“状态，当载波停止后则回到”静止“状态。</p><h2 id="8-链路层设备"><a href="#8-链路层设备" class="headerlink" title="8. 链路层设备"></a>8. 链路层设备</h2><p>首先设想一个场景，一个集线器上连接多台主机，一般情况下主机与集线器之间不能超过100m，如果超过100m，失帧就会非常严重，再怎么恢复也恢复不了。为了使距离较远的主机能够通信，就要先在物理层上把以太网扩展。</p><p>这时我们可以采用如下图两种方式：</p><img src="https://pic.imgdb.cn/item/6627427c0ea9cb1403565576.png" alt="计算机网络（三）——数据链路层——物理层拓展设备.png"><p>第一种，通过光纤。因为光纤长度非常长，而且光纤信号损耗小，所以可以用光纤拓展以太网。</p><p>第二种，利用集线器把很多个集线器二次组合起来。这里注意一点，每个集线器所构成的区域称为冲突域。冲突域指某一时间只能有一台主机发送信息。而主干集线器把很多集线器连接起来就成了一个更大的冲突域。这样虽然扩展了以太网，但也带来了更大的冲突（发生冲突的概率增大）。</p><p>要想减少冲突，又要扩大以太网，就可以通过链路层扩展，手段主要是通过网桥或交换机。</p><h3 id="8-1-网桥（非考点）"><a href="#8-1-网桥（非考点）" class="headerlink" title="8.1 网桥（非考点）"></a>8.1 网桥（非考点）</h3><p>写在开头：网桥并不是408考试内容，408要求的链路层设备只有交换机。但网桥和交换机的工作原理很类似，甚至可以说交换机就是多个端口的网桥，所以在这里说一下网桥知识，这样可以帮助理解交换机。</p><img src="https://pic.imgdb.cn/item/6627449f0ea9cb14035a0408.png" alt="计算机网络（三）——数据链路层——网桥.png"><p>从网桥的工作过程来看，网桥比集线器要聪明，集线器收到一个信号会从所有端口进行转发，而网桥会考虑要不要转发，从哪个端口转发。</p><p>上图是网桥的结构，可以看到通过网桥可以把几个以太网连接起来，因此就构成一个更大的以太网。原来的一个以太网就是一个冲突域，也叫一个网段。</p><p>网桥的端口并不是像上图那样只有两个，也有三个、四个的，但一般来说都是比较少的。</p><p><strong>网桥的优点：</strong></p><p>(1) 网桥工作在链路层，它可以把各个冲突域分隔开，所以不同网段上的数据通信是不会相互干扰的，所以网桥可以过滤通信量。又因为各网段互不干扰，所以以太网吞吐量也被扩大，是所有冲突域的和。</p><p>(2) 扩大物理传输范围。如图，通过网桥A可以和F通信。</p><p>(3) 提高了可靠性。这里指当一个网段出现故障，只有一个网段会受到影响。</p><p>(4) 可互连不同物理层、不同MAC子层和不同速率的以太网。</p><p><strong>网桥的分类：</strong></p><p>(1) 透明网桥。</p><img src="https://pic.imgdb.cn/item/66274b400ea9cb1403664c4e.png" alt="计算机网络（三）——数据链路层——透明网桥.png"><p>这里要说一下网桥的自学习。假设现在把网桥插入网段中，网桥会先自己构造一个转发表，一开始转发表里什么内容都没有，只有地址和接口两个字段，而自学习就是将该表丰满的过程。</p><p>这里我们以一个例子来说明自学习算法的执行过程：</p><p>现在A要给B发送一个数据帧，A发送的数据会在它自己的网段中广播出去，数据会传到B主机和网桥1的接口1，网桥1收到数据帧以后，会根据帧里信息来决定丢弃还是从哪个接口转发。网桥1会先按照源地址A的MAC地址来查找转发表，发现转发表里没有A地址，就会把A的地址及收到接口1写入转发表中。接下里网桥再按接口B来查找转发表，发现没有B地址，网桥就会通过A接口以外的所以接口转发出去。上图是从2接口转发。这个帧会被传到C、D以及网桥2的1号接口，网桥2同网桥1一样，记录A地址及接收接口1，然后再次转发出去。</p><p>接下来若B给A发送数据，帧到网桥1的接口1时的时候，网桥1会先查找源地址，把B及接口1写进转发表，再查找目的地址A及A的接口，发现是接口1，就会直接丢弃该数据帧。</p><p>(2) 源路由网桥</p><img src="https://pic.imgdb.cn/item/66274b8f0ea9cb1403671630.png" alt="计算机网络（三）——数据链路层——源路由网桥.png"><p>源站会先以广播方式发送发送帧，发送帧到达目的站会发回响应帧或发送帧原路返回，到达起点会告诉起点有多少种路由选择的方案，这些方案里肯定有一个路由最少&#x2F;时间最短的，这时候就可以把这个方案放在帧首部，以后发送帧到目的站时，都可以通过这种方案发送。</p><h3 id="8-2-交换机"><a href="#8-2-交换机" class="headerlink" title="8.2 交换机"></a>8.2 交换机</h3><img src="https://pic.imgdb.cn/item/66274bdc0ea9cb140367ca22.png" alt="计算机网络（三）——数据链路层——交换机.png"><p>以太网交换机就是多接口的网桥，因为网桥接口少，若要拓展以太网就需要很多网桥，这样比较浪费。随着技术发展，网桥接口越来越多，渐渐地就变成现在所说的交换机。以太网交换机一般有十几个接口。如果网络比较复杂，可以先通过集线器连接主机，再通过交换机连接集线器实现以太网拓展。</p><p>注意，<strong>以太网交换机是可以独占传输媒体带宽的。举例解释一下，如果以太网传输速率是10Mb&#x2F;s，现在又4台主机，如果使用集线器连接，每个主机只能分到2.5Mb&#x2F;s。如果使用以太网交换机，则每个主机可以分到10Mb&#x2F;s。</strong></p><p>以太网交换机有以下两种交换方式，其含义即优缺点都写在下图中：</p><img src="https://pic.imgdb.cn/item/66274c210ea9cb140368751b.png"><p>交换机是多接口的网桥，所以交换机也存在自学习功能。交换机的自学习功能和网桥一样，可以往上翻看网桥的自学习部分，这里跳过。</p><img src="https://pic.imgdb.cn/item/66274c480ea9cb140368be6e.png" alt="计算机网络（三）——数据链路层——以太网交换机的自学习.png"><h3 id="8-3-冲突域和广播域"><a href="#8-3-冲突域和广播域" class="headerlink" title="8.3 冲突域和广播域"></a>8.3 冲突域和广播域</h3><img src="https://pic.imgdb.cn/item/66274ca00ea9cb140369870d.png" alt="计算机网络（三）——数据链路层——广播域和冲突域.png"><p>这个图，我感觉挺好，说明了广播域和冲突域，同时也标注了各个层的设备及其能否隔离冲突域和广播域。</p><p>目前学到这，按照我的理解对下三层设备做一个解读的话就应该如下面这样。首先物理层设备，就是集线器、双绞线等，用来构成网段（也是冲突域），但物理层设备构成的冲突域太小，所以需要进行扩展。扩展也可以通过物理层设备扩展，但物理层设备拓展会形成更大冲突域，这会导致冲突域越来越大，数据冲突会愈发严重，所以需要链路层来帮助。而网桥和交换机就是来实现拓展和冲突问题，网桥和交换机在扩展的同时，能隔离各冲突域，这样就可以实现以太网拓展而不产生更大冲突。但是各网段内部是通过广播的方式传输数据帧，这样就导致数据帧即使不是给某台主机的，该主机也会收到，所以就需要网络层的路由器实现广播域的隔离。(这是我的理解，我也不清楚对不对，但还是那句话，能自圆其说就好。)</p><h3 id="8-4-链路层设备脑图"><a href="#8-4-链路层设备脑图" class="headerlink" title="8.4 链路层设备脑图"></a>8.4 链路层设备脑图</h3><img src="https://pic.imgdb.cn/item/66274cd90ea9cb140369f876.png" alt="计算机网络（三）——数据链路层——里路程设备脑图.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（三）——存储系统</title>
      <link href="/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（三）——存储系统"><a href="#计算机组成原理（三）——存储系统" class="headerlink" title="计算机组成原理（三）——存储系统"></a>计算机组成原理（三）——存储系统</h1><h2 id="1-存储系统基本结构"><a href="#1-存储系统基本结构" class="headerlink" title="1. 存储系统基本结构"></a>1. 存储系统基本结构</h2><h3 id="1-1-存储器的层次化结构"><a href="#1-1-存储器的层次化结构" class="headerlink" title="1.1 存储器的层次化结构"></a>1.1 存储器的层次化结构</h3><img src="https://pic.imgdb.cn/item/6615ee6b68eb9357135efab1.png" alt="计算机组成原理（三）——存储系统——存储器层次结构.png"><p>辅存里存储APP等应用软件的信息，所以辅存容量比较大，相应的，辅存的读取速度就比较慢。而CPU的读写速度很快，如果让CPU直接读写辅存，会被辅存的读写速度所拖累。所以一般不让CPU直接读写辅存。</p><p>通常情况下，我们将要执行的程序信息，先从辅存调入主存，然后让CPU访问主存进行读写。</p><p>在图里，我们看到，在辅存和主存之间仍有一个高速缓冲存储器（Cache），存在这个的原因是因为，即使主存读写速度比较快，但仍不能满足CPU的读写速度，为了缓解这种矛盾，计算机就会将当前主存里频繁被访用的部分放到cache里，然后CPU就会直接读取cache里的副本数据。</p><p>举个实例：某同学想使用微信，在辅存里选中微信以后，计算机将微信程序调用到主存，此时CPU可以访问主存，加载微信。若该同学频繁使用视频通话功能，计算机就会将该功能程序段放入cache里，方便频繁调用。</p><p>需要注意一点，主存数据放到cache里，CPU可以调用cache数据，也可以修改cache数据，被修改的数据，cache会更新回主存。</p><h3 id="1-2-存储器分类"><a href="#1-2-存储器分类" class="headerlink" title="1.2 存储器分类"></a>1.2 存储器分类</h3><h4 id="1-2-1-按层次分类"><a href="#1-2-1-按层次分类" class="headerlink" title="1.2.1 按层次分类"></a>1.2.1 按层次分类</h4><img src="https://pic.imgdb.cn/item/6615f54a68eb935713700ed3.png" alt="计算机组成原理（三）——存储系统——按层次分类.png"><h4 id="1-2-2-按存储介质分类"><a href="#1-2-2-按存储介质分类" class="headerlink" title="1.2.2 按存储介质分类"></a>1.2.2 按存储介质分类</h4><img src="https://pic.imgdb.cn/item/6615f5a168eb935713710088.png" alt="计算机组成原理（三）——存储系统——按存储介质.png"><h4 id="1-2-3-按存取方式分类"><a href="#1-2-3-按存取方式分类" class="headerlink" title="1.2.3 按存取方式分类"></a>1.2.3 按存取方式分类</h4><img src="https://pic.imgdb.cn/item/6615f5cc68eb93571371509b.png" alt="计算机组成原理（三）——存储系统——按存取方式.png"><h4 id="1-2-4-按信息可更改性分类"><a href="#1-2-4-按信息可更改性分类" class="headerlink" title="1.2.4 按信息可更改性分类"></a>1.2.4 按信息可更改性分类</h4><img src="https://pic.imgdb.cn/item/6615f61168eb93571371d239.png" alt="计算机组成原理（三）——存储系统——按信息可更改性.png"><h4 id="1-2-5-按信息的可保存性分类"><a href="#1-2-5-按信息的可保存性分类" class="headerlink" title="1.2.5 按信息的可保存性分类"></a>1.2.5 按信息的可保存性分类</h4><img src="https://pic.imgdb.cn/item/6615f64b68eb9357137247bb.png" alt="计算机组成原理（三）——存储系统——按信息可保存性.png"><h3 id="1-3-存储器性能指标"><a href="#1-3-存储器性能指标" class="headerlink" title="1.3 存储器性能指标"></a>1.3 存储器性能指标</h3><img src="https://pic.imgdb.cn/item/6615f69168eb93571372d77f.png" alt="计算机组成原理（三）——存储系统——存储器性能指标.png"><p>存储器的性能主要有三个，分别是存储容量，单位成本，存储速度。这里需要注意的就是存储速度，牵扯到一个存储周期的概念，存储周期包含存取时间以及存储器恢复时间，只有存储器恢复以后，才能进行下次存取。</p><h3 id="1-4-存储器基本概念小结"><a href="#1-4-存储器基本概念小结" class="headerlink" title="1.4 存储器基本概念小结"></a>1.4 存储器基本概念小结</h3><img src="https://pic.imgdb.cn/item/6615f6bf68eb93571373360f.png" alt="计算机组成原理（三）——存储系统——存储器基本概念小结.png"><h2 id="2-主存储器基本组成"><a href="#2-主存储器基本组成" class="headerlink" title="2. 主存储器基本组成"></a>2. 主存储器基本组成</h2><h3 id="2-1-存储元原理"><a href="#2-1-存储元原理" class="headerlink" title="2.1 存储元原理"></a>2.1 存储元原理</h3><img src="https://pic.imgdb.cn/item/6616000e68eb93571385ec84.png" alt="计算机组成原理（三）——存储系统——存储元.png"><p>在第一章我们了解过，存储容量&#x3D;存储字数×字长，这里的字长就是指存储元的数量。存储元结构如上图左，是由mos管和电容组成，电容里面存储高电平和低电平来代表二进制的1和0。</p><p>MOS管是一种特殊的元件，当MOS管输入端电压达到一定阈值时，会接通电路；否则电路会断开。</p><p>接下来说一下存储元的读出过程，当电容里存在高电荷，此时接通MOS管，电容会将里面的电荷信息通过电路传输出来，当在线路另一端检测到高电平时，会转换成二进制1；否则为0。</p><p>写入过程同理，接通mos管以后，通过电路向电容里面充电，写1就接通高电平充电，写0就低电平。</p><p>了解完单个存储元的结构以后，就可以将存储元拼接在一起，就形成了存储单元，多个存储单元并列就构成了存储体，如上图所示。而存储单元里存储的数据就是我们所说的存储字。</p><h3 id="2-2-存储器芯片的基本原理"><a href="#2-2-存储器芯片的基本原理" class="headerlink" title="2.2 存储器芯片的基本原理"></a>2.2 存储器芯片的基本原理</h3><img src="https://pic.imgdb.cn/item/661602f068eb9357138d4369.png" alt="计算机组成原理（三）——存储系统——存储器基本原理译码器.png"><p>经过2.1的了解以后，接下里我们需要考虑的问题是，如何通过CPU给的地址信息，去读取或写入对应的存储字。这里就牵扯到了我们对译码器的使用。</p><p>译码器一端接输入线，这些输入线与地址总线相连，用来接收CPU传来的地址信息。另一端接输出线，这些输出线与存储字相连，用来进行字选，所以这些线也叫字选线。</p><p>当译码器接收到来自CPU的二进制地址信息时，会将其转换成对应编码的输出线输出高电平。所以在译码器里，一般有n位地址输入线，就要有2<sup>n</sup>个字选输出线。例如3-8译码器，地址输入线有3根，则字选输出线有8根，若输入001，则输出线编码为1的线输出高电平。</p><p>此外，还有上图中绿色的线子，该线称为数据线，也叫位线，用来读出或写入每个存储元中的二进制信息，采集到的每个存储元的数据放到MDR里构成存储字。</p><p>知道了如何选择存储单元，那怎么知道是进行什么操作呢？这就需要我们接下来所说的控制电路。</p><img src="https://pic.imgdb.cn/item/6616058868eb93571392c3b3.png" alt="计算机组成原理（三）——存储系统——存储器基本原理控制器.png"><p>控制电路接接入片选线与读选控制信号，然后通过控制电路控制MAR、译码器以及MDR。因为数据传输使用电信号，而电信号具有不稳定的特性，当地址总线的数据输入到MAR中，在稳定前，是不能送入到译码器的。控制电路会控制MAR的输送，待MAR稳定以后，才会让MAR的数据进入译码器。同理，当数据输出时，只有电信号稳定以后，控制电路才认为此时的数据是正确的，这时才会把数据送到数据总线。</p><p>而控制电路主要用来控制读写操作，读写线的设计有两种情况，上图里给出了其中一种——两根读&#x2F;写线，一跟控制读、一根控制写。还有另一种情况——一根读写线，通过该读写线的高低电平来确定读写操作。</p><p>注意上图里，CS和ES上面有横线，这个代表着该信号低电平有效；如果没有就代表高电平有效。</p><p>片选线的作用：大家会发现这里的片选线还没被介绍，其实片选线是用来选中存储芯片的，在计算机的主板上，不只一个存储器芯片，这个时候，需要通过片选线来决定选中哪一个芯片。</p><img src="https://pic.imgdb.cn/item/661615a068eb935713b5e323.png" alt="计算机组成原理（三）——存储系统——存储器芯片.png"><p>通过对存储器基本原理的了解，我们就可以把存储器封装成上图左下角的样子，外接地址线、数据线、片选线以及读写控制线。考试时，可能会出题让我们计算引脚数量，到时候需要注意读写控制线的设计方法。除此以外，芯片还会包含电源引脚、地引脚，需要具体题目具体分析。</p><h3 id="2-3-寻址"><a href="#2-3-寻址" class="headerlink" title="2.3 寻址"></a>2.3 寻址</h3><img src="https://pic.imgdb.cn/item/661616e868eb935713ba1382.png" alt="计算机组成原理（三）——存储系统——寻址.png"><p>接下来讲下寻址，现代计算机一般采用按字节编址，所以我们在进行寻址时，一般查找其字节地址。假设存储矩阵如图所示，每个小方框代表一个字节（1B），每行表示一个存储字，则存储字长为4B。到这里其实就可以发现这是一个32位系统。总容量为1KB的话，说明一共有256行，即256个存储字。</p><p>如果采用字节寻址，则有1K个单元，每个单元1B，只需根据字节号查找即可。</p><p>如果采用字寻址，则相当于把每4个字节地址合并成一个字地址，有256个单元，每个单元4B，这时进行查找操作，需要将字号左移两位，转换成与之对应的字节地址，才可以查找到。</p><p>按半字和双字寻址方法与按字寻址一样，只是半字左移1位，双字左移4位。</p><h3 id="2-4-主存储器基本组成小结"><a href="#2-4-主存储器基本组成小结" class="headerlink" title="2.4 主存储器基本组成小结"></a>2.4 主存储器基本组成小结</h3><img src="https://pic.imgdb.cn/item/6616199368eb935713bdcac8.png" alt="计算机组成原理（三）——存储系统——主存储器组成小结.png"><h2 id="3-SRAM和DRAM"><a href="#3-SRAM和DRAM" class="headerlink" title="3. SRAM和DRAM"></a>3. SRAM和DRAM</h2><p>首先说一下，不论是SRAM还是DRAM，其实都是RAM芯片，而RAM芯片，它的特点就是<font color=red><strong>随机存取</strong></font>。</p><p>SRAM和DRAM虽然都是RAM芯片，但他们并不一样，其中一个最核心的区别就是他们的<font color=red><strong>存储元不一样</strong></font>。</p><p>DRAM的存储元使用<font color=green><strong>栅极电容</strong></font>存储信息，像我们2.2 存储器芯片的基本原理里说的就是DRAM芯片。</p><p>SRAM的存储元使用<font color=green><strong>双稳态触发器</strong></font>存储信息，在下图DRAM和SRAM的比较图里，右边的就是SRAM芯片的基本原理。</p><img src="https://pic.imgdb.cn/item/6618dc0d68eb93571337c44a.png" alt="计算机组成原理（三）——存储系统——SRAM与DRAM.png"><p>在如图的双稳态触发器里，A高B低，代表存储二进制1；A低B高，代表存储二进制0。</p><p>在进行读出操作时，如果双稳态触发器里面存储了0，则BL会输出低电平，BLX无输出；如果存储1，则BLX会输出低电平，BL无输出。</p><p>在进行写入操作时，如果想写输入0，只需给左边触发器加低电平，右边加高电平，使A低B高即可。同理写1，让A高B低即可。</p><p>在电路结构中，我们就可以看出，DRAM芯片使用删减电容存储，电容信息放电读取，读取以后会消失，也就是破坏性读出，想要保留还需要进行读写操作，也就是“再生”。而SRAM芯片使用双稳态触发器，读出的数据不会消失，所以不用重写。这里就可以看出，相交而言，SRAM的读写速度会快于DRAM的读写速度。</p><p>从上图结构中不难看出，DRAM的存储元相对于SRAM的存储元更为简单，所以DRAM的存储元制造成本更低，集成度高，功耗低；相反SRAM芯片的存储元制造成功更高，集成度低，功耗大。</p><p>综合以上来看，SRAM芯片一般用来制作cache芯片，而DRAM一般用来当主存。</p><img src="https://pic.imgdb.cn/item/6618dff868eb9357133d47c5.png" alt="计算机组成原理（三）——存储系统——SRAM与DRAM比较.png"><p>上面为DRAM和SRAM两种类型存储芯片的比较，但是有两点需要补充一下，一是刷新，二是行列地址。</p><p>首先说一下刷新，RAM芯片属于易失性存储器，一般断电后里面的信息就会消失，但是对于DRAM芯片，即使不断电，里面的信息可能也会丢失，而SRAM芯片，只要不断电，触发器的状态就不会改变，信息就不会丢失。刷新一般常用在DRAM芯片里，由于DRAM芯片使用电容存储信息，而电容我们都知道，里面的电量是每时每刻都在流失的，也就是说，当我们存储完信息以后，如果不进行操作的话，电容里面的电量会流失完尽，举个例子，我们在DRAM的一个存储元里存储1，一段时间后，电容电量流失，这个存储元的信息可能就从1变成0。</p><p>一般电容内的电荷只能维持2ms，即便不断电，2ms后，电容内的信息也会消失。所以，在2ms内，我们需要进行一次刷新。</p><p>DRAM的刷新策略如下图，题目中也经常会考三种策略，所以这部分可以关注一下，另外，题目里没有给刷新周期的话，一般默认2ms。</p><p>这里有一个知识点补充一下，<font color=red><strong>刷新由存储器独立完成，不需要CPU的介入</strong></font>。</p><img src="https://pic.imgdb.cn/item/6618e42e68eb93571342deb0.png" alt="计算机组成原理（三）——存储系统——刷新策略.png"><p>接下来，说一下行列地址的问题，在前面2.2存储器基本原理一节，我们介绍过译码器，通过译码器，我们可以选中读写哪一个存储单元。但是如果存储单元过多，比如存储单元有256个的时候，我们的译码器就要引出256跟字选线（256根按照如今的技术是很轻松就可以做到的，我这里举个例子方便理解），这样做起来稍显麻烦，为了解决这种麻烦，我们可以将这256个存储单元划分成16×16的行与列，这样我们使用两个译码器，一个表示行，一个表示列，每个译码器只需要引出16根字选线即可。所以通过行列地址方法的使用，我们就可以轻松的解决基数很大的存储单元的寻址问题。如今，技术发展，也出现了在三维空间上的存储方式，使用三个译码器，分别确定行列与垂直方向Z值，从而解决更大基数的寻址问题。</p><img src="https://pic.imgdb.cn/item/6618e4e868eb935713440962.png" alt="计算机组成原理（三）——存储系统——地址复用技术.png"><p>说完了行列地址的划分，这里我们要讲一下DRAM的地址线复用技术问题，前面我们光讨论了译码器的输出，但没有说过行列译码器的输入问题，行列地址的输送有两种方式，第一种同时送，第二种分两次送。</p><p>如上图，使用同时送的方式会丢掉左边的缓冲器，地址信息会同时被送入到行地址译码器和列地址译码器，比如地址0000 0000，前4位是行地址，后四位是列地址，但同时送的方式会将0000 0000同时送入列地址和行地址译码器。如果有n个位，就要有n根线接入行列地址译码器。</p><p>如果使用两次传送的方式，就可以如上图所示，第一次将行地址信息存入行地址缓冲器，第二次将列地址信息存入列地址缓冲器，再通过缓冲器向译码器发送数据时，行缓冲器会向行译码器传输0000，而列会也会传输0000，如果有n位地址，那行列译码器只需接n&#x2F;2个线子即可。</p><p><font color=red><strong>使用地址复用技术让行列分两次送，可使地址线更少，芯片引脚更少。</strong></font></p><h2 id="4-只读存储器ROM"><a href="#4-只读存储器ROM" class="headerlink" title="4. 只读存储器ROM"></a>4. 只读存储器ROM</h2><p>ROM芯片就是我们常说的只读存储器，虽然对其的定义为是只读存储器（只可读，不可写），但实际上，随着科技的发展，现在的ROM芯片也支持进行写操作。</p><p>对于各种ROM芯片的了解放在下图，可以结合理解记忆。（这部分可能会在选择题里考察）</p><img src="https://pic.imgdb.cn/item/6618ecc068eb935713525c81.png" alt="计算机组成原理（三）——存储系统——ROM.png"><p>除了上面的ROM芯片，我们还要说一个比较重要的ROM芯片，那就是BIOS芯片。在前面的RAM芯片里，我们介绍过，主存是采用DRAM芯片制造，作为RAM芯片，那必然逃不掉断电后，芯片内数据的丢失。所以在我们的计算机开机时，主存里没有任何信息，这个时候CPU会从主板上的一块ROM芯片里读取开机指令，而这块存储开机指令的ROM芯片，就是BIOS芯片（BIOS芯片里存储了“自举装入程序”，负责引导装入操作系统，即开机），BIOS芯片会引导主存去辅存里读取操作系统相关信息，将操作系统里的相关数据放到主存里。</p><p>补充一点，虽然BIOS芯片集成在主板上，但逻辑上会把他看成主存的一部分。所以，在接下来的这门课中，如果谈到主存，那应该是ROM+RAM组成的。而且CPU会把二者统一编址，这里举个简单易懂的例子，如果ROM芯片的大小是1KB，那ROM芯片的地址是0~1023，而RAM芯片会从1024开始编址。</p><img src="https://pic.imgdb.cn/item/6618edb768eb935713543094.png" alt="计算机组成原理（三）——存储系统——ROM-BIOS.png"><p>下面是关于ROM的总结，贴在这里方便有个宏观的概念。</p><img src="https://pic.imgdb.cn/item/6618f20268eb9357135b5808.png" alt="计算机组成原理（三）——存储系统——ROM小结.png"><h2 id="5-双端口RAM和多模块存储"><a href="#5-双端口RAM和多模块存储" class="headerlink" title="5. 双端口RAM和多模块存储"></a>5. 双端口RAM和多模块存储</h2><img src="https://pic.imgdb.cn/item/661e4faf0ea9cb14035fd619.png" alt="计算机组成原理（三）——存储系统——CPU存储周期.png"><p>在1.3里，我们有了解过存储器的性能指标中存取周期一概念，如上图。而在3.SRAM和DRAM里，又可以知道，DRAM芯片是以栅极电容作为电路中的存储元件，常用来做主存，数据读取时是破坏性读取，每次读取完还需要一个恢复时间。所以对于DRAM芯片来说，存取周期中的恢复时间比较长，有可能是存取时间的几倍。</p><p>但如今的设备大多具备多核CPU，如果按照这样的访问情况进行访问的话，第一个CPU访问完以后，第二个CPU依然要等待存取周期才能进行访问。这样就大大浪费了CPU资源。</p><p>除此以外，CPU的读写速度比主存快的多，如果主存恢复时间很长，CPU只能等待，这样会导致主存读取效率很低。</p><p>为了解决上面所说的两个问题，我们可以引入双端口RAM来解决第一个问题，使用多模块存储器来处理第二个问题。</p><h3 id="5-1-双端口RAM"><a href="#5-1-双端口RAM" class="headerlink" title="5.1 双端口RAM"></a>5.1 双端口RAM</h3><img src="https://pic.imgdb.cn/item/661e52d90ea9cb1403655d13.png" alt="计算机组成原理（三）——存储系统——双端口RAM.png"><p>双端口RAM会出现写入错误和读出错误，如上图3,4两条，出现这种情况时，双端口RAM的控制电路会置忙信号，这时由判断逻辑决定关闭哪边端口，留哪边端口进行正常访问。</p><h3 id="5-2-多模块存储器"><a href="#5-2-多模块存储器" class="headerlink" title="5.2 多模块存储器"></a>5.2 多模块存储器</h3><p>多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块并行工作来提高存储器的吞吐效率。常用的有单体多字存储器和多体低位交叉存储器。</p><img src="https://pic.imgdb.cn/item/661e53ec0ea9cb1403673d8b.png" alt="计算机组成原理（三）——存储系统——多模块存储器.png"><p><strong>这里着重说一下多体并行存储器，这是考研的重点。</strong></p><p>多体并行存储器由多体模块组成，每个模块都有相同的容量和存取速度，各模块都有独立读&#x2F;写控制电路、地址寄存器和数据寄存器。如下图，下图是由4个存储器构成的多体并行存储器。</p><img src="https://pic.imgdb.cn/item/661e55140ea9cb1403694b7b.png" alt="计算机组成原理（三）——存储系统——多体并行存储.png"><p>多体并行存储器分为高位交叉编址的多体存储器（上图左）和低位交叉编址的多体存储器（上图右）。</p><p><font color=red><strong>高位交叉编址的多体存储器的高位地址表示模块号（或体号），低位地址为存储体的内地址。</strong></font></p><p><font color=red><strong>低位交叉编址的多体存储器的低位地址表示模块号（或体号），高位地址为存储体的内地址。</strong></font></p><p>假设每个存储体有8个单元，那么对应的高位交叉编址和低位交叉编址的编址序号分别如上图左右所示。</p><p>现在假设每个存储体存取周期为T，存取时间为r，假设T&#x3D;4r，如果连续读取00000~00100。在高位交叉编址中，由于这些数据全部存储在一个存储体里，所以每次读取都要经过一个存取周期T，所以读完5个数据要5T（这里算上了最后一次读取恢复时间，如果不算的话其实只有4T+r）。在低位交叉编址中，由于这些数据分开存储在不同的存储体里，所以每次读取互不干扰，而且读完4个数据以后，第一个存储体存取时间结束可以二次读取，所以对于上面所示的低位交叉编址的多体存储器读完5个数据只要T+4r（这里算上了最后一次读取恢复时间，如果不算的话就是5r），进一步我们可以把其扩展为连续存取n个存储字，则耗时T+(n-1)r。从这里就可以看出，当进行连续数据的读取时，低位交叉编址的读取时间要高于高位交叉编址。</p><p>由于低位交叉编址的优越性，我们生活中，也常采用此编址方式进行主存设计。</p><p>接下里，要讨论一下另一个重点问题，那就是在多位并行存储器里，存储体的个数如何确定？</p><img src="https://pic.imgdb.cn/item/661e5b690ea9cb1403765805.png" alt="计算机组成原理（三）——存储系统——存储体个数.png"><p>假设存储体个数为m，存取周期为T，存取时间为r。当m&lt;T&#x2F;r时，仍会出现CPU等待的情况；当m&gt;T&#x2F;r时，会出现存储体闲置的情况；当m&#x3D;T&#x2F;r时，资源利用率最高；所以，最优的方法是选择第三种。（这里我直接说结论，具体过程联系图示理解，感觉这部分不难，就速速过一下，有问题跳转：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=35&vd_source=7fb4b255ed876969a742738d7b84f461">双端口RAM和多模块存储</a>）。</p><h2 id="6-主存储器与CPU的连接"><a href="#6-主存储器与CPU的连接" class="headerlink" title="6. 主存储器与CPU的连接"></a>6. 主存储器与CPU的连接</h2><p>在2.主存储器基本组成中，我们有学过存储器芯片的基本原理，不过在我们学习的时候，多是些8k×8位的芯片，这对于我们如今的64位机器来说，是远远不够的，所以在这部分我们需要了解一下，主存储器与CPU之间如何通过字扩展或位扩展的方式来实现主CPU的连接。（这部分的知识点比较重要，建议还是联合视频一起学习：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=36&vd_source=7fb4b255ed876969a742738d7b84f461">主存储器与CPU连接</a>）</p><h3 id="6-1-位扩展"><a href="#6-1-位扩展" class="headerlink" title="6.1 位扩展"></a>6.1 位扩展</h3><p>当数据总线长度&gt;存储器芯片字长时，我们就需要通过位扩展的方式，来实现存储器字长与总线长度的一致。</p><p>补充一点，我们在前面介绍的时候将MAR和MDR划分在存储器芯片里，但现在的计算机都是把MAR和MDR划分到CPU内部，而原本我们说的存储器里的MAR和MDR的位置，就变成普通的寄存器（可以参考2.2存储器基本原理的结构图）。</p><img src="https://pic.imgdb.cn/item/661e5f400ea9cb14037d1a53.png" alt="计算机组成原理（三）——存储系统——位扩展.png"><p>上图是存储字长的位扩展方式，我们将两个8k×1位的芯片串联，就可以实现如图的数据位拓展，另外，由于是字扩展，所以对于两个芯片的地址线及片选信号都应该是一样的（说白了就可以理解成在一个芯片上多焊了个引脚用来接通CPU上的第二位数据位）。</p><h3 id="6-2-字扩展"><a href="#6-2-字扩展" class="headerlink" title="6.2 字扩展"></a>6.2 字扩展</h3><img src="https://pic.imgdb.cn/item/661e609b0ea9cb14037fe7b6.png" alt="计算机组成原理（三）——存储系统——字扩展线选法.png"><p>如上图是字拓展方式，两个芯片的数据位一样，但是在地址总线处，通过对片选信号CS的选取，决定哪个芯片用来存取信息。如上图这种，<strong>通过使用不同地址总线来确定不同芯片的方式叫线选法</strong>。</p><p>在这张使用线选法进行字拓展的图中，第一个芯片的地址范围为010 0000 0000 0000<del>011 1111 1111 1111，第二个芯片的地址范围为100 0000 0000 0000</del>101 1111 1111 1111。通过比对我们发现，开头为00和11的两种地址类型没有任何作用，这也意味着这两种地址被浪费，对此，我们可以通过添加门电路进行如下图的优化：</p><img src="https://pic.imgdb.cn/item/661e62730ea9cb140383eaeb.png" alt="计算机组成原理（三）——存储系统——译码片选法.png"><p>在这里，我们将上面所说的线选法进行优化，使用一个取反门电路来让1个地址线同时控制两个芯片。这时我们在看两个芯片的地址时，就可以看到没有地址被浪费。而这里的取反电路设计也就是我们1-2译码器的前身。</p><p>这里我们就需要学会将译码器的内容与片选信号进行连通，使用合适的译码器可以将有限的地址线进行级数般的扩大，从而可以产生更多的片选信号控制更多的存储芯片。</p><h3 id="6-3-位、字同时扩展"><a href="#6-3-位、字同时扩展" class="headerlink" title="6.3 位、字同时扩展"></a>6.3 位、字同时扩展</h3><img src="https://pic.imgdb.cn/item/661e646e0ea9cb14038827dd.png" alt="计算机组成原理（三）——存储系统——字位同时拓展.png"><h3 id="6-4-译码器"><a href="#6-4-译码器" class="headerlink" title="6.4 译码器"></a>6.4 译码器</h3><img src="https://pic.imgdb.cn/item/661e64c20ea9cb1403883cde.png" alt="计算机组成原理（三）——存储系统——译码器.png"><p>这里补充一下译码器的相关知识，译码器就是将地址线进行编码转换的元器件，这里我贴了一张图，主要是想记录一下74LS138芯片的结构（这个芯片很容易被考到），在74ls138芯片里，只有当G<sub>1</sub>G<sub>2A</sub>G<sub>2b</sub>&#x3D;100时，芯片才能使能。而实际上也常通过这种原理，来控制片选信号生效时间。</p><h2 id="7-外部存储器"><a href="#7-外部存储器" class="headerlink" title="7. 外部存储器"></a>7. 外部存储器</h2><h3 id="7-1-磁盘存储器"><a href="#7-1-磁盘存储器" class="headerlink" title="7.1 磁盘存储器"></a>7.1 磁盘存储器</h3><h4 id="7-1-1-磁盘存储器工作原理"><a href="#7-1-1-磁盘存储器工作原理" class="headerlink" title="7.1.1 磁盘存储器工作原理"></a>7.1.1 磁盘存储器工作原理</h4><p>计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器。磁表面存储器介绍如下：</p><img src="https://pic.imgdb.cn/item/6621158c0ea9cb14036a7c3c.png" alt="计算机组成原理（三）——存储系统——磁表面存储.png"><p>如上图为磁表面存储器的工作原理，当我们在写线圈上添加不同方向的电流时，会使铁芯两头产生不同磁性，进而影响携带磁性的磁层。例如写1时，对写线圈添加向里的电流，这时假设铁芯两头产生磁极为N-S，就会在磁层上写上N-S；同理，写0时，对写线圈添加向外的电流，这时铁芯两头产生磁极就相反为S-N，就会在磁层上写上S-N。当带有磁性的磁层从铁芯处经过，会产生电流，读线圈根据产生的电流方向，判断1,0。</p><p>从工作过程就可以知道，使用磁表面存储，不能同时进行读写操作。另外，由于磁表面存储器是通过磁性来存储0,1，如果将磁表面存储器放到强磁场里会导致数据丢失，所以磁表面存储器对工作环境要求较高。</p><p>到这里，我们就已经了解了磁盘最底层的工作原理。</p><p>接下来就可以了解磁盘存储器了。</p><h4 id="7-1-2-磁盘存储器组成"><a href="#7-1-2-磁盘存储器组成" class="headerlink" title="7.1.2 磁盘存储器组成"></a>7.1.2 磁盘存储器组成</h4><img src="https://pic.imgdb.cn/item/6622715b0ea9cb1403bc6aa7.png" alt="计算机组成原理（三）——存储系统——磁盘设备组成.png"><p>上图是磁盘设备的组成，从上图左可以看到一个内部组成，中间有驱动轴，安装马达，带动磁盘旋转。在驱动轴上会有很多盘片，这些盘片表层就涂有前面所说的磁性材质，注意这些磁性材质是一圈一圈涂得。侧边安装有磁头移动臂，可以将磁头移动到磁圈上，让盘片旋转，使磁圈从磁头下方经过，就可以进行读&#x2F;写操作。</p><p>上图右是背面，里面有电路元件，这些电路元件就是磁盘控制器。</p><p>我们可以把左边的称为机械部分，右边的称为电子部分。</p><p>接下里对磁盘设备里的存储区域以及硬盘存储器进行介绍：</p><img src="https://pic.imgdb.cn/item/662273010ea9cb1403bfd024.png" alt="计算机组成原理（三）——存储系统——磁盘设备组成1.png"><p>这里提一点，我们在上面说到磁头数的概念，如下图，在设计时，为了节省资源，提高利用率，会在盘片两面都涂上磁道，安装两个磁头，分别对磁盘的下表面，上表面进行读写。注意，在最上面和最下面的盘片，并没有制造单向磁头对其上面和下面读写，因为这样做成本较高，不太划算。</p><img src="https://pic.imgdb.cn/item/6622737c0ea9cb1403c0d736.png" alt="计算机组成原理（三）——存储系统——磁盘盘片设计.png"><h4 id="7-1-3-磁盘存储器性能指标"><a href="#7-1-3-磁盘存储器性能指标" class="headerlink" title="7.1.3 磁盘存储器性能指标"></a>7.1.3 磁盘存储器性能指标</h4><h5 id="7-1-3-1-磁盘容量"><a href="#7-1-3-1-磁盘容量" class="headerlink" title="7.1.3.1 磁盘容量"></a>7.1.3.1 磁盘容量</h5><img src="https://pic.imgdb.cn/item/662274bd0ea9cb1403c3773d.png" alt="计算机组成原理（三）——存储系统——磁盘容量.png"><p>磁盘容量就是一个磁盘所能存储字节的总数。</p><p>但是磁盘容量有格式化和非格式化之分。</p><p>这里对格式化容量和非格式化容量进行一个补充：</p><p><strong>格式化容量</strong>：</p><p>格式化容量是指磁盘和光盘存储器能提供给用户存储数据的容量。它用字节数来表示。格式化容量是用户实际能存储数据的容量，是在磁盘进行格式化操作后所得到的可用存储空间。在存储数据之前，不论是硬磁盘、软磁盘还是光盘，都需要进行格式化，格式化会占用一定的存储空间，因此格式化容量通常会比非格式化容量小10%～20%。格式化容量的计算方式一般为：格式化容量&#x3D;扇区字节数×每道扇区数×每面磁道数×面数。</p><p><strong>非格式化容量</strong>：</p><p>非格式化容量，也被称为磁盘的原始容量或名义容量，是指磁盘或光盘在未经格式化处理之前，理论上所具有的存储二进制数据的总容量。这个容量是以指定的（通常是允许最大的）位密度把所有磁盘磁道或光盘轨道都写满时的存储容量。例如，一个硬盘标记可以存储500G数据，这就是其非格式化容量。然而，在实际使用中，由于磁盘上总会存在一些不可读或损坏的扇区，因此实际能存储的数据量会小于这个数值。</p><p>总结来说，格式化容量是用户实际可以使用的存储空间，而非格式化容量则是磁盘在理论上的最大存储容量。</p><h5 id="7-1-3-2-记录密度"><a href="#7-1-3-2-记录密度" class="headerlink" title="7.1.3.2 记录密度"></a>7.1.3.2 记录密度</h5><img src="https://pic.imgdb.cn/item/6622769b0ea9cb1403c73794.png" alt="计算机组成原理（三）——存储系统——记录密度.png"><p>这里注意道密度、位密度、面密度相关概念和计算。</p><p>另外说一个易错点，磁盘上所有磁道记录信息量是相等的，并不是最外层的信息量大，而最内层的信息量小。他们的差别在位密度上，外层位密度小，内层位密度大。</p><h5 id="7-1-3-3-平均存取时间（考研常考）"><a href="#7-1-3-3-平均存取时间（考研常考）" class="headerlink" title="7.1.3.3 平均存取时间（考研常考）"></a>7.1.3.3 平均存取时间（考研常考）</h5><img src="https://pic.imgdb.cn/item/662278320ea9cb1403ca87fb.png" alt="计算机组成原理（三）——存储系统——平均存取时间.png"><p>磁盘有马达带着运动，每次读写的单位是以扇区为单位。如上图，假设要对图中红色部分进行读写操作，要先让磁头移动，寻找到要读扇区所在磁道，移动磁头的时间称为寻道时间。接下来要让磁盘旋转，将要读扇区划到磁头位置，这个旋转所要的时间称为旋转延迟时间。接下来还要继续旋转磁盘，使目标扇区从磁头下方划过，这段时间称为传输时间。</p><p>注意，旋转延迟时间，如果题目未给，或无法求的时候，可以采用转半圈所用的时间。因为要读扇区在任何一个位置是相等的。从期望来看，要想让所读扇区划到磁头臂之下，期望时间就是转半圈所需时间。</p><p>另外，给磁盘发出读写命令也需要一段时间，所以有的题目可能会让加磁盘控制器延迟的时间。</p><h5 id="7-1-3-4-数据传输率"><a href="#7-1-3-4-数据传输率" class="headerlink" title="7.1.3.4 数据传输率"></a>7.1.3.4 数据传输率</h5><img src="https://pic.imgdb.cn/item/662278c50ea9cb1403cbae65.png" alt="计算机组成原理（三）——存储系统——数据传输率.png"><h4 id="7-1-4-磁盘地址"><a href="#7-1-4-磁盘地址" class="headerlink" title="7.1.4 磁盘地址"></a>7.1.4 磁盘地址</h4><p>既然知道了工作过程，就应该思考，主机如何知道自己想要操作的是哪个扇区？</p><p>为了指明是哪个扇区，一般会给磁盘里的扇区进行编号。</p><p>如下为磁盘地址的编号格式，主机通过对磁盘地址格式的解析就可以知道自己要找的是哪个扇区。</p><img src="https://pic.imgdb.cn/item/662279020ea9cb1403ce41c9.png" alt="计算机组成原理（三）——存储系统——磁盘地址.png"><h4 id="7-1-5-硬盘的工作过程"><a href="#7-1-5-硬盘的工作过程" class="headerlink" title="7.1.5 硬盘的工作过程"></a>7.1.5 硬盘的工作过程</h4><img src="https://pic.imgdb.cn/item/662279790ea9cb1403cf4e9b.png" alt="计算机组成原理（三）——存储系统——硬盘的工作过程.png"><p>因为磁盘读写操作是串行的，每次只能读写1个bit，所以对磁盘的控制器来说一定要添加串并行交换电路。主机可能会给磁盘发送并行的数据，即一次发送多个位，这时候需要一个并-串交换电路，将主机发来的并行数据转换为磁盘能识别的串行数据。另外，还需哟添加一个串-并行电路，将磁盘发送的串行数据转换为主机能识别的并行数据。</p><p>通过分析，就可以知道磁盘的设计结构如下图：</p><img src="https://pic.imgdb.cn/item/66227e670ea9cb1403da5c92.png" alt="计算机组成原理（三）——存储系统——磁盘设计结构.png"><h4 id="7-1-6-磁盘阵列"><a href="#7-1-6-磁盘阵列" class="headerlink" title="7.1.6 磁盘阵列"></a>7.1.6 磁盘阵列</h4><p>磁盘阵列（RAID）就是将多个独立的物理磁盘组成一个独立的逻辑盘，使用分割交叉存储等方式，来更好的存储数据，保护数据。</p><p>RAID的几种存储方案如下图，这里给出了RAID0和RAID1的方案介绍，但具体的大家可以自己了解一下。</p><p>因为这部分王道里也没说的很具体，只对了RAID0~RAID2的内容进行了介绍，所以我推荐大家自己去找点资料学习，不过我也有找一下，这里可以推一下我找的资料以及这节视频：</p><p>csdn：<a href="https://blog.csdn.net/lolloli/article/details/121669019?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171353710916800213063722%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171353710916800213063722&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121669019-null-null.142%5Ev100%5Epc_search_result_base5&utm_term=%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97&spm=1018.2226.3001.4187">磁盘阵列详解</a> </p><p>王道课程（28分钟~35分钟）：<a href="https://www.bilibili.com/video/BV1ps4y1d73V/?p=37&spm_id_from=pageDriver&vd_source=7fb4b255ed876969a742738d7b84f461">磁盘存储器</a></p><img src="https://pic.imgdb.cn/item/662279be0ea9cb1403cfd15f.png" alt="计算机组成原理（三）——存储系统——磁盘阵列.png"><h4 id="7-1-7-磁盘存储器小结"><a href="#7-1-7-磁盘存储器小结" class="headerlink" title="7.1.7 磁盘存储器小结"></a>7.1.7 磁盘存储器小结</h4><img src="https://pic.imgdb.cn/item/662279e70ea9cb1403d01e91.png" alt="计算机组成原理（三）——存储系统——磁盘存储器小结.png"><h3 id="7-2-固态硬盘"><a href="#7-2-固态硬盘" class="headerlink" title="7.2 固态硬盘"></a>7.2 固态硬盘</h3><img src="https://pic.imgdb.cn/item/6623651f0ea9cb140360c295.png" alt="计算机组成原理（三）——存储系统——固态硬盘与机械硬盘.png"><p>这部分介绍固态硬盘（上图右），从上图中不难看到，固态硬盘相较于机械硬盘，它的电路设计更为复杂，但是机械设计却也变的简单。</p><p>这里，将固态硬盘的所有考点总结到如下的图中：</p><img src="https://pic.imgdb.cn/item/662365010ea9cb1403607e3f.png" alt="计算机组成原理（三）——存储系统——固态硬盘.png"><p>接下来，通过下面这张硬盘结构图对知识点做个相关解释：</p><img src="https://pic.imgdb.cn/item/662365ce0ea9cb140362370b.png" alt="计算机组成原理（三）——存储系统——固态硬盘组成.png"><p>(1) 固态硬盘组成由闪存翻译层和存储介质组成。从上图可以看到，存储介质就是多块闪存芯片，每个芯片由多个块组成，每个块又由多个页组成。闪存翻译层的作用就是将总线传输的逻辑块号，转换成要寻找的页地址。所以，系统的读写是以页为单位的。到这里我们就可以知道，系统读写机械硬盘时，是以扇区为单位，通过找磁道定位扇区进行读写。那么在固态硬盘里，每个块对应的就是机械硬盘里的磁道，每个页对应的就是机械硬盘里的扇区。</p><p>(2) 在知识点里，我们看到，固态硬盘<font color=red><strong>以页为读写单位</strong></font>，但是<font color=red><strong>以块为擦除单位</strong></font>。这里说下固态硬盘的擦除。假设之前我们已经在闪存芯片1里的块1里的页0和页1处写上了数据，现在又想在页0写数据，这样的操作是不允许的，只有先将块1内的所有页上数据全部擦除，才能再继续在页0处写数据。</p><p>现在又产生了一个新的问题，想在闪存芯片1里的块1里的页0处写数据，但是页1和页2处也有数据，如果擦除的话，会把页1和页2的数据也擦掉，这样会导致页1和页2的数据丢失。为了防止数据的丢失，固态硬盘在进行擦除前，会把页1和页2的数据复制到另一块闪存芯片对应的位置，如将闪存芯片1里的块1里的页1和页2处的数据复制到闪存芯片2里的块1里的页1和页2处，然后把想要写到闪存芯片1里的块1里的页0处的数据，写到闪存芯片2里的块1里的页0处。然后把闪存芯片1里的块1数据擦除。这样会保证其他页的数据不会丢失。</p><p>这样数据丢失问题解决了，但是产生了新的问题，原本闪存翻译块将逻辑块号映射到了闪存芯片1里的块1处，但是现在这个逻辑块对应的数据被移动到了闪存芯片2里。为了保证逻辑块地址映射的正确，闪存翻译层会把这些逻辑块号重新进行映射，映射到新的位置，而原有的映射就会被舍弃。所以对一个固态硬盘来说，逻辑块号映射的实际物理地址可能会发生改变，只不过闪存翻译层会将映射关系修改正确。</p><p>所以，可以总结出来，固态硬盘写的操作要比读的操作慢上很多，因为其中还会牵扯到擦除的动作。</p><p>(3) 固态硬盘的扇区会因为擦除次数过多而坏掉，所以固态硬盘会有选择的将擦除动作平均分配到每一个块上，以提升使用寿命。这里面就又牵扯到了擦除的两种技术——动态磨损均衡和静态磨损均衡。</p><p>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存快。</p><p>静态磨损均衡：让老旧的闪存块承担以读为主的存储任务，让较新的闪存快承担更多的写任务。</p><p>这里给出一个理想固态硬盘寿命的计算，从计算可以看到，SSD的寿命很长，所以一块固态保护好的话，可以一直用很久。</p><img src="https://pic.imgdb.cn/item/66236c760ea9cb140371c542.png" alt="计算机组成原理（三）——存储系统——固态硬盘寿命.png"><h2 id="8-cache层"><a href="#8-cache层" class="headerlink" title="8. cache层"></a>8. cache层</h2><h3 id="8-1-cache的基本原理和概念"><a href="#8-1-cache的基本原理和概念" class="headerlink" title="8.1 cache的基本原理和概念"></a>8.1 cache的基本原理和概念</h3><p>在前面讲过，使用双端口RAM和多模块存储器的工作速度虽然有所提升，但与CPU差距仍然很大，为此，设计更高速的存储单元Cache。在与主存相同的价格下，cache的成本更高，但相应的cache所使用的是双稳态触发器，集成度较低，存储容量会有所下降。</p><h4 id="8-1-1-cache工作原理"><a href="#8-1-1-cache工作原理" class="headerlink" title="8.1.1 cache工作原理"></a>8.1.1 cache工作原理</h4><img src="https://pic.imgdb.cn/item/662372d30ea9cb1403806c2f.png" alt="计算机组成原理（三）——存储系统——cache工作原理.png"><p>假设辅存里安装了许多软件（包括微信等），现在要启动微信，会把微信相关的指令、程序代码等调入内存，这里包含着文字聊天、视频聊天、朋友圈等功能。这时候如果CPU从内存里读取一条一条指令，显然，CPU的读取速度很快，而内存的读取速度很慢，这就导致CPU的读取速率会被内存所拖累，所以要想办法尽可能高的提升CPU从内存里读取的速度。</p><p>现在再假设，如果现在只运行微信的视频聊天时，大概率就只会使用微信的视频聊天相关的功能代码，那就可以将微信里有关视频聊天的先关代码指令复制到一个更高速的cache当中，这时候CPU就可以直接从cache里读取视频聊天相关的指令数据。而cache的读写速度比内存快很多，这样就可以缓解CPU和内存的读写速度矛盾。</p><p>所以，现在很多设备都将cache集成在CPU上。</p><p>这里，会有一个疑问，上面举的例子是一个很理想的场景，就是使用微信的视频聊天，那使用别的程序，在某一段时间内，CPU是不是也只会访问到程序的某一段数据？这个问题可以通过程序的局部性原理来解释。</p><h4 id="8-1-2-程序的局部性原理"><a href="#8-1-2-程序的局部性原理" class="headerlink" title="8.1.2 程序的局部性原理"></a>8.1.2 程序的局部性原理</h4><img src="https://pic.imgdb.cn/item/662375f30ea9cb14038807b5.png" alt="计算机组成原理（三）——存储系统——局部性原理.png"><p>假设定义一个int类型的二维数组，那么它在存储空间里是按照行优先的顺序存储的，这个时候通过行优先的循环方式可以看到，频繁调用了for循环指令与加法指令，而这些程序数据在空间上是依次排列的，所有存在空间局部性；而因为for循环的存在，加法指令在未来也会被调用到，所以在时间上也存在局部性。</p><p>但是对于程序B来说，因为它按照列优先的循环方式进行访问，而数据存储按照行优先存储，这就导致B访问的数据地址不连续，所以B在空间上的局部性相对于A更差，同样，访问时间也要更久。</p><h4 id="8-1-3-cache性能分析"><a href="#8-1-3-cache性能分析" class="headerlink" title="8.1.3 cache性能分析"></a>8.1.3 cache性能分析</h4><img src="https://pic.imgdb.cn/item/662385090ea9cb1403b0b7e1.png" alt="计算机组成原理（三）——存储系统——cache性能.png"><p>cache性能主要是一个命中率的问题，而根据CPU是先访问cache再访问主存和同时访问主存两种情况，可以分别得出两种命中率求法。具体情况要根据题目分析。</p><p>这里给一道例题：</p><img src="https://pic.imgdb.cn/item/662385a00ea9cb1403b238cb.png" alt="计算机组成原理（三）——存储系统——cache性能例题.png"><h4 id="8-1-4-cache复制数据的范围界定方式"><a href="#8-1-4-cache复制数据的范围界定方式" class="headerlink" title="8.1.4 cache复制数据的范围界定方式"></a>8.1.4 cache复制数据的范围界定方式</h4><p>在8.1.1和8.1.2里说了，cache去存储内存里某段功能的相关程序指令，然后供CPU读写。那如何界定cache要从主存里复制数据的范围呢？</p><p>下面给出了解决方法：</p><img src="https://pic.imgdb.cn/item/662386a90ea9cb1403b51dcd.png" alt="计算机组成原理（三）——存储系统——cache存取主存数据.png"><p>将主存与cache进行以块为单位的数据交换，即可界定cache所要复制主存指令的范围。</p><p>说的通俗一点，假设cache一共可以存储8KB数据，主存可以存储4MB数据。在cache里每块（每行）存1KB数据，则cache里可以有8个块；而主存可以存储4MB，即2<sup>22</sup>个字节，这样可知道主存地址一共22位，但是为保证主存的块能与cache的块发生无错交换，这就要求<font color=green><strong>cache的块内地址位数与主存的块内地址位数相同</strong></font>，即都是1KB&#x3D;2<sup>10</sup>B。所以可以将主存地址划分为如图的块号和块内地址，块号12位，块内地址10位。而块号的最大数是1111 1111 1111&#x3D;4096，也就是说将主存划分为4096个块。那cache与主存进行交换时，就是将主存内的某个块的数据，放到cache的块里。</p><p>了解到这里，就产生发现新的问题：</p><p>(1) 如何区分cache与主存的数据块对应关系（就是主存的块要放到cache的哪个块里）。</p><p>(2) Cache的范围很小，主存却很大，如果cache满了，主存再次将块放入cache里时应该怎么放？</p><p>(3) CPU修改了Cache中的数据副本，如何确保主存中数据母本的一致性（即CPU写数据时，把cache块里的数据修改了，主存里对应的块内数据怎么处理）？</p><p>下面就对这三个问题进行讨论。</p><h3 id="8-2-Cache和主存的映射方式"><a href="#8-2-Cache和主存的映射方式" class="headerlink" title="8.2 Cache和主存的映射方式"></a>8.2 Cache和主存的映射方式</h3><p>第一个问题，如何区分cache与主存的数据块对应关系（就是主存的块要放到cache的哪个块里）？这就需要设计Cache和主存之间的映射方式。</p><p>而Cache和主存之间的映射方式总共有三种：全相联映射、直接映射、组相连映射。具体介绍如下图：</p><img src="https://pic.imgdb.cn/item/66238c7b0ea9cb1403c18168.png" alt="计算机组成原理（三）——存储系统——cache-主存的映射.png"><p>在上面对三种方式的介绍中，很容易发现一个问题，就是如何确定Cache块里存放的是主存当中的哪个块内数据？故此，需要在Cache前面加上一个<font color=red><strong>标记号</strong></font>，标记内记录主存块的块号，表示着当前cache块内存放的对应主存块。但是仅加一个标记号还不行，因为计算机里存储的数据都是以二进制的方式存储，只能写0或1，所以初始值都是0，这样就会出现一种情况，如果cache里存储的是主存块0内的数据，那标记就为0，但是标记初始化时就是0，这个时候如何确地0是对应的主存块地址，而不是初始值呢？所以还需要添加一个<font color=red><strong>有效位</strong></font>，如果该cache块内存储了数据，就将有效位记位1，反之记为0，这样就可以对0和初始值进行区分了。</p><h4 id="8-2-1-全相联映射的实现"><a href="#8-2-1-全相联映射的实现" class="headerlink" title="8.2.1 全相联映射的实现"></a>8.2.1 全相联映射的实现</h4><img src="https://pic.imgdb.cn/item/6623909d0ea9cb1403cadeaa.png" alt="计算机组成原理（三）——存储系统——全相联映射.png"><p>使用全相联映射，即将主存块随便放入cache中，在上图例子里，设定主机位256MB，cache块长64B，所以可以确定主存有22位块号，6位块内地址，对应的cache的标记号也是22位。因为这是全相联，有随便存放的性质，所以cache标记有22位。但是下面两种，在同样的条件下，标记长度却不一样，所以这个地方要着重理解一下各种映射方式的标记长度。</p><h4 id="8-2-2-直接映射"><a href="#8-2-2-直接映射" class="headerlink" title="8.2.2 直接映射"></a>8.2.2 直接映射</h4><img src="https://pic.imgdb.cn/item/6623911d0ea9cb1403cba103.png"><p>在直接映射里，需要通过取余操作来确定主存块在cache里的存放位置，这样就会产生一个问题，那就是当前主存块对应存放的cache块内已有数据，而cache块还有其它空闲块，但是主存块无法使用，只能将数据覆盖到当前有数据的块。如将主存0号块存放到cache的0号块里，再存放主存8号块时，通过直接映射的方式只能将主存8号块存放到cache0号块里，而不能存放到别的空闲块，这也是直接映射的弊端。</p><p>另外，可以发现，在直接映射的方案里，cache的标记位只有19位。这是因为，我们在直接映射里，通过取模运算得到主存块号对应的cache存放块号。在这个过程中可以发现，cache的总块数为8，即2<sup>3</sup>。用主存块号%2<sup>3</sup>，相当于留下最后三位二进制数，而这三位二进制数就可以直接对应cache内的块号，所以我们可以将22位标记位的最后三位去掉，这样就可以将标记位缩为19位，即只存储主存块号的前19位，而cache块号则对应主存块号的后3位。</p><p>这里，我们可以将其进行推广，即若Cache总块数&#x3D;2<sup>2</sup>，则主存块号末尾n位直接反映它在cache中的位置，而主存块号的其余位作为标记位。</p><h4 id="8-2-3-组相联映射"><a href="#8-2-3-组相联映射" class="headerlink" title="8.2.3 组相联映射"></a>8.2.3 组相联映射</h4><img src="https://pic.imgdb.cn/item/6623913f0ea9cb1403cbd2a5.png" alt="计算机组成原理（三）——存储系统——组相连映射.png"><p>在这里，可以看到标记位只有20位，原理与直接相连同理，根据分组数，可以把主存块号的后两位当做组号，只保留前20位作为标记位。</p><h4 id="8-2-4-cache-主存映射小结"><a href="#8-2-4-cache-主存映射小结" class="headerlink" title="8.2.4 cache-主存映射小结"></a>8.2.4 cache-主存映射小结</h4><img src="https://pic.imgdb.cn/item/6623964d0ea9cb1403d7268b.png" alt="计算机组成原理（三）——存储系统——映射小结.png"><h3 id="8-3-Cache替换算法"><a href="#8-3-Cache替换算法" class="headerlink" title="8.3 Cache替换算法"></a>8.3 Cache替换算法</h3><p>接下里，第二个问题，Cache的范围很小，主存却很大，如果cache满了，主存再次将块放入cache里时应该怎么放？这里就牵扯到了Cache的替换算法。</p><img src="https://pic.imgdb.cn/item/662396d90ea9cb1403d80b05.png" alt="计算机组成原理（三）——存储系统——cache替换算法总览.png"><p>对于上面三种映射方式，它们需不需要替换算法，以及替换时机，如上图所示。在直接映射里，每个主存块都只有对应的1个cache块，所以无需替换算法，直接覆盖数据即可。而在组相联里，只有分组满了才会进行替换。相较而言，只有全相联映射最为需要替换算法，且用的比较多，所以，这部分以全相联映射为例介绍替换算法。</p><p>替换算法主要有4个，分别是：随机算法（RAND）、先进先出算法（FIFO）、近期最少使用算法（LRU）、最近不经常使用算法（LFU）。</p><h4 id="8-3-1-随机算法（RAND）"><a href="#8-3-1-随机算法（RAND）" class="headerlink" title="8.3.1 随机算法（RAND）"></a>8.3.1 随机算法（RAND）</h4><img src="https://pic.imgdb.cn/item/6623981f0ea9cb1403daf055.png" alt="计算机组成原理（三）——存储系统——RAND.png"><h4 id="8-3-2-先进先出算法（FIFO）"><a href="#8-3-2-先进先出算法（FIFO）" class="headerlink" title="8.3.2 先进先出算法（FIFO）"></a>8.3.2 先进先出算法（FIFO）</h4><img src="https://pic.imgdb.cn/item/662398670ea9cb1403dbb41d.png" alt="计算机组成原理（三）——存储系统——FIFO.png"><h4 id="8-3-3-近期最少使用算法（LRU）"><a href="#8-3-3-近期最少使用算法（LRU）" class="headerlink" title="8.3.3 近期最少使用算法（LRU）"></a>8.3.3 近期最少使用算法（LRU）</h4><img src="https://pic.imgdb.cn/item/662399740ea9cb1403de6328.png" alt="计算机组成原理（三）——存储系统——LRU.png"><p>这种算法需要多加注意，因为这种算法是综合性能最好的一种算法，且因为算法的特殊性，计数器的最大数值是不会超过cache块的总数的，最大为cache块总数-1，这样就不会出现计数器无限增加的情况，且这种方法cache的命中率相对来说还可以，不会出现特别大的问题，所以，这个方法比较常用，考试也乐忠于考，要牢记。</p><h4 id="8-3-4-最不经常使用算法（LFU）"><a href="#8-3-4-最不经常使用算法（LFU）" class="headerlink" title="8.3.4 最不经常使用算法（LFU）"></a>8.3.4 最不经常使用算法（LFU）</h4><img src="https://pic.imgdb.cn/item/6623c6c20ea9cb1403518a5c.png" alt="计算机组成原理（三）——存储系统——LFU.png"><p>在LFU算法里，可能会出现多个计数器最小的行，这个时候可以按行号递增的方式（选择行号低的）选择，也可以按FIFO策略选择。</p><p>此外，LFU看似科学，但实际上并不合理，首先计数器可能会出现很大的情况。其次计数器大，并不代表经常访问，像微信视频聊天，在某次打开以后，就一直运行，导致其计数器一直增大，后来就不再运行了，但是计数器增大到一定地步，如果想要替代就会很难，至少要别的计数器都大于此才可以，这样进行下去，可能会出现某个不常用的程序指令一直占用cache块的问题。</p><h3 id="8-4-Cache写策略"><a href="#8-4-Cache写策略" class="headerlink" title="8.4 Cache写策略"></a>8.4 Cache写策略</h3><p>最后一个问题，CPU修改了Cache中的数据副本，如何确保主存中数据母本的一致性？处理这个问题就需要对使用Cache的写策略。</p><p>对于cache的写入，有两种情况，一种是写命中，一种是写不命中。</p><p>写命中，即CPU要写的地址可以在cache里找到。此时CPU有两种写入法，一是写回法，二是全写法。</p><p>写不命中，即CPU要写的地址不可以在cache里找到。此时CPU有两种执行方法，一是写分配法，二是非写分配法。</p><h4 id="8-4-1-写命中——写回法"><a href="#8-4-1-写命中——写回法" class="headerlink" title="8.4.1 写命中——写回法"></a>8.4.1 写命中——写回法</h4><img src="https://pic.imgdb.cn/item/6623c9120ea9cb1403598519.png" alt="计算机组成原理（三）——存储系统——写回法.png"><p>写回法：当CPU对cache写命中以后，会对cache块内的内容进行修改，被修改过的cache块不会立即写入主存，而是会等此块被换出时才会写会主存。而未被写过的cache块，则不需要写回主存，这样可以节省一部分写回时间。</p><p>由于CPU修改过的Cache块不会立刻写回主存，则可能出现数据不一致的隐患。</p><p>为了区分某个cache块是否被CPU写过，可以通过添加脏位的方式进行辨别，如果脏位为1则说明该cache块被CPU写入；若为0，则没有被写入。</p><h4 id="8-4-2-写命中——全写法"><a href="#8-4-2-写命中——全写法" class="headerlink" title="8.4.2 写命中——全写法"></a>8.4.2 写命中——全写法</h4><img src="https://pic.imgdb.cn/item/6623cb160ea9cb1403615b10.png" alt="计算机组成原理（三）——存储系统——全写法.png"><p>全写法，顾名思义，就是CPU即对Cache写，也对主存写。</p><p>当CPU写命中以后，必须把数据同时写入cache和主存，这样就会导致CPU访存次数增加，虽然数据一致性有了提升，但速度变慢了许多，为此，可以通过写缓冲的方式，提高CPU的写主存速度。</p><p>写缓冲就是在CPU和主存之间添加一个由SRAM芯片实现的FIFO队列（SRAM芯片就是用来做cache的芯片，读写速度很快），CPU将要写入主存的数据写入缓冲队列，然后CPU就可以执行别的事情，写缓冲队列再慢慢将数据写入主存，如果CPU第二次写入数据时，写缓冲队列的队头还没完全写入主存，则将第二次数据入队，等待队头写完再写第二次数据（队列的出队操作）。</p><p>注意，使用写缓冲队列，若CPU频繁写入，会出现写缓冲饱和继而发生阻塞。</p><h4 id="8-4-3-写不命中——写分配法"><a href="#8-4-3-写不命中——写分配法" class="headerlink" title="8.4.3 写不命中——写分配法"></a>8.4.3 写不命中——写分配法</h4><img src="https://pic.imgdb.cn/item/6623cd070ea9cb1403661bfe.png" alt="计算机组成原理（三）——存储系统——写分配法.png"><p>写分配法，当CPU写不命中时，会先将主存里对应的块调入Cache里，然后CPU再对cache里的块进行写操作。此方法经常搭配写回法进行使用。</p><h4 id="8-4-4-写不命中——非写分配法"><a href="#8-4-4-写不命中——非写分配法" class="headerlink" title="8.4.4 写不命中——非写分配法"></a>8.4.4 写不命中——非写分配法</h4><img src="https://pic.imgdb.cn/item/6623d09d0ea9cb140370ca34.png" alt="计算机组成原理（三）——存储系统——非写分配法.png"><p>非写分配法：当CPU不命中时，直接对主存里的块进行写操作。这种方法一般搭配全写法使用。</p><h4 id="8-4-5-多级cache"><a href="#8-4-5-多级cache" class="headerlink" title="8.4.5 多级cache"></a>8.4.5 多级cache</h4><img src="https://pic.imgdb.cn/item/6623d15c0ea9cb1403728cb6.png" alt="计算机组成原理（三）——存储系统——多级cache.png"><p>现代计算机常会采用如上图的多级cache结构，离CPU越近的cache，其读写速度越快，同时容量也越小。</p><p>另外，在前面说过，cache里保存的是主存一部分数据的副本，而更高级的cache保存的也是低级cache中部分数据的副本，因此在各级cache之间也存在数据一致性的问题。所以可以在各级cache之间采用全写法+非写分配法，而在cache和主存之间采用写回法+写分配法。</p><h4 id="8-4-6-写策略总结"><a href="#8-4-6-写策略总结" class="headerlink" title="8.4.6 写策略总结"></a>8.4.6 写策略总结</h4><img src="https://pic.imgdb.cn/item/6623d2ad0ea9cb140375f062.png" alt="计算机组成原理（三）——存储系统——写策略总结.png"><h2 id="9-虚拟存储器"><a href="#9-虚拟存储器" class="headerlink" title="9. 虚拟存储器"></a>9. 虚拟存储器</h2><h3 id="9-1-页式存储器"><a href="#9-1-页式存储器" class="headerlink" title="9.1 页式存储器"></a>9.1 页式存储器</h3><img src="https://pic.imgdb.cn/item/6624c38f0ea9cb140318ac37.png" alt="计算机组成原理（三）——存储系统——页式存储.png"><p>众所周知，辅存的存储容量要远大于主存的存储容量，像我们的手机等，辅存都是128GB起步，而主存只有8GB。在辅存里，会装有许多软件，而这些软件大多都超过1G存储，如果不做任何处理的把某个软件的数据直接调入主存并且连续占用一大片存储空间，这样做先不说在主存里能否找到这么一大片存储空间，即使找到了，对于主存的利用率也很低。</p><p>所以，一般来说，在逻辑上会把一个程序分为大小相等的页（每个页面大小和主存块相同），同cache与主存之间的块交换一样，在辅存和主存之间使用页交换的方式将辅存的数据调入主存。如上图，把一个4KB的程序分为4个大小相等的页，然后将这些页调入主存，这样就可以实现进程在主存里离散式的存储。</p><p>注意，这里有个很重要的点，我们所说的把进程分页，更多指的是逻辑上的划分，而主存和cache之间的分块，更多的是指物理层面上的划分。</p><p>接下里要考虑的就是一个程序被拆分成若干页放到主存里后，这个程序如何执行？</p><p>这里要引入两个很重要的概念：逻辑地址和物理地址。</p><p><strong>逻辑地址（虚地址）：程序员视角看到的地址。</strong></p><p><strong>物理地址（实地址）实际在主存中的地址。</strong></p><img src="https://pic.imgdb.cn/item/6624c8b00ea9cb1403246ca3.png" alt="计算机组成原理（三）——存储系统——实地址与虚地址.png"><p>知道了逻辑地址和物理地址的概念以后，就可以接着往下说。</p><p>首先进程的分页对于普通程序员来说是不可见得，一个程序的分页是操作系统做的事情，每一个页面的数据会被离散的放到主存的各个地方。</p><p>而对于程序员来说，自己可以知道自己写的程序所占用的存储空间是多大，进而可以知道存储地址的范围。如上图，程序员打包出一个4KB的程序，可以知道程序的地址范围是0000 0000 0000~1111 1111 1111。如果根据主存块长将这个4KB程序进行划分，就可以将这个程序划分为4个1KB存储页，所以我们可以将这个12位的地址划分为2位逻辑页号+10位页内地址。</p><p>程序员在写程序时是肯定可以知道自己将某个变量定义在了什么地方（即变量的逻辑地址），进而可以使用机器指令来执行操作。但程序员使用机器指令执行操作给的地址码是逻辑地址码，这是程序员视角的。如上图将x存至ACC寄存器，写的地址码是x变量的逻辑地址码0010 0000 0011，这是程序员根据自己对变量定义的所在位置（即程序眼视角）给出的地址码。</p><p>但实际上， 执行指令时，取得是变量x在主存中的物理地址（基于机器视角），即OS在执行指令时，会根据程序员所写逻辑地址的逻辑页号，找到与其对应的主存块号。在上图中，变量x的逻辑地址是00 10 0000 0011，这表示x在编号为0的页，页内地址为10 0000 0011，然而编号为0的页被调入主存块号为2的主存块里，这时x的物理地址就是0000 0000 0010 10 0000 0011。所以机器在在执行指令时，会把程序员所写的逻辑地址，根据逻辑地址号找到与其对应的主存块号，然后去掉逻辑页号，再将主存块号与页内地址拼起来（其实就是找在主存内的映射地址），进而得到该变量的物理地址，然后才执行指令。</p><p>这里补充一下我对逻辑地址的理解，感觉前面讲的不清楚（主要前面是王道视频里说的，感觉不好理解，所以讲下我的理解），逻辑地址在我看来就是程序员写某个软件时，其中相关的各个部分在软件里的位置。举个例子并且用大白话来说，就是程序员在写软件时，定义了一个变量x，x的逻辑地址就是把这个软件看做整体，取x在其中的相对位置为逻辑地址，如这个软件共1KB，那范围就是00 0000 0000~11 1111 1111，而x在这个1KB软件中的位置是00 0000 0010处，那x的逻辑地址就是00 0000 0010。至于映射到主存里是在哪里，逻辑地址几位为逻辑页号，几位为页内地址，这些东西与主存快长有关，而与软件的逻辑地址无关。</p><p>到这里可以探讨第二个问题，知道了程序指令执行时会把逻辑地址转换为物理地址，那中间的转换过程是如何进行的呢？</p><img src="https://pic.imgdb.cn/item/6624f39b0ea9cb140376a97e.png" alt="计算机组成原理（三）——存储系统——页表.png"><p>将逻辑地址转换为物理地址就牵扯到了页表的建立。CPU执行机器指令时，程序员提供的是逻辑地址，这时CPU需要通过页表将其转换为物理地址。</p><p>页表结构如上图，它的左边是逻辑页号（<strong>逻辑页号通常是按照页面的逻辑顺序进行编号</strong>），右边是对应的主存块号。页表信息是一行一行组成的，每一行读可以称为一个页表项（一个逻辑页号与对应的主存块号）。</p><p>页表数据存储在主存里，所以CPU在获取物理地址时要进行访问主存的操作。</p><p>接下来看下地址变换过程：</p><img src="https://pic.imgdb.cn/item/6624f7510ea9cb14037d28f2.png" alt="计算机组成原理（三）——存储系统——地址变换.png"><p>上图就是地址变换过程，先将逻辑地址拆分为逻辑页号和页内地址。然后将逻辑页号和页表基址寄存器结合，得到主存块号，将主存块号和页内地址拼接起来就是访问的物理地址。得到了物理地址，CPU就会对该地址进行cache和主存的访问，下面就回到了我们前面所学的对cache和主存的访问部分。</p><p>这里对页表基地址进行补充，页表基地址指明了页表在主存中的存放地址，例如页表地址为1058，则表示该程序对应的页表的起始地址为1058。页表每一行长度都是相同的，这里假设页表每一行占4B，这就意味着从1058开始往后取4个字节就是第一个页表项，即指明0号逻辑页面存储在什么位置。</p><p>由于页表数据存储在主存里，CPU每次读取时都要对主存进行访问，这就大大拉低了CPU的执行速度，所以根据cache与主存的方案，我们也可以将近期访问的页表项放入更高速的存储器，这样可以加快地址变换的速度。这就是接下来要说的快表。</p><img src="https://pic.imgdb.cn/item/6624f9730ea9cb140380ff62.png" alt="计算机组成原理（三）——存储系统——快表.png"><p>在CPU和页表之间也可以添加一个快表，快表可以使用SRAM芯片制造，同cache和主存的访问一样，CPU访问时会先去快表里查找，若未命中再去页表里查找，同时将查找到的页表项复制到快表里。当然快表容量有限，所以快表很容易被存满，存满以后，CPU若未命中再去页表里查找时，仍会把数据复制到快表里，至于替换哪个就涉及到替换算法，这里的原理与前面所说的cache-主存交换相通，另外这部分在操作系统里会用一大章介绍，计组这边只需了解即可，建议去深入理解操作系统第三章的内容。</p><p>下面，我们联系前面cache与主存的部分对CPU执行进程指令进行一个相对完整的知识回顾总结：</p><img src="https://pic.imgdb.cn/item/6624fc1e0ea9cb140385c6b2.png" alt="计算机组成原理（三）——存储系统——知识回顾.png"><h3 id="9-2-虚拟存储器"><a href="#9-2-虚拟存储器" class="headerlink" title="9.2 虚拟存储器"></a>9.2 虚拟存储器</h3><img src="https://pic.imgdb.cn/item/6624fcd10ea9cb140386ebc3.png" alt="计算机组成原理（三）——存储系统——虚拟存储系统.png"><p>众所周知，辅存的容量是要远大于主存的。如上图，微信、微波等应用程序加起来的容量是要大于内存的容量，然而只有4GB的主存却可以运行这么多程序，是因为运行这些程序时，只需要调用部分数据就可以正常使用，至于没有调用的部分，在之后要用到的时候再调入即可，这就是我们所说的虚拟存储系统。在用户看来，它的内存已经远超过4GB大小，因为它可以远超4GB的程序，但实际物理上，只有4GB的运行内存。<strong>用户感知的存储要比实际上的物理存储大，这就是操作系统虚拟性的体现</strong>。</p><p>虚拟存储系统很类似之前所学的把内存数据调入cache，只不过虚拟存储是把辅存里的数据调入主存。</p><p>说到这里，就可以想到之前在cache里所说的范围界定的问题，如何界定在程序运行时要把哪部分辅存里的数据调入主存呢？这里可以结合页式存储器进行探索。</p><p><img src="https://pic.imgdb.cn/item/66250fe60ea9cb1403ae96db.png" alt="计算机组成原理（三）——存储系统——页式虚拟存储.png">我们可以结合页式存储器与虚拟存储器两种思想，使用页式虚拟存储器。将程序在辅存里的数据分页，然后只调入部分可以满足运行的数据进入主存内，如上图，某程序只用的到0,1两个页面，就可以先把这两个页面放入主存，其它的页面当需要的时候再放到主存，这样可以使主存利用更充分。</p><p>基于这种方式，我们的页表就要进行部分修改。如上图，除了原有的逻辑页号和主存块号外，还添加了外存块号、有效位、访问位和脏位。下面依次介绍一下：</p><p>外存块号：某段数据页在外存里被存放的位置。</p><p>有效位：某页数据是否被调入内存，如果为1说明被调入，为0则没有被调入，这里有效位的作用和前面在cache与主存块里说的一样，为了区分当前主存块号的0是被调入数据在0号块，还是初始化为0。</p><p>访问位：是为了实现页面替换算法添加的属性，类似与cache替换算法，这里页面替换算法解决的是主存和辅存之间存储容量不匹配的问题，至于页面的替换算法在计组里并不重要，仅需了解有这么个东西就可以，但是在操作系统里，这部分会作为第三章的重点进行介绍，所以可以移步操作系统第三章进行学习。这里回到访问位，访问位记录当前一段时间某个块被访问的次数，结合访问位就可以实现按LFU算法，当进行页替换时，可以替换当前访问次数最少的页。</p><p>脏位：这个脏位和cache块的脏位也是同一个意思，当主存里的某些块里数据被修改时，就令脏位为1，当这个块被淘汰以后，就要把块里内容写回辅存。脏位决定着要不要把块里数据写回辅存。</p><img src="https://pic.imgdb.cn/item/6625146c0ea9cb1403b7c36f.png" alt="计算机组成原理（三）——存储系统——存储器层次结构回顾.png"><p>了解完主存与辅存的数据交换以后，就可以回到最初的存储器层次结构，cache与主存之间的交换由硬件自动完成，解决了速度不匹配的问题；主存和辅存之间的交换由硬件和OS共同完成，解决了存储容量不匹配的问题。</p><p><strong>接下来补充一下段式虚拟存储：</strong></p><img src="https://pic.imgdb.cn/item/662514a30ea9cb1403b831f4.png" alt="计算机组成原理（三）——存储系统——段式虚拟存储器.png"><p>页式虚拟存储器把数据拆分成一个一个大小相等的页面。而段式虚拟存储器则是按照功能模块拆分，所拆分出来的分组大小并不一定相同。</p><img src="https://pic.imgdb.cn/item/662515120ea9cb1403b907bc.png" alt="计算机组成原理（三）——存储系统——段式虚拟存储器2.png"><p>使用段式虚拟存储，虚拟地址就会发生一定的变化，将由段号和段内地址组成。</p><p>同页式存储一样，段式虚拟存储也有自己的段表。段表将由段首址，装入位、段长组成。段首址记录着该段在主存里的起始地址。装入位记录着该段是否装入主存。此外由于分段的每段长度不一样，所以需要给其添加段长项来记录段长。</p><p>另外在上图中大家也会发现，使用段式虚拟存储将不会再对主存分页，而是让主存的每个地址都对应一个字节，这样每个段就可以存放到主存的任何一个地方。而为了实现虚拟地址到物理地址的转换，所以要记录主存当中的起始地址是多少，即段首址。</p><p>既然有页式存储和段式存储，那么就可以把两种结合，得出段页式虚拟存储器。</p><img src="https://pic.imgdb.cn/item/6625172d0ea9cb1403bd2072.png" alt="计算机组成原理（三）——存储系统——段页式虚拟存储器.png"><p>段页式虚拟存储器就是把某程序按段分完，再把每个段按页分。虚拟地址就由段号+段内页号+页内地址组成。</p><p>写在最后：</p><p>第9部分关于虚拟存储器的相关知识，在计组里并不是重点，仅需了解即可，但这部分知识在操作系统里会着重介绍，所以考408推荐结合操作系统第三章一起学习。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（三）——串</title>
      <link href="/2024/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E4%B8%B2/"/>
      <url>/2024/04/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构（三）——串"><a href="#数据结构（三）——串" class="headerlink" title="数据结构（三）——串"></a>数据结构（三）——串</h1><h2 id="1-串的定义和基本操作"><a href="#1-串的定义和基本操作" class="headerlink" title="1. 串的定义和基本操作"></a>1. 串的定义和基本操作</h2><p>本节内容很少，重点是串的模式匹配，所以对于串的定义和基本操作，我就简单提一些易错点。另外，串也是一种特殊的线性表，只不过线性表是可以存储任何东西，而串只能存储字符。除此以外，我们进行串的查找时，很少查找单个字符，一般情况下是进行子串查取。</p><h3 id="1-1-串的定义"><a href="#1-1-串的定义" class="headerlink" title="1.1 串的定义"></a>1.1 串的定义</h3><img src="https://pic.imgdb.cn/item/6615270868eb9357135b325e.png" alt="数据结构（三）——串——串的定义.png"><p>上面是串的定义，以及一些有关串的术语的定义。</p><p>但是有几个易错点需要指出：</p><ol><li>串的长度是不包含两侧引号的，例如S&#x3D;”hello world!”的长度是12，而非14。</li><li>在串里，空格也要占1位长度。例如S&#x3D;“n h”的长度是3。另外，由空格组成的串叫空格串。</li><li>确定子串在主串中的位置，其实就是确定子串的第一个字符在主串中的位置。</li><li>查找串里某个字符的位置，从第一字符开始查找时，要从1开始查起，而不是从0开始查。</li></ol><h3 id="1-2-串的基本操作"><a href="#1-2-串的基本操作" class="headerlink" title="1.2 串的基本操作"></a>1.2 串的基本操作</h3><img src="https://pic.imgdb.cn/item/661529fb68eb93571360f53f.png" alt="数据结构（三）——串——串的基本操作.png"><p>串的基本操作全在上图，这里说下几个需要注意的点：</p><ol><li>区分清空操作和销毁串：清空操作是将串中字符情况，但是串本身的存储位置还在。而销毁操作，是将整个串都给销毁，无法在原地址上找到该串，要想使用串需重新分配存储空间。</li><li>串连接操作，是将两个串拼凑在一起，这个时候可能需要开辟存储空间，所以如果程序里多次使用串连接操作，要使用易扩展的存储结构。</li><li><font color=red><strong>定位操作</strong></font>，要在主串里找到子串，涉及到了匹配算法，也是我们这一章的重点，后面会细讲。</li><li><font color=red><strong>比较操作</strong></font>，注意比较两个字符串，并不是谁长谁就大，而是从第一个字符开始一位一位进行比较，当出现两个字符不同的时候，哪个字符大，哪个字符串就大。例如S&#x3D;”abcd”，M&#x3D;”acb”，两个字符串第一位全是a，所以比较第二位，而b&lt;c，所以M&gt;S。若两个字符串相等，则两个字符串一定相同。注意，这里b&lt;c，并不是按英语里的排序，而是在计算机对字母的编码大小，一般情况下，计算机对字母使用ASCLL码进行编码，而在ASCLL码表里b的二进制表示小于c的二进制表示，所以c&gt;b。如果有不理解的地方可以去看看视频<a href="https://www.bilibili.com/video/BV1b7411N798?p=33&vd_source=7fb4b255ed876969a742738d7b84f461">串的定义和基本操作</a></li></ol><h2 id="2-串的存储结构"><a href="#2-串的存储结构" class="headerlink" title="2. 串的存储结构"></a>2. 串的存储结构</h2><h3 id="2-1-串的顺序存储"><a href="#2-1-串的顺序存储" class="headerlink" title="2.1 串的顺序存储"></a>2.1 串的顺序存储</h3><p>同线性表，串的顺序存储也有两种创建方式，一使用静态数组进行顺序存储。二使用动态数据进行顺序存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态数组创建存储空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 255 <span class="comment">//定义串的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span> ch[MaxSize];<span class="comment">//每个分量存储一个字符</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//串当前长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态数组创建存储空间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">char</span>* ch;<span class="comment">//定义ch指针，指向串首地址</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/661532c368eb9357136f6ae1.png" alt="数据结构（三）——串——串的顺序存储.png"><p>在不同教材里顺序存储方式有所差别，以下给出4种方案，第一种方案在末尾使用int（不一定int，也可是其他数据类型）记录存储长度，这样更容易获得长度，且范围足够。第二种让ch[0]充当length，这样可以使字符的位序和数组下标相同，但是ch[0]仅有一个字节，表示最大长度为255，存储的长度有限。方案三在结尾以‘\0’结尾，没有length变量，这样每次获得长度就需要我们去遍历。第四种综合了第1种和第2种方案，所以也综合了1,2两种的优点，不出意外，我们接下来对于串的基本操作的实现，都基于第4种方案进行设计。</p><img src="https://pic.imgdb.cn/item/661538ed68eb93571379daf7.png" alt="数据结构（三）——串——顺序存储细节方式.png"><h3 id="2-2-串的链式存储"><a href="#2-2-串的链式存储" class="headerlink" title="2.2 串的链式存储"></a>2.2 串的链式存储</h3><p>这里可以看到，1个字符占1个存储空间，但是在一个32位系统里，一个指针占4个bit的存储空间。如果我们每个结点只存放一个字符，那就会有大量空间被浪费。所以我们可以采用一个存储结点放4个字符，这样可以平衡存储空间的利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> &#123;</span></span><br><span class="line"><span class="comment">//char ch;//每个结点存放一个字符</span></span><br><span class="line"><span class="type">char</span> ch[<span class="number">4</span>];<span class="comment">//每个结点存放4个字符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">String</span>* <span class="title">next</span>;</span><span class="comment">//指向下一个结点</span></span><br><span class="line">&#125;StringNode, *String;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/6615338f68eb935713714465.png" alt="数据结构（三）——串——串的链式存储.png"><h3 id="2-3-串的基本操作实现"><a href="#2-3-串的基本操作实现" class="headerlink" title="2.3 串的基本操作实现"></a>2.3 串的基本操作实现</h3><p>串的基本操作在1.2已展示，由于串就是一种特殊的线性表，而前面的线性表、栈、队列等，我们已对增删改查、初始化、判空等基本操作进行反复书写，这里为了节省时间便展示几个重要的操作的程序设计。</p><h4 id="2-3-1-求子串"><a href="#2-3-1-求子串" class="headerlink" title="2.3.1 求子串"></a>2.3.1 求子串</h4><img src="https://pic.imgdb.cn/item/661535b368eb935713743342.png" alt="数据结构（三）——串——求子串.png"><p>求子串，就是将字符串里第i个位置起，将长度为len的子串给取出来。注意，我们上图里采用的是2.1里几种存储方法的第4种，所以数组下标为0的位置没有进行数据存储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求子串</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SubString</span><span class="params">(SString&amp; Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pos + len - <span class="number">1</span> &gt; S.length)<span class="comment">//判断字符串长度</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; pos + len; i++)<span class="comment">//从pos位置将len长度子串取出</span></span><br><span class="line">Sub.ch[i - pos + <span class="number">1</span>] = S.ch[i];</span><br><span class="line">Sub.length = len;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-字符串比较"><a href="#2-3-2-字符串比较" class="headerlink" title="2.3.2 字符串比较"></a>2.3.2 字符串比较</h4><img src="https://pic.imgdb.cn/item/661536b968eb9357137629d3.png" alt="数据结构（三）——串——比较操作.png"><p>字符串比较，从首位开始一位一位比较，如果出现两个字符串同一位置字符不同，则哪个字符大，哪个字符串就大；若相同，接着往下比较。若两个字符串被扫描的地方都一样，则谁长谁大。若完全一样，则相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串比较，若S&gt;T，则返回值&gt;0;若S&lt;T,则返回值&lt;0；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.length &amp;&amp; i &lt;= T.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (S.ch[i] != T.ch[i])<span class="comment">//判相等</span></span><br><span class="line"><span class="keyword">return</span> S.ch[i] - T.ch[i];<span class="comment">//不相等返还S.ch[i] - T.ch[i]的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> S.length - T.length;<span class="comment">//若数据匹配完，谁长谁大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-求子串位置"><a href="#2-3-3-求子串位置" class="headerlink" title="2.3.3 求子串位置"></a>2.3.3 求子串位置</h4><img src="https://pic.imgdb.cn/item/6615376968eb93571377526c.png" alt="数据结构（三）——串——子串匹配.png"><p>这里我们可以使用这样一种思路，结合前面两种操作，从第1位每次从主串里取要求子串长度，然后与要求子串进行比较，相同则返回首位下标，不同则让主串里所取的位置往后移一位再进行取串比较的操作。通过这种思想，我们可以结合2.3.1和2.3.2，使用2.3.1取串，然后通过2.3.2比较。如果取到最后发现没有与要求子串相等的串，则说明该主串里不存在要求子串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求子串位置操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, n = StrLength(S), m = StrLength(T);<span class="comment">//获取子串和主串长度</span></span><br><span class="line">SString sub;<span class="comment">//暂存子串</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= n - m + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">SubString(sub, S, i, m);<span class="comment">//取子串</span></span><br><span class="line"><span class="keyword">if</span> (StrCompare(sub, T) != <span class="number">0</span>)<span class="comment">//判相等</span></span><br><span class="line">++i;<span class="comment">//不等进入下轮取串判等操作</span></span><br><span class="line"><span class="keyword">else</span><span class="comment">//相等返回串头下标</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-朴素模式匹配算法"><a href="#3-朴素模式匹配算法" class="headerlink" title="3. 朴素模式匹配算法"></a>3. 朴素模式匹配算法</h2><p>首先介绍两个概念——主串和模式串</p><p>​主串：一组数据较长的字符串。</p><p>​模式串：一组数据较少的字符串。</p><p>这里要区分子串和模式串，子串一定可以在主串里找到，而模式串不一定能在主串里找到。</p><p><strong>字符串的模式匹配</strong>：在主串中找到与模式串相同的子串，并返回其所在位置。</p><p>字符串匹配有两种算法，一种朴素匹配，一种KMP。</p><p>这里我们先介绍朴素模式匹配。</p><img src="https://pic.imgdb.cn/item/661664b168eb93571394b69e.png" alt="数据结构（三）——串——朴素模式匹配.png"><p>朴素模式匹配算法的具体过程如下，假设主串长度为n，模式串长度为m，m&lt;n。则从主串第1个位置开始，取长度为m的子串，与模式串进行匹配，不相等，则将所取子串的首位向后移动一位，再进行取串，判相等操作。最多匹配<font color=red><strong>n-m+1</strong></font>个子串。到这里，我们就会发现，所谓朴素模式匹配算法和我们前面2.3.3里所说的求子串方法一样，只不过这里出现了可能找不到的情况。</p><p>所以，联系前面的求子串算法，我们很容易写出如下的朴素模式匹配算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素模式匹配算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(SString S,SString T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;<span class="comment">//定义主串与模式串的起始匹配位置</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T,length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j])&#123;<span class="comment">//如果两个串当前匹配位置相等，继续后移匹配</span></span><br><span class="line">            ++i; ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;<span class="comment">//匹配失败，进行下一轮初始化待匹配状态</span></span><br><span class="line">            j=<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)<span class="comment">//匹配结束以后，如果j大于模式串长，说明匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i&gt;T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//j小于模式串长，匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更方便我们理解这个算法，这里以一个实例的匹配过程，作为演示，来进行算法详解。</p><img src="https://pic.imgdb.cn/item/6616678768eb935713984bec.png" alt="数据结构（三）——串——朴素模式匹配算法过程1.png"><p>首先，用i指向主串S的下标1的地方，j指向模式串T的下标为1的地方。从主串S里取出第一组与模式串T等长的子串，同时令i，j后移进行每一位判相等操作。从上图可以看到，当i&#x3D;j&#x3D;6时，两个串不相同，于是令j回到模式串T的数组下标为1的地方，但是i回到的应该是1的下一位，即数组下标为2的地方。这里，我们可以发现i每次回去的值等于i-j+2，即令当前S串中被匹配的长度i减去模式串S中被匹配的长度j，此时i会回到第一个匹配位的前一位，这时候加2即可令i指向第一个匹配位的下一位，也即下一个匹配子串的第一个位置。</p><img src="https://pic.imgdb.cn/item/6617375d68eb935713ad1032.png" alt="数据结构（三）——串——朴素模式匹配算法过程2.png"><p>接下来是第二个子串与模式串比较过程，可以发现两个串的第一位就不相同，于是i应指向3，即第三个子串的首位，而j仍然在模式串1的位置。</p><img src="https://pic.imgdb.cn/item/661737e868eb935713adf168.png" alt="数据结构（三）——串——朴素模式匹配算法过程3.png"><p>第三轮匹配，发现主串中第三个子串与模式串T相等，这个时候两者就相同，由于是判断一位相同，然后再移动到下一位，所以当我们的模式串最后一位也被判断相同时，此时j还会再加1，这时j的数值大于模式串T的数值，所以，我们可以用i-T.length&gt;0来判断相等。</p><p>说完了算法以及算法的运行过程，就要谈论评价一个算法必不可少的东西——时间复杂度。</p><img src="https://pic.imgdb.cn/item/661738da68eb935713afd0cf.png" alt="数据结构（三）——串——朴素模式匹配算法过程时间复杂度.png"><p>在朴素模式匹配算法里，假设模式串长m（即每次都要匹配m个字符），主串长n（要匹配n-m+1个串）：</p><p>最优的时间复杂度：第一次匹配m个字符就匹配成功，所以最快时间复杂度&#x3D;O(m)。</p><p>最坏时间复杂度：最后一个串匹配，才匹配成功，则要匹配n-m+1次m个字符，即O(mn-m<sup>2</sup>+m)&#x3D;O(mn)。</p><p>最后进行一个简短的思维图总结：</p><img src="https://pic.imgdb.cn/item/66173a7568eb935713b2361b.png" alt="数据结构（三）——串——朴素模式匹配算法思维图.png"><h2 id="4-KMP算法"><a href="#4-KMP算法" class="headerlink" title="4. KMP算法"></a>4. KMP算法</h2><p>写在开头：这一部分我写的有点简陋，主要是因为这部分内容是串这一章的核心，讲清比较繁琐，我只能在我的基础上进行一些重点指出，这样不会浪费时间，也能帮助我复习，有问题的可以跳转看视频：<a href="https://www.bilibili.com/video/BV1b7411N798?p=36&vd_source=7fb4b255ed876969a742738d7b84f461">KMP</a></p><h3 id="4-1-KMP基础"><a href="#4-1-KMP基础" class="headerlink" title="4.1 KMP基础"></a>4.1 KMP基础</h3><p>在前面，我们学习的朴素匹配算法里，如果匹配失败，主串前进了m步，就要退回m-1步，模式串要将数据指针指向头部。这样有大量时间消耗在回溯的过程上，所以为了减少这种时间消耗，提出了KMP匹配算法。</p><p>KMP算法就是在主串回溯位置上做了手脚，我们可以通过特殊的方法，使主串不进行回溯，同时对模式串每次回溯的位置进行确定，从而减少过多回溯产生的时间消耗。比如在bababaccd里找babac，我们第一次匹配时，会发现babab和babac最后一位不相同，按照朴素匹配算法，我们会将两者指针都回溯到最初位置。但我们可以发现，不将主串回溯，将模式串回溯到babac里第二个b的位置，也可以实现匹配成功，所以这就是我们优化后的KMP算法，<font color=red><strong>而KMP算法的核心就是要找到我们在模式串里匹配失败时，对应该位应回溯的位置</strong></font>。</p><p>接下来以一个匹配过程作为演示，来进行KMP的介绍：</p><img src="https://pic.imgdb.cn/item/66177ebf68eb9357132f8387.png" alt="数据结构（三）——串——KMP推导1.png"><p>模式串匹配在最后一位（第6位）没有匹配成功，此时j回溯到1位。</p><img src="https://pic.imgdb.cn/item/6617800468eb93571330fbac.png" alt="数据结构（三）——串——KMP推导2.png"><p>当j&#x3D;5时发生了不匹配，此时将j回溯到2。</p><p>综上，当j&#x3D;4,3,2,1时匹配失败都要回溯对应位置，我们将其总结如下。</p><img src="https://pic.imgdb.cn/item/6617808268eb935713316bbb.png" alt="数据结构（三）——串——KMP推导.png"><p>这里我们可以采用一个数组将每个不匹配位置的j要回溯的数位统计下来。然后在匹配失败时，从数组里提取要回溯的位置。</p><p>注意：</p><p>(1)在第1位匹配失败，理论上应保持不变，但却让其回溯到0，这是为了更方便代码的实施，可以联系接下来的算法代码理解。</p><p>(2)在回溯时出现可能会出现多个回溯位都可以的情况，例如从主串ababababababc里匹配模式串abababac，第一次匹配时，在c的位置出现匹配出错，此时可回溯到ababab，也可以回溯到abab，还可以回溯到ab，出现这种情况，要选择最大前缀(前缀和后缀的知识在下面补充，但大家应该都有基础，这里应该可以理解什么是前缀什么是后缀)回溯，即选择最长的那个进行回溯。</p><p>(3)如果从主串abccabca里匹配模式串abca，会发现在第4个位置匹配失败，这个时候要回溯到模式串头再次匹配，实际上，第4位的a匹配失败，我们就已经可以知道开头a的匹配肯定失败，但计算机依然会进行一次运算，这就是KMP所存在的缺点，从这里就可以发现KMP也存在非最优解。</p><p>接下来就着重说一下KMP的核心，next数组（模式串回溯数组）怎么求。</p><h3 id="4-2-next数组求解"><a href="#4-2-next数组求解" class="headerlink" title="4.2 next数组求解"></a>4.2 next数组求解</h3><img src="https://pic.imgdb.cn/item/6617857568eb9357133b1b7b.png" alt="数据结构（三）——串——next数组求解.png"><p>在next数组求解前，先补充一下概念——串的前缀和串的后缀。</p><p>串的前缀：包含第一个字符，且不包含最后一个字符的子串。</p><p>串的后缀：包含最后一个字符，且不包含第一个字符的子串。</p><p>求next数组的公式：假设第j个字符匹配失败，由前1~j-1个字符组成的串记为S，则：<font color=red><strong>next[j]&#x3D;S的最长相等前后缀长度+1</strong></font></p><p>接下来以一道练习题加深印象。</p><img src="https://pic.imgdb.cn/item/6617859c68eb9357133b4f24.png" alt="数据结构（三）——串——next数组求解练习题.png"><p>这里我仅以j&#x3D;5举例，其余的大家可以自己算。</p><p>j&#x3D;5，则S&#x3D;4，在aaaa里的最长前后相等缀为aaa&#x3D;aaa，所以next[5]&#x3D;3+1&#x3D;4。</p><p>另外，j&#x3D;1和2时，不论模式串有多长，他们的最长相等前后缀都为0，而为了匹配算法，所以1特定为0。在手算时，为了节省时间，我们可以直接写next[1]&#x3D;0，next[2]&#x3D;1。</p><img src="https://pic.imgdb.cn/item/6617866468eb9357133cfb39.png" alt="数据结构（三）——串——next数组求解公式.png"><p>上面是书上给出的next[j]求解公式，方法并不唯一，大家也可以根据自己的理解写自己的推导公式。</p><h3 id="4-3-KMP算法"><a href="#4-3-KMP算法" class="headerlink" title="4.3 KMP算法"></a>4.3 KMP算法</h3><p>说了半天，我们已经可以理解KMP算法的大致流程以及实现过程。接下来我们就可以对KMP算法进行代码书写以及性能分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next数组求解</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(SString T, <span class="type">int</span> next[])</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;T.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">++i; ++j;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里next数组的算法求解可能有点难以理解（我就没理解），所以我找了一个视频讲解，大家没看懂想弄懂的可以看一下：<a href="https://www.bilibili.com/video/BV16X4y137qw/?spm_id_from=333.337.search-card.all.click&vd_source=7fb4b255ed876969a742738d7b84f461">KMP算法next数组代码讲解</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KMP匹配</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(SString S, SString T)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> next[T.length+<span class="number">1</span>];<span class="comment">//这里加1，是因为我们使用2.1里的第四种存储方法，数组首位空出</span></span><br><span class="line">get_next(T, next);<span class="comment">//求模式串T的next数组</span></span><br><span class="line"><span class="keyword">while</span> (i&lt;=S.length&amp;&amp;j&lt;=T.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">++i; ++j;<span class="comment">//逐级匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = next[j];<span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line"><span class="keyword">return</span> i - T.length;<span class="comment">//匹配成功</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/661786b868eb9357133d8703.png" alt="数据结构（三）——串——KMP算法.png"><p>在这里，求next数组，假设模式串长m，get_next的时间复杂度可以简单认为是O(m)。</p><p>假设主串的长度为n，则匹配过程的时间复杂度可以简单认为是O(n)。</p><p><strong>KMP算法的时间复杂度就可以认为是O(m+n)。</strong></p><p>这里的理解是比较粗糙的，实际上的计算过程可能要考虑很多且很复杂。不过大家记住这个结论就好。</p><img src="https://pic.imgdb.cn/item/661786c868eb9357133da060.png" alt="数据结构（三）——串——KMP算法总结.png"><p>上面是对KMP算法与朴素模式匹配算法的一个简短总结与比较。大家可以看一下。</p><h3 id="4-4-KMP算法优化"><a href="#4-4-KMP算法优化" class="headerlink" title="4.4 KMP算法优化"></a>4.4 KMP算法优化</h3><p>在4.1的注意事项里的第三条，我们说过，如果出现匹配失败的位置上的字符与模式串回溯位置的字符相同，则会出现多匹配的情况，这里，我们就说一下如何解决这种情况。</p><img src="https://pic.imgdb.cn/item/6617a16768eb935713653b6b.png" alt="数据结构（三）——串——KMP优化.png"><p>如上图，我们在i&#x3D;j&#x3D;3的位置出现匹配失败，如果根据常规的next数组，此时next[3]&#x3D;1，我们回溯到j&#x3D;1的位置，显然j&#x3D;1与i&#x3D;3的位置仍会匹配失败，这次失败，我们就会将j&#x3D;1处根据next数组再进行回溯。既然如此，我们为什么不在一开始就令next[3]&#x3D;next[1]&#x3D;0呢？</p><p>提到这里，很多人就可以想到KMP的优化思路，就是优化next数组，获得一个新的nextval数组。</p><p>这里说下我对nextval数组的理解，希望能帮助大家更好的理解。我对nextval数组的理解其实就是一个带前继的链表，这个表的前继里指向着串里字符的回溯数据位置，数据域里存放该位置字符。如果一个结点数据域里的字符与前继结点里的字符相等，则他的前继里所指向的最终位置应该是前一个结点的前继所指向的位置，如果前一个结点的前继所指向的位置里的数据域与前一个结点数据域里的值一样，则应该继续向前指向，直到前面数据里的值与后一个结点里的数据域值不一样，才算指到最终位置，而这个最终的位置，就是我们要回溯到的位置，也就是nextval数组里对应字符应回溯的位置。</p><p>根据上面所说，我们可以得到nextval数组的优化思路，先写出next数组，然后判断匹配失败j处的字符是否等于其next[j]里所指向回溯位置的字符，如果不相等，则其回溯位置，就是其求出的next数组所要回溯的位置，即nextval[j]&#x3D;next[j]；如果相等，则其回溯位置，应与其next数组里所指的回溯位置的字符的最终回溯位置相同。</p><p>这里我们可以写出nextval求解算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nextval[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span> ; j&lt;=T.length ; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(T.ch[next[j]] == T.ch[j])<span class="comment">//当前位置字符与回溯位置字符相等</span></span><br><span class="line">        nextval[j] = nextval[next[j]];<span class="comment">//nextval应等于回溯位置字符的nextval</span></span><br><span class="line">    <span class="keyword">else</span><span class="comment">//不等</span></span><br><span class="line">        nextval[j] = next[j];<span class="comment">//nextval就是next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/6617a74f68eb935713722379.png" alt="数据结构（三）——串——KMP优化练习题.png"><p>这里给出一道练习题，大家可以做一做加深理解，毕竟看的再多，不消化相当于没看。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）——进程与线程</title>
      <link href="/2024/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/04/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（二）——进程与线程"><a href="#操作系统（二）——进程与线程" class="headerlink" title="操作系统（二）——进程与线程"></a>操作系统（二）——进程与线程</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><h3 id="1-1-进程的概念"><a href="#1-1-进程的概念" class="headerlink" title="1.1 进程的概念"></a>1.1 进程的概念</h3><p>在多道程序环境下，允许多个程序并发执行，此时他们将失去封闭性，并具有间断性及不可再现性的特征。为此引入<font color=red><strong>进程(Process)</strong></font>的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性，这两个特性在第一章里已经讲过，有遗忘可以去第一章回顾一下）。</p><p>所以，我们可以提出进程的概念：<strong>进程是程序的一次执行过程</strong>。</p><p>这里我们提到一个容易被混淆的概念：程序与进程。在此，对两者进行一个区分。</p><p>​程序：是<font color=red><strong>静态的</strong></font>，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。</p><p>​进程：是<font color=red><strong>动态的</strong></font>，是程序的一次执行过程，同一个程序多次执行会对应多个进程，例如QQ程序被多次执行，就会显示多个QQ登录界面。</p><p>为了使参与并发执行的每个程序都能独立运行，必须为之配置一个专门的数据结构，称为<font color=red><strong>进程控制块(PCB)</strong></font>。所谓创建进行，就是创建进程的PCB；撤销进程，就是撤销进程的PCB。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。</p><p>由程序段、相关数据和PCB三部分构成了<font color=red><strong>进程实体(又称进程映像)</strong></font>。注意，<strong>进程实体状态反应了进程在某一时刻的状态</strong>，<strong>是静态的</strong>。</p><p>在引入进程实体的概念后，我们可以将传统操作系统中的进程定义为：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度（一个进程被调度，就是指操作系统决定让这个进程上CPU执行）的一个独立单位。</strong></p><p>注意，在传统定义里所说的系统资源指CPU、存储器和其他设备服务某个进程的”时间”，例如将CPU资源理解为CPU的时间片才准确。又因为进程是这些资源分配和调度的独立单位，即“时间片”分配的独立单位，这就决定了进程一定是一个动态的、过程性的概念。</p><h3 id="1-2-进程的组成"><a href="#1-2-进程的组成" class="headerlink" title="1.2 进程的组成"></a>1.2 进程的组成</h3><p>进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。它由三部分组成：进程控制块、程序段、数据段。其中最核心的是进程控制块（PCB）。</p><h4 id="1-2-1-进程控制块"><a href="#1-2-1-进程控制块" class="headerlink" title="1.2.1 进程控制块"></a>1.2.1 进程控制块</h4><p><font color=red><strong>进程控制块是进程实体的一部分，也是进程存在的唯一标志。</strong></font></p><p>当进程创建时，操作系统为它创建一个PCB，该结构之后便常驻于内存，任意时刻都可以存取，并在进程结束时删除。当进程执行期间，操作系统要记录各种相关信息，而这些信息都会被保存在PCB中，如下图所示。</p><img src="https://pic.imgdb.cn/item/6614dae668eb935713dd103e.png" alt="计算机操作系统（二）——进程与线程——PCB存储信息.png"><p>需要注意，当进程被创建时，操作系统会为该进程分配一个<font color=navy><strong>唯一的、不重复的</strong></font>身份证号——PID（进程ID）。</p><p>PCB中主要包括进程描述信息、进程控制和管理信息、资源分配清单和CPU相关信息。各部分具体描述如下展示：</p><img src="https://pic.imgdb.cn/item/6614dbd668eb935713de145d.png" alt="计算机操作系统（二）——进程与线程——PCB存储信息分类.png"><h4 id="1-2-2-程序段"><a href="#1-2-2-程序段" class="headerlink" title="1.2.2 程序段"></a>1.2.2 程序段</h4><p>程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可被多个进程共享，即多个进程可以运行同一个程序。</p><h4 id="1-2-3-数据段"><a href="#1-2-3-数据段" class="headerlink" title="1.2.3 数据段"></a>1.2.3 数据段</h4><p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p><h4 id="1-2-4-进程组成小结"><a href="#1-2-4-进程组成小结" class="headerlink" title="1.2.4 进程组成小结"></a>1.2.4 进程组成小结</h4><img src="https://pic.imgdb.cn/item/6614dfbb68eb935713e36739.png" alt="计算机操作系统（二）——进程与线程——进程的组成.png"><h4 id="1-2-5-补充拓展——程序的运行过程"><a href="#1-2-5-补充拓展——程序的运行过程" class="headerlink" title="1.2.5 补充拓展——程序的运行过程"></a>1.2.5 补充拓展——程序的运行过程</h4><p>程序员将写好的程序经过编译等一系列步骤，最后形成一个可执行文件，存放在硬盘里。若要执行这个程序，需要先将可执行文件从硬盘读到内存当中，并且操作系统会建立一个与之对应的进程。操作系统会建立PCB，并将可执行文件里的指令序列（程序段）读到内存当中，同时程序运行过程中产生的各种数据（数据段）也会保存到内存中。</p><img src="https://pic.imgdb.cn/item/6614df6b68eb935713e2f2c7.png" alt="计算机操作系统（二）——进程与线程——程序的运行.png"><h3 id="1-3-进程的特征"><a href="#1-3-进程的特征" class="headerlink" title="1.3 进程的特征"></a>1.3 进程的特征</h3><p>进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。程序是静态的，进程是动态的，进程的基本特征是对比单个程序的循序执行提出的。</p><img src="https://pic.imgdb.cn/item/6614dd7968eb935713dfbb7d.png" alt="计算机操作系统（二）——进程与线程——进程的特征.png"><h3 id="1-4-进程的概念、组成和特征总结"><a href="#1-4-进程的概念、组成和特征总结" class="headerlink" title="1.4 进程的概念、组成和特征总结"></a>1.4 进程的概念、组成和特征总结</h3><img src="https://pic.imgdb.cn/item/6614de0468eb935713e0a71d.png" alt="计算机操作系统（二）——进程与线程——进程的概念组成和特征的总结.png"><h3 id="1-5-进程的状态与转换"><a href="#1-5-进程的状态与转换" class="headerlink" title="1.5 进程的状态与转换"></a>1.5 进程的状态与转换</h3><h4 id="1-5-1-进程的状态与转换"><a href="#1-5-1-进程的状态与转换" class="headerlink" title="1.5.1 进程的状态与转换"></a>1.5.1 进程的状态与转换</h4><p>进程在其生命周期内，由于系统中各个进程之间的相互制约及系统的运行环境的变化，使得进程的状态也在不断地发生变化。通常进程有以下5种状态：</p><ol><li>创建态。进程正在被创建，尚未转到就绪态。</li><li>就绪态。进程获得了除CPU外的一切资源，一旦得到CPU，便可立即运行。系统中处于就绪态的进程可能有多个，通常将他们排成一个队列，称为就绪队列。</li><li>运行态。进程正在CPU上运行。</li><li>阻塞态。又称等待态，进程正在等待某一事件而暂停运行。系统通常将阻塞态的进程也排成一个队列，甚至根据阻塞原因不同，设置多个阻塞队列。</li><li>终止态。进程从系统中消失，可能是进程正常结束或其他原因退出运行。</li></ol><p>注意区分就绪态和阻塞态：就绪态说明进程已经准备好，只差CPU资源就可以运行。而阻塞态是进程在运行过程中，因缺少相关资源，而暂时无法运行。</p><p><strong>接下来，我们以一个实例来对五态进行具体介绍：</strong></p><p>首先，我们在运行可执行文件时，系统会为其建立一个PCB，并对其进行资源分配以及PCB初始化，这个阶段称为进程的创建态。当进程被创建以后，便进入就绪态，处于就绪态的进程已经可以运行，至于能不能运行，还需要看CPU有没有处于空闲态，如果CPU一直处于忙碌状态，则进程就停留在就绪态。</p><img src="https://pic.imgdb.cn/item/6614f47268eb935713067af6.png" alt="计算机操作系统（二）——进程与线程——创建态与就绪态.png"><p>当CPU处于空闲状态时，操作系统就会选择一个处于就绪态的进程，让它进CPU进行处理。此时进程就会从就绪态转变为运行态。处于运行态的进行就会执行程序指令。当进程的指令里存在系统调用指令时，例如请求打印机操作，系统会处理该指令，当打印机处于繁忙状态，这个时候进程就无法进行该系统调用指令，于是进程就进入阻塞态。</p><img src="https://pic.imgdb.cn/item/6614f62868eb9357130a51a0.png" alt="计算机操作系统（二）——进程与线程——运行态.png"><p>进入阻塞态的进程由于无法继续往下运行，于是操作系统就当前的进程放回内存中，并从内存中再次调取一个处于就绪态的进程上CPU进行处理。当一段时间以后，打印机完成当前操作处于空闲状态时，这个时候处于阻塞态的进程等待的事件发生了，于是该进程从阻塞态转为就绪态，拥有了再次上CPU运行的权利。</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240409160839988.png" alt="image-20240409160839988"></p><p>一个进程在运行完以后或执行系统终止以后，就会从运行态转变为终止态，操作系统就会让该进程下CPU，并回收内存空间等资源，最后还会回收该进程的PCB。</p><img src="https://pic.imgdb.cn/item/6614f89068eb9357130c939c.png" alt="计算机操作系统（二）——进程与线程——终止态.png"><p><strong>通过实例的演示讲解，我们接下来对进程的五态进行一个总结：</strong></p><img src="https://pic.imgdb.cn/item/6614f93d68eb9357130da56a.png" alt="计算机操作系统（二）——进程与线程——五态.png"><p><font color=fuchsia><strong>创建态 -&gt; 就绪态</strong></font>：系统完成创建进程的一些列工作，包括PCB建立，资源分配等。</p><p><font color=fuchsia><strong>就绪态 -&gt; 运行态</strong></font>：处于就绪态的进程被CPU调用以后，获得CPU资源，于是进程由就绪态转变为运行态。</p><p><font color=fuchsia><strong>运行态 -&gt; 就绪态</strong></font>：当进程在CPU上运行了很长时间，系统发现CPU分给其的时间片使用完以后，会迫使进程让出CPU，从运行态转变为就绪态，等待下次运行。如果在可剥夺的OS中，有更高优先级的进程就绪时（比如中断），也会迫使当前进程从运行态转变为就绪态。</p><p><font color=fuchsia><strong>运行态 -&gt; 阻塞态</strong></font>：进程请求某一事件发生时，该事件无法发生，于是就从运行态转变为阻塞态。</p><p><font color=fuchsia><strong>阻塞态 -&gt; 就绪态</strong></font>：当请求的事件发生以后，OS会让进程从阻塞态转变为就绪态。</p><p><font color=fuchsia><strong>运行态 -&gt; 终止态</strong></font>：当进程运行结束，或运行过程中遇到不可修复的错误以后，会从运行态转变为终止态。</p><p>进程的整个生命周期中，大部分时间处于运行态、就绪态和阻塞态，所以这三种状态也被称为进程三种基本状态。</p><img src="https://pic.imgdb.cn/item/6614f99c68eb9357130e48e0.png" alt="计算机操作系统（二）——进程与线程——五态及组织.png"><p>在进程PCB中，还会有一个变量来表示进程的当前状态，为了方便对同一个状态下的进程进行统一管理，OS会将各个进程的PCB组织起来。</p><h4 id="1-5-2-进程的组织方式"><a href="#1-5-2-进程的组织方式" class="headerlink" title="1.5.2 进程的组织方式"></a>1.5.2 进程的组织方式</h4><h5 id="1-5-2-1-链接方式"><a href="#1-5-2-1-链接方式" class="headerlink" title="1.5.2.1 链接方式"></a>1.5.2.1 链接方式</h5><p>OS使用链接方式进行进程的组织。会使用不同指针指向不同状态的进程，并把同状态的进程链接起来。通常还会把优先级高的进程放在队头。</p><img src="https://pic.imgdb.cn/item/6614f9f768eb9357130eeb83.png" alt="计算机操作系统（二）——进程与线程——链接方式.png"><h5 id="1-5-2-2-索引方式"><a href="#1-5-2-2-索引方式" class="headerlink" title="1.5.2.2 索引方式"></a>1.5.2.2 索引方式</h5><p>采用索引的组织方式，OS会给不同状态的进程建立索引表，然后索引表又会指向相同状态的PCB，具体模型如下图</p><img src="https://pic.imgdb.cn/item/6614fa1f68eb9357130f4969.png" alt="计算机操作系统（二）——进程与线程——索引方式.png"><h5 id="1-5-2-3-组织方式思维图"><a href="#1-5-2-3-组织方式思维图" class="headerlink" title="1.5.2.3 组织方式思维图"></a>1.5.2.3 组织方式思维图</h5><img src="https://pic.imgdb.cn/item/6614fa7d68eb9357130feae3.png" alt="计算机操作系统（二）——进程与线程——组织方式思维图.png"><h4 id="1-5-3-进程的状态与转换小结"><a href="#1-5-3-进程的状态与转换小结" class="headerlink" title="1.5.3 进程的状态与转换小结"></a>1.5.3 进程的状态与转换小结</h4><img src="https://pic.imgdb.cn/item/6614fac568eb935713105efa.png" alt="计算机操作系统（二）——进程与线程——进程状态与转换小结.png"><h3 id="1-6-进程的控制"><a href="#1-6-进程的控制" class="headerlink" title="1.6 进程的控制"></a>1.6 进程的控制</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p>简化理解：进程控制就是要实现进程状态转换。</p><p>进程控制的实现是通过<font color=red><strong>原语</strong></font>实现的，在第一章里我们说过，原语是一种特殊的程序，它的执行具有原子性。也就是说，这段程序的运行必须一气呵成，不可中断。</p><img src="https://pic.imgdb.cn/item/6615170968eb93571340510f.png" alt="计算机操作系统（二）——进程与线程——原语.png"><p>为什么进程控制的程序需要一气呵成呢？具体的原因可以参考下图，假设state&#x3D;2表示阻塞态，这时候PCB2等待的事件发生，则操作系统会将PCB2转变成就绪态，并将他放入就绪队列指针。这个时候会经历两步骤，第一步将PCB2的state设为1；第二步将PCB2从阻塞队列放到就绪队列。如果进程控制程序不一气呵成的话，在第一步后收到中断信号，那么PCB2的state&#x3D;1，但是它却被放在阻塞队列里，这个时候就出现错误堆放的问题。</p><p>所以，如果进程控制程序不能一气呵成，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。</p><img src="https://pic.imgdb.cn/item/6615195e68eb935713441cd2.png" alt="计算机操作系统（二）——进程与线程——进程控制使用原语的原因.png"><p>原语程序刚好能满足进程控制程序一气呵成的特点，所以进程控制程序采用原语设计。</p><p>那原语的原子性究竟是怎么实现的呢？这就牵扯到了关中断指令以及开中断指令。具体如下。</p><img src="https://pic.imgdb.cn/item/66151a1568eb935713453275.png" alt="计算机操作系统（二）——进程与线程——原子性.png"><p>如图是一段内核程序，在前面我们学过，每执行完一条指令时，程序都要判断有没有中断信号。如果在这里使用了关中断指令，这个时候内核程序执行时，就不会去判断有没有中断信号，而是会一直往下运行，直到运行完开中断指令以后，才会再次去判断中断信号。这就是原语的实现。</p><p>需要注意的是，关中断和开中断指令是特权指令，只能内核程序使用，而不能让每个用户都使用，如果每个人都能调用的话，会导致CPU运行一个的程序，直到运行完才会运行别人的程序，如果运行过程中出现等待事件等问题，则会出现CPU一直被占用的情况。</p><p>对于原语以及进程控制相关知识了解完以后，接下来我们就可以讨论进程控制相关的原语了。</p><h4 id="1-6-1-进程的创建相关原语"><a href="#1-6-1-进程的创建相关原语" class="headerlink" title="1.6.1 进程的创建相关原语"></a>1.6.1 进程的创建相关原语</h4><img src="https://pic.imgdb.cn/item/66151c2568eb93571348decf.png" alt="计算机操作系统（二）——进程与线程——进程创建原语.png"><h4 id="1-6-2-进程的终止相关原语"><a href="#1-6-2-进程的终止相关原语" class="headerlink" title="1.6.2 进程的终止相关原语"></a>1.6.2 进程的终止相关原语</h4><img src="https://pic.imgdb.cn/item/66151c5f68eb9357134944b1.png" alt="计算机操作系统（二）——进程与线程——进程终止原语.png"><h4 id="1-6-2-进程的阻塞和唤醒原语"><a href="#1-6-2-进程的阻塞和唤醒原语" class="headerlink" title="1.6.2 进程的阻塞和唤醒原语"></a>1.6.2 进程的阻塞和唤醒原语</h4><img src="https://pic.imgdb.cn/item/66151c8268eb935713498d81.png" alt="计算机操作系统（二）——进程与线程——进程阻塞与唤醒原语.png"><h4 id="1-6-3-进程的切换原语"><a href="#1-6-3-进程的切换原语" class="headerlink" title="1.6.3 进程的切换原语"></a>1.6.3 进程的切换原语</h4><img src="https://pic.imgdb.cn/item/66151cd468eb9357134a26a8.png" alt="计算机操作系统（二）——进程与线程——进程切换原语.png"><p>这里稍微讲解一下进程的运行环境。运行环境，顾名思义，就是进程在运行时，当前计算机所处的一种状态，包括当前寄存器的数值，数据的位置等等。在我们运行一个进程时，这个进程在运行过程中所产生的数据等信息都会存到相应的寄存器里，但是这些寄存器并不是只为这一个进程服务。如果这个时候需要执行另一个进程时，系统会将当前正在运行的进程的寄存器、数据等环境信息存入到当前进程的PCB里。然后清空当前环境，为另一个进程的运行提供资源。如果另一个进程运行结束以后，想切回原来的进程，这时候OS会从原进程的PCB里读取环境信息，并复原到该进程停止运行时所处的环境状态。</p><p>注意，保存环境信息和复原环境信息是保证进程并发执行的一个很关键的技术。</p><h4 id="1-6-4-进程控制的小结"><a href="#1-6-4-进程控制的小结" class="headerlink" title="1.6.4 进程控制的小结"></a>1.6.4 进程控制的小结</h4><img src="https://pic.imgdb.cn/item/66151e8668eb9357134d33b6.png" alt="计算机操作系统（二）——进程与线程——进程控制小结.png"><p>这部分有关进程控制的相关原语，我写的很简陋。这里大部分都是理解的东西，参考1.5.1走一遍进程的运行过程，不仅完全可以理解，还会绝对这里很简单，所以我就不多说了。毕竟别人塞到嘴里的不一定好吃，但自己吃到嘴里的一定是自己想吃的。</p><h3 id="1-7-进程的通信"><a href="#1-7-进程的通信" class="headerlink" title="1.7 进程的通信"></a>1.7 进程的通信</h3><p><font color=red><strong>进程通信</strong>（IPC），指进程之间的信息交换。</font></p><p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的<font color=red><strong>内存地址空间相互独立</strong></font>。</p><p>为了保证安全，<font color=red><strong>一个进程不能直接访问另一个进程的地址空间</strong></font>。</p><p>如果想实现两个进程间的通信，主要有以下三种方法：共享存储、消息传递、管道通信。</p><h4 id="1-7-1-共享存储"><a href="#1-7-1-共享存储" class="headerlink" title="1.7.1 共享存储"></a>1.7.1 共享存储</h4><p>进程可以创建一个可直接访问的共享存储空间，通过对这片共享空间进行读&#x2F;写操作可以实现进程之间的信息交换。</p><p>需要注意的是，一个存储空间可以被多个进程读写，如果多个进程同时读写会出现错误，所以在对共享空间进行读&#x2F;写操作时，需要使用同步互斥工具（如P操作、V操作，我们会在互斥一节介绍），避免同时读写的情况。</p><p>共享存储分为两种存储方式，一种基于数据结构的共享，一种基于存储区的共享，具体如下图：</p><img src="https://pic.imgdb.cn/item/6617d36568eb935713c817bb.png" alt="计算机操作系统（二）——进程与线程——共享存储.png"><p>另外，操作系统只提供进行共享存储的存储空间和同步互斥工具，而数据交换是由用户自己安排读&#x2F;写指令完成的。</p><p>还有，进程空间一般是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。</p><h4 id="1-7-2-消息传递"><a href="#1-7-2-消息传递" class="headerlink" title="1.7.2 消息传递"></a>1.7.2 消息传递</h4><img src="https://pic.imgdb.cn/item/6617d3ca68eb935713c8b694.png" alt="计算机操作系统（二）——进程与线程——消息传递.png"><p>在消息传递系统中，进程间的数据以格式化的消息为单位，进程通过操作系统提供的发送消息和接收消息两个原语进行数据交换。</p><p>消息传递有两种方式，一种是直接通信。发送进程直接将消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</p><img src="https://pic.imgdb.cn/item/6617d42768eb935713c937e0.png" alt="计算机操作系统（二）——进程与线程——消息传递（直接通信）.png"><p>第二种是间接通信方式，发送进程将消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为<strong>信箱</strong>。该通信方式广泛应用于计算机网络中。</p><img src="https://pic.imgdb.cn/item/6617d44f68eb935713c95883.png" alt="计算机操作系统（二）——进程与线程——消息传递（间接通信）.png"><h4 id="1-7-3-管道通信"><a href="#1-7-3-管道通信" class="headerlink" title="1.7.3 管道通信"></a>1.7.3 管道通信</h4><p>管道是一个特殊的共享文件，又称pipe文件，数据在管道中是先进先出的。（管道其实就是一个循环队列）</p><p>使用管道通信，只要管道不满，写进程就能向管道的一端写入数据；只要管道非空，读进程就能从管道的一端读出数据。</p><p>为了协调双方的通信，管道机制必须提供三方面的协调能力：</p><ol><li>互斥：指当一个进程对管道进行读&#x2F;写操作时，其他进程必须等待。</li><li>同步：管道写满以后，写进程会被阻塞，直到读进程读取数据以后才能将其唤醒；同理，管道读空，读进程会被阻塞，直到写进程写入数据以后才能读取。</li><li>双方要确定彼此的存在。</li></ol><img src="https://pic.imgdb.cn/item/6617d49868eb935713c98349.png" alt="计算机操作系统（二）——进程与线程——管道通信.png"><h4 id="1-7-4-进程小结"><a href="#1-7-4-进程小结" class="headerlink" title="1.7.4 进程小结"></a>1.7.4 进程小结</h4><img src="https://pic.imgdb.cn/item/6617d9b168eb935713d3b75a.png" alt="计算机操作系统（二）——进程与线程——进程通信小结.png"><p>注意，不论是哪一种进程通信方式，数据在被读进程读取以后，都会从中转空间里消失，不会被保留。</p><h3 id="1-8-线程和多线程模型"><a href="#1-8-线程和多线程模型" class="headerlink" title="1.8 线程和多线程模型"></a>1.8 线程和多线程模型</h3><h4 id="1-8-1-线程的基本概念"><a href="#1-8-1-线程的基本概念" class="headerlink" title="1.8.1 线程的基本概念"></a>1.8.1 线程的基本概念</h4><img src="https://pic.imgdb.cn/item/661e053c0ea9cb1403d41a0a.png" alt="计算机操作系统（二）——进程与线程——线程的概念.png"><p>引入进程的目的是更好地使用多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p><p>线程最直接的理解就是轻量级进程，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。</p><p>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。</p><img src="https://pic.imgdb.cn/item/661e06bf0ea9cb1403d8b211.png" alt="计算机操作系统（二）——进程与线程——线程的概念2.png"><p>引入线程以后，进程只作为除CPU之外的系统资源的分配单元。例如，打印架等外接设备，都是按照进程分配使用的。</p><h4 id="1-8-2-线程与进程的比较"><a href="#1-8-2-线程与进程的比较" class="headerlink" title="1.8.2 线程与进程的比较"></a>1.8.2 线程与进程的比较</h4><img src="https://pic.imgdb.cn/item/661e081f0ea9cb1403dbaecc.png" alt="计算机操作系统（二）——进程与线程——线程与进程的比较.png"><h4 id="1-8-3-线程的属性"><a href="#1-8-3-线程的属性" class="headerlink" title="1.8.3 线程的属性"></a>1.8.3 线程的属性</h4><img src="https://pic.imgdb.cn/item/661e09200ea9cb1403dd8b1a.png" alt="计算机操作系统（二）——进程与线程——线程的属性.png"><h4 id="1-8-4-线程的状态与转换"><a href="#1-8-4-线程的状态与转换" class="headerlink" title="1.8.4 线程的状态与转换"></a>1.8.4 线程的状态与转换</h4><img src="https://pic.imgdb.cn/item/661e14cc0ea9cb1403f2fa83.png" alt="计算机操作系统（二）——进程与线程——线程的状态与转换.png"><p>与进程一样，线程之间也存在着状态转换，而在考研中，通常比较关心就绪态、运行态和阻塞态三态之间的转换。</p><p>运行态 -&gt; 就绪态：线程被分配的时间用完了，就会下处理机进入就绪态。</p><p>就绪态 -&gt; 运行态：一个就绪态的线程如果被处理机选中，就会从就绪态进入运行态开始运行。</p><p>运行态 -&gt; 阻塞态：如果一个运行态的线程发出了请求，等待某事件完成，就会从运行态进入阻塞态。</p><p>阻塞态 -&gt; 就绪态：当等待的事件发生以后，就会从阻塞态回到就绪态。</p><h4 id="1-8-5-线程的组织与控制"><a href="#1-8-5-线程的组织与控制" class="headerlink" title="1.8.5 线程的组织与控制"></a>1.8.5 线程的组织与控制</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://pic.imgdb.cn/item/661e15cf0ea9cb1403f531ce.png" alt="计算机操作系统（二）——进程与线程——线程的组织与控制.png"></h4><p>同进程的控制管理一样，线程也有自己的控制管理块——TCB。TCB块里包含的内容在上图显示，这部分的东西和进程PCB的内容大相径庭，所以我就不多说，有问题可以看看往上翻看看进程的相关知识，也可以看看这个视频，不多，就6分钟：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=18&vd_source=7fb4b255ed876969a742738d7b84f461">线程的状态转换和组织控制</a></p><h4 id="1-8-6-线程的实现方式"><a href="#1-8-6-线程的实现方式" class="headerlink" title="1.8.6 线程的实现方式"></a>1.8.6 线程的实现方式</h4><p>线程的实现可以分为两类：用户级线程（ULT）和内核级线程（KLT）。内核级线程又称为内核支持的线程。</p><h5 id="1-8-6-1-用户级线程"><a href="#1-8-6-1-用户级线程" class="headerlink" title="1.8.6.1 用户级线程"></a>1.8.6.1 用户级线程</h5><p>早期的操作系统只支持进程，不支持线程。当时的“线程”是由线程库实现的。所以用户级线程其实就是在应用程序里，使用线程库，将进程设计成多线程程序。如下图：</p><img src="https://pic.imgdb.cn/item/661e16440ea9cb1403f600db.png" alt="计算机操作系统（二）——进程与线程——用户级线程.png"><p>用户级线程的相关操作（创建、管理等）都是在用户态完成，无需操作系统干预，在这种模式下，线程只能从用户视角观察到，而内核意识不到线程的存在，所以系统的调度仍然以进程为单位。</p><h5 id="1-8-6-2-内核级线程"><a href="#1-8-6-2-内核级线程" class="headerlink" title="1.8.6.2 内核级线程"></a>1.8.6.2 内核级线程</h5><p>随着技术发展，越来越多的操作系统开始支持线程的开发。而在内核下执行的线程，就是内核级线程。内核级线程内容如下：</p><img src="https://pic.imgdb.cn/item/661e16820ea9cb1403f66c33.png" alt="计算机操作系统（二）——进程与线程——内核级线程.png"><p>内核级线程在内核的支持下运行，线程管理的所有工作也是在内核空间内实现的。操作系统为每个内核级线程设置一个线程控制块TCB，内核根据该控制块感知某线程的存在。</p><p>在内核级线程中，线程可以从操作系统观察到，所以系统的调度以线程为单位。</p><h4 id="1-8-7-多线程模型"><a href="#1-8-7-多线程模型" class="headerlink" title="1.8.7 多线程模型"></a>1.8.7 多线程模型</h4><p>用户级线程和内核级线程各有各的优缺点，所以为了综合两种模式，有的系统可以同时支持用户级线程和内核级线程，进而产生了三种不同的多线程模型——一对一模型、多对一模型、多对多模型。</p><h5 id="1-8-7-1-一对一模型"><a href="#1-8-7-1-一对一模型" class="headerlink" title="1.8.7.1 一对一模型"></a>1.8.7.1 一对一模型</h5><img src="https://pic.imgdb.cn/item/661e174c0ea9cb1403f7d6a6.png" alt="计算机操作系统（二）——进程与线程——一对一.png"><h5 id="1-8-7-2-多对一模型"><a href="#1-8-7-2-多对一模型" class="headerlink" title="1.8.7.2 多对一模型"></a>1.8.7.2 多对一模型</h5><img src="https://pic.imgdb.cn/item/661e17a10ea9cb1403f87a43.png" alt="计算机操作系统（二）——进程与线程——多对一.png"><h5 id="1-8-7-3-多对多模型"><a href="#1-8-7-3-多对多模型" class="headerlink" title="1.8.7.3 多对多模型"></a>1.8.7.3 多对多模型</h5><img src="https://pic.imgdb.cn/item/661e17f60ea9cb1403f935cc.png" alt="计算机操作系统（二）——进程与线程——多对多.png"><h2 id="2-CPU调度"><a href="#2-CPU调度" class="headerlink" title="2. CPU调度"></a>2. CPU调度</h2><h3 id="2-1-调度的基本概念"><a href="#2-1-调度的基本概念" class="headerlink" title="2.1 调度的基本概念"></a>2.1 调度的基本概念</h3><img src="https://pic.imgdb.cn/item/661f2d170ea9cb1403a8e241.png" alt="计算机操作系统（二）——进程与线程——调度的基本概念.png"><h3 id="2-2-调度的层次"><a href="#2-2-调度的层次" class="headerlink" title="2.2 调度的层次"></a>2.2 调度的层次</h3><p>一个作业从提交开始直到完成，往往要经历三级调度：高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）。</p><h4 id="2-2-1-高级调度（作业调度）"><a href="#2-2-1-高级调度（作业调度）" class="headerlink" title="2.2.1 高级调度（作业调度）"></a>2.2.1 高级调度（作业调度）</h4><img src="https://pic.imgdb.cn/item/661f2dd40ea9cb1403ac4d8b.png" alt="计算机操作系统（二）——进程与线程——高级调度.png"><h4 id="2-2-2-中级调度（内存调度）"><a href="#2-2-2-中级调度（内存调度）" class="headerlink" title="2.2.2 中级调度（内存调度）"></a>2.2.2 中级调度（内存调度）</h4><img src="https://pic.imgdb.cn/item/661f2e920ea9cb1403af75e7.png"><h4 id="2-2-3-低级调度（进程调度）"><a href="#2-2-3-低级调度（进程调度）" class="headerlink" title="2.2.3 低级调度（进程调度）"></a>2.2.3 低级调度（进程调度）</h4><img src="https://pic.imgdb.cn/item/661f2eb60ea9cb1403b00e73.png" alt="计算机操作系统（二）——进程与线程——低级调度.png"><h4 id="2-2-4-三级调度的联系与对比"><a href="#2-2-4-三级调度的联系与对比" class="headerlink" title="2.2.4 三级调度的联系与对比"></a>2.2.4 三级调度的联系与对比</h4><img src="https://pic.imgdb.cn/item/661f2f490ea9cb1403b28df8.png" alt="计算机操作系统（二）——进程与线程——三级调度联系对比.png"><h4 id="2-2-5-小结"><a href="#2-2-5-小结" class="headerlink" title="2.2.5 小结"></a>2.2.5 小结</h4><img src="https://pic.imgdb.cn/item/661f2f880ea9cb1403b39733.png" alt="计算机操作系统（二）——进程与线程——小结.png"><h4 id="2-2-6-补充——进程的挂起态与七状态模型"><a href="#2-2-6-补充——进程的挂起态与七状态模型" class="headerlink" title="2.2.6 补充——进程的挂起态与七状态模型"></a>2.2.6 补充——进程的挂起态与七状态模型</h4><img src="https://pic.imgdb.cn/item/661f2fd90ea9cb1403b4db45.png" alt="计算机操作系统（二）——进程与线程——七状态模型.png"><p>在进程一块有介绍过进行的五状态模型，但是通过这一节对调度层次的学习，我们可以将五状态模型拓展到七状态模型，即加上就绪挂起态和阻塞挂起态。</p><p>一个处于就绪态的进程，如果此时系统负载比较高，内存空间不够用，那系统就会将就绪态的进程调到外存里，此时处于就绪态的进程就是就绪挂起态。直到内存空间有空闲或进程需要被执行，这时处于就绪挂起态的进程才会被激活，相应的数据也会被移入内存中，这样处于就绪挂起的进程就回到了就绪态。</p><p>同理，处于阻塞态的进程也会因为负责问题进入阻塞挂起态，同样被激活以后回到阻塞态。但注意，有的系统处于阻塞挂起态的进程，等待的事件触发后，会进入就绪挂起态，之后被调入内存时，直接进入就绪态。</p><p>此外，处于运行态的进程，在下处理机时，有可能会直接进入就绪挂起态。而进程在创建态完成以后，也可能会直接进入就绪挂起态。</p><p>上图就是我们所说的七状态模型。</p><h3 id="2-3-调度的实现"><a href="#2-3-调度的实现" class="headerlink" title="2.3 调度的实现"></a>2.3 调度的实现</h3><h4 id="2-3-1-调度的时机"><a href="#2-3-1-调度的时机" class="headerlink" title="2.3.1 调度的时机"></a>2.3.1 调度的时机</h4><img src="https://pic.imgdb.cn/item/661f33500ea9cb1403c22777.png" alt="计算机操作系统（二）——进程与线程——进程调度的时机.png"><p>进程的调度与切换时间如上图所述，大部分的知识，我们都可以理解，但在不能进行进程调度与切换的部分，第二种情况稍微难理解一点，所我们详细说一下。</p><img src="https://pic.imgdb.cn/item/661f34ea0ea9cb1403c884f2.png" alt="计算机操作系统（二）——进程与线程——内核临界区.png"><p>首先说一下临界资源的概念，临界资源就是一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。而临界区，就是访问临界资源的那段代码。</p><p>而操作系统内核程序临界区，就是访问某种内核数据结构，比如进程的就绪队列（这里不解释，我们应该也知道，内核的东西多牵扯到硬件电路，一般都会禁止进程切换与中断实行）。在1.6进程的控制部分，我们说过，就绪队列里的进程指令段在执行时，是不能被打断的，否则会导致操作系统中的某些关键数据结构信息不统一，会影响操作系统的管理。</p><p>所以，在进程访问就绪队列前，会先将就绪队列上锁，只有等待进程访问结束以后，才会将就绪队列解锁。如果未解锁就进行了进程调度，那其他的进程也需要访问就绪队列，此时就绪队列上锁，导致其他进程也访问失败，这就会使调度无法进行。而内核程序临界区的临界资源不尽快释放会影响到OS的其它管理工作。所以<font color=red><strong>在访问内核程序临界区期间不能进行调度与切换</strong></font>。</p><p>但是，如果访问的是普通临界区能不能进行调度与切换呢？如我们上图中12年的考题，进程处于临界区不能进行调度与切换是错误的。原因在于，<font color=red><strong>访问普通临界区时是可以进行调度与切换的</strong></font>。</p><p>例如，打印机也是一种临界资源，在使用进程访问时，进程一直处于临界区内，临界资源上锁。但打印机是慢速设备，这个时候不进行调度的话，会导致CPU一直处于空闲状态，所以需要通过进程调度使CPU忙起来，由此可以看出，在访问普通临界资源时，要尽可能的使用调度与切换。</p><h4 id="2-3-2-调度的方式"><a href="#2-3-2-调度的方式" class="headerlink" title="2.3.2 调度的方式"></a>2.3.2 调度的方式</h4><p>有的系统，只允许进程主动放弃处理机；而有的系统，进程可以主动放弃处理机，当有更紧急的任务要处理时，也会强行剥夺处理机。基于这两种进程放弃的方式，衍生出了两种进程调度的方式，如下：</p><img src="https://pic.imgdb.cn/item/661f39400ea9cb1403da1e9e.png" alt="计算机操作系统（二）——进程与线程——进程调度的方式.png"><h4 id="2-3-3-进程切换的过程"><a href="#2-3-3-进程切换的过程" class="headerlink" title="2.3.3 进程切换的过程"></a>2.3.3 进程切换的过程</h4><img src="https://pic.imgdb.cn/item/661f39b10ea9cb1403dbdc88.png" alt="计算机操作系统（二）——进程与线程——进程的切换过程.png"><h4 id="2-3-4-调度程序（调度器）"><a href="#2-3-4-调度程序（调度器）" class="headerlink" title="2.3.4 调度程序（调度器）"></a>2.3.4 调度程序（调度器）</h4><p>用于调度和分派CPU的组件称为调度程序。</p><p>调度程序主要负责执行让谁运行，运行多长时间的功能。</p><p>一般在创建新进程、进程退出、运行进程阻塞、I&#x2F;O中断发生这四个情况下会触发”调度程序。”</p><img src="https://pic.imgdb.cn/item/661f52f70ea9cb14034d4a87.png" alt="计算机操作系统（二）——进程与线程——调度程序.png"><p>注意，在不支持内核级线程的操作系统里，调度的单位是进程。但是在支持内核级线程的操作系统里，调度程序的处理对象是内核线程，而非进程。</p><img src="https://pic.imgdb.cn/item/661f53450ea9cb14034ed311.png" alt="计算机操作系统（二）——进程与线程——调度对象.png"><h4 id="2-3-5-闲逛进程"><a href="#2-3-5-闲逛进程" class="headerlink" title="2.3.5 闲逛进程"></a>2.3.5 闲逛进程</h4><p>在没有其他就绪进程时，系统会让闲逛进程上CPU运行，所以CPU每时每刻都是处于运行中的。</p><img src="https://pic.imgdb.cn/item/661f52b20ea9cb14034bdf96.png" alt="计算机操作系统（二）——进程与线程——闲逛程序.png"><h3 id="2-4-调度算法"><a href="#2-4-调度算法" class="headerlink" title="2.4 调度算法"></a>2.4 调度算法</h3><h4 id="2-4-1-调度算法的评价指标（调度的目标）"><a href="#2-4-1-调度算法的评价指标（调度的目标）" class="headerlink" title="2.4.1 调度算法的评价指标（调度的目标）"></a>2.4.1 调度算法的评价指标（调度的目标）</h4><h5 id="2-4-1-1-CPU利用率"><a href="#2-4-1-1-CPU利用率" class="headerlink" title="2.4.1.1 CPU利用率"></a>2.4.1.1 CPU利用率</h5><img src="https://pic.imgdb.cn/item/6620b8d00ea9cb14032f8478.png" alt="计算机操作系统（二）——进程与线程——CPU利用率.png"><h5 id="2-4-1-2-系统吞吐量"><a href="#2-4-1-2-系统吞吐量" class="headerlink" title="2.4.1.2 系统吞吐量"></a>2.4.1.2 系统吞吐量</h5><img src="https://pic.imgdb.cn/item/6620b90e0ea9cb140331dbac.png" alt="计算机操作系统（二）——进程与线程——系统吞吐量.png"><h5 id="2-4-1-3-周转时间及带权周转时间"><a href="#2-4-1-3-周转时间及带权周转时间" class="headerlink" title="2.4.1.3 周转时间及带权周转时间"></a>2.4.1.3 周转时间及带权周转时间</h5><img src="https://pic.imgdb.cn/item/6620b93f0ea9cb140333bc30.png" alt="计算机操作系统（二）——进程与线程——周转时间.png"><p>周转时间这里对思考部分介绍说一下，如果两个作业周转时间相同，但是其中一个运行时间短，一个运行时间长，会给用户带来不同的感受。比如两个程序的周转时间都是11分钟，而其中一个程序只需运行1分钟，但需要等待10分钟，这对用户来说肯定是不乐意的；相反另一个程序运行需要10分钟，等待只要1分钟，这种情况下用户还是比较乐意的。所以，调度算法的实施，其实就是对等待时间的调度。</p><img src="https://pic.imgdb.cn/item/6620bac40ea9cb14034217ff.png" alt="计算机操作系统（二）——进程与线程——周转时间2.png"><h5 id="2-4-1-4-等待时间"><a href="#2-4-1-4-等待时间" class="headerlink" title="2.4.1.4 等待时间"></a>2.4.1.4 等待时间</h5><img src="https://pic.imgdb.cn/item/6620bb860ea9cb1403490f82.png" alt="计算机操作系统（二）——进程与线程——等待时间.png"><p>这里注意一点，等待时间是等进程建立后等待被服务的时间之和，但是等待I&#x2F;O完成的期间是被I&#x2F;O服务的，所以等待I&#x2F;O完成的时间不能算作等待被服务的时间。</p><h5 id="2-4-1-5-响应时间"><a href="#2-4-1-5-响应时间" class="headerlink" title="2.4.1.5 响应时间"></a>2.4.1.5 响应时间</h5><p>响应时间：指从用户提交请求到系统首次产生响应所用的时间。</p><p>从用户角度来看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p><h5 id="2-4-1-6-调度目标的小结"><a href="#2-4-1-6-调度目标的小结" class="headerlink" title="2.4.1.6 调度目标的小结"></a>2.4.1.6 调度目标的小结</h5><img src="https://pic.imgdb.cn/item/6620bc540ea9cb1403504f2a.png" alt="计算机操作系统（二）——进程与线程——调度性能小结.png"><h4 id="2-4-2-调度的算法"><a href="#2-4-2-调度的算法" class="headerlink" title="2.4.2 调度的算法"></a>2.4.2 调度的算法</h4><h5 id="2-4-2-1-先来先服务（FCFS）"><a href="#2-4-2-1-先来先服务（FCFS）" class="headerlink" title="2.4.2.1 先来先服务（FCFS）"></a>2.4.2.1 先来先服务（FCFS）</h5><p>先来先服务算法就是按照作业&#x2F;进程到达的先后顺序进行服务，先来的进程先服务，后到的进程要等待前一个进程的结束，才可以被服务。</p><p>以下是FCFS的相关知识点：</p><img src="https://pic.imgdb.cn/item/6620bd1e0ea9cb140357b501.png" alt="计算机操作系统（二）——进程与线程——FCFS.png"><p>接下里我们举个例子来演示一下FCFS的调度实现过程：</p><img src="https://pic.imgdb.cn/item/662101130ea9cb140342640f.png" alt="计算机操作系统（二）——进程与线程——FCFS例子.png"><p>如上图，是有关FCFS的调度实现及相关指标的求解，从求解的数据可以看到，P3的带权周转时间很大，这意味着P3有大部分时间都处在等待之中，所以我们可以验证出前一张有关FCFS基础知识的图里，对其缺点的描述，对短作业的运行是非常不利的。但是这种执行算法非常简单，且每个作业&#x2F;进程都会执行到，所以它不存在饥饿问题。</p><p>这里还有一点要注意，就是等待时间的求解，这里使用周转时间-运行时间，对于这题是可以这么写的，但这个公式并不是一成不变的，对于有I&#x2F;O操作的进程，因为I&#x2F;O操作过程也是在服务进程，所以还要减去I&#x2F;O操作的时间。这时，等待时间&#x3D;周转时间-运行时间-I&#x2F;O操作时间。</p><h5 id="2-4-2-2-短作业优先（SJF）"><a href="#2-4-2-2-短作业优先（SJF）" class="headerlink" title="2.4.2.2 短作业优先（SJF）"></a>2.4.2.2 短作业优先（SJF）</h5><p>短作业优先算法：最短的作业&#x2F;进程优先得到服务。</p><img src="https://pic.imgdb.cn/item/6620c1260ea9cb14037cf9a5.png" alt="计算机操作系统（二）——进程与线程——SJF.png"><p>在短作业优先算法里，一般是非抢占式的算法（考研一般默认非抢占），但也有抢占的版本，接下来以实例的方式分别介绍两个版本。</p><p>首先，非抢占式：</p><img src="https://pic.imgdb.cn/item/662102160ea9cb1403440c9b.png" alt="计算机操作系统（二）——进程与线程——非抢占式.png"><p>如上图，是非抢占式的短作业优先算法，可以看到，相比于FCFS来说，SJF算法的各项指标都降低了许多，这对用户来说，体验效果好了许多。</p><p>接下来看一下抢占式算法：</p><img src="https://pic.imgdb.cn/item/662103920ea9cb14034679d6.png" alt="计算机操作系统（二）——进程与线程——抢占式.png"><p>抢占式短作业优先算法的过程如上，通过对各项指标的计算，我们可以发现，对比非抢占式的短作业优先算法来说，抢占式的指标更低。</p><p>通过以上对抢占式和非抢占式的探究，可以发现一点，不论是哪一种，如果有源源不断的短进程进来，那长进程就永远不会处理，这就导致长进程会出现饥饿甚至饿死的情况。</p><p>另外，基于这两种情况，为了应对考试，需要对短作业优先算法做一个如下细节补充：</p><img src="https://pic.imgdb.cn/item/662104260ea9cb1403478e3c.png" alt="计算机操作系统（二）——进程与线程——短作业优先细节补充.png"><h5 id="2-4-2-3-高响应比优先调度算法"><a href="#2-4-2-3-高响应比优先调度算法" class="headerlink" title="2.4.2.3 高响应比优先调度算法"></a>2.4.2.3 高响应比优先调度算法</h5><p>首先，我们对之前说的FCFS和SJF算法进行一个思考。</p><p>FCFS算法是在每次调度的时候，它的工作本质是选择一个等待时间最长的作业（进程）为其服务（这里可会有人不懂为什么是选择等待时间最长的作业，因为作业分先来后来，而先来的作业已经处于等待，后来的作业此时可能还未创建，即使创建了，他由于来的时间比较晚，相较于先来的作用，他的等待时间也没有前面的长，这里的等待时间是从作业开始被创建计算的）。但是没有考虑到作用的运行时间，导致了对短作业不友好的问题。</p><p>SIF算是选择一个执行时间最短的作业为其服务。但是又不完全考虑各个作用的等待时间，因此导致了对长作业不友好的问题。</p><p>为此，有人设计了一个综合两种算法的全新调度算法——高响比优先算法。</p><img src="https://pic.imgdb.cn/item/662107070ea9cb14034cb5c7.png" alt="计算机操作系统（二）——进程与线程——高响应比优先.png"><p>高响应比优先算法在每次调度时先计算各个作业的响应比，选择响应比最高的作业&#x2F;进程为其服务。</p><p>高响应比优先算法没有抢占式的算法，因此只有当前运行的作用&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比。</p><p>接下来，仍以一个例子加深理解：</p><img src="https://pic.imgdb.cn/item/6621085b0ea9cb14034f2031.png" alt="计算机操作系统（二）——进程与线程——高响应比优先例子.png"><h5 id="2-4-2-4-对FCFS-SJF-高响应比优先的小结"><a href="#2-4-2-4-对FCFS-SJF-高响应比优先的小结" class="headerlink" title="2.4.2.4 对FCFS&#x2F;SJF&#x2F;高响应比优先的小结"></a>2.4.2.4 对FCFS&#x2F;SJF&#x2F;高响应比优先的小结</h5><p>这三种调度算法主要关心对用户的公平性、平均周转、评价等待时间等评价系统整体性能的指标，忽略了响应时间，也不区分紧急程度，交互性很糟，因此这三种算法一般适合用于早期的批处理系统。接下来，我们要介绍适合用于交互式系统的调度算法。</p><img src="https://pic.imgdb.cn/item/662108b00ea9cb14034fb118.png" alt="计算机操作系统（二）——进程与线程——调度的小结1.png"><h5 id="2-4-2-5-时间片轮转调度算法（RR）"><a href="#2-4-2-5-时间片轮转调度算法（RR）" class="headerlink" title="2.4.2.5 时间片轮转调度算法（RR）"></a>2.4.2.5 时间片轮转调度算法（RR）</h5><img src="https://pic.imgdb.cn/item/66210b0f0ea9cb140354a587.png" alt="计算机操作系统（二）——进程与线程——时间片轮转算法.png"><p>时间片轮转调度算法就是按照各进程到就绪队列的顺序，让各个进程执行一个时间片，若进程未在一个时间片内执行结束，则剥夺执行，将进程重新放到就绪队列队尾重新排队。</p><p>这里仍然举例演示，但是我们取两个时间片大小来演示，在演示过程中可以思考一下，时间片大小有什么影响。</p><p>时间片为2时：</p><img src="https://pic.imgdb.cn/item/66210bce0ea9cb1403566af6.png" alt="计算机操作系统（二）——进程与线程——时间片大小为2.png"><p>时间片为5时：</p><img src="https://pic.imgdb.cn/item/66210bee0ea9cb140356b44f.png" alt="计算机操作系统（二）——进程与线程——时间片大小为5.png"><p>通过两种演示，我们可以比较一下，得出下图的结论：</p><img src="https://pic.imgdb.cn/item/66210c080ea9cb140356e6ef.png" alt="计算机操作系统（二）——进程与线程——时间片比较.png"><p>一般来说，设计时间片时，要让切换进程的开销占比不超过1%。</p><h5 id="2-4-2-6-优先级调度算法"><a href="#2-4-2-6-优先级调度算法" class="headerlink" title="2.4.2.6 优先级调度算法"></a>2.4.2.6 优先级调度算法</h5><img src="https://pic.imgdb.cn/item/66210c9a0ea9cb140357f584.png" alt="计算机操作系统（二）——进程与线程——优先级调度算法.png"><p>优先级调度算法就是在调度时，选择优先级最高的作业&#x2F;进程。</p><p>同样，以例子演示过程，再从例子里进行总结归纳。</p><img src="https://pic.imgdb.cn/item/66210d0f0ea9cb140358e220.png" alt="计算机操作系统（二）——进程与线程——优先级调度算法过程.png"><p>优先级调度算法知识补充：</p><img src="https://pic.imgdb.cn/item/66210d5a0ea9cb1403597e1a.png" alt="计算机操作系统（二）——进程与线程——优先级调度算法补充.png"><h5 id="2-4-2-7-多级反馈队列算法"><a href="#2-4-2-7-多级反馈队列算法" class="headerlink" title="2.4.2.7 多级反馈队列算法"></a>2.4.2.7 多级反馈队列算法</h5><p>从前面的学习可以知道：</p><p>FCFS算法的优点是公平。</p><p>SJF算法的优点是能尽快处理完短作业。</p><p>时间片轮转调度算法可以让各个进程得到及时响应。</p><p>优先级调度算法可以灵活地调整各种进程被服务的机会。</p><p>这里，我们对各个算法进行折中权衡，可以综合出一个新的集合各种算法优点的全新算法——多级反馈队列调度算法。</p><img src="https://pic.imgdb.cn/item/66210e4c0ea9cb14035b9184.png" alt="计算机操作系统（二）——进程与线程——多级反馈队列.png"><p>多级反馈队列的算法规则如上图，如果没有理解的话可以参考下面的示例，不过这个算法我更推荐看下视频动态过程，我把讲解链接贴出来（大概30~35分钟）：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=24&vd_source=7fb4b255ed876969a742738d7b84f461">调度算法</a>。</p><img src="https://pic.imgdb.cn/item/66210f420ea9cb14035d7347.png" alt="计算机操作系统（二）——进程与线程——多级反馈队列过程.png"><h5 id="2-4-2-8-交互式调度总结"><a href="#2-4-2-8-交互式调度总结" class="headerlink" title="2.4.2.8 交互式调度总结"></a>2.4.2.8 交互式调度总结</h5><p>这里对几种适合交互式的调度算法进行一下总结。</p><img src="https://pic.imgdb.cn/item/66210f6c0ea9cb14035dd06d.png" alt="计算机操作系统（二）——进程与线程——交互式总结.png"><h5 id="2-4-2-9-多级队列调度算法"><a href="#2-4-2-9-多级队列调度算法" class="headerlink" title="2.4.2.9 多级队列调度算法"></a>2.4.2.9 多级队列调度算法</h5><p>多级队列调度就是系统根据进程类型设置队列，一个队列里的进程全是同一类型的。队列之间会采取调度算法，队列内部也会采取调度算法。</p><img src="https://pic.imgdb.cn/item/66210fe10ea9cb14035ed825.png" alt="计算机操作系统（二）——进程与线程——多级队列调度式算法.png"><p>队列间的调度算法可以采用固定优先级或时间片划分。但是固定优先级会出现高优先级的队列一直有进程，导致低优先级的队列无法执行。</p><p>队列里面可以采用不同的调度策略，如RR、FCFS等。</p><h2 id="3-同步与互斥"><a href="#3-同步与互斥" class="headerlink" title="3. 同步与互斥"></a>3. 同步与互斥</h2><h3 id="3-1-同步与互斥的基本概念"><a href="#3-1-同步与互斥的基本概念" class="headerlink" title="3.1 同步与互斥的基本概念"></a>3.1 同步与互斥的基本概念</h3><h4 id="3-1-1-同步的基本概念"><a href="#3-1-1-同步的基本概念" class="headerlink" title="3.1.1 同步的基本概念"></a>3.1.1 同步的基本概念</h4><img src="https://pic.imgdb.cn/item/662867040ea9cb14033b533a.png" alt="计算机操作系统（二）——进程与线程——同步的基本概念.png"><h4 id="3-1-2-互斥的基本概念"><a href="#3-1-2-互斥的基本概念" class="headerlink" title="3.1.2 互斥的基本概念"></a>3.1.2 互斥的基本概念</h4><img src="https://pic.imgdb.cn/item/6628677b0ea9cb14033c0b69.png" alt="计算机操作系统（二）——进程与线程——互斥的基本概念.png"><p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可将临界资源的访问过程分成4个部分，如下图：</p><img src="https://pic.imgdb.cn/item/662867b90ea9cb14033ea814.png" alt="计算机操作系统（二）——进程与线程——互斥分类.png"><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）。</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><p>下面小结一下：</p><img src="https://pic.imgdb.cn/item/662869db0ea9cb140341f42b.png" alt="计算机操作系统（二）——进程与线程——互斥与同步概念小结.png"><h3 id="3-2-进程互斥的软件实现方法"><a href="#3-2-进程互斥的软件实现方法" class="headerlink" title="3.2 进程互斥的软件实现方法"></a>3.2 进程互斥的软件实现方法</h3><p>首先设想一下，如果没有互斥会怎么样，假设A、B两人打印报告，A的申请打印进程先上打印机运行，B的申请在等待中。如果A的进程未结束，但因时间片到了，会切换B进程，而没有互斥的存在，打印机会开始打印B的报告，待B的进程时间片到了以后，又会切换回A。这样会导致两人的报告混合在一起，这显然不是我们想要的。所以，就需要设置互斥，只允许一个进程占用打印机，若未完成任务，即使时间片到了，另一个进程也无法访问临界资源。</p><p>进程互斥软件实现思想：要在进入区设置并检查一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p><p>进程互斥软件实现的方法有四种：单标志法、双标志先检查法、双标志后检查法、Peterson算法。</p><h4 id="3-2-1-单标志法"><a href="#3-2-1-单标志法" class="headerlink" title="3.2.1 单标志法"></a>3.2.1 单标志法</h4><img src="https://pic.imgdb.cn/item/66286b770ea9cb1403448382.png" alt="计算机操作系统（二）——进程与线程——单标志法.png"><p>单标志法设置了一个公用整型变量turn用来指示允许进入临界区的进程编号。如上图，turn初始化为0，此时若P1先上处理机运行，则会一直卡在while循环处，直到P1时间片用完，发生调度，此时P0上进程，不满足while循环条件，可以跳过while卡死循环，从而访问临界区资源。当P0时间片到了，即使切换为P1，因为P0未执行完，此时P1还会卡在while循环处，无法进入临界区。当P0的访问完临界区，会把turn设置为1，此时P1就可以上临界区了。</p><p>这个算法可以实现各个进程对临界区的互斥访问，但也存在一个致命的问题，就是每个进程只能轮流进入临界区。如果在进程的最后，表示了谦让的动作，即让对方访问临界区，但是对方没有访问临界区的话，下次即使自己想使用临界区资源，也无法使用。因此，<font color=red><strong>单标志法存在的主要问题是，违背了“空闲让进”原则。</strong></font></p><h4 id="3-2-2-双标志先检查法"><a href="#3-2-2-双标志先检查法" class="headerlink" title="3.2.2 双标志先检查法"></a>3.2.2 双标志先检查法</h4><img src="https://pic.imgdb.cn/item/66286be30ea9cb1403452418.png" alt="计算机操作系统（二）——进程与线程——双标志先检查法.png"><p>双标志检查法设置了布尔型数组，用来表示各个进程想进入临界区的意愿。如上图，设置了一个flag[2]数组来分别表示P0，P1想进入临界区的意愿。在每个进程想访问临界区资源前，先检查一下别的进程想不想访问，如果别的进程想访问，自己就先等待。</p><p>但是这样设计的算法也存在问题，如上图，在并发环境的运行下，若P0先执行1，发现flag[1]是false，于是P0就会进入下一步，但是在进入下一步前，受调度影响，切换到P1进程，P1执行5，发现flag[0]是false，于是P1也会进入下一步，此时切换到P0，P0将flag[0]改为true，再次切换到P1，P1将flag[1]也改为true，此时我们会发现，flag[0]&#x3D;flag[1]&#x3D;1，两边在接下来的调度中都会进入临界区，访问临界区资源。</p><p>所以，<font color=red><strong>双标志先检查法存在的主要问题是，违反“忙则等待”的原则。</strong></font>原因是由于检查和上锁不是一气呵成的（即检查对面意愿和表达自己意愿不是一步到位的）。</p><h4 id="3-2-3-双标志后检查法"><a href="#3-2-3-双标志后检查法" class="headerlink" title="3.2.3 双标志后检查法"></a>3.2.3 双标志后检查法</h4><img src="https://pic.imgdb.cn/item/66286bf40ea9cb1403453f47.png" alt="计算机操作系统（二）——进程与线程——双标志后检查法.png"><p>双标志后检查法是双标志先检查法的改变，这里先进行自己的意愿表达，然后才去检查别人的意愿。如上图，一个进程若想访问临界资源，会先将自己的意愿数组改为1，然后才去检查别的进程是否想访问临界资源。</p><p>在这算法之后，可以解决忙则等待的问题，但也产生了别的问题。假设一下，在并行的环境中，P0先执行1，然后P1执行5，紧接着切换到P0执行2时发现P1是true，此时P0卡在while循环等待P1。而切换到P1时，P1也发现P0是true，此时P1也卡在while循环等待P0。出现了每一个进程都进不了临界区的情况，所以，<font color=red><strong>双标志后检查法违背了空闲让进和有限等待的原则</strong></font>。</p><h4 id="3-2-4-Peterson算法"><a href="#3-2-4-Peterson算法" class="headerlink" title="3.2.4 Peterson算法"></a>3.2.4 Peterson算法</h4><img src="https://pic.imgdb.cn/item/6628757b0ea9cb140353b36e.png" alt="计算机操作系统（二）——进程与线程——Peterson算法.png"><p>由于上面三种算法都有自己的问题，但也有自己优点，所以结合三种算法设计出了Peterson算法。Peterson算法结合双标志法和单标志法，设计了意愿变量和谦让变量。在每个进程开始前，先表达自己想要进入临界区的意愿，然后再表示如果别的进程也想访问临界资源，则自己谦让给别的进程。在这种算法下，最后一个谦让的进程会进入等待状态，先执行谦让的进程会进入临界区。</p><p>这种算法不论进程如何调度切换，都遵循了空闲让进、忙则等待、有限等待三个原则。但仍没有遵循让权等待的原则。</p><h4 id="3-2-5-进程互斥的软件实现方法小结"><a href="#3-2-5-进程互斥的软件实现方法小结" class="headerlink" title="3.2.5 进程互斥的软件实现方法小结"></a>3.2.5 进程互斥的软件实现方法小结</h4><img src="https://pic.imgdb.cn/item/662879610ea9cb14035be5aa.png" alt="计算机操作系统（二）——进程与线程——进程互斥的软件实现方法小结.png"><h3 id="3-3-进程互斥的硬件实现方法"><a href="#3-3-进程互斥的硬件实现方法" class="headerlink" title="3.3 进程互斥的硬件实现方法"></a>3.3 进程互斥的硬件实现方法</h3><p>进程互斥硬件实现方法有三种，分别是中断屏蔽方法、TestAndSet（TS指令&#x2F;TSL指令）指令和Swap指令（XCHG指令）。</p><h4 id="3-3-1-中断屏蔽指令"><a href="#3-3-1-中断屏蔽指令" class="headerlink" title="3.3.1 中断屏蔽指令"></a>3.3.1 中断屏蔽指令</h4><img src="https://pic.imgdb.cn/item/66289c730ea9cb14039bde21.png" alt="计算机操作系统（二）——进程与线程——中断屏蔽指令.png"><p>中断屏蔽指令和前面在1.6进程的控制里的进程的原语实现一样，采用关中断指令杜绝了进程被中断调度的情况，因此，进程一旦进入临界区除了执行结束，否则无法被中断踢出临界区。</p><p>这种方法很简单，但也存在问题，首先，这种方法并不适合用于多处理机，因为关中断指令只能在设置本机的进程无法被中断，而无法更改别的主机，当一个主机访问临界资源时，开始了关中断指令，而另一台主机没有关中断，它也可能来访问临界资源，这样就出现了同时访问临界资源的情况，违背了忙则等待的原则。</p><p>另外，关中断和开中断指令要求的权限等级很高，只适合用于操作系统内核进程，不适合用于用户进程。</p><h4 id="3-3-2-TestAndSet（TS指令-TSL指令）"><a href="#3-3-2-TestAndSet（TS指令-TSL指令）" class="headerlink" title="3.3.2 TestAndSet（TS指令&#x2F;TSL指令）"></a>3.3.2 TestAndSet（TS指令&#x2F;TSL指令）</h4><img src="https://pic.imgdb.cn/item/66289ce60ea9cb14039cac1a.png" alt="计算机操作系统（二）——进程与线程——TestAndSet指令.png"><p>实现互斥还可以借助硬件指令——TestAndSet指令，这条指令是原子操作。其功能是读出指定标志后将该标志设置为真。指令的C语言描述的逻辑如上图，注意，虽然上图是C语言描述，但这条指令是由硬件操作的，不是软件，上面描述的只是硬件操作的过程。</p><p>根据上面的逻辑描述，可以看到设置了一共享变量lock，TestAndSet指令就是将该变量的值赋值给old变量，然后返还old变量的值。这里可能不大好理解，可以联系右边互斥逻辑一起看。可以看到，while循环里不停的判断TestAndSet指令返回的值，当某个进程要访问临界资源却发现临界资源被上锁时，lock&#x3D;&#x3D;1，然后把lock值赋值给old，old变量的值也为1，这时候返回的值也是1，while就会陷入死循环中，直到临界资源被释放。若lock&#x3D;&#x3D;0时，可以跳出while循环，这时候，该进程可以进入临界区，但是别忘了，进入临界区要把临界区上锁，而上锁这一步就是*lock&#x3D;true，这里我们就可以发现不论当前lock值是多少，都要把lock值赋true的原因，如果原来lock值为true，再赋值为true并没有影响，但是若lock&#x3D;0，先把lock给old，然后赋值为true，就是先判断出临界区没有处于忙状态，自己可以访问，所以对临界区上锁，表明自己要进入临界区。这里可以自己体会一下逻辑。</p><h4 id="3-3-3-Swap指令"><a href="#3-3-3-Swap指令" class="headerlink" title="3.3.3 Swap指令"></a>3.3.3 Swap指令</h4><img src="https://pic.imgdb.cn/item/66289d500ea9cb14039d6efd.png" alt="计算机操作系统（二）——进程与线程——Swap指令.png"><p>Swap指令看上去和TestAndSet指令不一样，实际上两者算法设计思路都是一样的，Swap指令先在一开始给old赋值为true，这一步是为了保证临界区是空闲时，自己要去访问时，要先给临界区上锁。然后通过不断交换lock与old的值，判断lock什么时候变为false，若lock是fasle，则可以跳出循环，进入临界区。在访问完以后，再进行解锁操作。稍加理解一下可以发现和TestAndSet指令是一样的。</p><p>但这里也要注意一下，Swap指令和TestAndSet一样，也是用硬件实现的，执行过程是不可打断的，上面描述的是硬件执行的逻辑结构。</p><h4 id="3-3-4-进程互斥的硬件实现方法小结"><a href="#3-3-4-进程互斥的硬件实现方法小结" class="headerlink" title="3.3.4 进程互斥的硬件实现方法小结"></a>3.3.4 进程互斥的硬件实现方法小结</h4><img src="https://pic.imgdb.cn/item/66289d760ea9cb14039da7f0.png" alt="计算机操作系统（二）——进程与线程——进程互斥的硬件实现方法小结.png"><p>这里补充一点，TestAndSet指令和Swap指令实现互斥的方法都违反了让权等待的原则。</p><h3 id="3-4-互斥锁"><a href="#3-4-互斥锁" class="headerlink" title="3.4 互斥锁"></a>3.4 互斥锁</h3><img src="https://pic.imgdb.cn/item/66289e240ea9cb14039ed587.png" alt="计算机操作系统（二）——进程与线程——锁.png"><p>锁是用于实现互斥的一种方法，可以简单理解为锁就是一个bool型变量，只有0或1（false或true）分别表示当前已上锁或没有上锁。上锁与释放锁可以通过acquire()和release()函数来实现。</p><p>用锁实现互斥的缺点就是忙等，如果进不了临界区就会不断while循环，这就会导致CPU资源浪费，违反了让权等待的原则。由于忙等过程中需要不断循环检查，因此这类锁也称为自旋锁。</p><img src="https://pic.imgdb.cn/item/66289e6e0ea9cb14039f5ba6.png" alt="计算机操作系统（二）——进程与线程——锁的特性.png"><p>特别注意一下，进程忙等，并不意味着该进程就会一直占用CPU，当进程时间片到了以后，进程依然会下CPU。</p><p>另外，忙等这种特性也有优点，在等待期间时不用切换进程上下文的（毕竟切换上下文的代价也很大），如果在多处理器系统中，若临界区上锁时间很短，则自旋等待代价很低。</p><p>举个例子，在一个4核系统里，某进程陷入自旋等待要独占一个核的运算资源，但其余的核可以接着运行，此时，若另一个核很快速的运行完占用临界资源的进程，临界资源就会被释放，此时这个在自旋等待中的进程就可以快速进入临界区。这也是忙等在多核系统里的优越性。</p><p>但是注意，如果是在单核系统里，若临界资源被上锁，此时该进程时间片到了，但临界资源没有访问完，待他下了处理机后，又上了一个进程，这时候临界资源被锁，该进程进入自旋状态，在这个进程等待的过程中，临界资源是不可能被释放的，所以该进程必须等待时间片到了以后，切换回上一个访问临界资源的进程。所以，这种忙等的性能，并不适合单处理机系统。</p><h3 id="3-5-信号量"><a href="#3-5-信号量" class="headerlink" title="3.5 信号量"></a>3.5 信号量</h3><h4 id="3-5-1-信号量基本概念"><a href="#3-5-1-信号量基本概念" class="headerlink" title="3.5.1 信号量基本概念"></a>3.5.1 信号量基本概念</h4><img src="https://pic.imgdb.cn/item/662b2f8d0ea9cb14036500ee.png" alt="计算机操作系统（二）——进程与线程——信号量.png"><p>在之前所学的所有进程互斥方案里，都无法实现让权等待的原则，为了解决这个问题，于是又提出了信号量的概念。</p><p>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的<strong>原语wait()和signal()访问</strong>，也可简写为P()和V()，或者简称P操作和V操作。</p><p>这里wait()和signal()是原语指令，是一气呵成的，无法被中断的。</p><p>信号量分为整形信号量和记录型信号量。</p><h4 id="3-5-2-整形信号量"><a href="#3-5-2-整形信号量" class="headerlink" title="3.5.2 整形信号量"></a>3.5.2 整形信号量</h4><img src="https://pic.imgdb.cn/item/662b2fdb0ea9cb14036585b2.png" alt="计算机操作系统（二）——进程与线程——整型信号量.png"><p><strong>所谓整形信号量，就是<font color=red>用一个整形的变量作为信号量，用来表示系统中某种资源的数量</font>。与普通整形变量相比，整形信号量只能进行三种操作，即<font color=red>初始化、P操作、V操作</font>。</strong></p><p>可以通过P(S)和V(S)（即wait(S)和signal(S)，这两个太长，我就简写为P、V），来对一个进程进行操作。一个进程使用P指令申请临界资源；若申请成功，则可访问临界资源；访问完资源以后，通过V指令，释放资源。</p><p>在上图左，展示了使用整型信号量定义的P、V操作执行过程的C语言表示。</p><p>以一个例子讲解一下进程基于整形信号量工作的过程：假设某计算机系统中有一台打印机，就可以初始化一个整形信号量S&#x3D;1，S表示当前系统中可用的打印机资源，1说明有一个资源可用，一般情况下，<strong>系统中有几个资源，初始值就等于几</strong>，例如有两台打印机，则S&#x3D;2。此时进程P0访问临界资源，先调佣P指令，令S-1，得S&#x3D;0，然后P访问临界资源，此时若进程P1也想访问临界资源，也会调用P指令，此时调用P指令，因为S&#x3D;0，进而进程P1会被卡在P指令里的while循环处，所以P1无法进入临界区。当P0访问完临界区以后，会将临界资源释放，即S+1，此时S&#x3D;1，P1可跳出P循环，进而访问临界资源。</p><p>从这里可以看出，使用整型信号量仍没有满足让权等待的原则，所以人们对整型信号量进一步修改，得到了下面的记录型信号量。</p><h4 id="3-5-3-记录型信号量"><a href="#3-5-3-记录型信号量" class="headerlink" title="3.5.3 记录型信号量"></a>3.5.3 记录型信号量</h4><img src="https://pic.imgdb.cn/item/662b30120ea9cb140365f1d4.png" alt="计算机操作系统（二）——进程与线程——记录型信号量.png"><p>记录型信号量在整型信号量的基础上，添加了等待队列。如上图的记录型信号量的结构描述，仍然定义一个value用来表示资源剩余数，但在此基础上添加了一个等待队列用来表示还有几个进程要访问资源。</p><p>基于结构型信号量的定义，可以设计上面的P(S)和V(S)，当某进程要访问临界资源时，就让value值减一，表示该临界资源若被本进程占用，则临界资源还有多少剩余的数量，进而对value值判断，若此时value值小于0，说明无资源可被本进程占用，要让本进程堵塞并排进等待队列。当进程释放资源时，先让value加1，表示有一个进程被释放，然后根据value值判断此时等待进程在等待队列里，若有则从等待队列里，唤醒一个进程访问临界资源。</p><p>结合上面对P指令和V指令的描述，下面举一个记录型信号量应用的例子：</p><img src="https://pic.imgdb.cn/item/662b30740ea9cb1403669a0e.png" alt="计算机操作系统（二）——进程与线程——记录型信号量举例.png"><p>如上图，假设有两台打印机，则value&#x3D;2，表示资源剩余数量为2。现在有四个进程要访问打印机，P0先使用P指令访问一台打印机，此时value变为1，P1也要访问打印机，value变为0。此时P2突然也想访问打印机，value变成-1，满足P里判断条件，要让P2堵塞，并进入等待队列，同理P3想访问打印机，也要被堵塞。</p><p>当P0访问完以后，要释放临界资源，同时根据value，判断队列里还有两个进程要访问资源，便会唤醒队头进程，因为P2比P3先进入队列，所以P2被唤醒，可以访问打印机。当P1访问完以后，也可以唤醒P3进程访问打印机。</p><p><strong>这里不难看出，被唤醒的进程不需要从头运行P指令，而是会直接进入临界资源进行访问。</strong></p><h4 id="3-5-4-信号量小结"><a href="#3-5-4-信号量小结" class="headerlink" title="3.5.4 信号量小结"></a>3.5.4 信号量小结</h4><p><strong>(1) 记录型信号量小结</strong></p><img src="https://pic.imgdb.cn/item/662b31210ea9cb140367dabe.png" alt="计算机操作系统（二）——进程与线程——记录型信号量小结.png"><p><strong>(2) 信号量知识点框架小结</strong></p><img src="https://pic.imgdb.cn/item/662b31410ea9cb1403681439.png" alt="计算机操作系统（二）——进程与线程——信号量知识点框架.png"><h3 id="3-6-用信号量实现进程互斥、同步、前驱"><a href="#3-6-用信号量实现进程互斥、同步、前驱" class="headerlink" title="3.6 用信号量实现进程互斥、同步、前驱"></a>3.6 用信号量实现进程互斥、同步、前驱</h3><h4 id="3-6-1-用信号量机制实现进程互斥"><a href="#3-6-1-用信号量机制实现进程互斥" class="headerlink" title="3.6.1 用信号量机制实现进程互斥"></a>3.6.1 用信号量机制实现进程互斥</h4><img src="https://pic.imgdb.cn/item/662b34a70ea9cb14036e8411.png" alt="计算机操作系统（二）——进程与线程——用信号量机制实现进程互斥.png"><p>互斥的这部分在3.5的记录型信号量里已经介绍的很详细，这部分提出几个重点说一下。</p><p>要注意，对不同的临界资源要设置不同的互斥信号量，如上图，对打印机设置mutex1信号量，而对摄像头则设置mutex2信号量。而不能把打印机资源和摄像头资源都定义为mutex1信号量。</p><p>在考试时，如果题目没有特别说明，可以简写semaphore mutex&#x3D;1来表示记录型信号量初始化，而不需要把记录型信号量的结构再C描述一遍。</p><h4 id="3-6-2-用信号量机制实现进程同步"><a href="#3-6-2-用信号量机制实现进程同步" class="headerlink" title="3.6.2 用信号量机制实现进程同步"></a>3.6.2 用信号量机制实现进程同步</h4><img src="https://pic.imgdb.cn/item/662b35030ea9cb140371a602.png" alt="计算机操作系统（二）——进程与线程——用信号量机制实现进程同步.png"><p>可以先回3.1.1里看一下同步的概念，知道了同步的概念以后，就知道，所谓用信号量机制实现同步就是通过P&#x2F;V指令来控制程序代码执行的先后顺序。如上图，是控制代码2在代码4之前执行的例子，通过初始化S&#x3D;0，来阻塞P2进程，进而让P1进行先执行，当代码2执行完以后，使用V释放资源，此时P2进程才可以执行，开始运行代码4，更详细的描述可以参考上图右。</p><p>在这里，可以将信号量实现进程同步总结为四字——<font color=red><strong>前V后P</strong></font>。解释一下就是在前操作后执行V(S)，在后操作前执行P(S)。可以结合下面的用信号量机制实现进程前驱理解。</p><h4 id="3-6-3-用信号量机制实现进程前驱"><a href="#3-6-3-用信号量机制实现进程前驱" class="headerlink" title="3.6.3 用信号量机制实现进程前驱"></a>3.6.3 用信号量机制实现进程前驱</h4><img src="https://pic.imgdb.cn/item/662b35430ea9cb1403722da7.png" alt="计算机操作系统（二）——进程与线程——用信号量机制实现进程前驱.png"><p>用信号量机制实现进程前驱其实就是用信号量机制实现多个进程的同步，这里我们牢记<font color=red><strong>前V后P</strong></font>四字口诀可轻松解题。如上图，进程P1有代码S1，P2有代码S2，根据图例可以看出，S1是S2的前驱，即S1先执行，执行完以后才可以执行S2，根据口诀，只需要在S1后加V(a)，S2前加P(a)，就可以轻松设计出P1进程和P2进程的同步。具体设计结果如上图，可以根据这个思路自己先把右图推一编，再与左边的结果对一下。</p><h4 id="3-6-4-小结"><a href="#3-6-4-小结" class="headerlink" title="3.6.4 小结"></a>3.6.4 小结</h4><img src="https://pic.imgdb.cn/item/662b35800ea9cb1403729bf9.png" alt="计算机操作系统（二）——进程与线程——用信号量机制实现同步、互斥、前驱小结.png"><h3 id="3-7-生产者与消费者问题"><a href="#3-7-生产者与消费者问题" class="headerlink" title="3.7 生产者与消费者问题"></a>3.7 生产者与消费者问题</h3><p>写在开头：3.7~3.11是经典的PV操作问题，这部分重点靠练题，所以我只记了题目和代码实现，最多记一些易错和重点。题目的具体分析以及如何做可以看书或跳转视频听讲解。老实说，这部分题做多了自然就会了，听得再多，不做，遇到也不会。</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1YE411D7nH?p=32&vd_source=7fb4b255ed876969a742738d7b84f461">生产者-消费者问题</a></p><p>问题描述：</p><img src="https://pic.imgdb.cn/item/663897230ea9cb1403676f29.png" alt="计算机操作系统（二）——进程与线程——生产者与消费者问题.png"><p>问题分析：</p><img src="https://pic.imgdb.cn/item/663897b70ea9cb140368ce8a.png" alt="计算机操作系统（二）——进程与线程——生产者与消费者问题分析.png"><p>问题实现：</p><img src="https://pic.imgdb.cn/item/6638987f0ea9cb14036a8a3c.png" alt="计算机操作系统（二）——进程与线程——生产者与消费者问题实现.png"><p>下面思考一个问题，上面都是先对同步信号量执行P操作，再对互斥信号量执行P操作，能不能颠倒，先对互斥信号量执行P操作，再对同步信号量执行P操作呢？</p><img src="https://pic.imgdb.cn/item/663899d50ea9cb14036d4973.png" alt="计算机操作系统（二）——进程与线程——生产者与消费者问题思考.png"><p>从上图的分析可以发现，不可以颠换同步信号量与互斥信号量的P操作，也就是说<font color=red><strong>实现互斥的P操作一定要在实现同步的P操作之后</strong></font>。</p><p>现在再思考一下，可不可以把生产一个产品和使用产品的操作放在临界区的P、V操作之间呢？逻辑上看是可以放到里面的，但是如果放到P、V操作之间，会导致临界区代码很长，也就是说一个进程对临界区上锁的时间会很长，这样就不利于各个进程交替使用临界区，所以要让临界区资源尽可能的短。所以，逻辑上把这两个操作放进去没有问题，但实际上会对系统效能产生影响，因而并不建议把这两个操作放到P、V操作里。</p><p>下面对生产者-消费者问题进行回顾：</p><img src="https://pic.imgdb.cn/item/66389b140ea9cb14036fe24e.png" alt="计算机操作系统（二）——进程与线程——生产者与消费者问题回顾.png"><h3 id="3-8-多生产者-多消费者问题"><a href="#3-8-多生产者-多消费者问题" class="headerlink" title="3.8 多生产者-多消费者问题"></a>3.8 多生产者-多消费者问题</h3><p>问题描述：</p><img src="https://pic.imgdb.cn/item/66389c730ea9cb140374f6c3.png" alt="计算机操作系统（二）——进程与线程——多生产者与多消费者问题.png"><p>问题分析：</p><img src="https://pic.imgdb.cn/item/66389ca40ea9cb1403756e77.png" alt="计算机操作系统（二）——进程与线程——多生产者与多消费者问题分析.png"><p>问题实现：</p><img src="https://pic.imgdb.cn/item/6638f7d30ea9cb1403794c33.png" alt="计算机操作系统（二）——进程与线程——多生产者与多消费者问题实现.png"><p>上图对该问题进行了解答，现在考虑一下，可不可以不用互斥信号量呢？</p><p>结论是可以的，如下图：</p><img src="https://pic.imgdb.cn/item/6638f89e0ea9cb14037bb1f3.png" alt="计算机操作系统（二）——进程与线程——多生产者与多消费者问题实现改进.png"><p>这里可以不设置互斥信号量的原因在于，本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。</p><p>但是，如果缓冲区改为2，就需要设置互斥信号量，原因如下图：</p><img src="https://pic.imgdb.cn/item/6638fa870ea9cb1403817a5f.png" alt="计算机操作系统（二）——进程与线程——多生产者与多消费者问题实现改进缓冲区设置.png"><p>经过对缓冲区的讨论，可以得到以下结论：</p><img src="https://pic.imgdb.cn/item/6638fb3f0ea9cb140383ace5.png" alt="计算机操作系统（二）——进程与线程——多生产者与多消费者问题缓冲区结论.png"><p>下面，对多生产者-多消费者问题进行总结：</p><img src="https://pic.imgdb.cn/item/6638fb7d0ea9cb1403846ee1.png" alt="计算机操作系统（二）——进程与线程——多生产者与多消费者问题总结.png"><h3 id="3-9-吸烟者问题"><a href="#3-9-吸烟者问题" class="headerlink" title="3.9 吸烟者问题"></a>3.9 吸烟者问题</h3><p>问题描述：</p><img src="https://pic.imgdb.cn/item/663a49390ea9cb1403f6e38b.png" alt="计算机操作系统（二）——进程与线程——吸烟者问题描述.png"><p>问题分析：</p><img src="https://pic.imgdb.cn/item/663a49820ea9cb1403f77054.png" alt="计算机操作系统（二）——进程与线程——吸烟者问题分析1.png"><p>信号量设置：</p><img src="https://pic.imgdb.cn/item/663a49cc0ea9cb1403f7e87f.png" alt="计算机操作系统（二）——进程与线程——吸烟者问题分析2.png"><p>问题实现：</p><img src="https://pic.imgdb.cn/item/663a4a0d0ea9cb1403f8541e.png"><p>吸烟者问题总结：</p><img src="https://pic.imgdb.cn/item/663a4a2d0ea9cb1403f88ad5.png" alt="计算机操作系统（二）——进程与线程——吸烟者问题回顾.png"><h3 id="3-10-读者写者问题"><a href="#3-10-读者写者问题" class="headerlink" title="3.10 读者写者问题"></a>3.10 读者写者问题</h3><p>问题描述：</p><img src="https://pic.imgdb.cn/item/663a4aab0ea9cb1403f948db.png" alt="计算机操作系统（二）——进程与线程——读者写者问题描述.png"><p>问题分析：</p><img src="https://pic.imgdb.cn/item/663a4af40ea9cb1403f9a25a.png" alt="计算机操作系统（二）——进程与线程——读者写者问题分析.png"><p>问题实现：</p><img src="https://pic.imgdb.cn/item/663a4b630ea9cb1403fa2748.png" alt="计算机操作系统（二）——进程与线程——读者写者问题实现.png"><p>注意，这里mutex变量是用来保证各读进程之间的互斥访问，如果没有P(mutex)，在并发条件下，可能会出现两个进程同时进行count判断从而进入P(rw)，第一个进入的可以顺利执行，第二个会被阻塞。出现这种情况的原因是由于对count变量的检查和赋值操作不是一气呵成的，所以设置mutex来实现读进程的互斥，保证了检查和赋值的操作可以一气完成。</p><p>注意，上面的实现还有问题，当利用count变量来记录当前有几个读进程在访问文件时，可以看到，文件被第一个读进程加锁，被最后一个读进程解锁。不难发现，当第一个读进程执行时，如果执行了写进程，则写进程会被堵塞，此时如果再执行读进程，读进程会使count数量增加，此时上一个读进程运行完，不会执行先来的写进程，而是会执行再写进程后的读进程。所以，这种实现方式暗含着读进程优先。</p><p>下面对此实现进行修改，提高了写进程的权值，暗含写优先思想，即当在执行一个读进程时，如果写进程先来，可以先执行，而不是在比其来的晚的读进程后执行。</p><img src="https://pic.imgdb.cn/item/663a4ed20ea9cb1403ff0c25.png" alt="计算机操作系统（二）——进程与线程——读者写者问题实现改进.png"><p>下面对读写者问题进行总结：</p><img src="https://pic.imgdb.cn/item/663a4f040ea9cb1403ff4b2b.png" alt="计算机操作系统（二）——进程与线程——读者写者问题回顾总结.png"><h3 id="3-11-哲学家进餐问题"><a href="#3-11-哲学家进餐问题" class="headerlink" title="3.11 哲学家进餐问题"></a>3.11 哲学家进餐问题</h3><p>问题描述：</p><img src="https://pic.imgdb.cn/item/663b98ed0ea9cb14030544e4.png" alt="计算机操作系统（二）——进程与线程——哲学家问题描述.png"><p>问题分析：</p><img src="https://pic.imgdb.cn/item/663b993a0ea9cb140305eb2b.png" alt="计算机操作系统（二）——进程与线程——哲学家问题分析.png"><p>经过分析，我们可以先写出上图的程序，即让一个哲学家想吃饭就拿起自己左右两个筷子，吃完再放下。但不难发现，这样执行存在一个问题，如果5个哲学家并发拿起了自己左手边的筷子，则每一个哲学家都会堵塞在拿右边筷子处，这就产生了死锁现象。</p><p>如何避免这种现象？下面提供了几种方法：</p><img src="https://pic.imgdb.cn/item/663b9a0a0ea9cb1403078add.png" alt="计算机操作系统（二）——进程与线程——哲学家问题出现死锁解决方法1.png"><p>除了上图提供的两种方法，还可以有下面这种方法，即<strong>仅当一个哲学家的左右两支筷子都可用时才允许他抓起筷子</strong>。对于这种方法的代码实现如下图：</p><img src="https://pic.imgdb.cn/item/663b9b1f0ea9cb140309b7a7.png" alt="计算机操作系统（二）——进程与线程——哲学家问题实现.png"><p>如上图，这段代码虽然说是<strong>仅当一个哲学家的左右两支筷子都可用时才允许他抓起筷子</strong>，但实际并非如此。根据程序可以看出，0号哲学家先拿起筷子吃饭，此时1号哲学家若想吃饭，发现左边筷子被占，则会堵塞在拿左的程序处，此时若2号哲学家想吃饭，虽然2号哲学家两侧筷子都可拿，但因为1号哲学家堵塞在拿左处，他已经使用P(mutex)上锁，所以此时2号也无法拿筷子。再重新看，如果0号哲学家拿起筷子吃饭，此时4号哲学家想吃饭，他会拿起左边筷子，被堵塞在拿右边筷子处，直到0号吃完，放回筷子0，4号哲学家才会拿起右边筷子吃饭。</p><p>经过上面的描述，不难发现，用<strong>仅当一个哲学家的左右两支筷子都可用时才允许他抓起筷子</strong>来描述并不准确，因为这种方法并不能保证只有两边的筷子都可用时才允许哲学家拿起筷子。</p><p>对于上述程序更准确的描述应该是，各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放在筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p><p>下面对哲学家问题进行总结：</p><img src="https://pic.imgdb.cn/item/663b9d070ea9cb14030df907.png" alt="计算机操作系统（二）——进程与线程——哲学家问题总结.png"><h3 id="3-12-管程"><a href="#3-12-管程" class="headerlink" title="3.12 管程"></a>3.12 管程</h3><p>在信号量机制中，每个要访问的临界资源的进程必须自备同步的PV操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当导致系统死锁。于是，便产生了一种新的进程同步工具——管程。</p><p>管程的定义和基本特征如下：</p><img src="https://pic.imgdb.cn/item/663c78650ea9cb14032fac2e.png" alt="计算机操作系统（二）——进程与线程——管程的定义与特征.png"><p>利用共享数据结构抽象地表示系统中的共享资源，而将对该数据结构实施的操作定义为一组过程。</p><p><strong>这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程</strong>。有了管程以后，程序员就不需要考虑同步PV操作，仅调用管程的过程（函数）即可。</p><p>局部于管程的数据只能被局部于管程的过程所访问，用大白话来说就是管程中定义的共享数据结构，只能被管程里的函数所修改。所以一个进程想修改管程里的数据，只能通过调用管程里的函数来实行。另外，每次仅允许一个进程在管程内调用某个函数，如果别的进程也想访问管程，就需要等待当前进程访问结束以后，才能访问。</p><p>为了加深理解，下面看一下用管程实现的生产者与消费者问题：</p><img src="https://pic.imgdb.cn/item/663c7f0d0ea9cb1403392680.png" alt="计算机操作系统（二）——进程与线程——管程实现生产者与消费者.png"><p>上图左边，封装在monitor内的就是管程函数（这里给的是用C实现的伪代码），右边是实现生产者与消费者进程的方式，仅需调用管程内的函数即可。编译器会负责实现个进程互斥地进入管程中的过程。</p><p>这里补充说一点，上图左边伪代码里，通过定义两个条件变量full与empty，用来解决同步问题。如果缓冲区产品满了，则生产者进程要被堵塞掉，仅当有消费者进程产生以后，取走了一个产品，才会通过full变量来唤醒被堵塞的生产者进程。 消费者进程同理，当缓冲区为空以后，消费者进程也要被堵塞，仅当有生产者进程产生以后，生产了一个产品，才会通过empty变量来唤醒被堵塞的消费者进程。</p><p>经过用管程实现生产者与消费者问题，可以总结出管程的以下特点：</p><img src="https://pic.imgdb.cn/item/663c89370ea9cb140348b0fb.png" alt="计算机操作系统（二）——进程与线程——管程的特点.png"><p>在JAVA里也有类似实现管程的机制，可以参考了解一下：</p><img src="https://pic.imgdb.cn/item/663c8b730ea9cb14034c2dd1.png" alt="计算机操作系统（二）——进程与线程——JAVA实现管程.png"><p>下面对管程一节进行小结：</p><img src="https://pic.imgdb.cn/item/663c8bba0ea9cb14034cb215.png" alt="计算机操作系统（二）——进程与线程——管程小结.png"><h2 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4. 死锁"></a>4. 死锁</h2><h3 id="4-1-死锁的概念"><a href="#4-1-死锁的概念" class="headerlink" title="4.1 死锁的概念"></a>4.1 死锁的概念</h3><p><strong>死锁的定义：指多个进程因竞争资源而造成的一种僵局（互相等待对方手里的资源），使得各个进程都被阻塞，若无外力干涉，这些进程都无法向前推进。</strong></p><p>死锁易与饥饿和死循环产生混淆，下面看一下死锁、饥饿与死循环的区别：</p><img src="https://pic.imgdb.cn/item/663c8f1a0ea9cb1403514318.png" alt="计算机操作系统（二）——进程与线程——死锁、饥饿、死循环的区别.png"><p>了解完死锁定义以后，下面看一下有哪些条件会导致死锁的产生：</p><img src="https://pic.imgdb.cn/item/663c8fb60ea9cb140351f6bb.png" alt="计算机操作系统（二）——进程与线程——死锁产生的必要条件.png"><p>接下来看一下，在什么情况下会满足这些条件，导致死锁的产生：</p><img src="https://pic.imgdb.cn/item/663c90120ea9cb14035263b5.png" alt="计算机操作系统（二）——进程与线程——死锁在什么时候产生.png"><p>既然存在死锁问题，就要想办法处理死锁，死锁的处理策略如下：</p><img src="https://pic.imgdb.cn/item/663c90550ea9cb140352b739.png" alt="计算机操作系统（二）——进程与线程——死锁的处理策略.png"><p>下面对死锁的概念部分进行一个小结：</p><img src="https://pic.imgdb.cn/item/663c918c0ea9cb140356f3d8.png" alt="计算机操作系统（二）——进程与线程——死锁概念总结.png"><h3 id="4-2-死锁的处理策略"><a href="#4-2-死锁的处理策略" class="headerlink" title="4.2 死锁的处理策略"></a>4.2 死锁的处理策略</h3><p>在上面标注了死锁的三种处理策略，接下来分别对其进行介绍。</p><h4 id="4-2-1-死锁的处理策略——预防死锁。"><a href="#4-2-1-死锁的处理策略——预防死锁。" class="headerlink" title="4.2.1 死锁的处理策略——预防死锁。"></a>4.2.1 死锁的处理策略——预防死锁。</h4><img src="https://pic.imgdb.cn/item/663c92280ea9cb140358166d.png" alt="计算机操作系统（二）——进程与线程——预防死锁.png"><p>预防死锁就是破坏会导致死锁产生的几个必要条件，接下来分别看一下怎么破坏这些条件。</p><h5 id="4-2-1-1-破坏互斥条件"><a href="#4-2-1-1-破坏互斥条件" class="headerlink" title="4.2.1.1 破坏互斥条件"></a>4.2.1.1 破坏互斥条件</h5><img src="https://pic.imgdb.cn/item/663c92b60ea9cb140358f32a.png" alt="计算机操作系统（二）——进程与线程——破坏互斥条件.png"><p>破坏互斥条件，就是将只能互斥使用的资源改造为允许共享使用的资源，则系统就不会进入死锁状态。比如使用SPOOLing技术，如上图。</p><p>在使用SPOOLing技术以后，会有一个输出进程（类似缓冲区）用来存储每个进程的请求，比如进程1先申请使用打印机，此时进程2也发出申请，就会放到输出进程里，若有别的进程也想使用，则会依次放到输出进程的进程2的申请之后。通过这种方式，各个进程的申请被放到输出进程里依次输出，在各个进程看来，自己对打印机资源的使用请求是立即被接受处理的，不需要阻塞，但实际上会通过输出进程的安排来依次使用打印机。</p><p>该策略也存在缺点，如上图下。</p><h5 id="4-2-1-2-破坏不可剥夺条件"><a href="#4-2-1-2-破坏不可剥夺条件" class="headerlink" title="4.2.1.2 破坏不可剥夺条件"></a>4.2.1.2 破坏不可剥夺条件</h5><img src="https://pic.imgdb.cn/item/663c94370ea9cb14035ac0cb.png" alt="计算机操作系统（二）——进程与线程——破坏不可剥夺条件.png"><h5 id="4-2-1-3-破坏请求和保持条件"><a href="#4-2-1-3-破坏请求和保持条件" class="headerlink" title="4.2.1.3 破坏请求和保持条件"></a>4.2.1.3 破坏请求和保持条件</h5><img src="https://pic.imgdb.cn/item/663c946a0ea9cb14035b02b6.png" alt="计算机操作系统（二）——进程与线程——破坏请求和保持条件.png"><p>使用静态分配方法破坏请求和保持条件，需要在进程运行前一次申请完它所需要的全部资源，若有的资源已被占用，要释放掉当前已申请的资源。如果进程一直申请不到全部的资源，则会导致进程饥饿。</p><p>此外，进程一旦申请资源成功，就会一直保持所有资源，这其中的一些资源，可能仅需使用很短的时间，但是会一直被占用，这样资源利用率就会很低，造成很严重的资源浪费。</p><h5 id="4-2-1-4-破坏循环等待条件"><a href="#4-2-1-4-破坏循环等待条件" class="headerlink" title="4.2.1.4 破坏循环等待条件"></a>4.2.1.4 破坏循环等待条件</h5><img src="https://pic.imgdb.cn/item/663c94b10ea9cb14035b5a60.png" alt="计算机操作系统（二）——进程与线程——破坏循环等待条件.png"><p>采用顺序资源分配法，会对系统中的资源进行编号，每个进程必须按编号递增的顺序请求资源，而大编号的资源进程不可能逆向地回来申请小编号的资源，这也就不会产生循环等待的现象。</p><p>但这种策略也有缺点，如果进程想先使用一个大编号的资源再使用一个小编号的资源，就必须先占用小编号资源，否则系统使用大编号资源以后，无法再回来申请小编号资源，这就导致资源浪费。</p><p>另外，通过这种策略，如果要添加新的设备，可能会导致重新分配编号。因为必须按规定次序申请资源，用户编程需要考虑的逻辑等东西也会很多，用户编程变得很麻烦。</p><p>下面对预防死锁进行总结：</p><img src="https://pic.imgdb.cn/item/663c9ad40ea9cb140363618a.png" alt="计算机操作系统（二）——进程与线程——预防死锁总结.png"><h4 id="4-2-2-死锁的处理策略——避免死锁"><a href="#4-2-2-死锁的处理策略——避免死锁" class="headerlink" title="4.2.2 死锁的处理策略——避免死锁"></a>4.2.2 死锁的处理策略——避免死锁</h4><img src="https://pic.imgdb.cn/item/663c9c130ea9cb140364f4c1.png" alt="计算机操作系统（二）——进程与线程——避免死锁.png"><p>避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在每次分配资源的过程中，都要分析此次分配是否会带来死锁风险，只有在不产生死锁的情况下，系统才会为其分配资源。实现避免死锁最经典的方法便是银行家算法。</p><p>首先，用一个例子来了解一下什么是安全序列。</p><img src="https://pic.imgdb.cn/item/663c9d1a0ea9cb14036657fd.png" alt="计算机操作系统（二）——进程与线程——什么是安全序列.png"><p>在上面这个借钱例子里，有一个限制条件，如果借给企业的钱总数达不到企业提出的最大要求，那么不管之前借给企业多少钱，这些钱最终都拿不回来。</p><p>如果，BAT的最大需求是70亿，40亿，50亿，但是一开始BAT三个企业分别借走20亿，10亿，30亿，此时银行家手里只剩40亿。如果这时B又想借30亿，那么银行家借出去的话，就只剩10亿，此时无论再借给BAT中的谁，都无法达到企业最大需求，也就意味着银行家的钱都拿不回来了。可以说，再借给B30亿是不安全的操作。</p><p>如果，银行家还剩40亿，但是A向银行家借20亿，银行家就会剩20亿，此时这20亿不论借给A还是T都可以收回，然后把收回的钱再借给B，就可以把所有的钱都收回，即通过T-&gt;B-&gt;A或A-&gt;T-&gt;B的序列可以安全收回所有的钱。所以，银行家再借20亿给A是安全的操作。而T-&gt;B-&gt;A或A-&gt;T-&gt;B就是安全序列。</p><p>由此，可以引出下面对安全序列的定义：</p><img src="https://pic.imgdb.cn/item/663ca2920ea9cb1403704897.png" alt="计算机操作系统（二）——进程与线程——安全序列.png"><p>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求，这也是银行家算法的核心思想。</p><p>下面看一下如何把银行家算法应用到操作系统上。</p><img src="https://pic.imgdb.cn/item/663ca3110ea9cb140370d46b.png" alt="计算机操作系统（二）——进程与线程——银行家算法.png"><p>在BAT例子里，只有一种类型的资源——钱，但是在计算机系统中会有多种多样的资源，可以把单维的数字拓展为多维的向量，实现银行家算法在操作系统中的应用。具体如上图下的例子，把3种资源的剩余数量当成一个3维向量，根据其剩余数量进行银行家算法分配。此时可以思考一下，这个系统是否处于安全状态，也就是说能不能找到一个安全序列完成各个进程的运行。</p><p>我们可以通过从需求资源较小的进程开始每一轮检查，分析过程如下图：</p><img src="https://pic.imgdb.cn/item/663cc7240ea9cb1403a64c69.png" alt="计算机操作系统（二）——进程与线程——银行家算法安全判断.png"><p>上面的分析过程是机器运算时的步骤，但在考试里，我们实际手算时并不需如此，可以参考如下方法：</p><img src="https://pic.imgdb.cn/item/663cc7a70ea9cb1403a729de.png" alt="计算机操作系统（二）——进程与线程——银行家算法安全判断（手算）.png"><p>接下来看一个找不到安全序列的例子：</p><img src="https://pic.imgdb.cn/item/663cc8010ea9cb1403a7c10c.png" alt="计算机操作系统（二）——进程与线程——银行家算法找不到安全序列.png"><p>下面说一下银行家算法实现的流程：</p><img src="https://pic.imgdb.cn/item/663cc8ed0ea9cb1403ab6352.png" alt="计算机操作系统（二）——进程与线程——银行家算法代码实现流程.png"><p>下面对避免死锁一节进行总结：</p><img src="https://pic.imgdb.cn/item/663cc9300ea9cb1403abcbb7.png" alt="计算机操作系统（二）——进程与线程——避免死锁总结.png"><h4 id="4-2-3-死锁的处理策略——检测和解除"><a href="#4-2-3-死锁的处理策略——检测和解除" class="headerlink" title="4.2.3 死锁的处理策略——检测和解除"></a>4.2.3 死锁的处理策略——检测和解除</h4><img src="https://pic.imgdb.cn/item/663ccd2f0ea9cb1403b1ec65.png" alt="计算机操作系统（二）——进程与线程——死锁的检测和解除.png"><p>如果系统中不提预防死锁和避免死锁的措施，系统就很可能发生死锁，这种情况下，系统应该提供死锁检测和死锁解除两种算法。接下来分别看一下这两种算法。</p><h5 id="4-2-3-1-死锁的检测"><a href="#4-2-3-1-死锁的检测" class="headerlink" title="4.2.3.1 死锁的检测"></a>4.2.3.1 死锁的检测</h5><img src="https://pic.imgdb.cn/item/663cce770ea9cb1403b3c8b4.png" alt="计算机操作系统（二）——进程与线程——死锁的检测的数据结构.png"><p>为了能对系统是否已发生死锁进行检测，必须用某种数据结构来保存资源的请求和分配信息，而这种数据结构在上图中已经被提供，可以用如图的资源分配图来表示。</p><p>基于这个资源分配图，可以来思考一下，系统怎么分析是否处于死锁状态。分析如下图：</p><img src="https://pic.imgdb.cn/item/663cd01a0ea9cb1403b81279.png" alt="计算机操作系统（二）——进程与线程——死锁的检测原理.png"><p>上图把分析过程讲的很清楚，但这里要提一点，在上图右的资源分配图里，蓝色表示申请，绿色表示分配，他俩并不是一对，这跟数据结构里的有向图很类似。进程发出申请，则用蓝色箭头指向资源，资源可以提供，则消去蓝色箭头，并指回一个绿色箭头。如果有蓝色箭头指向，则说明进程要申请一个资源，但资源还未分配回应。</p><p>下面是死锁的检测算法在书上的描述：</p><img src="https://pic.imgdb.cn/item/663cd1610ea9cb1403bc469c.png" alt="计算机操作系统（二）——进程与线程——死锁的检测.png"><p>既然检测到了死锁，接下来就要考虑如何想办法解出死锁了。</p><h5 id="4-2-3-2-解除死锁"><a href="#4-2-3-2-解除死锁" class="headerlink" title="4.2.3.2 解除死锁"></a>4.2.3.2 解除死锁</h5><img src="https://pic.imgdb.cn/item/663cd2560ea9cb1403bdb1ab.png" alt="计算机操作系统（二）——进程与线程——死锁的解除.png"><p>死锁的解除有以上三种策略，但无一例外的都要牺牲一些处于死锁状态的进程，这时候我们就要考虑一下，要牺牲哪一个处于死锁状态的进程。</p><p>我们可以从以下几个方面决定牺牲哪一个进程：</p><ol><li>进程优先级：优先牺牲优先级低的进程。</li><li>已执行多长时间：可以牺牲执行时间少的进程来让执行时间很久的进程先运行。</li><li>还要多久能完成：可以优先牺牲需要时间久的进程来释放资源让快执行结束的进程优先完成。</li><li>进程已经使用了多少资源：可以牺牲使用资源多进程，牺牲该进程可以释放更多资源，加快死锁局面的解除。</li><li>进程是交互式还是批处理的：如果是交互式进程，牺牲掉会影响用户感受，所以可以牺牲用户不太关心的批处理的进程，解除死锁局面。</li></ol><h5 id="4-2-3-3-小结"><a href="#4-2-3-3-小结" class="headerlink" title="4.2.3.3 小结"></a>4.2.3.3 小结</h5><p>接下来对死锁的检测和解除进行一个小结：</p><img src="https://pic.imgdb.cn/item/663cd40a0ea9cb1403c3210e.png" alt="计算机操作系统（二）——进程与线程——死锁的检测和解除总结.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（二）——数据的表示和运算</title>
      <link href="/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/"/>
      <url>/2024/04/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（二）——数据的表示和运算"><a href="#计算机组成原理（二）——数据的表示和运算" class="headerlink" title="计算机组成原理（二）——数据的表示和运算"></a>计算机组成原理（二）——数据的表示和运算</h1><h2 id="1-进位计数制"><a href="#1-进位计数制" class="headerlink" title="1. 进位计数制"></a>1. 进位计数制</h2><p>这部分主要是关于十进制、二进制、八进制及十六进制之间的相互转换与计算，老实说，这部分是学软件的基础知识，没啥难点，所以我就跳了这部分笔记。有疑惑的可以2倍速过一下视频：<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=8&vd_source=7fb4b255ed876969a742738d7b84f461">进位计数制</a></p><h2 id="2-BCD码"><a href="#2-BCD码" class="headerlink" title="2. BCD码"></a>2. BCD码</h2><p><font color=teal><strong>BCD码：指用二进制编码的十进制数。</strong></font></p><p><font color=olive><strong>BCD码有三种，分别是8421码、余3码、2421码。</strong></font></p><p>将二进制转换为十进制时，可以让每一个数码位乘与这个位的权值，再进行一个相加的操作，就可以转换成十进制。使用这种方式，将机器数转换为真值是比较麻烦的，所以使用BCD码来解决这个问题。</p><p>BCD码原理：使用4个二进制位（4个bit）来对应一个十进制位。因为4个二进制位可以表示16种状态，而这16种状态就足够用来表示十进制里0~9这十种状态，而且还会有6种冗余。</p><h3 id="2-1-8421码"><a href="#2-1-8421码" class="headerlink" title="2.1 8421码"></a>2.1 8421码</h3><p><strong>8421码是BCD码的一种编码方式，他将BCD码4个二进制位的权重分为8,4,2,1。</strong></p><p>如果用8421码来表示真值8，对应的机器码就是1000。</p><p>如果用8421码来表示真值985，对应的机器码就是1001 1000 0101。</p><p>8421码的加法运算（以5+8为例）：</p><ol><li>如果采用手动计算，可以算出5+8&#x3D;13，将13转换成机器码0001 0011即可。</li><li>如果是机算，应该是0101+1000&#x3D;1101，得到的1101代表13已经超出8421码的编码范围，这时候要再加0110（加6）才可得到正确的机器码。</li></ol><p>通过上述我们就可以知道，<font color=red><strong>当按8421码编码的机器进行加法运算时，如果结果落在了1010~1111非合法区域内，需要对结果进行加6处理</strong></font>。</p><img src="https://pic.imgdb.cn/item/660fa2b368eb9357135995cd.png" alt="计算机组成原理（二）——数据的表示与运算——8421码.png"><h3 id="2-2-余三码"><a href="#2-2-余三码" class="headerlink" title="2.2 余三码"></a>2.2 余三码</h3><p><font color=teal><strong>余三码规则：8421码 + (0011)<sub>2</sub></strong></font></p><p>余三码就是在8421码的基础上进行加3处理。</p><p>但是8421码每一位都有固定的权值，所以像8421码这种有权值的码，称之为有权码；而余三码每一位没有固定的权值，所以像余三码这种没有固定权值的码，也被称为无权码。</p><img src="https://pic.imgdb.cn/item/660fa3dd68eb9357135bf157.png" alt="计算机组成原理（二）——数据的表示与运算——余三码.png"><h3 id="2-3-2421码"><a href="#2-3-2421码" class="headerlink" title="2.3 2421码"></a>2.3 2421码</h3><p>2421码同8421码一样，但他将每个位的权值进行了改变，即权值按高到低依次是2,4,2,1。</p><p>例如，真值7按2421编码方式对应的机器码就是1101。</p><p>需要注意，因为2421码中间存在两位权值相等的情况，这就导致含权值2的真值数有两种编码方式，例如7可以对应1101，也可以对应0111。为了避免出现这种情况，<font color=maroon><strong>2421码规定，真值小于5的数，最高位为0，真值大于等于5的数，最高位为1</strong></font>。</p><img src="https://pic.imgdb.cn/item/660fa81868eb9357136562f8.png" alt="计算机组成原理（二）——数据的表示与运算——2421码.png"><h2 id="3-无符号整数的表示和运算"><a href="#3-无符号整数的表示和运算" class="headerlink" title="3. 无符号整数的表示和运算"></a>3. 无符号整数的表示和运算</h2><p>如果一个计算机机器字长是8位，这就意味着计算机只能同时处理8位运算，所以ALU的输入只能有8位。同时机器字长也限制了通用寄存器只能存8位。所以计算机硬件能支持的无符号整数位数是有上限的。</p><p>现在的计算机通常都是64位，至少也是32位。</p><h3 id="3-1-无符号整数在8位计算机内部的表示"><a href="#3-1-无符号整数在8位计算机内部的表示" class="headerlink" title="3.1 无符号整数在8位计算机内部的表示"></a>3.1 无符号整数在8位计算机内部的表示</h3><img src="https://pic.imgdb.cn/item/660fbbd168eb9357138d3248.png" alt="计算机组成原理（二）——数据的表示与运算——无符号整数的表示.png"><h3 id="3-2-无符号整数的运算"><a href="#3-2-无符号整数的运算" class="headerlink" title="3.2 无符号整数的运算"></a>3.2 无符号整数的运算</h3><h4 id="3-2-1-无符号整数的加法"><a href="#3-2-1-无符号整数的加法" class="headerlink" title="3.2.1 无符号整数的加法"></a>3.2.1 无符号整数的加法</h4><p><font color=red><strong>计算机硬件做无符号整数的加法：从最低位开始，按位相加，并往更高位进位。</strong></font></p><img src="https://pic.imgdb.cn/item/660fbea368eb935713949d78.png" alt="计算机组成原理（二）——数据的表示与运算——无符号数加法.png"><h4 id="3-2-2-无符号整数的减法"><a href="#3-2-2-无符号整数的减法" class="headerlink" title="3.2.2 无符号整数的减法"></a>3.2.2 无符号整数的减法</h4><p><font color=red><strong>计算机硬件做无符号整数的减法：被减数不变，将减数全部位按位取反，末位+1，减法变加法；然后从最低未开始，按位相加，并往更高位进位。</strong></font></p><p>将减法转变为加法的原因：加法电路造价便宜，减法电路造价昂贵。将减法变加法更省钱。</p><img src="https://pic.imgdb.cn/item/660fbeb568eb93571394c6f1.png" alt="计算机组成原理（二）——数据的表示与运算——无符号数减法.png"><h3 id="3-3-无符号整数小结"><a href="#3-3-无符号整数小结" class="headerlink" title="3.3 无符号整数小结"></a>3.3 无符号整数小结</h3><img src="https://pic.imgdb.cn/item/660fc2b968eb9357139d98e6.png" alt="计算机组成原理（二）——数据的表示与运算——无符号整数小结.png"><h2 id="4-带符号整数的表示和运算"><a href="#4-带符号整数的表示和运算" class="headerlink" title="4. 带符号整数的表示和运算"></a>4. 带符号整数的表示和运算</h2><h3 id="4-1-带符号整数在8位计算机内部的原码表示"><a href="#4-1-带符号整数在8位计算机内部的原码表示" class="headerlink" title="4.1 带符号整数在8位计算机内部的原码表示"></a>4.1 带符号整数在8位计算机内部的原码表示</h3><img src="https://pic.imgdb.cn/item/660fc4da68eb935713a238b0.png" alt="计算机组成原理（二）——数据的表示与运算——原码表示.png"><h3 id="4-2-带符号整数在8位计算机内部的原码计算"><a href="#4-2-带符号整数在8位计算机内部的原码计算" class="headerlink" title="4.2 带符号整数在8位计算机内部的原码计算"></a>4.2 带符号整数在8位计算机内部的原码计算</h3><p>如果按照无符号整数的加减运算法则，使用原码对带符号整数进行加减操作，我们会发现，结果会出现错误。</p><p>比如19+（-19），手算结果应为0。但是机器运算时会转换成二进制00010011+10010011，得到的结果是10100110，很明显结果并不正确，原因时，在带符号整数中，高位代表符号位，表示的不是数值信息，而是符号信息，这时候我们按照加法规则进行处理，就会出现错误。所以，我们可以发现原码的缺点。</p><p>原码的缺点：符号位不能参与运算，需要设计复杂的硬件电路才能处理，这样做很费钱！</p><p>所以，为了节约硬件设计电路的成本，人们发明了补码。</p><h3 id="4-3-原码、反码、补码的转换"><a href="#4-3-原码、反码、补码的转换" class="headerlink" title="4.3 原码、反码、补码的转换"></a>4.3 原码、反码、补码的转换</h3><img src="https://pic.imgdb.cn/item/660fc82368eb935713a88a06.png" alt="计算机组成原理（二）——数据的表示与运算——原反补的转换.png"><img src="https://pic.imgdb.cn/item/660fc85e68eb935713a8fda7.png" alt="计算机组成原理（二）——数据的表示与运算——原反补的快速转换.png"><h3 id="4-4-带符号整数在8位计算机内部的补码计算"><a href="#4-4-带符号整数在8位计算机内部的补码计算" class="headerlink" title="4.4 带符号整数在8位计算机内部的补码计算"></a>4.4 带符号整数在8位计算机内部的补码计算</h3><h4 id="4-4-1-带符号整数在8位计算机内部的补码加法计算"><a href="#4-4-1-带符号整数在8位计算机内部的补码加法计算" class="headerlink" title="4.4.1 带符号整数在8位计算机内部的补码加法计算"></a>4.4.1 带符号整数在8位计算机内部的补码加法计算</h4><img src="https://pic.imgdb.cn/item/660fc8fe68eb935713aa57ec.png" alt="计算机组成原理（二）——数据的表示与运算——补码的加法.png"><h4 id="4-4-2-带符号整数在8位计算机内部的补码减法计算"><a href="#4-4-2-带符号整数在8位计算机内部的补码减法计算" class="headerlink" title="4.4.2 带符号整数在8位计算机内部的补码减法计算"></a>4.4.2 带符号整数在8位计算机内部的补码减法计算</h4><img src="https://pic.imgdb.cn/item/660fced768eb935713b5fb99.png" alt="计算机组成原理（二）——数据的表示与运算——补码的减法.png"><p><font color=green><strong>通过了解带符号整数的补码减法运算，可以发现，他和无符号整数的减法运算步骤一样。这意味着，我们可以用同一套电路同时实现带符号整数的补码减法和无符号整数的减法运算，这大大节省了成本。</strong></font></p><h3 id="4-5-带符号整数运算小结"><a href="#4-5-带符号整数运算小结" class="headerlink" title="4.5 带符号整数运算小结"></a>4.5 带符号整数运算小结</h3><img src="https://pic.imgdb.cn/item/660fcfc668eb935713b7ec27.png" alt="计算机组成原理（二）——数据的表示与运算——带符号整数小结.png"><h2 id="5-移码"><a href="#5-移码" class="headerlink" title="5. 移码"></a>5. 移码</h2><p><font color=red><strong>移码：在补码的基础上将符号位取反。</strong></font></p><p><font color=green><strong>注意：移码只能用于表示整数，而且是有符号的整数。</strong></font></p><p>移码的真值0只有一种表示形式，这一点和补码一样，但是两者的表示不一样：[0]<sub>移码</sub>&#x3D;10000000；[0]<sub>补码</sub>&#x3D;00000000</p><img src="https://pic.imgdb.cn/item/660fd35268eb935713be7ebc.png" alt="计算机组成原理（二）——数据的表示与运算——移码.png"><h2 id="6-原反补移的转换及特性对比"><a href="#6-原反补移的转换及特性对比" class="headerlink" title="6. 原反补移的转换及特性对比"></a>6. 原反补移的转换及特性对比</h2><img src="https://pic.imgdb.cn/item/660fd39268eb935713bf07cb.png" alt="计算机组成原理（二）——数据的表示与运算——原反补移转换.png"><img src="https://pic.imgdb.cn/item/660fd3c468eb935713bf6c93.png" alt="计算机组成原理（二）——数据的表示与运算——原反补移特性总结.png"><img src="https://pic.imgdb.cn/item/660fd3e368eb935713bf8fe8.png" alt="计算机组成原理（二）——数据的表示与运算——原反补移表示.png"><h2 id="7-定点小数"><a href="#7-定点小数" class="headerlink" title="7. 定点小数"></a>7. 定点小数</h2><h3 id="7-1-定点数"><a href="#7-1-定点数" class="headerlink" title="7.1 定点数"></a>7.1 定点数</h3><p>定点数分为定点整数和定点小数。其中定点整数的小数点位隐藏在最后，而定点小数的小数点位隐藏在符号位之后。</p><p><strong>关于定点整数和定点小数的一些知识的补充（可看可不看，看了提不了分，不看也不影响考高分）：</strong></p><p>(1) <strong>定点整数并不等同于整数</strong>。定点整数是计算机中数值数据的一种表示方法，它采用定点格式表示整数。定点数的小数点位置是固定不变的，即小数点固定在某一个位置，不再变动。与定点数相对的是浮点数，浮点数的小数点位置是浮动的。</p><p>定点整数虽然主要用来表示整数，但它实际上是定点数的一个子集，其小数点位置隐含在最低有效位的后面。因此，当我们说一个数是定点整数时，我们是在描述它的数值表示方式，即采用定点格式并且小数点位置固定。</p><p>然而，整数是一个更广泛的概念，在数学中，整数包括正整数、零和负整数。在计算机科学中，整数可以是带符号的或无符号的，可以是定点的或浮点的。所以，虽然定点整数可以用来表示整数，但整数不仅仅可以通过定点整数来表示。</p><p>综上所述，定点整数是整数在计算机中的一种特定表示方式，但不等同于整数本身。</p><p>(2) <strong>定点整数并不一定就是带符号整数</strong>。定点整数在计算机中的表示是将小数点位置固定在数值的最右端，符号位右边的所有位表示整数的数值。它分为无符号的定点整数和有符号的定点整数两种。无符号定点整数没有符号位，其全部数位都用来表示数字，且小数点隐含在最低位后。而有符号的定点整数则是在无符号整数的基础上，在最左边加上符号位构成的。符号位用来表示整数的正负，0代表正数，1代表负数。</p><p>因此，定点整数可以是带符号的，也可以是不带符号的，具体取决于其应用场景和表示需求。</p><p><font color=red><strong>不过在本节里，我们把定点整数当成前面的带符号整数来运算可能会更容易帮助我们理解定点小数，毕竟我们本节所说的定点小数全是带符号的定点小数，带符号的定点小数也是考研大纲有关定点小数部分里最容易被考的。</strong></font></p><p>(3) <strong>定点小数不一定有符号位</strong>。定点小数在计算机中的表示方法是将小数点位置固定，通常用于表示纯小数。对于定点小数来说，其符号位的情况取决于具体的表示方法和应用需求。</p><p>在某些情况下，定点小数可能包含符号位，用于表示正数或负数。符号位通常位于最高位，用0表示正数，用1表示负数。这样，定点小数就可以表示正数和负数范围内的小数值。</p><p>然而，并非所有的定点小数都必须包含符号位。在某些特定的应用或算法中，可能只需要表示非负的小数值，此时定点小数可以不包含符号位，只使用剩余的位来表示数值部分。</p><p>因此，定点小数是否有符号位取决于具体的应用场景和需求。在设计和实现定点小数表示时，需要根据实际情况确定是否需要包含符号位，并相应地调整数值的表示范围和精度。</p><p>需要注意的是，即使定点小数包含符号位，其表示范围和精度仍然受到字长和小数点位置的限制。因此，在使用定点小数进行数值计算时，需要仔细考虑其表示范围和精度要求，以避免溢出或精度损失等问题。</p><p>(4) 对于8位定点小数，如果不带符号位，那么它全部8位都用来表示数值部分。在这种情况下，每一位可以是0或1，因此整个数值部分可以表示2<sup>8</sup>个不同的值。</p><p>此时的取值范围：0~1 - 2<sup>-8</sup></p><p>最小值：当所有位都是0时，表示的数值是0。</p><p>最大值：当所有位都是1时，表示的数值是 1 - 2<sup>-8</sup></p><img src="https://pic.imgdb.cn/item/660fff2768eb935713261e52.png" alt="计算机组成原理（二）——数据的表示与运算——定点整数和定点小数.png"><h3 id="7-2-定点小数的表示及运算"><a href="#7-2-定点小数的表示及运算" class="headerlink" title="7.2 定点小数的表示及运算"></a>7.2 定点小数的表示及运算</h3><h4 id="7-2-1-定点小数的原反补转换"><a href="#7-2-1-定点小数的原反补转换" class="headerlink" title="7.2.1 定点小数的原反补转换"></a>7.2.1 定点小数的原反补转换</h4><p>定点小数的原反补转换与定点整数的原反补转换规则是一样的。都可以参考这个图：</p><img src="https://pic.imgdb.cn/item/6610005b68eb93571328722c.png" alt="计算机组成原理（二）——数据的表示与运算——定点数原反补.png"><h3 id="7-2-2-定点小数的原码表示"><a href="#7-2-2-定点小数的原码表示" class="headerlink" title="7.2.2 定点小数的原码表示"></a>7.2.2 定点小数的原码表示</h3><p>定点小数的原码表示和定点整数规则一样，只是由于小数点移动到了符号位之后，所以每个位的位权发生了改变。</p><img src="https://pic.imgdb.cn/item/661000d468eb935713290c0b.png" alt="计算机组成原理（二）——数据的表示与运算——定点数原码表示.png"><h3 id="7-2-3-定点小数的加减运算"><a href="#7-2-3-定点小数的加减运算" class="headerlink" title="7.2.3 定点小数的加减运算"></a>7.2.3 定点小数的加减运算</h3><p>定点小数的加减运算和前面带符号整数的运算一样，都是转换成补码，然后对补码进行运算。</p><img src="https://pic.imgdb.cn/item/6610021b68eb9357132a0746.png" alt="计算机组成原理（二）——数据的表示与运算——定点小数的运算.png"><h4 id="7-2-3-1-定点小数的补码加法运算"><a href="#7-2-3-1-定点小数的补码加法运算" class="headerlink" title="7.2.3.1 定点小数的补码加法运算"></a>7.2.3.1 定点小数的补码加法运算</h4><img src="https://pic.imgdb.cn/item/661004e868eb9357132d45c2.png" alt="计算机组成原理（二）——数据的表示与运算——定点小数补码的加法运算.png"><h4 id="7-2-3-2-定点小数的补码减法运算"><a href="#7-2-3-2-定点小数的补码减法运算" class="headerlink" title="7.2.3.2 定点小数的补码减法运算"></a>7.2.3.2 定点小数的补码减法运算</h4><img src="https://pic.imgdb.cn/item/66100a4168eb935713343c8f.png" alt="计算机组成原理（二）——数据的表示与运算——定点小数补码的减法运算.png"><h3 id="7-3-定点小数与定点整数的比较"><a href="#7-3-定点小数与定点整数的比较" class="headerlink" title="7.3 定点小数与定点整数的比较"></a>7.3 定点小数与定点整数的比较</h3><img src="https://pic.imgdb.cn/item/6610030f68eb9357132b19ca.png" alt="计算机组成原理（二）——数据的表示与运算——定点小数与整数的比较.png"><h3 id="7-4-定点小数与定点整数的位扩展"><a href="#7-4-定点小数与定点整数的位扩展" class="headerlink" title="7.4 定点小数与定点整数的位扩展"></a>7.4 定点小数与定点整数的位扩展</h3><p>定点小数的位扩展在数值位最后补0，而定点整数的位扩展是在符号位与数值位之间添0。</p><img src="https://pic.imgdb.cn/item/6610041f68eb9357132c4ded.png" alt="计算机组成原理（二）——数据的表示与运算——定点小数与整数的扩展.png"><h2 id="8-奇偶校验码（计组大纲已删，但跑到计网里了，所以考408，逃不掉的）"><a href="#8-奇偶校验码（计组大纲已删，但跑到计网里了，所以考408，逃不掉的）" class="headerlink" title="8. 奇偶校验码（计组大纲已删，但跑到计网里了，所以考408，逃不掉的）"></a>8. 奇偶校验码（计组大纲已删，但跑到计网里了，所以考408，逃不掉的）</h2><p>二进制代码在计算机内部进行计算存取过程中，有可能因为元器件出现故障，或者由于某些环境噪音干扰，导致计算机内部二进制数据出现错误，所以必须考虑数据校验的问题。</p><h3 id="8-1-校验原理简介"><a href="#8-1-校验原理简介" class="headerlink" title="8.1 校验原理简介"></a>8.1 校验原理简介</h3><img src="https://pic.imgdb.cn/item/6610105368eb935713401a1f.png" alt="计算机组成原理（二）——数据的表示与运算——校验原理简介.png"><p>如上图，假设用2bit映射4个合法状态，然后传输数据B即01，如果出现错误，1变0，则另一台主机接收到数据是00，代表A，这时数据发生了错误，但接收主机无法判断错误。</p><p>为了避免这种情况，可以将2bit扩展到3bit，此时映射状态有8种，但我们只取如图所示的4种，还有4种冗余的非法状态。此时发送B，如果1变0，则接收主机收到数据为000，显然000不在合法数据内，可知道数据出现错误，</p><h3 id="8-2-奇偶校验"><a href="#8-2-奇偶校验" class="headerlink" title="8.2 奇偶校验"></a>8.2 奇偶校验</h3><img src="https://pic.imgdb.cn/item/661011a968eb935713431b3a.png" alt="计算机组成原理（二）——数据的表示与运算——奇偶校验.png"><p>奇校验：整个校验码中1的个数为奇数，这里的奇数是指有效信息位和校验位的1的个数加起来为奇数。例如上面的例2-3，1001101中1的个数为偶数，此时采用奇校验，需要里面有奇数个1，所以需要在校验位补1。</p><p>同理，偶校验：整个校验码中1的个数为偶数，这里的偶数是指有效信息位和校验位的1的个数加起来为偶数。例如上面的例2-3，1001101中1的个数为偶数，此时采用偶校验，需要里面有偶数个1，所以需要在校验位补0。</p><p>对于奇偶校验，如果出现奇数个位上的数据出现跳变（0变1或1变0），我们可以通过奇偶校验判断出数据出现错误，但如果偶数个位上的数据出现跳变，此时接收到数据进行判断时，扔满足规则，但数据却是错的。</p><p>例如：偶校验的数据01001101，在发送过程中，末位跳变成0，此时数据为01001100，接收方接收到数据发现不是偶数个1，会发现错误。但如果出现最后两个位跳变，变成01001110，此时接收方接收到数据发现是偶数个1，会默认正确，但实际数据是错误的。</p><p>所以，我们可以知道，奇偶校验仍是存在缺陷的。</p><p>不过以上的运算全是基于我们人类视角来看的，那计算机硬件是如何进行运算的呢？</p><p><strong>这里以偶校验为例：</strong></p><p>偶校验的硬件实现：各信息进行异或（模2加）运算，得到的结果即为偶校验位。</p><p>如上面的1001101，在硬件里，将7个bit位进行异或运算，得到结果为0，所以此时校验位补0，变成01001101。接受方接收到这组数据，将01001101中的8个bit位进行异或运算，得到结果为0，说明数据正确。</p><img src="https://pic.imgdb.cn/item/6610154e68eb93571346372d.png" alt="计算机组成原理（二）——数据的表示与运算——奇偶校验硬件实现.png"><p>硬件的奇偶校验和我们前面发现的结论一样，如果偶数个位置跳变，是无法发现错误的！</p><h2 id="9-电路基本原理——门电路"><a href="#9-电路基本原理——门电路" class="headerlink" title="9. 电路基本原理——门电路"></a>9. 电路基本原理——门电路</h2><p>这部分是有关电路非与门，串并行的电路知识介绍，有电路基础的可以直接跳过。</p><h3 id="9-1-算术逻辑单元-ALU"><a href="#9-1-算术逻辑单元-ALU" class="headerlink" title="9.1 算术逻辑单元(ALU)"></a>9.1 算术逻辑单元(ALU)</h3><p>运算器内部除了包含一些寄存器外，还包含用于计算的核心部件——ALU（算术逻辑单元）。</p><p>ALU可以实现算术运算（加、减、乘、除等）；还可以实现逻辑运算（与、或、非、异或等）；还可以实现辅助功能（移位、求补等）</p><img src="https://pic.imgdb.cn/item/6610cc2968eb9357135c6dc0.png" alt="计算机组成原理（二）——数据的表示与运算——ALU.png"><p>上图左边为抽象ALU表达图，有两个输入端，比如想实现两个8bit数的加法，其中一个数从A端进，另一个数从B端进，通过K区域控制信号，实现两个数相加运算，最后从F端输出。</p><p>上图右边为74181ALU芯片的结构图，从图可以看出，这个芯片是4位ALU，右边一列M~S<sub>3</sub>，是来自CU的控制信号，通过不同的组合，实现不同的运算规则。</p><p>74181下面是输入信号，表示可以输入两组4bit数据，这其实就是机器字长的真面目，机器字长指计算机能同时处理多少个bit整数的运算，也就是ALU可以同时输入多少个bit的数据。</p><p>需要注意的是，74181上还有一些我们没有说的输出输入口，而这些端口是为了用来与其他芯片进行串联而设计。这部分内容放在接下来的并行进位加法器中进行详细讲解。</p><h3 id="9-2-基本逻辑——与或非电路"><a href="#9-2-基本逻辑——与或非电路" class="headerlink" title="9.2 基本逻辑——与或非电路"></a>9.2 基本逻辑——与或非电路</h3> <img src="https://pic.imgdb.cn/item/6610d52168eb9357136f683f.png" alt="计算机组成原理（二）——数据的表示与运算——与或非.png"><img src="https://pic.imgdb.cn/item/6610df4468eb935713853e7c.png" alt="计算机组成原理（二）——数据的表示与运算——与或非补充.png"><h3 id="9-3-复合逻辑"><a href="#9-3-复合逻辑" class="headerlink" title="9.3 复合逻辑"></a>9.3 复合逻辑</h3><img src="https://pic.imgdb.cn/item/6610dfe168eb935713867a63.png" alt="计算机组成原理（二）——数据的表示与运算——复合逻辑.png"><h2 id="10-加法器设计"><a href="#10-加法器设计" class="headerlink" title="10. 加法器设计"></a>10. 加法器设计</h2><h3 id="10-1-一位全加器"><a href="#10-1-一位全加器" class="headerlink" title="10.1 一位全加器"></a>10.1 一位全加器</h3><p>一位全加器：用于将两个一位二进制数进行加法运算，并生成一个和值以及一个进位值。</p><img src="https://pic.imgdb.cn/item/6610e08368eb93571387c370.png" alt="计算机组成原理（二）——数据的表示与运算——一位全加器.png"><p>上图左下角为一位全加器设计电路图，一位全加器主要有5个对外接口，分别是输入A<sub>i</sub>、输入B<sub>i</sub>、来自低位的进位C<sub>i-1</sub>、本位的和S<sub>i</sub>、向高位的进位C<sub>i</sub>。</p><p>其中S<sub>i</sub>由于是本位的和，能影响到他的只有本位的两个二进制输入数据，以及来自低位的进位。所以S<sub>i</sub>的结果如上图右上角的公式，是A<sub>i</sub>、B<sub>i</sub>、C<sub>i-1</sub>三者的异或。</p><p>注意，S<sub>i</sub>理论是三者相加，但这里使用异或，首先是因为我们设计的是加法器，而不是用加法器设计更复杂的电路。其次，这里的异或运算是对三个二进制数使用，根据进位规则，这里的异或运算就同等于加法运算（这么说有问题，但好理解）。最后，异或运算只需一个门电路即可完成，简单便宜。实际上，这里说了一堆道理都没用，记住就好。</p><p>除了S<sub>i</sub>，还有C<sub>i</sub>，C<sub>i</sub>是本位产生的进位。能产生进位的情况只有两种：第一，两个本位都为1,；第二，两个本位有一个为1，但是来自低位的进位是1。根据这两种情况可以写出上图中右上角的C<sub>i</sub>公式。</p><h3 id="10-2-串行加法器"><a href="#10-2-串行加法器" class="headerlink" title="10.2 串行加法器"></a>10.2 串行加法器</h3><p>串行加法器：就是在一个全加器的基础上，添加了一个进位触发器，每次产生的进位信号都存储到进位触发器，当进行下一组运算时，进位触发器在将存储的进位数据运送到低位进位处。如下图。</p><img src="https://pic.imgdb.cn/item/6610e4eb68eb93571391ef51.png" alt="计算机组成原理（二）——数据的表示与运算——串行加法器.png"><p>串行加法器运行一组n位的数据，就要执行n次，所以效率是很低的。</p><h3 id="10-3-并行加法器"><a href="#10-3-并行加法器" class="headerlink" title="10.3 并行加法器"></a>10.3 并行加法器</h3><p>串行进位的并行加法器：把n个全加器串接起来，就可进行两个n位数的相加。</p><p>串行进位：每一级进位都依赖于前一级进位，即进位信号是逐级形成的。</p><img src="https://pic.imgdb.cn/item/6610e67868eb935713956101.png" alt="计算机组成原理（二）——数据的表示与运算——串行进位的并行加法器.png"><p>如上图所示，由于串行进位的并行加法器需要逐级进位，才能计算下一位的本位和和进位，所以运算速度很大程度上取决于进位的速度，那么这种方法可以进行优化吗？答案当然是可以的，接下来就来阐述一下，如何进位问题进行优化。</p><img src="https://pic.imgdb.cn/item/6610ed1968eb935713a1e1e1.png" alt="计算机组成原理（二）——数据的表示与运算——如何进位.png"><p>根据上图列举规则，可以发现，每一位的进位其实可以由被加数、加数以及低位进行所表示，而低位进位可以由更低位进位推算，通过递归，到达最后一位不存在进位。当我们按照递归进行逆推，会发现每一组数据都可以写出来，这样我们就可以在下一位产生进位前，提前算出当前位有没有进位。通过这种手段，就可以实现各个位同时进行加法运算，大大提高了运算时间。</p><p><img src="https://pic.imgdb.cn/item/6610ee5b68eb935713a3525a.png" alt="计算机组成原理（二）——数据的表示与运算——优化.png">通过优化可以发现，每扩展一位，进行的运算就会复杂很多，所需设计的电路就越庞大，所以一般情况下，我们只设计到4位。</p><h3 id="10-4-9-10两块小结"><a href="#10-4-9-10两块小结" class="headerlink" title="10.4 9~10两块小结"></a>10.4 9~10两块小结</h3><img src="https://pic.imgdb.cn/item/6610f85868eb935713b708ce.png" alt="计算机组成原理（二）——数据的表示与运算——9~10小结.png"><h2 id="11-补码加减运算器"><a href="#11-补码加减运算器" class="headerlink" title="11. 补码加减运算器"></a>11. 补码加减运算器</h2><h3 id="11-1-知识回顾"><a href="#11-1-知识回顾" class="headerlink" title="11.1 知识回顾"></a>11.1 知识回顾</h3><h4 id="11-1-1-加法器原理"><a href="#11-1-1-加法器原理" class="headerlink" title="11.1.1 加法器原理"></a>11.1.1 加法器原理</h4><img src="https://pic.imgdb.cn/item/6610ef3d68eb935713a422a9.png" alt="计算机组成原理（二）——数据的表示与运算——加法器原理.png"><h4 id="11-1-2-补码加减运算"><a href="#11-1-2-补码加减运算" class="headerlink" title="11.1.2 补码加减运算"></a>11.1.2 补码加减运算</h4><img src="https://pic.imgdb.cn/item/6610ef7968eb935713a4b03c.png" alt="计算机组成原理（二）——数据的表示与运算——补码加减运算.png"><h3 id="11-2-补码加减运算电路"><a href="#11-2-补码加减运算电路" class="headerlink" title="11.2 补码加减运算电路"></a>11.2 补码加减运算电路</h3><img src="https://pic.imgdb.cn/item/6610efd968eb935713a59d7f.png" alt="计算机组成原理（二）——数据的表示与运算——补码加减运算电路.png"><p>上面便是补码加减运算电路，在加法器的基础上，添加了一个多路选择器。如果是加法，则Sub&#x3D;0，Y端输入多少，多路选择器便输出多少。当Sub&#x3D;1时，代表减法，此时Y端输入需要经过一个非门取反，进行加法时，还要加上来自Cin的1（这一连串操作其实就补码减法中的减数全部位取反末位加1）。</p><p>上图例1里有个重要知识点，不知道的话可能理解不了例子，就是X&#x3D;-8，X<sub>补</sub>&#x3D;1000。这里可能很多人理解不了，是因为这里采用补码表示，他的原码真值0有两种表示，但补码只有一种，而多出来的一种被放到负数的最后一位，拓展了一位负数，所以这里-8补码的表示为1000，如果是原码是表示不了-8的，原码的表示范围只能是-7~7，说到这里其实我们还可以扒出一些别的知识点，既然我们看出来了是用补码表示的-8，说明他是一个带符号整数，且最高位是符号位，那他的数值位就只有3位，所以我们可以将其理解为一个带符号的8进制数。</p><p>在前面有提过，补码的加减电路其实和无符号数的运算电路是一样的（这个是知识点，要牢记的！），所以对于补码加减运算电路，我们也可以用其来说无符号整数的运算，如下。</p><img src="https://pic.imgdb.cn/item/6610f7d568eb935713b5f277.png" alt="计算机组成原理（二）——数据的表示与运算——无符号整数加减运算电路.png"><h2 id="12-加减运算和溢出判断"><a href="#12-加减运算和溢出判断" class="headerlink" title="12. 加减运算和溢出判断"></a>12. 加减运算和溢出判断</h2><h3 id="12-1-加减运算"><a href="#12-1-加减运算" class="headerlink" title="12.1 加减运算"></a>12.1 加减运算</h3><h4 id="12-1-1-原码加法运算"><a href="#12-1-1-原码加法运算" class="headerlink" title="12.1.1 原码加法运算"></a>12.1.1 原码加法运算</h4><img src="https://pic.imgdb.cn/item/6610f93c68eb935713b90000.png" alt="计算机组成原理（二）——数据的表示与运算——原码加减运算.png"><h4 id="12-1-2-补码的加减运算"><a href="#12-1-2-补码的加减运算" class="headerlink" title="12.1.2 补码的加减运算"></a>12.1.2 补码的加减运算</h4><img src="https://pic.imgdb.cn/item/6610f97968eb935713b97a1d.png" alt="计算机组成原理（二）——数据的表示与运算——补码的加减运算.png"><h3 id="12-2-溢出判断"><a href="#12-2-溢出判断" class="headerlink" title="12.2 溢出判断"></a>12.2 溢出判断</h3><p>溢出判断的方法有三种，分别是采用一位符号位、采用双符号位、采用一位符号位根据数值位的进位情况判断溢出。</p><h4 id="12-2-1-采用一位符号位"><a href="#12-2-1-采用一位符号位" class="headerlink" title="12.2.1 采用一位符号位"></a>12.2.1 采用一位符号位</h4><p>一位符号位判断的核心思想：</p><p>​<font color=red><strong>正数</strong>+<strong>正数</strong>&#x3D;<strong>负数</strong>，出现上溢（只有正数+正数才会有上溢）</font></p><p>​<font color=red><strong>负数</strong>+<strong>负数</strong>&#x3D;<strong>正数</strong>，出现下溢（只有负数+负数才会有下溢）</font></p><img src="https://pic.imgdb.cn/item/6610fb8b68eb935713bde007.png" alt="计算机组成原理（二）——数据的表示与运算——第一种溢出判断.png"><h4 id="12-2-2-采用双符号位"><a href="#12-2-2-采用双符号位" class="headerlink" title="12.2.2 采用双符号位"></a>12.2.2 采用双符号位</h4><p>双号为溢出判断的核心思想：假设两个符号位为S<sub>1</sub>S<sub>2</sub>。</p><p>​<font color=red>S<sub>1</sub>S<sub>2</sub>&#x3D;00：结果为正数，无溢出。</font></p><p>​<font color=red>S<sub>1</sub>S<sub>2</sub>&#x3D;01：结果正溢出。</font></p><p>​<font color=red>S<sub>1</sub>S<sub>2</sub>&#x3D;10：结果复溢出。</font></p><p>​<font color=red>S<sub>1</sub>S<sub>2</sub>&#x3D;11：表示结果为负数，无溢出。</font></p><p>​</p><img src="https://pic.imgdb.cn/item/661100af68eb935713c8f606.png" alt="计算机组成原理（二）——数据的表示与运算——双符号位溢出判断.png"><h4 id="12-2-3-采用一位符号位根据数值位的进位情况做判断"><a href="#12-2-3-采用一位符号位根据数值位的进位情况做判断" class="headerlink" title="12.2.3 采用一位符号位根据数值位的进位情况做判断"></a>12.2.3 采用一位符号位根据数值位的进位情况做判断</h4><img src="https://pic.imgdb.cn/item/6611005f68eb935713c84452.png" alt="计算机组成原理（二）——数据的表示与运算——第二种溢出判断.png"><h3 id="12-3-符号扩展"><a href="#12-3-符号扩展" class="headerlink" title="12.3 符号扩展"></a>12.3 符号扩展</h3><p>通过上面的了解，我们知道当一个数的表示超出表示范围，就会溢出，那么该如何处理这个问题呢？一个最容易想到的办法就是符号扩展。</p><img src="https://pic.imgdb.cn/item/661102ba68eb935713ce17fa.png" alt="计算机组成原理（二）——数据的表示与运算——扩展.png"><p>在上图，通过观察可以发现，不论是定点小数还是定点整数，他们的正数都添0，而负数的原码也添0，反码都补1，而补码从右往左遇到的第一个1的左边和原码一样，右边和反码一样。所以我们可以总结一条规律，对于补码，从右往左遇到的第一个1的左边跟反码一样补1，而右边和原码一样添0。</p><h3 id="12-4-小结"><a href="#12-4-小结" class="headerlink" title="12.4 小结"></a>12.4 小结</h3><img src="https://pic.imgdb.cn/item/6611053b68eb935713d28805.png" alt="计算机组成原理（二）——数据的表示与运算——溢出小结.png"><h2 id="13-标志位的生成"><a href="#13-标志位的生成" class="headerlink" title="13. 标志位的生成"></a>13. 标志位的生成</h2><img src="https://pic.imgdb.cn/item/6611060368eb935713d40dea.png" alt="计算机组成原理（二）——数据的表示与运算——标志位.png"><img src="https://pic.imgdb.cn/item/6611063d68eb935713d47ef9.png" alt="计算机组成原理（二）——数据的表示与运算——标志位信息.png"><h2 id="14-定点数的移位运算"><a href="#14-定点数的移位运算" class="headerlink" title="14. 定点数的移位运算"></a>14. 定点数的移位运算</h2><p>移位运算可以分为算数移位和逻辑移位以及循环移位。</p><h3 id="14-1-算数移位"><a href="#14-1-算数移位" class="headerlink" title="14.1 算数移位"></a>14.1 算数移位</h3><p>算术移位：是一种计算机科学中的运算方法，它涉及到二进制数的移位操作。算术移位的对象是有符号数，也称为有符号移位，移位过程中符号位保持不变。</p><p>算数移位，通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。</p><h4 id="14-1-1-原码的算数移位"><a href="#14-1-1-原码的算数移位" class="headerlink" title="14.1.1 原码的算数移位"></a>14.1.1 原码的算数移位</h4><p>原码的算数移位——符号位保持不变，仅对数值位进行移位。（以下基于二进制来讨论）</p><p><strong>右移</strong>：高位补0，低位舍弃，右移相当于除2。但是右移过程中，被舍弃的位置如果是0，则无影响；如果是1，则会影响精度（0说明能除尽2，1说明除不尽，除不尽的部分相当于直接被舍弃了，所以右移出现精度丢失，会导致数据变小）。<strong>所以右移会出现丢失精度问题</strong>。</p><p><strong>左移</strong>：低位补0，高位舍弃，左移相当于乘2，但是是左移过程中，被舍弃的位置如果是0，则无影响；如果是1，则会出现严重误差（0说明高位无数据，丢了没影响。但是1说明高位有数据，此时左移，会导致数据溢出，所以丢弃高位会产生严重误差）。<strong>所以左移会出现严重误差问题</strong>。</p><p>以上的左移和右移规则，对于定点整数和定点小数都适应。不仅仅包括原码的算术移位，接下来我们讨论的反码、补码的算数移位规则对于定点整数和定点小数也都适应。</p><h4 id="14-1-2-反码的算数移位"><a href="#14-1-2-反码的算数移位" class="headerlink" title="14.1.2 反码的算数移位"></a>14.1.2 反码的算数移位</h4><img src="https://pic.imgdb.cn/item/661109e468eb935713db6349.png" alt="计算机组成原理（二）——数据的表示与运算——反码的算数移位.png"><h4 id="14-1-3-补码的算数移位"><a href="#14-1-3-补码的算数移位" class="headerlink" title="14.1.3 补码的算数移位"></a>14.1.3 补码的算数移位</h4><img src="https://pic.imgdb.cn/item/66110c7a68eb935713e0d853.png" alt="计算机组成原理（二）——数据的表示与运算——补码的算数移位.png"><h3 id="14-2-逻辑移位"><a href="#14-2-逻辑移位" class="headerlink" title="14.2 逻辑移位"></a>14.2 逻辑移位</h3><img src="https://pic.imgdb.cn/item/66110cef68eb935713e19d7b.png" alt="计算机组成原理（二）——数据的表示与运算——逻辑移位.png"><img src="https://pic.imgdb.cn/item/66110e0368eb935713e37a08.png" alt="计算机组成原理（二）——数据的表示与运算——逻辑移位应用.png"><h3 id="14-3-循环移位"><a href="#14-3-循环移位" class="headerlink" title="14.3 循环移位"></a>14.3 循环移位</h3><img src="https://pic.imgdb.cn/item/66110ea468eb935713e42275.png" alt="计算机组成原理（二）——数据的表示与运算——循环移位.png"><h3 id="14-4-小结"><a href="#14-4-小结" class="headerlink" title="14.4 小结"></a>14.4 小结</h3><img src="https://pic.imgdb.cn/item/66110ef168eb935713e4bb92.png" alt="计算机组成原理（二）——数据的表示与运算——移位小结.png"><h2 id="15-乘法运算"><a href="#15-乘法运算" class="headerlink" title="15.乘法运算"></a>15.乘法运算</h2><h3 id="15-1-原码的乘法"><a href="#15-1-原码的乘法" class="headerlink" title="15.1 原码的乘法"></a>15.1 原码的乘法</h3><p><strong>手算乘法</strong>：手算二进制乘法和我们数学里的日常计算乘法一样。</p><img src="https://pic.imgdb.cn/item/6611375568eb9357132a5075.png" alt="计算机组成原理（二）——数据的表示与运算——原码乘法运算.png"><p>当我们进行手算二进制乘法时可以发现3个核心问题，第一，我们需要区分数值正负；第二，结果的位数相较于乘数扩大一倍；第三，每次相乘的位积都要保存下来然后再统一相加。发现这三个核心问题以后，我们就可以发现，只要我们的计算机能处理这三种问题，那么机算乘法就已经得到了解决。</p><img src="https://pic.imgdb.cn/item/66114a8468eb93571349c3c5.png" alt="计算机组成原理（二）——数据的表示与运算——原码乘法硬件构成.png"><p>上图是原码乘法的硬件构成，为了应对我们上面说的三个问题，所以我们设计出了如图所示的硬件构成，其中X里存放被乘数，MQ里存放乘数以及乘积的低位，ACC里存放乘积的高位，ALU进行运算。说到这里，已经出现不可理解的问题，那就是ACC和MQ里存放的乘积高位和乘积低位分别是什么意思。</p><p>很简单，在初始时，我们将ACC置0，MQ里存放乘数，在进行乘法过程中，每次都是MQ最低位与X进行相乘，注意，说的是相乘，实际上，机器是判断MQ最低位是1还是0，如果是1，则将X中数据加入ACC中，如果是0，则ACC保持不变。当MQ的最后一位运算结束以后，需要将ACC和MQ整体向右移，即舍弃MQ最低位，为下一次运算相乘的结果加入，做好位积相加准备。这样我们就可以解决上面所说的二、三问题。至于第一个问题，我们可以使用两个数的绝对值相加，最后使用异或运算判断符号位即可，具体过程可以参考下图。</p><img src="https://pic.imgdb.cn/item/661141af68eb9357133ac989.png" alt="计算机组成原理（二）——数据的表示与运算——原码乘法运算手算模拟.png"><p>注意，这里我贴了一张计算例子图，是因为这一块乘法在运算器中的执行是一个动态过程，我不太好用几句话描述，再加上我这个地方看了4遍，了解的还算可以，所以贴了一个手算模拟计算的例题，方便我快速回忆。有问题的可以连接跳转，去看一遍视频。<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=22&vd_source=7fb4b255ed876969a742738d7b84f461">原码的乘法运算</a></p><h3 id="15-2-补码的乘法运算"><a href="#15-2-补码的乘法运算" class="headerlink" title="15.2 补码的乘法运算"></a>15.2 补码的乘法运算</h3><p>补码的乘法与原码的乘法大体上一致，但补码的乘法需要在MQ的最后面补一位作为辅助位，使用该辅助位来判断该加上什么数。</p><img src="https://pic.imgdb.cn/item/6611482368eb93571347ebfe.png" alt="计算机组成原理（二）——数据的表示与运算——补码乘法.png"><p>下图，是补码的乘法运算的硬件构成，相比较于原码，在MQ的最后一位，添加了一个辅助位。一般在寄存器内，各个算术硬件的长度都相等，所以ACC和X也相应的扩展了一位，而这扩展的一位，便用来充当符号位，加上ACC和X的最高位原本就是符号位，所以补码运算里是双符号位的。</p><img src="https://pic.imgdb.cn/item/6611492768eb93571348f829.png" alt="计算机组成原理（二）——数据的表示与运算——补码乘法运算器.png"><p>具体的运算内容我便不详细叙述，因为他和原码运算一样。这里我贴张例子方便我自己回忆，大家可以去看看视频。<a href="https://www.bilibili.com/video/BV1ps4y1d73V?p=23&vd_source=7fb4b255ed876969a742738d7b84f461">补码乘法</a></p><img src="https://pic.imgdb.cn/item/66114ce168eb9357134b7e0f.png" alt="计算机组成原理（二）——数据的表示与运算——补码乘法模拟.png"><h3 id="15-3-定点数乘法的小结"><a href="#15-3-定点数乘法的小结" class="headerlink" title="15.3 定点数乘法的小结"></a>15.3 定点数乘法的小结</h3><img src="https://pic.imgdb.cn/item/66114d4068eb9357134bb307.png" alt="计算机组成原理（二）——数据的表示与运算——乘法小结.png"><p>这里有一个易错的知识点，就是原码右移是逻辑右移，即符号位在计算过程中也要右移。而补码右移是算数右移，即符号位在计算过程中，是不会右移的。</p><h2 id="16-除法运算"><a href="#16-除法运算" class="headerlink" title="16. 除法运算"></a>16. 除法运算</h2><h3 id="16-1-原码的除法"><a href="#16-1-原码的除法" class="headerlink" title="16.1 原码的除法"></a>16.1 原码的除法</h3><p>原码的除法有两种方法，一种叫恢复余数法，一种叫加减交替法（不恢复余数法）。听名字就可以看出两种方法的区别产生在余数上，接下来，就对两种方法进行一个剖析。</p><h4 id="16-1-1-恢复余数法"><a href="#16-1-1-恢复余数法" class="headerlink" title="16.1.1 恢复余数法"></a>16.1.1 恢复余数法</h4><img src="https://pic.imgdb.cn/item/66129ded68eb93571366f6b9.png" alt="计算机组成原理（二）——数据的表示与运算——恢复余数法.png"><p>除法硬件结构如上图右下角的结构图，与乘法运算的结构一样。</p><p>在进行原码除法运算时，在ACC中存放被除数以及余数、在X中存放除数，而MQ中则存放商。需要注意的是，除法运算的商放在MQ的最后一位，然后通过左移，来进行商的移位。这点与乘法不一样，乘法是右移实现的。</p><p>除法的运算原理：首先令MQ的最后一位为1，然后会执行ACC-X，结果为正，则说明被除数大于除数，商1是正确的，则MQ最后一位的商保持不变；<font color=red><strong>如果结果为负，则说明被除数小于除数，商1是错误的，应该商0，此时，让ACC中余数加上X中的除数，恢复被除数，再令商为0（加红加粗的这段就是恢复余数的核心）</strong></font>。商完以后，令ACC和MQ整体左移，舍弃最高位，像上图左侧的竖式一样，此时ACC中剩下第一轮除商剩下的余数，MQ中得到商的第一位。然后再令MQ最后一位商1，如此循环，当MQ被商的结果填满以后，则停止运算。（注意，这里商的结果位数，应与乘商寄存器的最大位数一样。）</p><img src="https://pic.imgdb.cn/item/6612a1ac68eb9357136bdeee.png" alt="计算机组成原理（二）——数据的表示与运算——恢复余数模拟.png"><p>上图是我们手动模拟机器计算的过层，需要注意的是，原码的除法运算左移的时候，是算数左移，连符号位也要左移，这一点和乘法运算一样，而且如果机器字长为n+1位（n为数值位，1为符号位），则要左移n次，商n+1次，这是因为最后一次商的余数，不需要进行左移操作。（注意是先商1，结果没问题再左移，结果为负责先恢复改商在左移，别颠倒商与左移两者顺序。）</p><p>经过上面的了解，我们可以发现，每次进行运算时，会有大量时间浪费在恢复余数上，有没有什么办法可以节省这段时间呢？答案是肯定的，这就是接下来说的加减交替法。</p><h4 id="16-1-2-加减交替法"><a href="#16-1-2-加减交替法" class="headerlink" title="16.1.2 加减交替法"></a>16.1.2 加减交替法</h4><img src="https://pic.imgdb.cn/item/6612a36268eb9357136dc587.png" alt="计算机组成原理（二）——数据的表示与运算——加减交替.png"><p>我们可以对前面的恢复余数法进行深入研究，假设令余数为a，被除数为b。当除商以后的余数是负数，说明商1是有问题的，此时我们要加上余数，恢复原被除数，即a+b。这以后的操作便是商0，然后令被除数左移1位。在前面我们过，二进制左移即乘2，所以左移以后的被除数可以用(a+b)×2表示，这个时候按照规则，应加上被除数即2a+2b-b，这样才可得到下一个商的余数。所以，当出现商1不正确时，中间一系列的转换过程最后可以总结为一个式子2a+b，这个式子的意思就是若余数为负，则可直接商0，并让余数左移1位再加上除数的绝对值。</p><p>上述的理解，是我根据王道课程做的理解，我个人的感觉，王道每一组运算的结尾，是以商1做判断为结尾，即每一组的末尾都是加上[-|y|]<sub>补码</sub>。这样做的好处是，此时得到的余数如果是负，则可直接商0如果为正，则直接商1。但是不大好理解，所以我理解时，一般都把这段添[-|y|]<sub>补码</sub>放在一组运算的开头，先加上[-|y|]<sub>补码</sub>，表示商1做预测，结果为负，则回溯改0，不为负，则商就是1。所以，我的自己的思路是，到2a+2b就结束，即出现余数为负，在商0，让被除数左移1位，再开始进行新一轮商1判断。这里大家自己根据自己的喜好理解，当然有自己的理解更好。</p><p>接下里是原码加减交替法的手动模拟及思维导图，注意图中给的例子，最后若商的刚刚好，即余数为正数，则不需要回溯，如果为负数，则需要商0，并进行回溯得正确的余数</p><img src="https://pic.imgdb.cn/item/6612a3fe68eb9357136f17c8.png" alt="计算机组成原理（二）——数据的表示与运算——加减交替模拟.png"><img src="https://pic.imgdb.cn/item/6612b0a568eb9357137c69dd.png" alt="计算机组成原理（二）——数据的表示与运算——加减交替导图.png"><h3 id="16-2-补码的除法运算"><a href="#16-2-补码的除法运算" class="headerlink" title="16.2 补码的除法运算"></a>16.2 补码的除法运算</h3><img src="https://pic.imgdb.cn/item/6612b12a68eb9357137d16f3.png" alt="计算机组成原理（二）——数据的表示与运算——补码除发加减交替.png"><p>补码的除法运算与原码的加减交替变化并不大，但需要注意的是补码的最后一位为了缩减精度，指接商恒置为1，相较于原码来说简单了许多。</p><h3 id="16-3-除法运算总结"><a href="#16-3-除法运算总结" class="headerlink" title="16.3 除法运算总结"></a>16.3 除法运算总结</h3><img src="https://pic.imgdb.cn/item/6612b21968eb9357137db327.png" alt="计算机组成原理（二）——数据的表示与运算——除法运算总结.png"><h2 id="17-C语言类型转换"><a href="#17-C语言类型转换" class="headerlink" title="17. C语言类型转换"></a>17. C语言类型转换</h2><p>老实说，这节很基础，我感觉没啥好注释的…</p><img src="https://pic.imgdb.cn/item/6612b26b68eb9357137df3a3.png" alt="计算机组成原理（二）——数据的表示与运算——C语言类型转换.png"><h2 id="18-数据存储和排列"><a href="#18-数据存储和排列" class="headerlink" title="18. 数据存储和排列"></a>18. 数据存储和排列</h2><h3 id="18-1-大小端模式"><a href="#18-1-大小端模式" class="headerlink" title="18.1 大小端模式"></a>18.1 大小端模式</h3><p>大端：一连串字节，与一连串地址，将高位字节存储在低位地址上，就是大端存储，这种存储方式方便人类阅读。</p><p>小端：一连串字节，与一连串地址，将低位字节存储在低位地址上，就是小端存储，这种存储方式方便机器阅读。</p><img src="https://pic.imgdb.cn/item/6612b2ba68eb9357137e4527.png" alt="计算机组成原理（二）——数据的表示与运算——大小端方式.png"><h3 id="18-2-边界对齐"><a href="#18-2-边界对齐" class="headerlink" title="18.2 边界对齐"></a>18.2 边界对齐</h3><p>边界对齐和边界不对齐是两种不同的数据存储方式，它们各自具有特定的优缺点。</p><p>边界对齐，也称为内存对齐，是处理器为了提高处理性能而对存取数据的起始地址所提出的一种要求。这种方式的主要优点在于它可以提高访存速度。当数据按照边界对齐的方式存储时，处理器可以更有效地访问这些数据，因为它们位于预期的地址边界上。这减少了处理器需要进行的额外计算和操作，从而提高了数据处理的速度和效率。此外，边界对齐也有助于减少缓存未命中的次数，进一步提高系统性能。</p><p>然而，边界对齐的缺点在于它可能牺牲主存空间。在某些情况下，为了满足对齐要求，可能需要在数据之间插入填充字节，这会导致存储空间的浪费。特别是在存储小量数据时，这种浪费可能更加明显。</p><p>相比之下，边界不对齐的存储方式可以节省主存空间。由于没有强制性的对齐要求，数据可以紧密地存储在内存中，减少了填充字节的使用。这在存储大量小量数据时尤为有用，因为可以更有效地利用存储空间。</p><p>然而，边界不对齐的缺点在于它可能牺牲访存速度。当处理器尝试访问未对齐的数据时，它可能需要进行额外的计算和操作来找到正确的数据位置。这增加了处理器的负担，可能导致性能下降。此外，未对齐的访问还可能引发硬件异常或错误，需要额外的错误处理机制。</p><p>综上所述，边界对齐和边界不对齐两种存储方式各有其优缺点。在选择使用哪种方式时，需要根据具体的应用场景和需求进行权衡。在需要提高访存速度和数据处理效率的场景中，边界对齐可能是一个更好的选择；而在需要节省主存空间的场景中，边界不对齐可能更为合适。</p><img src="https://pic.imgdb.cn/item/6612b37968eb9357137f7eef.png" alt="计算机组成原理（二）——数据的表示与运算——边界对齐方式.png"><h2 id="19-浮点数"><a href="#19-浮点数" class="headerlink" title="19. 浮点数"></a>19. 浮点数</h2><h3 id="19-1-浮点数的表示"><a href="#19-1-浮点数的表示" class="headerlink" title="19.1 浮点数的表示"></a>19.1 浮点数的表示</h3><img src="https://pic.imgdb.cn/item/66133f7268eb9357132d7fd9.png" alt="计算机组成原理（二）——数据的表示与运算——浮点数的表示.png"><p>浮点数在计算机里以阶码+尾数的形式存在，类比科学技术法a×10<sup>b</sup>，浮点数的真值表示形式为N&#x3D;r<sup>E</sup>×M。这里阶码的真值对应公式里的E，尾数的真值对应M，其中数符与阶符分别是尾数与阶码的符号位。一般数据在计算机里都是以二进制形式进行运算，所以r一般取2。根据前面所学的乘法运算，可以发现，E的大小与正负，决定着乘2还是除2或乘2的几次方，除2的几次方，这些结果最后都可以归结为尾数部分的小数点左移或右移几位。</p><p>注意，阶码常为用补码或移码表示的定点整数，而尾数常为用原码或补码表示的定点小数。</p><p>这里我们可以参考上图中例子里的a的真值求取。</p><p>但是，当我们求b的真值时会发现，求出b的尾数为001001，如果用1B空间存储的话，会发现，前面3位用来存储了阶码，剩下5位存储尾数显然不够，最后一位1会被舍弃，这样会丢失精度，如下图。出现这种情况，我们仍可以类比科学计数法标准化思想（小数点前仅一位a，且0&lt;a&lt;10），这时我们会发现，假如我左移一位，将阶码减1，丢失高位0，将低位1移入存储空间，这样对精度就没有影响了。这种思想就是浮点数的左规思想。</p><img src="https://pic.imgdb.cn/item/6613401b68eb9357132e5ef0.png" alt="计算机组成原理（二）——数据的表示与运算——浮点数规格化的引出.png"><p>有了浮点数左规，那逆向思考一下，就很容易想到浮点数的右规。不论是浮点数的左规还是右规，统一都可以理解为浮点数的规格化。</p><p>但是，右规与左规不同，左规通常出现在浮点数运算结果尾数低位有精度缺失的情况；而右规通常出现在浮点数运算结果出现假溢出的情况。</p><p>如果尾数采用双符号位，且双符号为10或01，这个时候显然出现溢出，结果出现严重误差。这时候我们可以通过右规思想，将尾数算数右移一位，阶码加1，便可得到正确的结果。</p><p>当然当存储空间有限时，这样的操作可能会导致低位精度缺失，例如8bit存储空间里，尾数存储位有6bit，且为01,1001，右移以后就变成了00,1100。虽然精度有所缺失，但显然要比出现重大误差要好，具体的可以参考下图的例子。</p><p>注意，采用双符号位进行溢出判断，可以挽救溢出，所以双符号位判断溢出也是最常用的一种方式。</p><img src="https://pic.imgdb.cn/item/6613407f68eb9357132eff4b.png" alt="计算机组成原理（二）——数据的表示与运算——浮点数规格化.png"><p>通过以上的了解，我们就可以对规格化的浮点数的特点进行一个简短的总结概述，具体如下图。</p><img src="https://pic.imgdb.cn/item/66134cb768eb935713457577.png" alt="计算机组成原理（二）——数据的表示与运算——浮点数规格化特点.png"><p>需要注意的就是原码与补码进行规格化的时候，要保证最高位是有效数值位。这里可以发现，原码的最高数值位不论是正数还是负数，都是有效数值位1，而补码的正数最高位是有效数值1。但是补码的负数的最高数值位是0这个非有效数字，这是因为，最高有效数值位的有效数字是根据真值转换成原码来看的，补码为0，对应的原码的最高位就是1。当然这里理解不了也没事，可以直接记住规格化的补码尾数，符号位与最高数值位一定相反。</p><p>还有一点，如图左下角的浮点数规格化以后的范围，规格化以后的数据有一个表示范围，如果超出这个范围的最大绝对值称为正上溢（或负上溢）如果小于这个范围的最小绝对值，则称为正下溢（或负下溢），如果是正下溢（或负下溢）则当为机器0处理，如果是正上溢（或负上溢），则机器会报异常。不过考研大纲这部分已删，了解即可。</p><img src="https://pic.imgdb.cn/item/6613501768eb9357134c6598.png" alt="计算机组成原理（二）——数据的表示与运算——浮点数表示小结.png"><h3 id="19-2-浮点数标准——IEEE-754"><a href="#19-2-浮点数标准——IEEE-754" class="headerlink" title="19.2 浮点数标准——IEEE 754"></a>19.2 浮点数标准——IEEE 754</h3><p>浮点数由阶码和尾数两个部分组成，如果不能采用统一的规则，规定阶码占多少位，尾数占多少位，阶码和尾数采用原码、补码还是移码表示，那么在信息传输中就会出现错误。所以，为了避免这种情况，IEEE 754就应运而生。</p><p>在IEEE 754 标准中，阶码采用移码的方式进行表示，移码的基础部分我们在本章第5个知识点里说过，可以翻到前面看看。因为阶码都是整数，而移码恰好也只能表示整数，所以为了充分利用资源，采用移码表示浮点数的阶码。在了解具体的表示过程之前，我们需要先对移码进行一个深入拓展。</p><h4 id="19-2-1-移码的拓展"><a href="#19-2-1-移码的拓展" class="headerlink" title="19.2.1 移码的拓展"></a>19.2.1 移码的拓展</h4><p>移码，在前面的定义是补码的符号位取反，但其实，移码的本身定义确是如下的公式，<font color=red><strong>移码&#x3D;真值+偏置值</strong></font>。</p><p>我们会先用二进制写出移码的真值，然后加上偏置值去求得移码。前面我们所说的符号取反，其实是偏置值取固定值的一种例子。</p><p>需要注意的是，通常移码的偏置值是一个非负整数。这是因为在移码的设计中，偏置值的主要目的是为了实现正数和负数的无符号表示，从而简化计算机的运算过程。</p><p>前面我们对移码的定义是对补码的符号位取反，其实就是加上了2<sup>n-1</sup>，其中n为移码的最大存储长度。例如，用8bit表示移码，真值-127的二进制形式是-1111111B，这个时候的偏置值就是2<sup>8-1</sup>&#x3D;128D&#x3D;10000000B，所以-127的移码&#x3D;-1111111B+10000000B&#x3D;00000001B。（注意这里的无符号数与有符号数的运算，在计组这门课里没有讲，所以大家可以手算，当然考研的时候也不会出机算过长，只会让大家手算将浮点数转换成IEEE 754标准。）</p><p>当然，偏置值不是固定的，也可以是其他数，在我们的IEEE 754标准里，阶码就由移码表示，且移码的偏置值就等于2<sup>n-1</sup>-1。</p><p>例如下图里的-128真值&#x3D;-10000000B，但是偏置值只有127D。这里因为是8位，所以可以看成mod2<sup>8</sup>的运算（2<sup>8</sup>&#x3D;1 0000 0000），所以127-128&#x3D;0111 1111+1 0000 0000-1000 0000&#x3D;1111 1111。</p><img src="https://pic.imgdb.cn/item/661363d268eb935713719f87.png" alt="计算机组成原理（二）——数据的表示与运算——移码拓展.png"><h4 id="19-2-2-IEEE754标准"><a href="#19-2-2-IEEE754标准" class="headerlink" title="19.2.2 IEEE754标准"></a>19.2.2 IEEE754标准</h4><img src="https://pic.imgdb.cn/item/6613639568eb935713713889.png" alt="计算机组成原理（二）——数据的表示与运算——IEEE754标准.png"><p>IEEE754标准与正常的浮点数表示格式不一样，具体格式如上图（上图给出C语言里三中国浮点数的格式）。在这里需要注意几个重点，在IEEE754标准里，因为阶码用移码表示，而移位通过偏置值的转换，是正整数，所以，可省略移码的符号位（默认为正）。尾数部分使用原码表示，前面我们说过，浮点数的尾数需要进行规格化，而规格化以后的最高位必须是有效数字位，而使用原码表示，最高位必定为1，所以这里，我们可以把尾数的最高位省略（默认为1）。如上图，虽然在短浮点数里，尾数只有23位，但实际上有24位（最高位1省略）。转换公式在上图也给出（公式不是万能的，要理解掌握推导过程，学会具体问题具体分析）。</p><p>另外，阶码全1、全0的两种情况，是用作特殊用途，所以阶码的实际表示范围要忽略这两位。如上图短浮点数，阶码8位，表示范围时-128<del>-127，但转换成移码就是1111 1111、0000 0000</del>1111 1110。其中1111 1111和0000 0000有特殊作用，所以阶码实际的表示范围是-126~127。</p><p><strong>接下来举个例题</strong>：</p><img src="https://pic.imgdb.cn/item/661366f368eb935713776035.png" alt="计算机组成原理（二）——数据的表示与运算——IEEE754标准例题.png"><p>这个例题大家可以手算一下，很简单，我贴张图在这，方便自己下次看的时候回忆推导过程。</p><img src="https://pic.imgdb.cn/item/661368f868eb9357137b331b.png" alt="计算机组成原理（二）——数据的表示与运算——单精度浮点数绝对值.png"><p>接下来，我们讨论一下，IEEE754标准下的浮点数的最大绝对值与最小绝对值的问题。这里我们以单精度浮点数为例，若绝对值最小，因为阶码表示2的次方项，所以阶码越小数值越小，而尾数也要取绝对值最小的数，因为在754标准下，尾数是省略1的，所以我们尾数的最小值是1.M（M&#x3D;0），M代表尾数值。而最大绝对值就是阶码最大，尾数也是最大的，对应的就是阶码位1111 1110，尾数为1.M（M&#x3D;1）。具体范围如上图。</p><p>上述表示范围里，绝对值最小的数是1.M(M&#x3D;0)。那有没有更小的数呢？答案是有的，这就牵扯到阶码全0全1的情况。如果用无符号整数来看阶码，那阶码的表示范围应该是1~254（我们把全0和全1的情况舍掉了）。丢掉的0和255就是阶码全0和全1的情况。</p><p>如果阶码全为0，尾数M不全为0时，表示的就是非规格化的小数，在这里我们把小数点前隐藏的1默认为0，阶码的真值固定视为0。这时候表示的浮点数就是0.M。例如表示0.001×2<sup>-126</sup>，对应的就是E&#x3D;0，M&#x3D;0.001，数符&#x3D;0。</p><p>如果阶码全为0，尾数M全为0时，表示的就是真值的绝对值为0的数。</p><p>如果阶码全为1，尾数M全为0时，表示的就是无穷大，至于正无穷大还是负无穷大要看符号位。</p><p>如果阶码全为1，尾数M不全为0时，则表示非数值。</p><img src="https://pic.imgdb.cn/item/6613756268eb93571394fd20.png" alt="计算机组成原理（二）——数据的表示与运算——阶码全0全1.png"><h4 id="19-2-3-知识回顾"><a href="#19-2-3-知识回顾" class="headerlink" title="19.2.3 知识回顾"></a>19.2.3 知识回顾</h4><img src="https://pic.imgdb.cn/item/6613759168eb935713956a70.png" alt="计算机组成原理（二）——数据的表示与运算——知识回顾.png"><h3 id="19-3-浮点数运算"><a href="#19-3-浮点数运算" class="headerlink" title="19.3 浮点数运算"></a>19.3 浮点数运算</h3><h4 id="19-3-1-浮点数的加减运算"><a href="#19-3-1-浮点数的加减运算" class="headerlink" title="19.3.1 浮点数的加减运算"></a>19.3.1 浮点数的加减运算</h4><img src="https://pic.imgdb.cn/item/6613faa868eb9357136cf79b.png" alt="计算机组成原理（二）——数据的表示与运算——浮点数加减运算.png"><p>浮点数的加减运算分为五步：</p><ol><li>对阶。将两个浮点数的阶数进行对阶操作。一般情况下，我们用小阶去对大阶。这样小阶对应的尾数只需右移即可。如果用大阶对小阶，可能出现大阶左移，导致小数点前有效位不只1位。例如1.2×2<sup>10</sup>与1.3×2<sup>13</sup>。我们会选择将1.2×2<sup>10</sup>转换成0.0012×2<sup>13</sup>，来进行对阶操作。</li><li>尾数加减。将对阶以后的浮点数的尾数进行加减操作。</li><li>规格化。加减以后可能出现小数点前有效位不只1位，或无有效位的情况，这个时候需要进行规格化处理。</li><li>舍入。舍入一般用来保留位数，具体的舍入有两种情况，我们再后面进行细说。</li><li>判溢出。最后一步需要对阶码进行一个判断，如果阶码超出存储最大值，这个时候说明数据存在溢出。</li></ol><p>接下来我们以一个例子演示上面的步骤：</p><img src="https://pic.imgdb.cn/item/6613fe1268eb935713708495.png" alt="计算机组成原理（二）——数据的表示与运算——浮点数加减运算例子.png"><p>上面是浮点数加减运算的例子，注意题目给的是按机器补码浮点运算规则计算，所以运算过程中采用的都是补码，可以手动跟着算一遍，按照步骤算一遍就全都明白了。需要小心的是，我们在上面的例子里可以看到在尾数加减以后，算得的符号位为10，说明数据发生溢出，但这个溢出是可以挽回的，记得我们在19.1里说过（忘了可以回去看一下），双符号位可以用来拯救溢出。所以这里进行右移操作，将数据规格化处理。</p><p>右移时，最低位被舍入，但这里被移除的是0，所以对数据没有影响。但如果移除的是1，那对精度就有影响力，接下来，我们就对舍入进行一个讲解。</p><p>舍入有两种方法：</p><p>​第一种：0舍1入：如果移除位是0，则直接舍弃即可。如果是1就在尾数剩下的位置上进行加1操作。</p><p>​第二种：恒置1法：不论右移时丢弃的数值位是1还是0，都在右移后的位数末尾恒置1。</p><p>具体的可以参考下面的图。</p><img src="https://pic.imgdb.cn/item/6613fea268eb93571370eb15.png" alt="计算机组成原理（二）——数据的表示与运算——舍入.png"><p>这里有一种情况，有些计算机为了保证数据在运算过程中的精确度，可能会把尾数的数据拿出去放到一个更大的内存空间里进行操作，操作以后原尾数长度再拼回浮点数。</p><h4 id="19-3-2-强制转化"><a href="#19-3-2-强制转化" class="headerlink" title="19.3.2 强制转化"></a>19.3.2 强制转化</h4><img src="https://pic.imgdb.cn/item/6614013e68eb935713763e04.png"><p>强制转换在c语言里我们都有学过，所以这里简单提一下。以float类型为例，在32位机器里，float类型以IEEE754标准存储，即1位数符位，8位阶码，23位数据（实际24位，最高位1隐藏）。而int型是1位符号位，31位数据位。虽然float数据位少，但float表示数据范围大，所以int向float转化不会存在溢出，但int数据位多，所以会丢失精度。而float向int类型转换就有可能溢出，另外float型如果表示0.00001这样的小数，向int型转换时，int会截取小数点前的位置，表示0，f所以loat转int也可能会产生精度损失（这里大家都学过c语言，float转int会丢失精度大家写过代码都清楚，所以结合写代码的经历理解）。</p><h4 id="19-3-3-浮点数运算小结"><a href="#19-3-3-浮点数运算小结" class="headerlink" title="19.3.3 浮点数运算小结"></a>19.3.3 浮点数运算小结</h4><img src="https://pic.imgdb.cn/item/6614015a68eb935713766268.png" alt="计算机组成原理（二）——数据的表示与运算——浮点数运算小结.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（二）——物理层</title>
      <link href="/2024/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2024/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="1-物理层的基本概念"><a href="#1-物理层的基本概念" class="headerlink" title="1. 物理层的基本概念"></a>1. 物理层的基本概念</h2><p>物理层考虑的是怎样才能在连接各台计算机的传输媒体上<font color=red><strong>传输数据比特流</strong></font>，而不是具体的传输介质。</p><p>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</p><p>物理层的主要任务：确定与传输媒体<font color=blue><strong>接口</strong></font>有关的一些特性。</p><p>物理层接口的特性的内容：</p><ol><li>机械特性。指明接口所用的接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li><li>电气特性。指明在接口电缆的各条线上的电压范围、传输速率和距离限制等。</li><li>功能特性。指明某条线上出现的某一电平的电压的意义，以及每条线的功能。</li><li>过程特性。也称规程特性。指明对不同功能的各种可能事件的出现顺序（即定义各条物理线路的工作规程和时序关系）。</li></ol><img src="https://pic.imgdb.cn/item/66096ae79f345e8d03f38f39.png" alt="计算机网络（二）——物理层——物理层的概念.png"><h2 id="2-数据通信"><a href="#2-数据通信" class="headerlink" title="2. 数据通信"></a>2. 数据通信</h2><h3 id="2-1-典型的数据通信模型"><a href="#2-1-典型的数据通信模型" class="headerlink" title="2.1 典型的数据通信模型"></a>2.1 典型的数据通信模型</h3><img src="https://pic.imgdb.cn/item/66096c019f345e8d03fd68cc.png" alt="计算机网络（二）——物理层——数据通信模型.png"><h3 id="2-2-数据通信相关概念"><a href="#2-2-数据通信相关概念" class="headerlink" title="2.2 数据通信相关概念"></a>2.2 数据通信相关概念</h3><p>（1）通信的目的：传送消息。</p><p>（2）数据：传送信息的实体，通常是有意的符号符号序列。</p><p>（3）信号：数据的电气或电磁表现。</p><p>（4）信源：产生和发送数据的源头。</p><p>（5）信宿：接收数据的终点。</p><p>（6）信道：信号的传输介质，一条双向通信的线路包含一个发送信道和一个接收信道。</p><p>（7）噪声源：信道上的噪声及分散在通信系统其他各处的噪声的集中表示。</p><p>补充拓展：</p><p>（1）数据和信号都有模拟或数字之分：模拟数据（或模拟信号）的取值是连续的；数字数据（或数字信号）的取值是离散的。</p><p>（2）信道的两种分类方式：</p><ol><li>按传输信号形式的不同，可以分为传送模拟信号的模拟信道和传送数字信号的数字信道。</li><li>按传输介质的不同，可分为无线信道和有线信道。</li></ol><p>（3）信道上传送的信号也有基带信号和宽带信号之分。</p><ol><li>基带信号：将数字信号1和0直接用两种不同的电压表示，然后送到数字信道上传输，这种传输方式也称为基带传输。</li><li>宽带信号：将基带信号进行调制，形成频分复用模拟信号，然后送到模拟信道上传输，这种传输方式也称为宽带传输。</li></ol><p>（4）信道上的噪声是指信道中存在的不需要的电信号。</p><img src="https://pic.imgdb.cn/item/660973069f345e8d03482f14.png" alt="计算机网络（二）——物理层——通信概念.png"><h3 id="2-3-传输方式"><a href="#2-3-传输方式" class="headerlink" title="2.3 传输方式"></a>2.3 传输方式</h3><h4 id="2-3-1-串行传输和并行传输"><a href="#2-3-1-串行传输和并行传输" class="headerlink" title="2.3.1 串行传输和并行传输"></a>2.3.1 串行传输和并行传输</h4><p>串行传输：数据一个比特一个比特依次发送。串行传输适合远距离传输，例如计算机网络之间的数据传输。</p><p>并行传输：一次发送n个比特，为此在发送端和接收端之间有n个线路。并行传输适合近距离传输，例如计算机内部的总线传输（常见的总线宽度有8位、16位、32位和64位）。</p><img src="https://pic.imgdb.cn/item/660973d69f345e8d03505a1b.png" alt="计算机网络（二）——物理层——并行传输和串行传输.png"><h4 id="2-3-2-同步传输和异步传输"><a href="#2-3-2-同步传输和异步传输" class="headerlink" title="2.3.2 同步传输和异步传输"></a>2.3.2 同步传输和异步传输</h4><p>同步传输：数据块以稳定的比特流的形式传输，字节之间没有间隔。</p><p>异步传输：以字节为独立的传输单位，字节之间的时间间隔不固定。</p><img src="https://pic.imgdb.cn/item/660975b49f345e8d0363c8c1.png" alt="计算机网络（二）——物理层——同步和异步（1）.png"><img src="https://pic.imgdb.cn/item/660975ff9f345e8d0366b898.png" alt="计算机网络（二）——物理层——同步和异步（2）.png"><h4 id="2-3-3-三种通信方式"><a href="#2-3-3-三种通信方式" class="headerlink" title="2.3.3 三种通信方式"></a>2.3.3 三种通信方式</h4><p>（1）单向通信：也称单工通信。只有一个方向的通信而没有反方向的交互，如无线广播、电视广播等。</p><p>（2）半双工通信：通信双方都可以发送或接收信息，但任何一方都不能同时发送和接收信息。</p><p>（3）全双工通信：通信双方都可以同时发送和接收信息。</p><p>注意：单向通信只有一个信道，而半双工和全双工通信都需要两个信道，每个方向一个信道。</p><h3 id="2-4-码元"><a href="#2-4-码元" class="headerlink" title="2.4 码元"></a>2.4 码元</h3><p>码元：码元代表不同离散数值的基本波形（实质上就是构成信号的一段波形）。码元是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。</p><img src="https://pic.imgdb.cn/item/660e429b9f345e8d0336e9d1.png" alt="计算机网络（二）——物理层——码元.png"><p>注意：4进制码元说明码元离散状态有4个，可以知道码元有4种不同的信号波形，可以说明一个码元携带2bit的信息量。</p><h3 id="2-5-数据传输速率"><a href="#2-5-数据传输速率" class="headerlink" title="2.5 数据传输速率"></a>2.5 数据传输速率</h3><p>速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用<font color=red><strong>码元传输速率</strong></font>和<font color=red><strong>信息传输速率</strong></font>来表示。</p><h4 id="2-5-1-码元传输速率"><a href="#2-5-1-码元传输速率" class="headerlink" title="2.5.1 码元传输速率"></a>2.5.1 码元传输速率</h4><p><font color=blue><strong>码元传输速率</strong></font>：又称<strong>波特率、码元速率、波形速率、调制速率、符号速率</strong>等，表示单位时间内数字通信系统所传输的码元数，单位是波特（Baud）。1波特表示每秒传输1码元。码元速率与进制数无关，只与码元长度有关。</p><img src="https://pic.imgdb.cn/item/660e45d49f345e8d034ce0ee.png" alt="计算机网络（二）——物理层——码元传输速率.png"><h4 id="2-5-2-信息传输速率"><a href="#2-5-2-信息传输速率" class="headerlink" title="2.5.2 信息传输速率"></a>2.5.2 信息传输速率</h4><p><font color=blue><strong>信息传输速率</strong></font>：又称<strong>比特率</strong>，表示单位时间内数字通信系统所传输的二进制码元数（即比特数），单位是比特&#x2F;秒（b&#x2F;s）。</p><h4 id="2-5-3-两种传输速率小结"><a href="#2-5-3-两种传输速率小结" class="headerlink" title="2.5.3 两种传输速率小结"></a>2.5.3 两种传输速率小结</h4><p>(1) <font color=blue><strong>码元传输速率</strong></font>探究的是1s传输多少个码元，<font color=blue><strong>信息传输速率</strong></font>探究的是1s传输多少个比特。</p><p>(2) 在二进制数字信号中能够，他的码元传输速率就对等于他的信息传输速率，因为二进制数字信号的码元，携带1bit信息，所以两者对等（同数不同意）。</p><p>(3) 若一个码元携带 n bit的信息量，则 M Baud的码元传输速率所对应的信息传输速率为M×n bit&#x2F;s。</p><h3 id="2-6-带宽"><a href="#2-6-带宽" class="headerlink" title="2.6 带宽"></a>2.6 带宽</h3><p>在<font color=green><strong>模拟信号系统</strong></font>中，带宽（又称频率带宽）用来表示某个信道所能传输信号的频率范围，即最高频率与最低频率直插，单位是赫兹（Hz）。</p><p>在<font color=green><strong>计算机网络</strong></font>中，带宽用来表示网络的通信线路所能传输数据的能力，即最高数据率，此时带宽的单位是b&#x2F;s。</p><p>注意：拥有更宽的带宽，也就有更大的信息运送能力。</p><img src="https://pic.imgdb.cn/item/660e4f869f345e8d0390af4b.png" alt="计算机网络（二）——物理层——带宽.png"><h2 id="3-信道的极限容量（重点）"><a href="#3-信道的极限容量（重点）" class="headerlink" title="3. 信道的极限容量（重点）"></a>3. 信道的极限容量（重点）</h2><h3 id="3-1-失真"><a href="#3-1-失真" class="headerlink" title="3.1 失真"></a>3.1 失真</h3><p>任何实际的信道都是不理想的，信号在信道上传输时会不可避免地产生失真。</p><p>失真：指信号在传输过程中与原有信号或标准相比发生了偏差。</p><p>失真产生的因素：</p><ol><li>码元传输速率。码元传输速率越高，越容易失真。</li><li>信号传输距离。信号传输距离越远，干扰越久，信号衰减也越久，信号受到影响也越大。</li><li>噪声干扰。噪声干扰越多，信号越容易失真。</li><li>传输媒体质量。传输媒体质量越差，信号失真越严重。</li></ol><p>在信宿接收到信源的信号会出现两种情况，一种失真但可识别；另一种失真很大已经无法识别。</p><p>如果是第一种情况，失真对目标机的接收来说产生的影响并不大，因为接收机仍能判断出码元界限。</p><p>但如果是第二种情况，失真很大，这个时候在输出端就很难判断这个信号里码元间的分界，信号波形失去了码元之间的清晰界限，这种现象叫做<font color=red><strong>码间串扰</strong></font>。</p><p>在计算机网络中的码间串扰，是指因为码元传输速率太快，导致码元间传输界限不清晰，失去对0和1的判定。</p><img src="https://pic.imgdb.cn/item/660e538b9f345e8d03ae416a.png" alt="计算机网络（二）——物理层——码间串扰.png"><h3 id="3-2-奈奎斯特定理（奈氏准则）"><a href="#3-2-奈奎斯特定理（奈氏准则）" class="headerlink" title="3.2 奈奎斯特定理（奈氏准则）"></a>3.2 奈奎斯特定理（奈氏准则）</h3><p>为了解决码间串扰的问题，于是奈奎斯特在1924年提出了奈奎斯特定理。</p><p><font color=red><strong>奈氏准则</strong></font>规定：在<font color=blue><strong>理想低通（无噪声，带宽受限）条件</strong></font>下，为了避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz。</p><p><font color=red><strong>公式：理想低通信道下的极限数据传输率&#x3D;2Wlog<sub>2</sub>V (单位b&#x2F;s)</strong></font> </p><p>在该公式中V是码元离散电平数目（几种码元），W是带宽。</p><p>奈氏准则结论：</p><ol><li>任何信道中，码元传输速率都是有上限的。</li><li>信道的频率带宽越宽，就越可用更高的速率有效地传输码元。</li><li>奈氏准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制。</li><li>由于码元的传输速率受奈氏准则制约，所以要提高数据传输速率，就要设法让每个码元携带更多比特信息量，所以要采用多元制的调制方法。</li></ol><img src="https://pic.imgdb.cn/item/660e5d819f345e8d03c802b0.png" alt="计算机网络（二）——物理层——奈氏准则.png"><img src="https://pic.imgdb.cn/item/660e63b068eb93571319f262.png" alt="计算机网络（二）——物理层——奈氏准则补充.png"><h3 id="3-3-香农定理"><a href="#3-3-香农定理" class="headerlink" title="3.3 香农定理"></a>3.3 香农定理</h3><p>奈氏准则规定了最高码元传输速率，但并没有规定最高比特传输速率，所以人们又提出了香农定理，来解决比特的传输速率问题。</p><p>香农定理与奈氏准则相比，不仅定义了在信道当中，比特传输的极限传输速率，还考虑到了信道当中实际会存在的电磁干扰（即噪声影响）。</p><p><font color=red><strong>香农定理</strong></font>给出<font color=blue><strong>带宽受限且有高斯噪声干扰的信道的极限数据传输速率，当用该速率传输数据时，不会产生误差</strong></font>。</p><p><font color=red><strong>公式：信道的极限数据传输速率&#x3D;Wlog<sub>2</sub>(1+S&#x2F;N) (单位为b&#x2F;s)</strong></font></p><p>在该公式中，W是信道的频率带宽，S为信道内所传输信号的平均功率，N为信道内的高斯噪声功能。S&#x2F;N为信噪比，即信号的平均功率与噪声的平均功率纸币，信噪比&#x3D;10log<sub>10</sub>(S&#x2F;N) (单位为dB)。</p><img src="https://pic.imgdb.cn/item/660e62dd68eb935713185f6a.png" alt="计算机网络（二）——物理层——香农定理.png"><p>香农定理的一些推论：</p><img src="https://pic.imgdb.cn/item/660e632a68eb93571318fafc.png" alt="计算机网络（二）——物理层——香农定理推论.png"><h3 id="3-4-信道小结"><a href="#3-4-信道小结" class="headerlink" title="3.4 信道小结"></a>3.4 信道小结</h3><p>(1) 在奈氏准则和香农定理里，信道带宽（W），是指信道能通过的最高频率和最低频率之差，单位使用的是Hz。</p><p>(2) 奈氏准则限制的是码元传输速率有一个上限，香农定理才是真正的限制信息传输速率，即比特率有一个上限。</p><p>(3) 补充——低通、高通、带通、带阻</p><p>低通：允许低于截止频率的信号分量通过。</p><p>高通：允许高于某一频率以上信号分量通过。</p><p>带通：允许某一频率范围内的信号分量通过。</p><p>带阻：不允许某一频率范围内的信号分量通过。</p><p>这部分可以参考这个大佬的博客：<a href="https://blog.csdn.net/chehec2010/article/details/95941122">低通，高通，带通，带阻滤波器的定义</a></p><img src="https://pic.imgdb.cn/item/660e648168eb9357131b9b10.png" alt="计算机网络（二）——物理层——信道小结.png"><h2 id="4-编码与调制"><a href="#4-编码与调制" class="headerlink" title="4. 编码与调制"></a>4. 编码与调制</h2><p>信号是数据的具体表现形式，数据无论是数字的还是模拟的，为了传输的目的，都要转换成信号。<strong>将数据转换为模拟信号的过程称为调制，将数据转换为数字信号过层称为编码。</strong></p><p>数字数据可通过数字发送器转换为数字信号传输，也可通过调制器转换成模拟信号传输；同理，模拟数据可通过PCM编码器转换成数字信号传输，也可替换放大器调制器转换成模拟信号传输。</p><img src="https://pic.imgdb.cn/item/660e6d6968eb9357132e935f.png" alt="计算机网络（二）——物理层——四种编码与调制.png"><h3 id="4-1-基带信号与宽带信号"><a href="#4-1-基带信号与宽带信号" class="headerlink" title="4.1 基带信号与宽带信号"></a>4.1 基带信号与宽带信号</h3><img src="https://pic.imgdb.cn/item/660e6c6f68eb9357132bb000.png" alt="计算机网络（二）——物理层——基带与宽带.png"><h3 id="4-2-数字数据编码为数字信号"><a href="#4-2-数字数据编码为数字信号" class="headerlink" title="4.2 数字数据编码为数字信号"></a>4.2 数字数据编码为数字信号</h3><p>数字数据编码用于基带传输中，即在基本不改变数字数据信号频率的情况下，直接传输数字信号。具体用什么样的数字信号表示0及用什么样的数字信号表示1，就是所谓的编码。</p><img src="https://pic.imgdb.cn/item/660e6ed668eb935713318699.png" alt="计算机网络（二）——物理层——数字数据转为数字信号.png"><p>(1) <font color=blue><strong>归零(RZ)编码：</strong></font>用高电平表示1，低电平表示0（或者相反），每个码元传输结束后信号都要“归零”。<font color=green>&gt;（注意：这里低电平表示的0是数字信号的0，而非零电平；最后归零，指的是电平变为零电平。）</font></p><p>每个码元传输结束后都要“归零”，所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号。</p><p>实际上，归零编码相当于把时钟信号用“归零”方式编码在了数据之内，这称为<font color=red><strong>“自同步”</strong></font>信号。</p><p>但是，归零编码中大部分的数据带宽，都用来传输“归零”而浪费掉了。</p><p>(2) <font color=blue><strong>不归零(NRZ)编码：</strong></font>与RZ编码的区别是不用归零，一个时钟全部用来传输数据，编码效率最高。但NRZ编码的收发双发存在同步问题（即如果出现连续三个数字信号1，则接受方无法进行判断），为此需要额外一根传输线来传输时钟信号，便于发送方和接收同步。但对于计算机网络，宁愿利用这根传输线传输数据信号，而不是传输时钟信号！</p><p>(3) <font color=blue><strong>反向归零(NRZI)编码：</strong></font>与NRZ编码的区别是用电平跳变表示0，电平保持不变表示1。跳变本身可作为一种通知机制。这种编码方式集成了前两种编码的优点，既能传输时钟信号，又能尽量不损失系统带宽。</p><p>(4) <font color=blue><strong>曼彻斯特编码：</strong></font>每个码元中间都发生电平跳变，电平跳变既作为时钟信号（用于同步），又作为数据信号。可用向下跳变表示1，向上跳变表示0，或采用相反规定。</p><p>曼彻斯特编码所占的频带宽带是原始的基带宽度的两倍。每一个码元都被调成两个电平。所以数据传输速率只有调制速率的1&#x2F;2。</p><p>该编码一个时钟周期变化两次，开始一次，中间跳变一次。所以调制速率是比特传输速率的2倍。</p><p>(5) <font color=blue><strong>差分曼彻斯特编码：</strong></font>每个码元的中间都发生电平跳变，与曼彻斯特编码不同的是，电平跳变进表示时钟信号，而不表示数据。数据的表示在于每个码元开始处是否有电平跳变：有跳变表示0，无跳变表示1.差分曼彻斯特编码有更强的抗干扰能力。</p><h3 id="4-3-模拟数据转换为数字信号"><a href="#4-3-模拟数据转换为数字信号" class="headerlink" title="4.3 模拟数据转换为数字信号"></a>4.3 模拟数据转换为数字信号</h3><img src="https://pic.imgdb.cn/item/660e994c68eb93571384ddbd.png" alt="计算机网络（二）——物理层——模拟数据转为数字信号.png"><h3 id="4-4-数字数据调制为模拟信号"><a href="#4-4-数字数据调制为模拟信号" class="headerlink" title="4.4 数字数据调制为模拟信号"></a>4.4 数字数据调制为模拟信号</h3><p>数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。</p><p>数字调制的基本方法有三种：</p><ol><li><font color=purple>&lt;<strong>调幅(AM)</strong></font>：也称幅移键控（ASK）。通过改变载波的振幅来改变数字信号1和0。</li><li><font color=purple><strong>调频(FM)</strong></font>：也称频移键控（FSK）。通过改变载波的频率来表示数字信号1和0。</li><li><font color=purple><strong>调相(PM)</strong></font>：也称相移键控（PSK）。通过改变载波的相位来表示数字信号1和0。</li></ol><img src="https://pic.imgdb.cn/item/660e9de468eb935713947d9e.png" alt="计算机网络（二）——物理层——三种调制方法.png"><p>通过上面的了解，我们可以知道数字数据如何调制为模拟信号，但是使用基本调制方法，1个码元只能包含1个比特信息。如何能使1个码元包含更多的比特呢？</p><p>答案就是可以使用混合调整的方法。但是频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的一个。所以我们只能挑选相位或频率来和振幅进行混合调制。</p><p>通常情况下，选择相位和振幅联合调制，这种调制方式称为<font color=purple><strong>正交振幅调制（QAM）</strong></font>。</p><p><strong>混合调制举例——正交振幅调制QAM-16：</strong></p><img src="https://pic.imgdb.cn/item/660e9fe868eb935713981603.png" alt="计算机网络（二）——物理层——QAM16.png"><h3 id="4-5-模拟数据调制为模拟信号"><a href="#4-5-模拟数据调制为模拟信号" class="headerlink" title="4.5 模拟数据调制为模拟信号"></a>4.5 模拟数据调制为模拟信号</h3><p>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的。</p><h2 id="5-数据交换方式"><a href="#5-数据交换方式" class="headerlink" title="5. 数据交换方式"></a>5. 数据交换方式</h2><p>数据交换的方式有三种，分别是电路交换、报文交换、分组交换。</p><p>其中分组交换又分为数据报方式和虚电路方式。</p><p>然而电路交换、报文交换、分组交换的一些基础性知识，在计算机网络（一）这篇文章里已经介绍过，可以参考我的这篇博客：<a href="https://blog.csdn.net/qq_63040545/article/details/136405996?spm=1001.2014.3001.5501">电路交换、报文交换和分组交换</a>。这里对于三种分组方式就不再介绍。着重说一下分组交换的两种方式：数据报方式和虚电路方式。</p><h3 id="5-1-数据报方式"><a href="#5-1-数据报方式" class="headerlink" title="5.1 数据报方式"></a>5.1 数据报方式</h3><img src="https://pic.imgdb.cn/item/660f6d4768eb935713ed6861.png" alt="计算机网络（二）——物理层——数据报过程.png"><p>注意：主机B收到的分组并不一定是按照发送顺序排列的，所以主机B还要对数据进行重组。</p><img src="https://pic.imgdb.cn/item/660f6dea68eb935713eec4b5.png" alt="计算机网络（二）——物理层——数据报特点.png"><p>注意：交换结点丢弃部分分组时，并不是该分组就无法到达目标主机，发送端还会重新发送一遍，所以，最后只是到达早晚的问题。但是需要提出的是，这里发送端的重发，并不是立刻重发的，当中间节点（如路由器或交换机）由于各种原因（如网络拥塞、缓冲区溢出、硬件故障等）丢弃了数据报时，发送方和接收方都不会立即得知。发送方会继续发送后续的数据报，而接收方在接收到不连续的数据报时，可能会发现数据丢失的情况，但这已经是在数据丢失之后的事情了。总的来说，数据报在传送过程中如果数据被中间节点丢弃，通常需要在应用层或传输层采取措施来处理这种情况。这些措施可能包括应用层重传、使用更可靠的传输层协议、网络层优化以及流量控制等。</p><h3 id="5-2-虚电路"><a href="#5-2-虚电路" class="headerlink" title="5.2 虚电路"></a>5.2 虚电路</h3><img src="https://pic.imgdb.cn/item/660f6f3368eb935713f18a89.png" alt="计算机网络（二）——物理层——虚电路.png"><p>注意：释放连接的过程，如果是主机A想释放连接，则主机A会向主机B发送释放请求，主机B确认以后，会返回确认释放信息，并逐层释放连接（与电路交换释放方式一样）。总的来说就是释放是A提出的，但是是从B端开始向A端进行释放。</p><p>虚电路建立的是逻辑连接，而非物理连接，这点与电路交换是不同的。</p><img src="https://pic.imgdb.cn/item/660f815268eb9357131874c2.png" alt="计算机网络（二）——物理层——虚电路特点.png"><h3 id="5-3-数据报与虚电路的对比"><a href="#5-3-数据报与虚电路的对比" class="headerlink" title="5.3 数据报与虚电路的对比"></a>5.3 数据报与虚电路的对比</h3><img src="https://pic.imgdb.cn/item/660f818768eb93571318f773.png" alt="计算机网络（二）——物理层——数据报与虚电路对比.png"><h2 id="6-物理层传输介质"><a href="#6-物理层传输介质" class="headerlink" title="6. 物理层传输介质"></a>6. 物理层传输介质</h2><p><strong>传输介质也称传输媒体</strong>，是数据传输系统中发送器和接收器之间的<font color=red><strong>物理通路</strong></font>。</p><p>传输介质可分为：</p><ol><li>导向传输介质，指铜线或光纤等，电磁波被导向为沿着固体介质传播；</li><li>非导向传输介质，指自由空间（空气、真空或海水），电磁波在非导向传输介质中的传输称为无线传输。</li></ol><p><font color=red><strong>需要注意的是，传输媒体不属于物理层，它在物理层之下！</strong></font></p><img src="https://pic.imgdb.cn/item/660ea23b68eb9357139f89e3.png" alt="计算机网络（二）——物理层——传输介质及分类.png"><h3 id="6-1-双绞线"><a href="#6-1-双绞线" class="headerlink" title="6.1 双绞线"></a>6.1 双绞线</h3><img src="https://pic.imgdb.cn/item/660ea2af68eb935713a07717.png" alt="计算机网络（二）——物理层——双绞线.png"><p>双绞线绞合的作用：抵御部分来自外界的电磁波干扰；减少相邻导线的电磁干扰。</p><h3 id="6-2-同轴电联"><a href="#6-2-同轴电联" class="headerlink" title="6.2 同轴电联"></a>6.2 同轴电联</h3><img src="https://pic.imgdb.cn/item/660ea34d68eb935713a166fa.png" alt="计算机网络（二）——物理层——同轴电缆.png"><h3 id="6-3-光纤"><a href="#6-3-光纤" class="headerlink" title="6.3 光纤"></a>6.3 光纤</h3><img src="https://pic.imgdb.cn/item/660ea3ba68eb935713a1d9b6.png" alt="计算机网络（二）——物理层——光纤.png"><img src="https://pic.imgdb.cn/item/660ea41068eb935713a26c83.png" alt="计算机网络（二）——物理层——单模光纤和多模光纤.png"><p><strong>光纤的特点：</strong></p><ol><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。</li></ol><h3 id="6-4-无线传输介质"><a href="#6-4-无线传输介质" class="headerlink" title="6.4 无线传输介质"></a>6.4 无线传输介质</h3><h4 id="6-4-1-无线波"><a href="#6-4-1-无线波" class="headerlink" title="6.4.1 无线波"></a>6.4.1 无线波</h4><p>无线电波具有较强的穿透能力，可以传输很长的距离，因此广泛用于通信领域。</p><h4 id="6-4-2-微波、红外线和激光"><a href="#6-4-2-微波、红外线和激光" class="headerlink" title="6.4.2 微波、红外线和激光"></a>6.4.2 微波、红外线和激光</h4><p>目前高带宽的无限通信主要使用三种技术：微波、红外线和激光。它们都需要在发送方和接收方之间有一条视线通路，有很强的方向性，沿直线传播。不同的是，红外通信和激光通信将要传输的信号分别转换为各自的信号格式，即红外光信号和激光信号，再直接在空间中传播。</p><h5 id="6-4-2-1-微波"><a href="#6-4-2-1-微波" class="headerlink" title="6.4.2.1 微波"></a>6.4.2.1 微波</h5><p>微波通信的频率较高，频段范围也很宽，载波频率通常为2~40GHz。与通常的无限电波不同，微波通信的信号是沿着直线传播的，因此在地面上的传播距离有限，超过一定距离后就要使用中继站来接力。</p><p>卫星通信利用地球同步卫星作为中继来转发微波信号。卫星通信优点是通信容量大、距离远、覆盖广，缺点是保密性差、端到端传播时延长。</p><p>微波通信优点：</p><ol><li>通信容量大。</li><li>距离远。</li><li>覆盖广。</li><li>广播通信和多址通信。</li></ol><p>微波通信缺点：</p><ol><li>传播时延长。</li><li>受气候影响大。</li><li>误码率较高。</li><li>成本高。</li></ol><h5 id="6-4-2-2-红外线通信"><a href="#6-4-2-2-红外线通信" class="headerlink" title="6.4.2.2 红外线通信"></a>6.4.2.2 红外线通信</h5><p>红外通信有很多缺点，目前已经处于淘汰边缘。</p><p>红外通信缺点：</p><ol><li>需要点对点无线传输。</li><li>沿直线传输，中间不能有障碍物，传输距离短。</li><li>传输速率低（4Mb&#x2F;s~16Mb&#x2F;s）.</li></ol><h5 id="6-4-2-3-激光通信"><a href="#6-4-2-3-激光通信" class="headerlink" title="6.4.2.3 激光通信"></a>6.4.2.3 激光通信</h5><p>激光通信同红外通信一样需要将传输的信号转换为自己的信号格式，即激光信号，才可直接在空间中传播。</p><h2 id="7-物理层设备"><a href="#7-物理层设备" class="headerlink" title="7. 物理层设备"></a>7. 物理层设备</h2><h3 id="7-1-中继器"><a href="#7-1-中继器" class="headerlink" title="7.1 中继器"></a>7.1 中继器</h3><img src="https://pic.imgdb.cn/item/660ea83068eb935713adbef4.png" alt="计算机网络（二）——物理层——中继器.png"><h3 id="7-2-集线器"><a href="#7-2-集线器" class="headerlink" title="7.2 集线器"></a>7.2 集线器</h3><img src="https://pic.imgdb.cn/item/660ea86768eb935713add5db.png" alt="计算机网络（二）——物理层——集线器.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（二）——栈与队列与数组</title>
      <link href="/2024/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E6%95%B0%E7%BB%84/"/>
      <url>/2024/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构（二）——栈与队列与数组"><a href="#数据结构（二）——栈与队列与数组" class="headerlink" title="数据结构（二）——栈与队列与数组"></a>数据结构（二）——栈与队列与数组</h1><h2 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h2><h3 id="1-1-栈的定义"><a href="#1-1-栈的定义" class="headerlink" title="1.1 栈的定义"></a>1.1 栈的定义</h3><p>栈（stack）是只允许在一端进行插入或删除操作的线性表。</p><p><font color=red><strong>栈的特点：后进先出</strong></font></p><p>栈的相关术语：</p><ol><li>栈顶（Top）：线性表允许进行插入删除的那一端。</li><li>栈底（Bottom）：固定的，不允许进行插入和删除的另一端。</li><li>空栈。不含任何元素的空表。</li></ol><img src="https://pic.imgdb.cn/item/660509289f345e8d03efef0f.png" alt="数据结构（二）——栈与队列与数组——栈的定义.png"><p>栈的数学性质：当n个不同元素进栈时，出栈元素不同排列的个数为下述表达式：<br>$$<br>\frac{1}{n+1}{C_{2n}^n}<br>$$<br>这个公式称为卡特兰数公式，可采用数学归纳法证明。</p><h3 id="1-2-顺序栈的实现"><a href="#1-2-顺序栈的实现" class="headerlink" title="1.2 顺序栈的实现"></a>1.2 顺序栈的实现</h3><h4 id="1-2-1-顺序栈的定义"><a href="#1-2-1-顺序栈的定义" class="headerlink" title="1.2.1 顺序栈的定义"></a>1.2.1 顺序栈的定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10           <span class="comment">//定义栈中元素最大个数 </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize];  <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line"><span class="type">int</span> top; <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SqStack S;<span class="comment">//声明一个顺序栈（分配空间）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-初始化操作"><a href="#1-2-2-初始化操作" class="headerlink" title="1.2.2 初始化操作"></a>1.2.2 初始化操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack&amp; S)</span> &#123;</span><br><span class="line">S.top = <span class="number">-1</span>; <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里进行初始化，将栈顶指针设置为-1，则之后进行入栈操作时，将会先移动栈顶指针再进行入栈操作；进行出栈操作时，会先将数据取出，再移动栈顶指针。但是题目可能会出现S.Top&#x3D;0，这个时候的入栈出栈操作就会变的不一样，需要具体问题具体分析。</p><h4 id="1-2-3-栈空、栈满判断"><a href="#1-2-3-栈空、栈满判断" class="headerlink" title="1.2.3 栈空、栈满判断"></a>1.2.3 栈空、栈满判断</h4><p>栈空判断：判断栈顶指针是否为-1，如果是的，说明栈空返回true；如果不是，说明栈非空，返还false。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈空判断</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)<span class="comment">//栈空，返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈满判断：判断栈顶指针指向的下标，是否是栈的最大长度减1，如果是，说明栈已经装满，返回true；反之返回false。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈满判断</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackFull</span><span class="params">(SqStack S)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>)<span class="comment">//栈满，返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-4-栈顶元素读取"><a href="#1-2-4-栈顶元素读取" class="headerlink" title="1.2.4 栈顶元素读取"></a>1.2.4 栈顶元素读取</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈顶元素读取</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S, ElemType&amp; x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == StackEmpty(S)) <span class="comment">//判断栈空，StackEmpty为栈空函数，参考1.2.3</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S.data[S.top];   <span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-5-入栈操作"><a href="#1-2-5-入栈操作" class="headerlink" title="1.2.5 入栈操作"></a>1.2.5 入栈操作</h4><p>入栈操作，需要先进行栈满判断，如果栈满要返还false信息。又因为前面进行初始化时，设置栈顶指针为-1，所以这里需要先将栈顶指针上移，再进行元素入栈。入栈成功，返还true。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack&amp; S, ElemType x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == StackFull(S)) <span class="comment">//判断栈满，StackFull为栈满函数，参考1.2.3</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S.top += <span class="number">1</span>;  <span class="comment">//指针先加1</span></span><br><span class="line">S.data[S.top] = x;  <span class="comment">//新元素入栈</span></span><br><span class="line"><span class="comment">//入栈操作还可以写成S.data[++S.top]=x;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-6-出栈操作"><a href="#1-2-6-出栈操作" class="headerlink" title="1.2.6 出栈操作"></a>1.2.6 出栈操作</h4><p>出栈操作，需要先进行栈空判断，如果栈空，则返还false信息。若栈不为空，则先让栈顶元素出栈，再进行指针减1操作。出栈成功，返还true。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack&amp; S, ElemType&amp; x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == StackEmpty(S)) <span class="comment">//判断栈空，StackEmpty为栈空函数，参考1.2.3</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S.data[S.top];   <span class="comment">//栈顶元素先出栈</span></span><br><span class="line">S.top--;   <span class="comment">//指针减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-7-S-top-0"><a href="#1-2-7-S-top-0" class="headerlink" title="1.2.7 S.top&#x3D;0"></a>1.2.7 S.top&#x3D;0</h4><p>如果栈顶指针初始化时指向0，那么在进行入栈，出栈操作时，就与栈顶指针指向-1产生了区别。</p><p>S.top&#x3D;0，在进行入栈时，需要先进行入栈操作，再将栈顶指针上移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S.data[S.top]=x;</span><br><span class="line">S.top++;</span><br></pre></td></tr></table></figure><p>S.top&#x3D;0，在进行出栈时，需要先进行指针下移操作，再将栈顶元素出栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S.top--;</span><br><span class="line">x=S.data[S.top];</span><br></pre></td></tr></table></figure><h4 id="1-2-8-共享栈（两个栈共享同一片空间）"><a href="#1-2-8-共享栈（两个栈共享同一片空间）" class="headerlink" title="1.2.8 共享栈（两个栈共享同一片空间）"></a>1.2.8 共享栈（两个栈共享同一片空间）</h4><p>利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</p><img src="https://pic.imgdb.cn/item/660522b39f345e8d03724402.png" alt="数据结构（二）——栈与队列与数组——共享栈.png"><h4 id="1-2-9-顺序栈小结"><a href="#1-2-9-顺序栈小结" class="headerlink" title="1.2.9 顺序栈小结"></a>1.2.9 顺序栈小结</h4><img src="https://pic.imgdb.cn/item/660523299f345e8d03748813.png" alt="数据结构（二）——栈与队列与数组——顺序栈小结.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序栈的C语言框架，要根据项目具体要求进行修改。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10           <span class="comment">//定义栈中元素最大个数 </span></span></span><br><span class="line"><span class="comment">//ElemType并不是一个数据类型，而是伪代码中所有数据类型的代指</span></span><br><span class="line"><span class="comment">//ElemType可以是int，也可以是float，但项目中更多的是struct结构体类型</span></span><br><span class="line"><span class="comment">//这份程序做示范所以将ElemType定义为int类型 </span></span><br><span class="line"><span class="comment">//实际项目中ElemType究竟是什么类型要根据具体项目情况</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize];  <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line"><span class="type">int</span> top; <span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(SqStack&amp; S)</span> &#123;</span><br><span class="line">S.top = <span class="number">-1</span>; <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈空判断</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(SqStack S)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == <span class="number">-1</span>)<span class="comment">//栈空，返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈满判断</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackFull</span><span class="params">(SqStack S)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>)<span class="comment">//栈满，返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack&amp; S, ElemType x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == StackFull(S)) <span class="comment">//判断栈满，StackFull为栈满函数，参考1.2.3</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">S.top += <span class="number">1</span>;  <span class="comment">//指针先加1</span></span><br><span class="line">S.data[S.top] = x;  <span class="comment">//新元素入栈</span></span><br><span class="line"><span class="comment">//入栈操作还可以写成S.data[++S.top]=x;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack&amp; S, ElemType&amp; x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == StackEmpty(S)) <span class="comment">//判断栈空，StackEmpty为栈空函数，参考1.2.3</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S.data[S.top];   <span class="comment">//栈顶元素先出栈</span></span><br><span class="line">S.top--;   <span class="comment">//指针减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶元素读取</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetTop</span><span class="params">(SqStack S, ElemType&amp; x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == StackEmpty(S)) <span class="comment">//判断栈空，StackEmpty为栈空函数，参考1.2.3</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = S.data[S.top];   <span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SqStack S;  <span class="comment">//声明一个顺序栈（分配空间）</span></span><br><span class="line">ElemType a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>; <span class="comment">//a为入栈数，b为栈顶元素读取存放，c为出栈数</span></span><br><span class="line">InitStack(S);  <span class="comment">//初始化栈</span></span><br><span class="line">Push(S, a);  <span class="comment">//入栈</span></span><br><span class="line">GetTop(S, b);  <span class="comment">//获取栈顶元素</span></span><br><span class="line">Pop(S, c);  <span class="comment">//出栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-链栈"><a href="#1-3-链栈" class="headerlink" title="1.3 链栈"></a>1.3 链栈</h3><p>在前面我们有提过，栈就是表的一种特殊结构，链栈就是只允许在表头进行插入和删除操作的链表。所以链栈和链表一样，可以分为带头结点的和不带头结点的。</p><p>不过与链表不同的是，我们在进行链表操作时，推荐使用带头结点的链表，这样更方便我们进行插入删除等操作。</p><p>但在栈的数据结构中，我们更推荐用不带头结点的方式进行实现，因为在进行链栈的出入栈过程中，我们是在表头进行。虽然表面上是在表头进行，但在这里我们可以把表头理解为栈顶，在这种情况下，如果不带头结点，那么我们每次入栈操作只需要在栈顶插入一个新元素，并令头结点指向新元素即可；出栈同理，先取出栈头元素，再令头指针向后移动一位即可；都是非常标准的出入栈操作。</p><p>如果我们使用了带头结点的方式，那每次的入栈和出栈操作，就是非常标准的在带头结点的链表中，对第一位进行数据插入和删除操作。</p><img src="https://pic.imgdb.cn/item/660566e19f345e8d03f03052.png" alt="数据结构（二）——栈与队列与数组——链栈的结构.png"><h4 id="1-3-1-链栈的实现"><a href="#1-3-1-链栈的实现" class="headerlink" title="1.3.1 链栈的实现"></a>1.3.1 链栈的实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义栈的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LiStack;<span class="comment">//栈类型结构</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">LiStack S;<span class="comment">//定义一个栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-链栈的初始化"><a href="#1-3-2-链栈的初始化" class="headerlink" title="1.3.2 链栈的初始化"></a>1.3.2 链栈的初始化</h4><p>不带头结点的链栈初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点的链栈的初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitStackWithoutHeader</span><span class="params">(LiStack&amp; S)</span> &#123;</span><br><span class="line">S = <span class="literal">NULL</span>; <span class="comment">// 栈顶指针初始化为NULL </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带头结点的链栈初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头结点的链栈的初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitStackWithHeader</span><span class="params">(LiStack&amp; S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建头结点</span></span><br><span class="line">S = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line"><span class="comment">//头结点之后暂时还没有元素结点</span></span><br><span class="line">S-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-链栈的入栈操作"><a href="#1-3-3-链栈的入栈操作" class="headerlink" title="1.3.3 链栈的入栈操作"></a>1.3.3 链栈的入栈操作</h4><p>不带头结点的链栈入栈操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入栈操作函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(LiStack&amp; S, ElemType e)</span> &#123;  </span><br><span class="line">    <span class="comment">// 分配新结点  </span></span><br><span class="line">    LinkNode* newNode = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  </span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 分配失败  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    newNode-&gt;data = e;    <span class="comment">// 将元素值赋给新结点  </span></span><br><span class="line">    newNode-&gt;next = S;    <span class="comment">// 新结点的next指向原栈顶  </span></span><br><span class="line">    S = newNode;          <span class="comment">// 修改栈顶指针  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>带头结点的链栈入栈操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点的链栈的入栈操作  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PushWithHeader</span><span class="params">(LiStack&amp; S, ElemType e)</span> &#123;  </span><br><span class="line">    <span class="comment">// 分配新结点  </span></span><br><span class="line">    LinkNode* newNode = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  </span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 分配失败  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    newNode-&gt;data = e;               <span class="comment">// 将元素值赋给新结点  </span></span><br><span class="line">    newNode-&gt;next = S-&gt;next;        <span class="comment">// 新结点的next指向原栈顶结点  </span></span><br><span class="line">    S-&gt;next = newNode;               <span class="comment">// 头结点的next指向新结点，完成入栈  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="1-3-4-链栈的出栈操作"><a href="#1-3-4-链栈的出栈操作" class="headerlink" title="1.3.4 链栈的出栈操作"></a>1.3.4 链栈的出栈操作</h4><p>不带头结点的出栈操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带头结点的链栈的出栈操作  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PopWithoutHeader</span><span class="params">(LiStack&amp; S, ElemType&amp; e)</span> &#123;  </span><br><span class="line">    <span class="comment">// 如果栈为空，则无法出栈  </span></span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 获取栈顶元素的值  </span></span><br><span class="line">    e = S-&gt;data;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 将栈顶指针指向下一个结点，实现出栈  </span></span><br><span class="line">    LinkNode* temp = S;  </span><br><span class="line">    S = S-&gt;next;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 释放原栈顶结点的内存  </span></span><br><span class="line">    <span class="built_in">free</span>(temp);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>带头结点的出栈操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带头结点的链栈的出栈操作  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PopWithHeader</span><span class="params">(LiStack&amp; S, ElemType&amp; e)</span> &#123;  </span><br><span class="line">    <span class="comment">// 检查栈是否为空  </span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈空，无法出栈  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 获取栈顶元素的值  </span></span><br><span class="line">    LinkNode* top = S-&gt;next;  </span><br><span class="line">    e = top-&gt;data;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 删除栈顶元素  </span></span><br><span class="line">    S-&gt;next = top-&gt;next;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 释放原栈顶结点的内存  </span></span><br><span class="line">    <span class="built_in">free</span>(top);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="1-3-5-链栈小结"><a href="#1-3-5-链栈小结" class="headerlink" title="1.3.5 链栈小结"></a>1.3.5 链栈小结</h4><img src="https://pic.imgdb.cn/item/660582539f345e8d03d65fdf.png" alt="数据结构（二）——栈与队列与数组——链栈小结.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链栈的代码框架，包含带头结点和不带头结点，按需删除更改</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;*LiStack;<span class="comment">//栈类型结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不带头结点的链栈的初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitStackWithoutHeader</span><span class="params">(LiStack&amp; S)</span> &#123;</span><br><span class="line">S = <span class="literal">NULL</span>; <span class="comment">// 栈顶指针初始化为NULL </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的链栈的初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitStackWithHeader</span><span class="params">(LiStack&amp; S)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建头结点</span></span><br><span class="line">S = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line"><span class="comment">//头结点之后暂时还没有元素结点</span></span><br><span class="line">S-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈操作函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(LiStack&amp; S, ElemType e)</span> &#123;</span><br><span class="line"><span class="comment">// 分配新结点  </span></span><br><span class="line">LinkNode* newNode = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 分配失败  </span></span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;data = e;    <span class="comment">// 将元素值赋给新结点  </span></span><br><span class="line">newNode-&gt;next = S;    <span class="comment">// 新结点的next指向原栈顶  </span></span><br><span class="line">S = newNode;          <span class="comment">// 修改栈顶指针  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带头结点的链栈的出栈操作  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PopWithoutHeader</span><span class="params">(LiStack&amp; S, ElemType&amp; e)</span> &#123;</span><br><span class="line"><span class="comment">// 如果栈为空，则无法出栈  </span></span><br><span class="line"><span class="keyword">if</span> (S == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素的值  </span></span><br><span class="line">e = S-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将栈顶指针指向下一个结点，实现出栈  </span></span><br><span class="line">LinkNode* temp = S;</span><br><span class="line">S = S-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放原栈顶结点的内存  </span></span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带头结点的链栈的出栈操作  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">PopWithHeader</span><span class="params">(LiStack&amp; S, ElemType&amp; e)</span> &#123;</span><br><span class="line"><span class="comment">// 检查栈是否为空  </span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈空，无法出栈  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素的值  </span></span><br><span class="line">LinkNode* top = S-&gt;next;</span><br><span class="line">e = top-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除栈顶元素  </span></span><br><span class="line">S-&gt;next = top-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放原栈顶结点的内存  </span></span><br><span class="line"><span class="built_in">free</span>(top);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">LiStack S;<span class="comment">//定义一个栈</span></span><br><span class="line">ElemType e = <span class="number">1</span>;</span><br><span class="line">InitStackWithoutHeader(S);</span><br><span class="line">Push(S, e);</span><br><span class="line">PopWithoutHeader(S, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h2><h3 id="2-1-队列的定义"><a href="#2-1-队列的定义" class="headerlink" title="2.1 队列的定义"></a>2.1 队列的定义</h3><p>队列同栈一样，也是一个操作受限的线性表。队列是只允许在一端进行插入，在另一端删除的线性表。</p><p><font color=red><strong>队列的特点：先进先出</strong></font></p><p>队列的相关术语：</p><ol><li>队头（Front）：允许删除的一端，又称队首。</li><li>队尾（Rear）：允许插入的一端。</li><li>空队列：不含任何元素的空表。</li></ol><img src="https://pic.imgdb.cn/item/6606bffa9f345e8d037bd5b1.png" alt="数据结构（二）——栈与队列与数组——队列的定义.png"><h3 id="2-2-队列的顺序实现"><a href="#2-2-队列的顺序实现" class="headerlink" title="2.2 队列的顺序实现"></a>2.2 队列的顺序实现</h3><h4 id="2-2-1-队列存储类型定义"><a href="#2-2-1-队列存储类型定义" class="headerlink" title="2.2.1 队列存储类型定义"></a>2.2.1 队列存储类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列存储类型的描述</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize];<span class="comment">//用静态数组存放队列元素</span></span><br><span class="line"><span class="type">int</span> front, rear;<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">SqQueue Q;<span class="comment">//声明一个顺序存储的队列</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-队列的基本操作"><a href="#2-2-2-队列的基本操作" class="headerlink" title="2.2.2 队列的基本操作"></a>2.2.2 队列的基本操作</h4><p>队列像表与栈一样，也存在增删改查等操作，而我们说的队列，是首位不相连的结构，也就是单纯的只允许在表头、表尾操作的顺序表。而对于顺序表的操作，我就没有必要再写一遍，具体内容可参考我的线性表的笔记，然后自己去写顺序队列的基本操作（纸上得来终觉浅，绝知此事要躬行）。<a href="./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8.md">数据结构（一）——线性表</a></p><p>虽然我在此没有对队列的操作进行一个详细的描述，但并不妨碍我们发现问题，那就是对于队列的队满与队空，如何进行判断？如果我们使用 <font color=red><strong> Q.front&#x3D;&#x3D;Q.rear</strong></font> 进行队空判断，那我们该如何进行队满判断呢？</p><p>我们如果使用最容易想到的方法，即 <font color=red><strong>Q.rear&#x3D;&#x3D;MaxSize</strong></font> 来进行判断，会发现，如果队列在入队的过程中出现出队操作，即使最后Q.rear&#x3D;&#x3D;MaxSize了，前面依然存有空余空间，显然，这个判断条件是有问题的。</p><p>在此，就可以引出我们接下来要说的<strong>循环队列</strong>。</p><h4 id="2-2-3-循环队列的队空与队满判断"><a href="#2-2-3-循环队列的队空与队满判断" class="headerlink" title="2.2.3 循环队列的队空与队满判断"></a>2.2.3 循环队列的队空与队满判断</h4><h5 id="2-2-3-1-队空判断"><a href="#2-2-3-1-队空判断" class="headerlink" title="2.2.3.1 队空判断"></a>2.2.3.1 队空判断</h5><p>循环队列的队空判断可以采用我们之前所说的方法，判断队头与队尾指针是否指向头一处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队空判断条件 Q.front==Q.rear</span></span><br><span class="line"><span class="comment">//队空判断</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.rear == Q.front)<span class="comment">//队空判断条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-3-2-队满判断"><a href="#2-2-3-2-队满判断" class="headerlink" title="2.2.3.2 队满判断"></a>2.2.3.2 队满判断</h5><img src="https://pic.imgdb.cn/item/6607b0e29f345e8d032e1cbe.png" alt="数据结构（二）——栈与队列与数组——循环队列队空队满判断.png"><p>队满判断操作可以采用取模运算的方法进行判断，这样实际上首尾不相连的队列，在逻辑上就变成了相连，普通的队列就变成了循环队列。</p><p>在循环队列中，每次入队时，先将数据元素放到队尾指针当前的位置，再令队尾指针加1取模，当队尾指针指到最后一个存储单元时，就默认队已满，如上面图例。在这里有一个疑问，那就是队列中最后一个存储单元还空着，为什么却说队已满？实际原因很简单，那就是这个时候如果往最后一个存储单元插入新的数据，那队尾指针就会继续向后指，此时队尾指针与队头指针指向同一处，根据前面所说的队空判断条件，此时会判断队空，但实际上却是队满。为了避免这种尴尬情形，所以选择牺牲最后一个存储单元。那队满的判断条件就显而易见了，每次进行入队操作前，对队尾指针的下一位进行判断是否等于队头指针；如果等于，则队满；反之则未满。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队满判断</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueFull</span><span class="params">(SqQueue Q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front)<span class="comment">//队满判断条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-循环队列的初始化"><a href="#2-2-4-循环队列的初始化" class="headerlink" title="2.2.4 循环队列的初始化"></a>2.2.4 循环队列的初始化</h4><p>循环队列的初始化，让队头队尾指针全指向存储空间的首位即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue&amp; Q)</span> &#123;</span><br><span class="line">Q.rear = Q.front = <span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-循环队列入队操作"><a href="#2-2-5-循环队列入队操作" class="headerlink" title="2.2.5 循环队列入队操作"></a>2.2.5 循环队列入队操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == QueueFull(Q))<span class="comment">//判断队满</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">Q.data[Q.rear] = x;<span class="comment">//将数据入队</span></span><br><span class="line"><span class="comment">//用模运算将存储空间在逻辑上变成环状</span></span><br><span class="line">Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;<span class="comment">//队尾指针加1取模</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-6-循环队列的出队操作"><a href="#2-2-6-循环队列的出队操作" class="headerlink" title="2.2.6 循环队列的出队操作"></a>2.2.6 循环队列的出队操作</h4><p>注意，出队是在队头进行操作的，要先把队头元素取出，再将队头指针加1取模。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == QueueEmpty(Q))<span class="comment">//队空判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = Q.data[Q.front];<span class="comment">//取出队头元素</span></span><br><span class="line">Q.front = (Q.front + <span class="number">1</span>) % MaxSize;<span class="comment">//进行出队操作</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将程序里的Q.front &#x3D; (Q.front + 1) % MaxSize;删掉，就是获取队头元素的函数。</p><h4 id="2-2-7-队中元素的数量"><a href="#2-2-7-队中元素的数量" class="headerlink" title="2.2.7 队中元素的数量"></a>2.2.7 队中元素的数量</h4><p>根据上面对循环队列的队空与队满的判断条件，可以思考一下，如何对队列中的元素个数进行计算？</p><p>首先可以知道的是，在进行取模运算以后，逻辑上队列已经成了一个环，这个时候有两种情况：第一种情况是队头指针在前，队尾指针在后，这时元素个数为队尾指针减去队头指针。第二种情况是队尾指针在前，队头指针在后，这个时候队尾指针相当于第二次进入队列进行入队操作，可以让队尾指针加上存储单元的个数再减去队头指针，所得结果便是队中元素数量。</p><p>通过分析，我们可以通过下面这个式子来对上面两种情况进行一个总结：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total = (Q.rear+MaxSize-Q.front)%MaxSize <span class="comment">//获取元素个数</span></span><br></pre></td></tr></table></figure><h4 id="2-2-8-拓展补充（1）——-队空与队满的判断"><a href="#2-2-8-拓展补充（1）——-队空与队满的判断" class="headerlink" title="2.2.8 拓展补充（1）—— 队空与队满的判断"></a>2.2.8 拓展补充（1）—— 队空与队满的判断</h4><p>在上面，我们已经说过一种队空与队满的判断方案，那就是牺牲一个存储单元来区分队空队满，入队时少用一个队列单元，这也是一种较为普遍的做法。但除了这种做法，我们还可以使用其它方法来进行队空队满的判断，可以参考接下来的几种方案。</p><h5 id="2-2-8-1-方案二"><a href="#2-2-8-1-方案二" class="headerlink" title="2.2.8.1 方案二"></a>2.2.8.1 方案二</h5><p>如果我们不想浪费那一个存储单元，又想能够进行队空队满的判断该怎么做呢？可以在描述队列结构体的存储类型时，增加一个长度项，这样每次入队和出队操作时，都对长度进行加减操作，当队头指针和队尾指针指向同一处时，对长度进行判断。如果长度为0，则队空；如果长度为最大存储数量，则队满。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列存储类型的描述</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize];<span class="comment">//用静态数组存放队列元素</span></span><br><span class="line"><span class="type">int</span> front, rear;<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//队列当前长度</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/6607cca89f345e8d03dcdbf3.png" alt="数据结构（二）——栈与队列与数组——判断方案二.png"><h5 id="2-2-8-2-方案三"><a href="#2-2-8-2-方案三" class="headerlink" title="2.2.8.2 方案三"></a>2.2.8.2 方案三</h5><p>我们还可以定义一个变量，用来记录最近一次进行的是入队操作还是出队操作，根据最近一次进行的操作来判断队满还是队空。</p><p>比如定义一个tag变量，当tag&#x3D;1时，最近一次进行的是入队操作，这时如果队头与队尾指向同一处，可以判断队满；当tag&#x3D;0时，最近一次进行的是出队操作，这时如果队头与队尾指向同一处，可以判断队空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列存储类型的描述</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize];<span class="comment">//用静态数组存放队列元素</span></span><br><span class="line"><span class="type">int</span> front, rear;<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//记录最近一次操作</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/6607cdc09f345e8d03e38a67.png" alt="数据结构（二）——栈与队列与数组——判断方案三.png"><h4 id="2-2-9-拓展补充（2）——-队列的变形"><a href="#2-2-9-拓展补充（2）——-队列的变形" class="headerlink" title="2.2.9 拓展补充（2）—— 队列的变形"></a>2.2.9 拓展补充（2）—— 队列的变形</h4><p>在前面，我们对队列进行初始化时，让队头指针和队尾指针都指向同一起始位置。然后在进行基本操作入队时，先将元素入队，再让队尾指针后移，队尾指针指向最后一个存储数据的下一位。</p><p>但也可能会遇到别的情况，就是队尾指针永远指向最后一个存储数据的位置，这个时候就需要先让队尾指针后移一位，再让数据入队。面对这种情况，在进行初始化时，就需要让队尾指针指向存储单元的最后一位，即最大存储长度减1（Q.rear&#x3D;MaxSize-1），这个时候进行入队操作时，队尾指针加1，刚好与队头指向同一位置（都指向存储单元首地址），数据即可存入首位。</p><img src="https://pic.imgdb.cn/item/6607dfdf9f345e8d03533860.png" alt="数据结构（二）——栈与队列与数组——队列变形.png"><img src="https://pic.imgdb.cn/item/6607e01a9f345e8d03547d9f.png" alt="数据结构（二）——栈与队列与数组——变形队空队满.png"><h4 id="2-2-10-顺序队列小结"><a href="#2-2-10-顺序队列小结" class="headerlink" title="2.2.10 顺序队列小结"></a>2.2.10 顺序队列小结</h4><img src="https://pic.imgdb.cn/item/6607e2869f345e8d03631377.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列的框架</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MaxSize 10<span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int<span class="comment">//含义参考1.2.9的程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列存储类型的描述</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ElemType data[MaxSize];<span class="comment">//用静态数组存放队列元素</span></span><br><span class="line"><span class="type">int</span> front, rear;<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队空判断</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(SqQueue Q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.rear == Q.front)<span class="comment">//队空判断条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队满判断</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueFull</span><span class="params">(SqQueue Q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % MaxSize == Q.front)<span class="comment">//队满判断条件</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue&amp; Q)</span> &#123;</span><br><span class="line">Q.rear = Q.front = <span class="number">0</span>;<span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == QueueFull(Q))<span class="comment">//判断队满</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">Q.data[Q.rear] = x;<span class="comment">//将数据入队</span></span><br><span class="line"><span class="comment">//用模运算将存储空间在逻辑上变成环状</span></span><br><span class="line">Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;<span class="comment">//队尾指针加1取模</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(SqQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> == QueueEmpty(Q))<span class="comment">//队空判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">x = Q.data[Q.front];<span class="comment">//取出队头元素</span></span><br><span class="line">Q.front = (Q.front + <span class="number">1</span>) % MaxSize;<span class="comment">//进行出队操作</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">SqQueue Q;<span class="comment">//声明一个顺序存储的队列</span></span><br><span class="line">ElemType x;</span><br><span class="line">InitQueue(Q);</span><br><span class="line">EnQueue(Q, x);</span><br><span class="line">DeQueue(Q, x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-队列的链式实现"><a href="#2-3-队列的链式实现" class="headerlink" title="2.3 队列的链式实现"></a>2.3 队列的链式实现</h3><p>链式队列可以看成单链表的阉割版，即就是只允许在表头和表尾进行操作的单链表。所以，单链表的一切都可以移植到链式队列上来。同单链表一样，链式队列也可以分为带头结点和不带头结点两种，如果是带头结点的，队头指针就要指向头结点；如果是不带头结点的，队头指针就指向首个数据。在执行入队与出队等基本操作时，也要注意区分。</p><img src="https://pic.imgdb.cn/item/6607e8089f345e8d03857fcc.png" alt="数据结构（二）——栈与队列与数组——链队列的分类.png"><h4 id="2-3-1-链队列的定义"><a href="#2-3-1-链队列的定义" class="headerlink" title="2.3.1 链队列的定义"></a>2.3.1 链队列的定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义链式队列中的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">LinkNode* front, * rear;<span class="comment">//定义队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">LinkQueue Q;<span class="comment">//创建一个链式队列变量</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-链队列的初始化及队空判断"><a href="#2-3-2-链队列的初始化及队空判断" class="headerlink" title="2.3.2 链队列的初始化及队空判断"></a>2.3.2 链队列的初始化及队空判断</h4><p>因为采用链式存储的方式，所以一般不存在队满的情况（除非内存满了），那这里我就只对队列的队空进行判断。</p><h5 id="2-3-2-1-带头结点初始化及队空判断"><a href="#2-3-2-1-带头结点初始化及队空判断" class="headerlink" title="2.3.2.1 带头结点初始化及队空判断"></a>2.3.2.1 带头结点初始化及队空判断</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头结点的初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> &#123;</span><br><span class="line"><span class="comment">//初始化时 front、rear都指向头结点</span></span><br><span class="line">Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断带头结点队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/6607ec259f345e8d039f1fed.png" alt="数据结构（二）——栈与队列与数组——带头结点初始化.png"><h5 id="2-3-2-2-不带头结点的初始化及队空判断"><a href="#2-3-2-2-不带头结点的初始化及队空判断" class="headerlink" title="2.3.2.2 不带头结点的初始化及队空判断"></a>2.3.2.2 不带头结点的初始化及队空判断</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点的初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化时 front、rear都指向NULL</span></span><br><span class="line">Q.front = <span class="literal">NULL</span>;</span><br><span class="line">Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断不带头结点队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/6607ec539f345e8d03a04e2e.png" alt="数据结构（二）——栈与队列与数组——不带头结点初始化.png"><h4 id="2-3-3-链队列的入队操作"><a href="#2-3-3-链队列的入队操作" class="headerlink" title="2.3.3 链队列的入队操作"></a>2.3.3 链队列的入队操作</h4><h5 id="2-3-3-1-带头结点的链队列的入队操作"><a href="#2-3-3-1-带头结点的链队列的入队操作" class="headerlink" title="2.3.3.1 带头结点的链队列的入队操作"></a>2.3.3.1 带头结点的链队列的入队操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头结点的链队列的入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueueWithhead</span><span class="params">(LinkQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line">LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Q.rear-&gt;next = s;</span><br><span class="line">Q.rear = s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66081c779f345e8d032dee80.png" alt="数据结构（二）——栈与队列与数组——带头结点入队.png"><h5 id="2-3-3-2-不带头结点的入队操作"><a href="#2-3-3-2-不带头结点的入队操作" class="headerlink" title="2.3.3.2 不带头结点的入队操作"></a>2.3.3.2 不带头结点的入队操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点的链队列入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueueWithouthead</span><span class="params">(LinkQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line">LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//在不带头结点的队列中插入数据，需要先判断当前队列有没有数据</span></span><br><span class="line"><span class="keyword">if</span> (Q.front==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在空队列插入第一个数据，需要同时更改队头队尾指针</span></span><br><span class="line">Q.front = s;</span><br><span class="line">Q.front = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//不在空队列插入数据，只需更改表尾指针</span></span><br><span class="line">Q.rear-&gt;next = s;</span><br><span class="line">Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/66081dfd9f345e8d033aad9c.png" alt="数据结构（二）——栈与队列与数组——不带头结点入队.png"><h4 id="2-3-4-链队列的出队操作"><a href="#2-3-4-链队列的出队操作" class="headerlink" title="2.3.4 链队列的出队操作"></a>2.3.4 链队列的出队操作</h4><h5 id="2-3-4-1-带头结点的链队列的出队操作"><a href="#2-3-4-1-带头结点的链队列的出队操作" class="headerlink" title="2.3.4.1 带头结点的链队列的出队操作"></a>2.3.4.1 带头结点的链队列的出队操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头结点的链队列的出队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueueWithhead</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)<span class="comment">//队空判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LinkNode* p = Q.front-&gt;next;<span class="comment">//开辟一个结点指向头结点后首个数据</span></span><br><span class="line">x = p-&gt;data;<span class="comment">//用变量x返还队头元素</span></span><br><span class="line">Q.front-&gt;next = p-&gt;next;<span class="comment">//修改头结点next指针</span></span><br><span class="line"><span class="keyword">if</span> (Q.rear == p)<span class="comment">//如果出队元素是最后一个</span></span><br><span class="line">Q.rear = Q.front;<span class="comment">//修改队尾指针</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放结点空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/6608213d9f345e8d03575d75.png" alt="数据结构（二）——栈与队列与数组——带头结点出队.png"><h5 id="2-3-4-2-不带头结点的链队列的出队操作"><a href="#2-3-4-2-不带头结点的链队列的出队操作" class="headerlink" title="2.3.4.2 不带头结点的链队列的出队操作"></a>2.3.4.2 不带头结点的链队列的出队操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点的链队列的出队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueueWithouthead</span><span class="params">(LinkQueue&amp; Q, ElemType&amp; x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)<span class="comment">//队空判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LinkNode* p = Q.front;<span class="comment">//开辟一个结点指向当前出队元素</span></span><br><span class="line">x = p-&gt;data;<span class="comment">//用变量x返还队头元素</span></span><br><span class="line">Q.front = p-&gt;next;<span class="comment">//修改头结点front指针</span></span><br><span class="line"><span class="keyword">if</span> (Q.rear == p) &#123;<span class="comment">//如果出队元素是最后一个</span></span><br><span class="line">Q.front = <span class="literal">NULL</span>;<span class="comment">//修改队头指针</span></span><br><span class="line">Q.rear = <span class="literal">NULL</span>;<span class="comment">//修改队尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放结点空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/660821e69f345e8d035d4c42.png" alt="数据结构（二）——栈与队列与数组——不带头结点出队.png"><h4 id="2-3-5-链队列小结"><a href="#2-3-5-链队列小结" class="headerlink" title="2.3.5 链队列小结"></a>2.3.5 链队列小结</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链队列框架</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int<span class="comment">//含义参考1.2.9的程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链式队列中的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链式队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">LinkNode* front, * rear;<span class="comment">//定义队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> &#123;</span><br><span class="line"><span class="comment">//初始化时 front、rear都指向头结点</span></span><br><span class="line">Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断带头结点队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的链队列的入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueueWithhead</span><span class="params">(LinkQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line">LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Q.rear-&gt;next = s;</span><br><span class="line">Q.rear = s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带头结点的链队列的出队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueueWithhead</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)<span class="comment">//队空判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LinkNode* p = Q.front-&gt;next;<span class="comment">//开辟一个结点指向头结点后首个数据</span></span><br><span class="line">x = p-&gt;data;<span class="comment">//用变量x返还队头元素</span></span><br><span class="line">Q.front-&gt;next = p-&gt;next;<span class="comment">//修改头结点next指针</span></span><br><span class="line"><span class="keyword">if</span> (Q.rear == p)<span class="comment">//如果出队元素是最后一个</span></span><br><span class="line">Q.rear = Q.front;<span class="comment">//修改队尾指针</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放结点空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不带头结点的初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> &#123;</span><br><span class="line"><span class="comment">//初始化时 front、rear都指向NULL</span></span><br><span class="line">Q.front = <span class="literal">NULL</span>;</span><br><span class="line">Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断不带头结点队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不带头结点的链队列入队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueueWithouthead</span><span class="params">(LinkQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line">LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data = x;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//在不带头结点的队列中插入数据，需要先判断当前队列有没有数据</span></span><br><span class="line"><span class="keyword">if</span> (Q.front==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在空队列插入第一个数据，需要同时更改队头队尾指针</span></span><br><span class="line">Q.front = s;</span><br><span class="line">Q.front = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//不在空队列插入数据，只需更改表尾指针</span></span><br><span class="line">Q.rear-&gt;next = s;</span><br><span class="line">Q.rear = s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不带头结点的链队列的出队操作</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueueWithouthead</span><span class="params">(LinkQueue&amp; Q, ElemType&amp; x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (Q.front == Q.rear)<span class="comment">//队空判断</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">LinkNode* p = Q.front;<span class="comment">//开辟一个结点指向当前出队元素</span></span><br><span class="line">x = p-&gt;data;<span class="comment">//用变量x返还队头元素</span></span><br><span class="line">Q.front = p-&gt;next;<span class="comment">//修改头结点front指针</span></span><br><span class="line"><span class="keyword">if</span> (Q.rear == p) &#123;<span class="comment">//如果出队元素是最后一个</span></span><br><span class="line">Q.front = <span class="literal">NULL</span>;<span class="comment">//修改队头指针</span></span><br><span class="line">Q.rear = <span class="literal">NULL</span>;<span class="comment">//修改队尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放结点空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">LinkQueue Q;<span class="comment">//创建一个链式队列变量</span></span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line"><span class="comment">//此间为操作函数，根据情况调用</span></span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://pic.imgdb.cn/item/660823439f345e8d036a7b75.png" alt="数据结构（二）——栈与队列与数组——链队列小结.png"><h3 id="2-4-双端队列"><a href="#2-4-双端队列" class="headerlink" title="2.4 双端队列"></a>2.4 双端队列</h3><h4 id="2-4-1-双端队列定义"><a href="#2-4-1-双端队列定义" class="headerlink" title="2.4.1 双端队列定义"></a>2.4.1 双端队列定义</h4><p>双端队列是指只允许在两端进行插入和删除操作的线性表。双端队列两端的地位是平等的。</p><img src="https://pic.imgdb.cn/item/660824c69f345e8d03779adf.png" alt="数据结构（二）——栈与队列与数组——双端队列.png"><h4 id="2-4-2-输入受限的双端队列和输出受限的双端队列"><a href="#2-4-2-输入受限的双端队列和输出受限的双端队列" class="headerlink" title="2.4.2 输入受限的双端队列和输出受限的双端队列"></a>2.4.2 输入受限的双端队列和输出受限的双端队列</h4><p>输入受限的双端队列：只允许从一端插入、两端删除的线性表。</p><p>输出受限的双端队列：只允许从两端插入、一端删除的线性表。</p><img src="https://pic.imgdb.cn/item/660825359f345e8d037bba45.png" alt="数据结构（二）——栈与队列与数组——输入输出受限的双端队列.png"><h4 id="2-4-3-双端队列小结"><a href="#2-4-3-双端队列小结" class="headerlink" title="2.4.3 双端队列小结"></a>2.4.3 双端队列小结</h4><img src="https://pic.imgdb.cn/item/660825689f345e8d037da7cb.png" alt="数据结构（二）——栈与队列与数组——双端队列小结.png"><h2 id="3-栈的应用"><a href="#3-栈的应用" class="headerlink" title="3. 栈的应用"></a>3. 栈的应用</h2><h3 id="3-1-栈在括号匹配中的应用"><a href="#3-1-栈在括号匹配中的应用" class="headerlink" title="3.1 栈在括号匹配中的应用"></a>3.1 栈在括号匹配中的应用</h3><p>众所周知，括号字符是以组（成双成对）的形式出现，每一组括号字符里都包含同类型的左右括号。在一连串的数据或程序里，出现的越晚的左括号，他得等级越低，所以与之匹配的同类型的右括号出现的就越早。</p><p>知道这一点后，就可以发现，括号嵌套的顺序是有规律的，如假设表达式中有圆括号和方括号两种，那么（ [ ] ( ) ）、[ ( [ ] ) ]都是合法且正确的，但是（ [ ) ]就不正确。</p><p>这是因为，假设有一个存储容器，出现左括号就暂存进去，出现右括号，就将容器里最后进入的括号取出来进行匹对，匹对成功则两者可以算作一组消除。这时就可以发现，上面正确的两组括号顺序，他们最后可以完全消除而错的那一组，”[“ “)”并不匹配。</p><p>由此可以发现，括号的匹配算法，与栈的特性很相近，都是先入后出的。<font color=red><strong>先依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配。</strong></font></p><p>这样的匹配会出现以下失败的情况：</p><ol><li>左括号单身。扫描完以后，栈里仍有左括号。</li><li>右括号单身。栈里已经没有括号了，但是扫描到了右括号。</li><li>左右括号不匹配。</li></ol><img src="https://pic.imgdb.cn/item/660b995b9f345e8d03d89728.png" alt="数据结构（二）——栈与队列与数组——括号匹配算法流程.png"><img src="https://pic.imgdb.cn/item/660b985b9f345e8d03d20d50.png" alt="数据结构（二）——栈与队列与数组——括号匹配算法实现.png"><h3 id="3-2-栈在表达式求值中的应用"><a href="#3-2-栈在表达式求值中的应用" class="headerlink" title="3.2 栈在表达式求值中的应用"></a>3.2 栈在表达式求值中的应用</h3><p>表达式由三个部分组成：操作数、运算符、界限符（界限符即括号，是必不可少的，反映了计算的先后顺序）</p><h4 id="3-2-1-三种算数表达式"><a href="#3-2-1-三种算数表达式" class="headerlink" title="3.2.1 三种算数表达式"></a>3.2.1 三种算数表达式</h4><p>中缀表达式：运算符在两个操作数中间，也是最贴近人类使用的表达式，但是计算机不易解析。所以产生了后缀表达式和前缀表达式。</p><p>后缀表达式：也称逆波兰表达式，运算符在两个操作数之后。</p><p>前缀表达式：也称波兰表达式，运算符在两个操作数之前。</p><img src="https://pic.imgdb.cn/item/660b9c739f345e8d03ec685c.png" alt="数据结构（二）——栈与队列与数组——三种表达式.png"><h4 id="3-2-2-中缀表达式转后缀表达式"><a href="#3-2-2-中缀表达式转后缀表达式" class="headerlink" title="3.2.2 中缀表达式转后缀表达式"></a>3.2.2 中缀表达式转后缀表达式</h4><img src="https://pic.imgdb.cn/item/660b9ebd9f345e8d03fb5be2.png" alt="数据结构（二）——栈与队列与数组——中缀转后缀.png"><p>中缀表达式转后缀表达式，由于表达式中各个运算符的运算顺序不唯一，所以得到的后缀表达式也不唯一。如图中的 A+B*(C-D)-E&#x2F;F 根据两种不同的运算顺序可以得到两种不同的后缀表达式结果。</p><p>但是需要注意，客观来看两种都正确，但计算机计算采用的是第一种情况，<font color=red><strong>即后缀表达式中的运算符的排列顺序与中缀表达式的运算符的运算顺序一致。</strong></font>这是因为我们计算机实现此运算的算法采用的是栈的结构（参考3.2.7）。后续我们在进行中缀转后缀计算时，也可以通过查看后缀表达式中的运算符的排列顺序与中缀表达式的运算符的运算顺序是否一致进行算法的验证。</p><p>为了保证我们每次都可以获得正确的机算后缀表达式，所以这里提出一个<font color=blue><strong>左优先原则：只要表达式中偏向左边的运算符能先计算，就优先计算。</strong></font></p><h4 id="3-2-3-后缀表达式计算"><a href="#3-2-3-后缀表达式计算" class="headerlink" title="3.2.3 后缀表达式计算"></a>3.2.3 后缀表达式计算</h4><p><strong>手算：</strong></p><img src="https://pic.imgdb.cn/item/660ba2109f345e8d0311e402.png" alt="数据结构（二）——栈与队列与数组——后缀计算.png"><p><strong>机算：</strong></p><img src="https://pic.imgdb.cn/item/660ba2e09f345e8d0316cb87.png" alt="数据结构（二）——栈与队列与数组——后缀计算机算.png"><p>注意，后缀表达式的计算过程，这里我只贴了一张结果图，但具体的模拟过程要掌握，考试时可能会出现选择题或大题。不熟悉的可以参考连接视频：<a href="https://www.bilibili.com/video/BV1b7411N798?p=28&vd_source=7fb4b255ed876969a742738d7b84f461">表达式求值</a></p><h4 id="3-2-4-中缀表达式转前缀表达式"><a href="#3-2-4-中缀表达式转前缀表达式" class="headerlink" title="3.2.4 中缀表达式转前缀表达式"></a>3.2.4 中缀表达式转前缀表达式</h4><img src="https://pic.imgdb.cn/item/660ba4d79f345e8d03247f6b.png" alt="数据结构（二）——栈与队列与数组——中缀转前缀.png"><p>中缀转前缀与中缀转后缀一样，不同的是这里采用右优先原则。</p><p><font color=blue><strong>右优先原则：只要表达式中偏向右边的运算符能先计算，就优先计算。</strong></font></p><p>通过右优先原则得出的表达式最后的排列呈现如下的规则：<font color=red><strong>即前缀表达式中的运算符的排列顺序与中缀表达式的运算符的运算顺序相反。</strong></font></p><h4 id="3-2-5-前缀表达式计算"><a href="#3-2-5-前缀表达式计算" class="headerlink" title="3.2.5 前缀表达式计算"></a>3.2.5 前缀表达式计算</h4><img src="https://pic.imgdb.cn/item/660ba5d29f345e8d032b13e1.png" alt="数据结构（二）——栈与队列与数组——前缀表达式计算.png"><p>注意：</p><ol><li>前缀表达式计算的扫描顺序是<font color=green><strong>从右向左</strong></font>，而后缀则是<font color=green><strong>从左向右</strong></font>。</li><li><strong>在前缀表达式中，先出栈的是左操作数，后出栈的是右操作数。后缀表达式恰恰相反，先出栈的是右操作数 ，后出栈的是左操作数。</strong></li></ol><h4 id="3-2-6-前缀、中缀、后缀基础小结"><a href="#3-2-6-前缀、中缀、后缀基础小结" class="headerlink" title="3.2.6 前缀、中缀、后缀基础小结"></a>3.2.6 前缀、中缀、后缀基础小结</h4><img src="https://pic.imgdb.cn/item/660ba8939f345e8d033d4dc3.png" alt="数据结构（二）——栈与队列与数组——前缀中缀后缀小结.png"><h4 id="3-2-7-中缀表达式转后缀表达式算法"><a href="#3-2-7-中缀表达式转后缀表达式算法" class="headerlink" title="3.2.7 中缀表达式转后缀表达式算法"></a>3.2.7 中缀表达式转后缀表达式算法</h4><img src="https://pic.imgdb.cn/item/660bad189f345e8d035bdf11.png" alt="数据结构（二）——栈与队列与数组——中缀转后缀模拟.png"><p>中缀转后缀表达式的机算是考试重点，尤其是牵扯到括号的转化，这里需要深入掌握计算机通过栈进行计算转化的过程。  </p><h4 id="3-2-8-栈实现中缀表达式的计算"><a href="#3-2-8-栈实现中缀表达式的计算" class="headerlink" title="3.2.8 栈实现中缀表达式的计算"></a>3.2.8 栈实现中缀表达式的计算</h4><p>栈实现中缀表达式计算，就是在扫描表达式的时候，将他转化成后缀，同时，在转化的时候，对已转化的部分能进行计算的先计算。</p><p>说的明白点，中缀表达式计算就是3.2.7中缀表达式转后缀表达式的算法与3.2.3后缀表达式算法的交叉结合。</p><p>通过以上的了解，就可以知道，在初始化时，需要初始化两个栈，一个用来存放操作数，一个用来存放运算符。</p><img src="https://pic.imgdb.cn/item/660bb5169f345e8d03912e74.png" alt="数据结构（二）——栈与队列与数组——中缀表达式机算.png"><p>注意，这部分的考察是重点，3.2.7和3.2.8的知识点需要深刻掌握，相关视频链接贴在这里 <a href="https://www.bilibili.com/video/BV1b7411N798?p=29&vd_source=7fb4b255ed876969a742738d7b84f461">栈的应用——表达式计算</a>。</p><h4 id="3-2-9-栈的表达式计算应用小结"><a href="#3-2-9-栈的表达式计算应用小结" class="headerlink" title="3.2.9 栈的表达式计算应用小结"></a>3.2.9 栈的表达式计算应用小结</h4><img src="https://pic.imgdb.cn/item/660bb6499f345e8d03991c7a.png" alt="数据结构（二）——栈与队列与数组——栈的应用小结.png"><h3 id="3-3-栈在递归中的应用"><a href="#3-3-栈在递归中的应用" class="headerlink" title="3.3 栈在递归中的应用"></a>3.3 栈在递归中的应用</h3><p>函数调用的特点：最后被调用的函数最先执行结束（LIFO）。</p><p>函数的调用，就是通过栈，将最开始执行的函数压入栈中，然后跟据其他函数被调用的顺序，依次往栈中压入函数。当最后一个被调用的函数执行结束时，则将该函数出栈，执行接下来的栈顶被调用函数。</p><p>同理函数的递归就是函数通过不断调用函数自己本身从而达到目的的一种实现方法。所以，递归函数的使用也是通过栈来执行。递归调用时，函数调用栈可称为 “递归工作栈”。</p><p>另外，<font color=blue><strong>函数调用时，需要用一个栈存储：调用返回地址、实参和局部变量。</strong></font></p><img src="https://pic.imgdb.cn/item/660bbd8d9f345e8d03ca1f9a.png" alt="数据结构（二）——栈与队列与数组——栈的递归.png"><p>递归算法的缺点：</p><ol><li>太多层递归可能会导致栈溢出。</li><li>可能出现很多次重复调用运算。</li></ol><h2 id="4-队列的应用"><a href="#4-队列的应用" class="headerlink" title="4. 队列的应用"></a>4. 队列的应用</h2><p>队列的应用：</p><ol><li>树的层次遍历。</li><li>图的广度优先。</li><li>操作系统的应用。多个进程争抢着使用有限的系统资源时，FCFS（先来先服务）是一种常用策略。</li></ol><h2 id="5-数组和特殊矩阵的压缩存储"><a href="#5-数组和特殊矩阵的压缩存储" class="headerlink" title="5. 数组和特殊矩阵的压缩存储"></a>5. 数组和特殊矩阵的压缩存储</h2><h3 id="5-1-数组"><a href="#5-1-数组" class="headerlink" title="5.1 数组"></a>5.1 数组</h3><h4 id="5-1-1-一维数组存储结构"><a href="#5-1-1-一维数组存储结构" class="headerlink" title="5.1.1 一维数组存储结构"></a>5.1.1 一维数组存储结构</h4><img src="https://pic.imgdb.cn/item/660bc3b09f345e8d03f27258.png" alt="数据结构（二）——栈与队列与数组——一维数组存储结构.png"><h4 id="5-1-2-二维数组存储结构"><a href="#5-1-2-二维数组存储结构" class="headerlink" title="5.1.2 二维数组存储结构"></a>5.1.2 二维数组存储结构</h4><p>二维数组如图所示，它的存储分为<font color=red><strong>行优先</strong></font>和<font color=red><strong>列优先</strong></font>。</p><img src="https://pic.imgdb.cn/item/660bc6599f345e8d03036ce6.png" alt="数据结构（二）——栈与队列与数组——二维数组结构.png"><h5 id="5-1-2-1-行优先存储"><a href="#5-1-2-1-行优先存储" class="headerlink" title="5.1.2.1 行优先存储"></a>5.1.2.1 行优先存储</h5><img src="https://pic.imgdb.cn/item/660bc6ff9f345e8d03077be5.png" alt="数据结构（二）——栈与队列与数组——二维数组行优先.png"><p>只要给了图中i，j的值，计算机就能立刻计算出该位的存储地址，所以二维数组也具有<font color=red><strong>随机存取</strong></font>的特性。</p><h5 id="5-1-2-2-列优先存储"><a href="#5-1-2-2-列优先存储" class="headerlink" title="5.1.2.2 列优先存储"></a>5.1.2.2 列优先存储</h5><img src="https://pic.imgdb.cn/item/660bc7af9f345e8d030c8a5b.png" alt="数据结构（二）——栈与队列与数组——二维数组列优先.png"><h3 id="5-2-矩阵的压缩存储"><a href="#5-2-矩阵的压缩存储" class="headerlink" title="5.2 矩阵的压缩存储"></a>5.2 矩阵的压缩存储</h3><h4 id="5-2-1-普通矩阵的存储"><a href="#5-2-1-普通矩阵的存储" class="headerlink" title="5.2.1 普通矩阵的存储"></a>5.2.1 普通矩阵的存储</h4><img src="https://pic.imgdb.cn/item/660bd8fb9f345e8d037ac989.png" alt="数据结构（二）——栈与队列与数组——普通矩阵存储.png"><h4 id="5-2-2-对称矩阵的压缩存储"><a href="#5-2-2-对称矩阵的压缩存储" class="headerlink" title="5.2.2 对称矩阵的压缩存储"></a>5.2.2 对称矩阵的压缩存储</h4><img src="https://pic.imgdb.cn/item/660bd97c9f345e8d037e1ca5.png" alt="数据结构（二）——栈与队列与数组——对称矩阵的压缩存储.png"><p>矩阵就是由许多a<sub>i,j</sub>组成的一个集合，也可以看成 a[i] [j]形式的一个二维数组。对称矩阵的上三角区和下三角区是相等的，所以存储的策略有两种：一是上三角加对角线；二是下三角加对角线。</p><p><font color=green><strong>(1)通过行优先加下三角加对角线的方式进行矩阵存储：</strong></font></p><p>一般情况下，采用下三角加对角线的方式进行存储，这个时候，i&gt;&#x3D;j，而存储方法就是把下三角和对角线的数据映射到一个一维数组中进行存储。</p><p>这个时候产生了一个问题，这个数组的大小应为多少？假设是个n阶的方阵，数组里存储下半三角加对角线的数据，那这个数组的长度，就应该是1+2+3+……+n，即等差数列求和公式：n（n+1）&#x2F;2。</p><p>解决了数组大小的问题，就又产生了第二个问题，程序员如何快速使用压缩存储后的数据呢？方法很简单，就是根据存储数据在矩阵中的下标，通过计算快速得到在一维数组中的下标，即可实现对矩阵的随机存取。具体的计算公式在接下来的贴图中。</p><p><font color=green><strong>(2)通过行优先加上三角加对角线的方式进行矩阵存储：</strong></font></p><p>上三角加对角线，并通过行优先存储的方式基本实现与（1）的下三角存储一样。上三角的模型中，j&gt;&#x3D;i，可以通过将他转置的方法，把a<sub>i,j</sub>转换成a<sub>j,i</sub>，这样上三角的计算与存储，就与下三角的一样了。</p><img src="https://pic.imgdb.cn/item/660be3469f345e8d03c1a3b2.png" alt="数据结构（二）——栈与队列与数组——对称矩阵压缩存储行优先.png"><p><font color=green><strong>(3)通过列优先加上三角&#x2F;下三角加对角线的方式进行矩阵存储：</strong></font></p><p>列优先的存储方式和行优先的思想是一致的，所以我在这里只贴了一张图，详细的思想可以参考（1）。</p><img src="https://pic.imgdb.cn/item/660be4029f345e8d03c6e687.png" alt="数据结构（二）——栈与队列与数组——对称矩阵压缩存储列优先.png"><h4 id="5-2-3-三角矩阵的压缩存储"><a href="#5-2-3-三角矩阵的压缩存储" class="headerlink" title="5.2.3 三角矩阵的压缩存储"></a>5.2.3 三角矩阵的压缩存储</h4><p>所谓三角矩阵，就是除对角线和三角区，其余的元素都是相同的。这里的存储方法和对称矩阵如出一辙，唯一不同的是，需要在映射的一维数组的最后，添加一个常量存储位用来存储常量c。</p><p><font color=green><strong>(1)下三角矩阵的行优先压缩存储：</strong></font></p><img src="https://pic.imgdb.cn/item/660be5779f345e8d03d1493a.png" alt="数据结构（二）——栈与队列与数组——下三角压缩存储.png"><p><font color=green><strong>(2)上三角矩阵的行优先压缩存储：</strong></font></p><img src="https://pic.imgdb.cn/item/660be78d9f345e8d03dfc4f2.png" alt="数据结构（二）——栈与队列与数组——上三角压缩存储.png"><h4 id="5-2-4-三对角矩阵的压缩存储"><a href="#5-2-4-三对角矩阵的压缩存储" class="headerlink" title="5.2.4 三对角矩阵的压缩存储"></a>5.2.4 三对角矩阵的压缩存储</h4><p>三对角矩阵，又称带状矩阵，即只有矩阵对角线上的元素以及对角线上元素的上下左右可以是非0元素的矩阵，其余位置均为0。用数学式来表达就是，对于矩阵中任意一元素a<sub>i,j</sub>，当|i-j|&gt;1时，a<sub>i,j</sub>&#x3D;0。</p><p>从图中也可以很明显发现三对角矩阵的特点，那就是除了第一行和最后一行只有两个元素外，其余每一行都有三个元素。</p><img src="https://pic.imgdb.cn/item/660be9919f345e8d03efb392.png" alt="数据结构（二）——栈与队列与数组——对三角压缩存储.png"><img src="https://pic.imgdb.cn/item/660becd29f345e8d030865fc.png" alt="数据结构（二）——栈与队列与数组——对三角压缩存储反解.png"><p>注意上图中右侧，两种计算取值的<font color=red><strong>刚好临界</strong></font>问题。</p><h4 id="5-2-5-稀疏矩阵的压缩存储"><a href="#5-2-5-稀疏矩阵的压缩存储" class="headerlink" title="5.2.5 稀疏矩阵的压缩存储"></a>5.2.5 稀疏矩阵的压缩存储</h4><p><font color=green><strong>(1)使用三元组进行稀疏矩阵的压缩存储：</strong></font></p><img src="https://pic.imgdb.cn/item/660beeab9f345e8d03172a20.png" alt="数据结构（二）——栈与队列与数组——三元组存储稀疏矩阵.png"><p><font color=green><strong>(2)使用十字链表法进行稀疏矩阵的压缩存储：</strong></font></p><img src="https://pic.imgdb.cn/item/660bef9d9f345e8d031ed4ad.png" alt="数据结构（二）——栈与队列与数组——十字链表存储稀疏矩阵.png"><h4 id="5-2-6-小结"><a href="#5-2-6-小结" class="headerlink" title="5.2.6 小结"></a>5.2.6 小结</h4><img src="https://pic.imgdb.cn/item/660befe7de83db5d38abbd56.png" alt="数据结构（二）——栈与队列与数组——压缩矩阵小结.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（一）——计算机系统概述</title>
      <link href="/2024/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（一）——计算机系统概述"><a href="#计算机组成原理（一）——计算机系统概述" class="headerlink" title="计算机组成原理（一）——计算机系统概述"></a>计算机组成原理（一）——计算机系统概述</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>在学习计算机组成原理之前，首先我们要了解什么是计算机系统。<strong><font color=red>计算机系统</font>&#x3D;硬件+软件</strong></p><p>硬件：计算机的实体，如主机、外设等。</p><p>软件：由具有各类特殊功能的程序组成。</p><p>计算机组成原理主要研究的是计算机系统里的硬件。</p><h2 id="2-计算机发展历程（了解，大纲已删）"><a href="#2-计算机发展历程（了解，大纲已删）" class="headerlink" title="2. 计算机发展历程（了解，大纲已删）"></a>2. 计算机发展历程（了解，大纲已删）</h2><h3 id="2-1-计算机硬件的发展（四代变化）"><a href="#2-1-计算机硬件的发展（四代变化）" class="headerlink" title="2.1 计算机硬件的发展（四代变化）"></a>2.1 计算机硬件的发展（四代变化）</h3><p>（1）第一代计算机（1946~1957年）——电子管时代。</p><p>（2）第二代计算机（1958~1964年）——晶体管时代。</p><p>（3）第三代计算机（1965~1971年）——中小规模集成电路时代。</p><p>（4）第四代计算机（1972至今）——超大规模集成电路时代。</p><h3 id="2-2-计算机软件的发展"><a href="#2-2-计算机软件的发展" class="headerlink" title="2.2 计算机软件的发展"></a>2.2 计算机软件的发展</h3><p>计算机语言的发展经历了面向机器的机器语言和汇编语言、面向问题的高级语言。其中高级语言的发展真正促进了软件的发展，它经历了从科学计算和工程计算的FORTRAN、结构化程序设计的PASCAL到面向对象的C++和适应网络环境的Java。</p><h2 id="3-计算机系统层次结构"><a href="#3-计算机系统层次结构" class="headerlink" title="3. 计算机系统层次结构"></a>3. 计算机系统层次结构</h2><p>硬件系统和软件系统共同构成了一个完整的计算机系统。<font color=red><strong>硬件</strong></font>是指有形的物理设备，是计算机系统中实际物理装置的总称。<font color=red><strong>软件</strong></font>是指在硬件上运行的程序和相关的数据及文档。对于某一个功能来说，若其既可以用软件实现，又可以用硬件实现，则称为<font color=red><strong>软&#x2F;硬件在逻辑功能上是等价的</strong></font>。</p><h3 id="3-1-计算机硬件的基本组成"><a href="#3-1-计算机硬件的基本组成" class="headerlink" title="3.1 计算机硬件的基本组成"></a>3.1 计算机硬件的基本组成</h3><h4 id="3-1-1-早期冯诺依曼机结构"><a href="#3-1-1-早期冯诺依曼机结构" class="headerlink" title="3.1.1 早期冯诺依曼机结构"></a>3.1.1 早期冯诺依曼机结构</h4><p>1945 年，冯·诺依曼中提出了冯·诺依曼体系结构，又称：存储程序计算机。即：程序本身是存储在主机内存中的，可以通过加载不同的程序来解决不同的问题。</p><p>冯诺依曼在研究EDVAC(离散变量自动电子计算机)机时提出了<STRONG>&gt;“存储程序”</strong>的概念。</p><p><font color=blue><strong>存储程序的基本思想</strong></font>：将事先编制好的程序和原始数据送入主存储器后才能执行，一旦程序被启动执行，就无须操作人员的干预，计算机会自动逐条执行指令，直至程序执行结束。</p><p><font color=red><strong>存储程序</strong></font>：将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令。以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p><p><strong>冯诺依曼机结构组成：</strong></p><img src="https://pic.imgdb.cn/item/6602a7939f345e8d037f1f52.png" alt="计算机组成原理（一）——计算机系统概述——冯诺依曼结构.png"><p><strong>冯诺依曼计算机特点：</strong></p><ol><li>计算机由五大部件组成：：运算器，存储器，控制器，输入设备，输出设备。</li><li>指令和数据以同等地位存于存储器，可按地址寻访。</li><li>指令和数据用二进制表示。</li><li>指令由操作码和地址码组成。</li><li>存储程序。</li><li><font color=red><strong>以运算器为中心。（输入&#x2F;输出设备与存储器之间的数据传送通过运算器完成。）</strong></font></li></ol><h4 id="3-1-2-现代计算机结构"><a href="#3-1-2-现代计算机结构" class="headerlink" title="3.1.2 现代计算机结构"></a>3.1.2 现代计算机结构</h4><img src="https://pic.imgdb.cn/item/6602aa0d9f345e8d038bb3a4.png" alt="计算机组成原理（一）——计算机系统概述——现代计算机结构.png"><p><font color=red><strong>现代计算机结构特点：以存储器为中心。</strong></font></p><p><font color=purple><strong>CPU&#x3D;运算器+控制器</strong></font></p><img src="https://pic.imgdb.cn/item/6602ab369f345e8d039249b9.png" alt="计算机组成原理（一）——计算机系统概述——现代计算机结构系统.png"><h4 id="3-1-3-硬件组成小结"><a href="#3-1-3-硬件组成小结" class="headerlink" title="3.1.3 硬件组成小结"></a>3.1.3 硬件组成小结</h4><img src="https://pic.imgdb.cn/item/6602ab8a9f345e8d03942333.png" alt="计算机组成原理（一）——计算机系统概述——硬件组成小结.png"><h3 id="3-2-各硬件的工作原理"><a href="#3-2-各硬件的工作原理" class="headerlink" title="3.2 各硬件的工作原理"></a>3.2 各硬件的工作原理</h3><h4 id="3-2-1-主存储器的组成"><a href="#3-2-1-主存储器的组成" class="headerlink" title="3.2.1 主存储器的组成"></a>3.2.1 主存储器的组成</h4><p>存储器被分为主存储器（也称内存储器或主存，我们还常说他是运行内存）和辅助存储器（也称外存储器或外存，我们也常说他是机身存储）。CPU能够直接访问的存储器是主存储器。辅助存储器用于帮助主存储器记忆更多的信息。主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为<font color=red><strong>按地址存取方式</strong></font>。</p><img src="https://pic.imgdb.cn/item/6602ac959f345e8d039a18a7.png" alt="计算机组成原理（一）——计算机系统概述——主存储器的组成.png"><p><font color=red><strong>MAR：地址寄存器。</strong></font></p><p><font color=red><strong>MDR：数据寄存器。</strong></font></p><p><font color=red><strong>存储体：存放二进制信息。</strong></font></p><p>CPU从主存储器读取数据过程：首先，CPU将所要读取数据的地址写到MAR地址寄存器里。然后，主存储器根据MAR地址寄存器里接收到的地址信息，去存储体里找到该地址上的数据，并将其写到MDR的数据寄存器里。最后，CPU通过数据总线去MDR里读取想要的数据。</p><p>CPU向主存储器写入数据过程：首先，CPU先向MAR里写入想要写入数据所存放的地址。然后，CPU通过控制总线告诉主存储器这次操作为写操作。最后，CPU通过数据总线向MDR里写入该地址上想要写入的数据。</p><p>注意：CPU向主存储器里进行读写操作时，一般都是先给MAR，再给CU，MDR会等待操作以后才进行数据读写。</p><p>先给MAR，再通过CU给控制信号是因为在CPU执行读取指令的过程中，这个地址由PC（程序计数器）提供，通过内部总线传递到MAR。当MAR接收到地址后，它会通过地址总线将指令地址发送到存储器。</p><p>在地址信号稳定之后，CPU的控制单元（CU）才会发出读写信号。这是因为需要确保地址信号已经稳定，防止在地址信号变化期间错误地写入数据，从而避免破坏数据。</p><p>因此，CPU在执行读取指令的过程中，是先向MAR发送地址，等地址信号稳定后再通过CU发出读写信号。这个过程确保了数据读取的准确性和可靠性。</p><h4 id="3-2-2-运算器的基本组成"><a href="#3-2-2-运算器的基本组成" class="headerlink" title="3.2.2 运算器的基本组成"></a>3.2.2 运算器的基本组成</h4><p><img src="https://pic.imgdb.cn/item/6603f2669f345e8d03dfdb0c.png" alt="计算机组成原理（一）——计算机系统概述——运算器的组成.png">运算器的主要作用是用于进<strong>算术运算和逻辑运算</strong>。</p><p>运算器的核心是<font color=red><strong>算术逻辑单元（ALU）</strong></font>。运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等。</p><p>运算器内部还有<strong>程序状态寄存器（PSW），也称标志寄存器。</strong>（PSW即操作系统里所讲的内核态和用户态的标志位，可以联系我的操作系统第一章笔记里的中断和异常一起学习。<a href="https://bandit-ljc-1.github.io/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">[操作系统（一）—— 计算机系统概述]</a>）</p><h4 id="3-2-3-控制器的基本组成"><a href="#3-2-3-控制器的基本组成" class="headerlink" title="3.2.3 控制器的基本组成"></a>3.2.3 控制器的基本组成</h4><img src="https://pic.imgdb.cn/item/6602bb499f345e8d03f3b03f.png" alt="计算机组成原理（一）——计算机系统概述——控制器的基本组成.png"><p>一条指令的完成分为三个阶段：</p><p>​第一阶段：会根据PC里面记录的指令地址，从内存里取出该地址上的指令。被取出的指令会放在IR里。</p><p>​第二阶段：CU分析IR里的指令。</p><p>​第三阶段：当CU分析完IR指令以后，CU会控制其它部件，来配合着完成指令的具体执行。</p><p>注意：很多地方也会把前面两个阶段统一的称为取指阶段，最后一个阶段称为执行阶段。</p><h4 id="3-2-4-计算机工作过程"><a href="#3-2-4-计算机工作过程" class="headerlink" title="3.2.4 计算机工作过程"></a>3.2.4 计算机工作过程</h4><p>这里以执行下面这段程序为例，来展示计算机的工作过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">2</span>,b=<span class="number">3</span>,c=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">y=a*b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序经过编译之后，以机器指令的形式装载进如下图的主存。</p><img src="https://pic.imgdb.cn/item/6602be079f345e8d03063175.png" alt="计算机组成原理（一）——计算机系统概述——主存装载指令.png"><p>第一条指令（主存地址为0）执行过程：</p><img src="https://pic.imgdb.cn/item/6602bf109f345e8d030d58d8.png" alt="计算机组成原理（一）——计算机系统概述——第一条指令执行过程.png"><p>第二条指令（主存地址为1）执行过程：</p><img src="https://pic.imgdb.cn/item/660391359f345e8d0358fe9e.png" alt="计算机组成原理（一）——计算机系统概述——第二条指令执行过程.png"><p>第三条指令（主存地址为2）执行过程：</p><img src="https://pic.imgdb.cn/item/6603919a9f345e8d035a9d46.png" alt="计算机组成原理（一）——计算机系统概述——第三条指令执行过程.png"><p>第四条指令（主存地址为3）执行过程：</p><img src="https://pic.imgdb.cn/item/660391fa9f345e8d035c12de.png" alt="计算机组成原理（一）——计算机系统概述——第四条指令执行过程.png"><p>第五条指令（主存地址为4）执行过程：</p><img src="https://pic.imgdb.cn/item/660392529f345e8d035d835a.png" alt="计算机组成原理（一）——计算机系统概述——第五条指令执行过程.png"><p><font color=red><strong>注意：CPU区分指令和数据的依据：指令周期的不同阶段。</strong></font>即CPU根据指令执行周期的不同，就处于不同的阶段，CPU就能区分出这次从内存里取出的是指令还是数据。</p><h4 id="3-2-5-硬件工作原理小结"><a href="#3-2-5-硬件工作原理小结" class="headerlink" title="3.2.5 硬件工作原理小结"></a>3.2.5 硬件工作原理小结</h4><img src="https://pic.imgdb.cn/item/660393fc9f345e8d0364b96b.png" alt="计算机组成原理（一）——计算机系统概述——硬件工作原理小结.png"><h3 id="3-3-计算机系统层次结构"><a href="#3-3-计算机系统层次结构" class="headerlink" title="3.3 计算机系统层次结构"></a>3.3 计算机系统层次结构</h3><h4 id="3-3-1-计算机系统的层次结构"><a href="#3-3-1-计算机系统的层次结构" class="headerlink" title="3.3.1 计算机系统的层次结构"></a>3.3.1 计算机系统的层次结构</h4><p>计算机是一个硬软件组成的综合体。因为面对的应用范围越来越广，所以必须有复杂的系统软件和硬件的支持。由于软&#x2F;硬件设计者和使用者从不同角度、用不同语言来对待同一个计算机系统，因此他们看到的计算机系统的属性对计算机系统提出的要求也就各不相同。</p><p>为了针对上述情况，就产生了计算机系统的多级层次结构的作用，根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统。</p><p>但关于计算机系统层次结构的分层方式，目前尚无统一的标准。</p><img src="https://pic.imgdb.cn/item/6603977c9f345e8d03738a82.png" alt="计算机组成原理（一）——计算机系统概述——计算机系统层次结构.png"><p>上图是常用的一种计算机系统层次结构。大致可分为以下5级：</p><ol><li>第1级是微程序机器层，这是一个实在的硬件层，由机器硬件直接执行微指令。</li><li>第2级是传统机器语言层，这也是一个实际的机器层，由微程序解释机器指令系统。</li><li>第3级是操作系统层，它由操作系统程序实现。（可查看操作系统笔记，在此不详述。）</li><li>第4级是汇编语言层，这一层由汇编程序支持和执行，借此可编写汇编语言源程序。</li><li>第5级是高级语言层，它是面向用户的，是为了方便用户编写应用程序而设置。</li></ol><p>注意：</p><ol><li>层次之间的关系紧密，下层是上层的基础，上层是下层的扩展。</li><li>软件和硬件之间的界面就是<font color=green><strong>指令集体系结构（ISA）</strong></font>，ISA定义了一台计算机可以执行的所有指令的集合，每条指令规定了计算机执行什么操作，以及所处理的操作数存放的地址空间和操作数类型。可以看出，ISA是指软件能感知到的部分，也称软件可见部分。</li></ol><h4 id="3-3-2-三个级别的语言"><a href="#3-3-2-三个级别的语言" class="headerlink" title="3.3.2 三个级别的语言"></a>3.3.2 三个级别的语言</h4><p>三个级别的语言分别是：机器语言、汇编语言和高级语言。</p><p>机器语言：也称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。</p><p>汇编语言：汇编语言用英文单词或其缩写代替二进制的指令代码。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为机器语言程序后，才能在计算机的硬件系统上执行。</p><p>高级语言：高级语言是为方便程序设计人员写出解决问题的处理方案和解题过程的此程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</p><p>补充：各种翻译程序的概念</p><ol><li>编译程序（编译器）：将高级语言编写的源程序全部语句依次全部翻译成机器语言程序，而后再执行机器语言程序。</li><li>解释程序（解释器）：将源程序的一条语句翻译成对应机器语言的语句，并立即执行。紧接着再翻译下一句。</li><li>汇编程序（汇编器）：将汇编语言程序翻译成机器语言程序。</li></ol><p>如果某一功能能被硬件实现也能被软件实现，在用户角度来看，它在功能上是等价的。这一等价性被称为软&#x2F;硬件逻辑功能的等价性。（可查看3.计算机系统层次结构一栏的开头）</p><img src="https://pic.imgdb.cn/item/6603ac1e9f345e8d03d21d91.png" alt="计算机组成原理（一）——计算机系统概述——三个级别的语言.png"><h4 id="3-3-3-计算机层次结构小结"><a href="#3-3-3-计算机层次结构小结" class="headerlink" title="3.3.3 计算机层次结构小结"></a>3.3.3 计算机层次结构小结</h4><img src="https://pic.imgdb.cn/item/6603ac579f345e8d03d30556.png" alt="计算机组成原理（一）——计算机系统概述——计算机层次结构.png"><h2 id="4-计算机性能指标"><a href="#4-计算机性能指标" class="headerlink" title="4. 计算机性能指标"></a>4. 计算机性能指标</h2><h3 id="4-1-机器字长"><a href="#4-1-机器字长" class="headerlink" title="4.1 机器字长"></a>4.1 机器字长</h3><p>通常所说的“某16位或32位机器”，其中的16，32指的是<strong>机器字长</strong>，简称字长。<strong>字长</strong>是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，通常与CPU的寄存器位数、ALU有关。</p><p>补充：计算机中的ALU和通用寄存器的位数（宽度）一定与机器字长相同。</p><p><font color=purple><strong>考题</strong></font>：下列给出的部件中，其位数（宽度）一定与机器字长相同的是（ B）。</p><p>​Ⅰ. ALUⅡ. 指令寄存器Ⅲ. 通用寄存器IV. 浮点寄存器</p><p>​A. 仅Ⅰ、ⅡB. 仅Ⅰ、ⅢC. 仅Ⅱ、ⅢD. 仅Ⅱ、Ⅲ、IV</p><p>解答：</p><p>机器字长是指计算机进行一次整数运算所能处理的二进制数据的位数（整数运算即定点整数运算）。因为计算机中数的表示有定点数和浮点数之分，定点数又有定点整数和定点小数之分，这里所说的整数运算即定点整数运算。机器字长也就是运算器进行定点数运算的字长，通常也是CPU内部数据通路的宽度。</p><p>机器字长反映了计算机的运算精度，即字长越长，数的表示范围也越大，精度也越高。机器的字长也会影响机器的运算速度。倘若CPU字长较短，又要运算位数较多的数据，那么需要经过两次或多次的运算才能完成，这样势必影响整机的运行速度。</p><p>机器字长与主存储器字长通常是相同的，但也可以不同。不同的情况下，一般是主存储器字长小于机器字长，例如机器字长是32位，主存储器字长可以是32位，也可以是16位，当然，两者都会影响CPU的工作效率。</p><p>Ⅰ. ALU（算术逻辑单元）：ALU是执行算术和逻辑操作的核心部件。它通常是根据机器字长设计的，能够处理与机器字长相同位数的数据。因此，ALU的位数一定与机器字长相同。正确。</p><p>Ⅱ. 指令寄存器：指令寄存器用于存储当前执行的指令。其位数（宽度）可能比机器字长更小，因为指令可能只需要较少的位数来表示。错误。</p><p>Ⅲ. 通用寄存器：通用寄存器是用于存储临时数据和计算结果的寄存器。这些寄存器通常与机器字长相匹配，以便能够存储和处理与机器字长相同位数的数据。正确。</p><p>IV. 浮点寄存器：浮点寄存器用于存储浮点数数据。其位数可以与机器字长相同，也可以不同，取决于计算机体系结构的设计。错误。</p><p>综上，Ⅰ和Ⅲ的位数一定与机器字长相同。本题选B。</p><h3 id="4-2-数据通路带宽"><a href="#4-2-数据通路带宽" class="headerlink" title="4.2 数据通路带宽"></a>4.2 数据通路带宽</h3><p>数据通路带宽是指数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）。这里所说的数据通路宽度是指外部数据总线的宽度，它与CPU内部的数据总线宽度（内部寄存器的大小）有可能不同。</p><p>例如：假设数据通路带宽为8bit，那么想从存储体里读取16bit数据到CPU里，就要进行两次数据传输。</p><h3 id="4-3-主存容量"><a href="#4-3-主存容量" class="headerlink" title="4.3 主存容量"></a>4.3 主存容量</h3><p>主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数×字长（如512K×16位）来表示存储容量。其中MAR的位数反映了存储单元的个数，MDR的位数反映了存储单元的字长。例如MAR位16位，表示2<sup>16</sup>&#x3D;65536，即此存储体内有65536个存储单元（可称为64K内存，1K&#x3D;1024），若MDR为32位，则表示存储容量为64K×32位。</p><img src="https://pic.imgdb.cn/item/6603cc309f345e8d03c57ea8.png" alt="计算机组成原理（一）——计算机系统概述——主存容量.png"><h3 id="4-4-运算速度"><a href="#4-4-运算速度" class="headerlink" title="4.4 运算速度"></a>4.4 运算速度</h3><h4 id="4-4-1-吞吐量和响应时间"><a href="#4-4-1-吞吐量和响应时间" class="headerlink" title="4.4.1 吞吐量和响应时间"></a>4.4.1 吞吐量和响应时间</h4><p>（1）吞吐量：指系统在单位时间内处理请求的数量。它取决于信息能够多快地输入内存，CPU能多快地取指令，数据能多快地从内存取出或存入。</p><p>（2）响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。</p><h4 id="4-4-2-主频-CPU时钟周期-CPI"><a href="#4-4-2-主频-CPU时钟周期-CPI" class="headerlink" title="4.4.2 主频&amp;CPU时钟周期&amp;CPI"></a>4.4.2 主频&amp;CPU时钟周期&amp;CPI</h4><p>（1）CPU时钟周期：机器内部主时钟脉冲信号的宽度，它是CPU工作的最小时间单位。单位常用微秒，纳秒。</p><p>​时钟脉冲信号由机器脉冲源发出的脉冲信号径整形和分频后形成。</p><p>​时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定。</p><p>​时钟周期也以指令流水线的每个流水段的最大延迟时间确定。</p><p>（2）主频（CPU时钟频率）：机器内部主时钟的频率（CPU内数字脉冲信号振荡的频率），即时钟周期的倒数，它是衡量机器速度的重要参数。单位常用Hz（赫兹）（10Hz：每秒振荡10次或每秒产生10个时钟周期。）</p><p>对于同一型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。主频最直观的理解就是每秒有多少个时钟周期。</p><p>（3）CPI：即执行一条指令所需的时钟周期数。不同的指令，CPI不同。相同的指令，CPI也可能发生变化。</p><p><font color=blue><strong>执行一条指令的耗时&#x3D;CPI×CPU时钟周期</strong></font> </p><img src="https://pic.imgdb.cn/item/6603d2119f345e8d03f55fb7.png" alt="计算机组成原理（一）——计算机系统概述——主频和时钟周期和CPI.png"><h4 id="4-4-3-IPS-FLOPS-基准程序"><a href="#4-4-3-IPS-FLOPS-基准程序" class="headerlink" title="4.4.3 IPS&amp;FLOPS&amp;基准程序"></a>4.4.3 IPS&amp;FLOPS&amp;基准程序</h4><p>（1）IPS：每秒执行多少条指令。</p><p>（2）FLOPS：即每秒执行多少次浮点运算。</p><img src="https://pic.imgdb.cn/item/6603d3b49f345e8d0302c89a.png" alt="计算机组成原理（一）——计算机系统概述——IPS和FLOPS.png"><p>（3）基准程序：专门用来进行性能评价的一组程序，如鲁大师跑分，就是通过测试电脑执行程序进行性能评估。</p><h4 id="4-4-5-补充思考"><a href="#4-4-5-补充思考" class="headerlink" title="4.4.5 补充思考"></a>4.4.5 补充思考</h4><ol><li><p>主频高的CPU一定比主频低的CPU快吗？</p><p>答：不一定，如果两个CPU，A的主频为2GHz，平均CPI&#x3D;10，则IPS&#x3D;0.2G。</p><p>B的主频为1GHz，平均CPI&#x3D;1，则IPS&#x3D;1G。显然B的CPU主频没A高，但比A快。</p></li><li><p>若A主频高于B，且A、B两个CPU的平均CPI相同，那么A一定更快吗？</p><p>答：不一定，还要看指令系统，如果A不支持乘法指令，只能用多次加法实现乘法；而B支持乘法指令，那么B可能表现的比A快。</p></li><li><p>基准此程序执行得越快说明机器性能越好吗？</p><p>答：不一定，基准程序中的语句存在频度差异，运行结果也不能完全说明问题。</p></li></ol><h3 id="4-5-计算机性能小结"><a href="#4-5-计算机性能小结" class="headerlink" title="4.5 计算机性能小结"></a>4.5 计算机性能小结</h3><img src="https://pic.imgdb.cn/item/6603d7f59f345e8d03244051.png" alt="计算机组成原理（一）——计算机系统概述——计算机性能小结.png">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）——计算机系统概述</title>
      <link href="/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="1-操作系统的基本概念"><a href="#1-操作系统的基本概念" class="headerlink" title="1. 操作系统的基本概念"></a>1. 操作系统的基本概念</h2><h3 id="1-1-操作系统的概念"><a href="#1-1-操作系统的概念" class="headerlink" title="1.1 操作系统的概念"></a>1.1 操作系统的概念</h3><p><font color=red><strong>操作系统（OS）</strong></font>：是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。</p><img src="https://pic.imgdb.cn/item/65fd91e79f345e8d03fbfe4f.png" alt="操作系统（一）——计算机系统概述——操作系统层次结构.png"><p>注意：操作系统是最接近硬件的一层软件。</p><h3 id="1-2-操作系统的特征"><a href="#1-2-操作系统的特征" class="headerlink" title="1.2 操作系统的特征"></a>1.2 操作系统的特征</h3><h4 id="1-2-1-并发"><a href="#1-2-1-并发" class="headerlink" title="1.2.1 并发"></a>1.2.1 并发</h4><p>并发：并发是指两个或多个事件在同一时间间隔内发生。（<font color=red>宏观上是同时发生的，微观上是交替的。</font>）</p><p>并发与并行的辨析：</p><p>​(1)并行性指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。而并发性在同一时刻只能运行一种工作。</p><p>​(2)并发之所以让人类感觉工作是在同时进行的，是因为并发运行交替速度过快，所以人类在感官上觉得是在同时运行。</p><img src="https://pic.imgdb.cn/item/65fd25e29f345e8d0320417e.png" alt="操作系统（一）——计算机系统概述——并发.png"><h4 id="1-2-2-共享"><a href="#1-2-2-共享" class="headerlink" title="1.2.2 共享"></a>1.2.2 共享</h4><p>共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>两种共享方式：</p><ol><li><p>互斥共享</p><p>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。这种资源共享方式称为<font color=red><strong>互斥共享</strong></font>。而将在一段时间内只允许一个进程访问的资源称为<font color=blue><strong>临界资源</strong></font>。</p></li><li><p>同时访问</p><p>系统中的某些资源，允许同一个时间段内由多个进程”同时“进行访问。注意，”同时”通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即“分时共享”的。</p></li></ol><h4 id="1-2-3-虚拟"><a href="#1-2-3-虚拟" class="headerlink" title="1.2.3 虚拟"></a>1.2.3 虚拟</h4><p>虚拟：虚拟是指将一个物理上的实体变为若干逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物是用户感受到的。用于实现虚拟的技术称为虚拟技术。</p><p><font color=red><strong>虚拟技术：时分复用技术（如虚拟处理器）、空分复用技术（如虚拟存储器）</strong></font></p><ol><li>时分复用技术：通过多道程序设计技术，让多道程序并发执行，来分时使用一个处理器。此时，虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个CPU在专门为它服务。利用多道程序设计技术将一个物理上的CPU虚拟为多个逻辑上的CPU，称为虚拟处理器。</li><li>空分复用技术：采用虚拟存储器技术将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。我们将用户感觉到（但实际不存在）的存储器称为虚拟存储器。</li></ol><h4 id="1-2-4-异步"><a href="#1-2-4-异步" class="headerlink" title="1.2.4 异步"></a>1.2.4 异步</h4><p>异步：多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。</p><p>举例：程序A、B并发执行，两道程序都有占用CPU的指令，如果A先执行占用CPU了，此时B并发的执行到占用CPU指令时，B会停止运行进行等待，等待A将CPU资源释放，B才会占用CPU。例如打印机，两个人同时使用，但A已经在打印，B需要等A打印完才可使用打印机。</p><h4 id="1-2-5-小结"><a href="#1-2-5-小结" class="headerlink" title="1.2.5 小结"></a>1.2.5 小结</h4><p>（1）共发和共享是操作系统两个最基本的特征，两者之间互为存在的条件。资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</p><p>（2）如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义。因此，没有并发性就谈不上虚拟性。</p><p>（3）如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。</p><img src="https://pic.imgdb.cn/item/65fd915e9f345e8d03f63cd1.png" alt="操作系统（一）——计算机系统概述——特征总结.png"><h3 id="1-3-操作系统的目标和功能"><a href="#1-3-操作系统的目标和功能" class="headerlink" title="1.3 操作系统的目标和功能"></a>1.3 操作系统的目标和功能</h3><p>为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：处理机管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时，操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p><h4 id="1-3-1-操作系统作为计算机系统资源的管理者"><a href="#1-3-1-操作系统作为计算机系统资源的管理者" class="headerlink" title="1.3.1 操作系统作为计算机系统资源的管理者"></a>1.3.1 操作系统作为计算机系统资源的管理者</h4><p>操作系统作为计算机系统资源的管理者提供四种功能，分别是处理机管理、存储器管理、设备管理和文件管理。目标是为了程序运行安全、高效。</p><p>（1）处理机管理</p><p>处理机管理也称进程管理，在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位，因而对处理机的管理可归结为对进程的管理。</p><p>注意区分处理机和处理器：</p><p>​处理机：是处理计算机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。</p><p>​处理器：作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。</p><p>（2）存储器管理</p><p>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。</p><p>（3）文件管理</p><p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为文件系统。</p><p>（4）设备管理</p><p>设备管理的主要任务是完成用户的I&#x2F;O请求，方便用户使用各种设备，并提高设备的利用率。</p><p>补充知识点：每一个程序执行前都需要将该程序放到内存中，才能被CPU处理。</p><h4 id="1-3-2-操作系统作为用户与计算机硬件系统之间的接口"><a href="#1-3-2-操作系统作为用户与计算机硬件系统之间的接口" class="headerlink" title="1.3.2 操作系统作为用户与计算机硬件系统之间的接口"></a>1.3.2 操作系统作为用户与计算机硬件系统之间的接口</h4><p>硬件只能听得懂二进制指令，所以在硬件之上安装了操作系统，操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p><p>操作系统提供的接口主要分为两类：命令接口与程序接口。</p><p>（1）命令接口（用户利用这些操作命令来组织和控制作业的执行。）：使用命令接口进行作业控制的主要方式有两种，即联机控制方式和脱机控制方式。按作业控制方式的不同，可将命令接口分为联机命令接口和脱机命令接口。</p><p>​联机命令接口：又称交互式命令接口，适用于分时或实时系统的接口。用户每输入一条命令，控制权就转给操作系统的命令解释程序。（用户说一句系统跟着做一句。）</p><p>​脱机命令接口：又称批处理命令接口，适用于批处理系统，它由一组作业控制命令组成。脱机用户不能直接干预作业的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。（用户说一堆，系统做一堆。）</p><p>（2）程序接口（编程人员可以使用它们来请求操作系统服务）：程序接口由一组<font color=red><strong>系统调用</strong></font>（也称广义指令。系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式。）组成。用户通过在程序中使用这些系统调用来请求操作系统为其提供服务。（普通用户不能直接使用，只能通过程序代码间接使用。）当前最流行的是图形用户界面（GUI），即图形接口。</p><h4 id="1-3-3-操作系统实现了对计算机资源的扩充"><a href="#1-3-3-操作系统实现了对计算机资源的扩充" class="headerlink" title="1.3.3 操作系统实现了对计算机资源的扩充"></a>1.3.3 操作系统实现了对计算机资源的扩充</h4><p>没有任何软件支持的计算机称为<font color=blue><strong>裸机</strong></font>，它仅构成计算机系统的物质基础，而实际呈现在用户面前的计算机系统是经过若干层软件改造的计算机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强，使用更方便的机器。通常把覆盖了软件的机器称为<font color=blue><strong>扩充机器</strong></font>，又称之为<font color=blue><strong>虚拟机</strong></font>。</p><h4 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4 小结"></a>1.3.4 小结</h4><img src="https://pic.imgdb.cn/item/65fd9b9e9f345e8d03587c7b.png" alt="操作系统（一）——计算机系统概述——操作系统功能.png"><h2 id="2-操作系统的发展与分类"><a href="#2-操作系统的发展与分类" class="headerlink" title="2. 操作系统的发展与分类"></a>2. 操作系统的发展与分类</h2><h3 id="2-1-手工操作阶段（此阶段无操作系统）"><a href="#2-1-手工操作阶段（此阶段无操作系统）" class="headerlink" title="2.1 手工操作阶段（此阶段无操作系统）"></a>2.1 手工操作阶段（此阶段无操作系统）</h3><p>手工操作阶段用户在计算机上算题的所有工作都要人工干预。</p><p>手工操作阶段有两个突出的缺点：</p><ol><li>用户独占全机，资源利用率低。</li><li>CPU等待手工操作，CPU的利用不充分。</li></ol><p>对于手工操作阶段的缺点，唯一的解决办法是用高速的机器代替相对较慢的手工操作来对作业进行控制。</p><img src="https://pic.imgdb.cn/item/65fecca49f345e8d03b4e2d6.png" alt="操作系统（一）——计算机系统概述——手工操作阶段.png"><h3 id="2-2-批处理阶段（操作系统开始出现）"><a href="#2-2-批处理阶段（操作系统开始出现）" class="headerlink" title="2.2 批处理阶段（操作系统开始出现）"></a>2.2 批处理阶段（操作系统开始出现）</h3><p>为了解决人机矛盾及CPU和I&#x2F;O设备之间速度不匹配的矛盾，出现了批处理系统。按发展历程又分为单道批处理系统、多道批处理系统（多道程序设计技术出现以后）。</p><h4 id="2-2-1-单道批处理系统（操作系统的雏形）"><a href="#2-2-1-单道批处理系统（操作系统的雏形）" class="headerlink" title="2.2.1 单道批处理系统（操作系统的雏形）"></a>2.2.1 单道批处理系统（操作系统的雏形）</h4><p>为实现对作业的连续处理，要先将一批作业以<font color =red><strong>脱机方式</strong></font>输入磁带，并在系统中配上监督程序，再其控制下，使这批作业能一个接一个地连续处理。虽然系统对作业的处理是成批的，但内存中始终保持一道作业。这就是单道批处理系统</p><p>单道批处理系统主要特征：</p><ol><li>自动性。自动运行作业。</li><li>顺序性。磁带上各道作业按顺序地进入内存。</li><li>单道性。内存中仅有一道程序运行。</li></ol><p>单道批处理系统面临的问题：每次主机内存中仅存放一道作业，每当它在运行期间发出输入&#x2F;输出请求后，高速的CPU便处于等待低速的I&#x2F;O完成的状态。为了进一步提高资源的利用率和系统的吞吐量，所以引入了多道程序技术。</p><img src="https://pic.imgdb.cn/item/65fed1739f345e8d03e5611d.png" alt="操作系统（一）——计算机系统概述——单道批处理.png"><h4 id="2-2-2-多道批处理系统（操作系统正式诞生）"><a href="#2-2-2-多道批处理系统（操作系统正式诞生）" class="headerlink" title="2.2.2 多道批处理系统（操作系统正式诞生）"></a>2.2.2 多道批处理系统（操作系统正式诞生）</h4><p>多道批处理系统：在内存中存放多道程序，当某道程序因某种原因如执行I&#x2F;O操作时而不能继续运行放弃CPU时，操作系统便调度另一程序运行，这样CPU就尽量忙碌，达到提高系统效率的目的。</p><p>多道程序设计的特点：</p><ol><li>多道。计算机内存中同时存放多道相互独立的程序。</li><li>宏观上并行。同时进入系统的多道程序都处于运行过程中，但都未运行完毕。</li><li>微观上串行。内存中的多道程序轮流占有CPU，交替执行。</li></ol><p>多道程序设计的优点：资源利用率高；系统吞吐量大。</p><p>多道程序设计的缺点：用户响应时间长；不提供人机交互能力。</p><img src="https://pic.imgdb.cn/item/65fed33e9f345e8d03f934f7.png" alt="操作系统（一）——计算机系统概述——多道批处理.png"><h3 id="2-3-分时操作系统"><a href="#2-3-分时操作系统" class="headerlink" title="2.3 分时操作系统"></a>2.3 分时操作系统</h3><p>分时操作系统：是指将处理器的运行时间分成很短的时间片，按时间片轮流将处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成计算，则该作业暂时停止运行，将处理器让给其它作业使用，等待下一轮在继续运行。</p><p>分时操作系统的主要特征：</p><ol><li>同时性。多个用户可以同时使用一台计算机。</li><li>交互性。可以进行人机交互。</li><li>独立性。系统中多个用户可以彼此独立地进行操作，互不干扰。</li><li>及时性。用户请求能在很短时间内获得响应。</li></ol><p>分时操作系统的缺点：不能优先处理一些紧急任务。在一些场合需要系统能对外部信号在规定时间内做出处理，为此操作系统在某些场合就要优先处理某些程序。</p><img src="https://pic.imgdb.cn/item/65fed70f9f345e8d03250b1b.png" alt="操作系统（一）——计算机系统概述——分时操作系统.png"><h3 id="2-4-实时操作系统"><a href="#2-4-实时操作系统" class="headerlink" title="2.4 实时操作系统"></a>2.4 实时操作系统</h3><p>为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。这里的时间限制分为两种情况，若某个动作必须绝对地在规定的时刻（或规定的时间范围）发生，则称为<font color=red><strong>硬实时系统</strong></font>。若能够偶尔接受违反时间规定且不会引起任何永久性的损害，则称为<font color=red><strong>软实时系统</strong></font>。</p><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在<font color=red><strong>严格的时限内</strong></font>处理完接收的事件。</p><p>实时操作系统的主要特点·：及时性和可靠性。</p><img src="https://pic.imgdb.cn/item/65fee4129f345e8d03afd338.png" alt="操作系统（一）——计算机系统概述——实时操作系统.png"><h3 id="2-5-其它几种操作系统（了解）"><a href="#2-5-其它几种操作系统（了解）" class="headerlink" title="2.5 其它几种操作系统（了解）"></a>2.5 其它几种操作系统（了解）</h3><p>（1）网络操作系统：将计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。</p><p>（2）分布式计算机系统：分布式计算机系统由多台计算机组成，且系统中任意两台计算机通过通信方式交换信息；系统中的每台计算机都具有同等的地位；系统中每台计算机上的资源为所有用户共享；系统中任意台计算机都可以构成一个子系统；任何工作都可以分布在几台计算机上。用于管理分布式计算机系统的操作系统称为<font color=red><strong>分布式计算机系统</strong></font>。该系统的主要特点：分布性和并行性。</p><p>（3）个人计算机操作系统：个人计算机操作系统是目前使用最广泛的操作系统，常见的有Windows、linux。</p><img src="https://pic.imgdb.cn/item/65fee6459f345e8d03c60567.png" alt="操作系统（一）——计算机系统概述——其它操作系统.png"><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><img src="https://pic.imgdb.cn/item/65fee7349f345e8d03cee0c3.png" alt="操作系统（一）——计算机系统概述——操作系统发展历程.png"><p><font color=red><strong>手工阶段</strong></font>，计算机造价昂贵，但工作时却有大量时间处于空闲状态，为了解决这个问题人类发明了<font color=red><strong>单道批处理系统</strong></font>。单道批处理系统虽然较手工阶段资源利用率有所提升，但仍有大量空闲时间等待I&#x2F;O操作完成，资源利用率仍然很低。为了进一步提高资源利用率，人类发明了<font color=red><strong>多道批处理系统</strong></font>。这个阶段操作系统正式诞生，但在这阶段，用户无法进行程序调试，所以为了实现人机交互，人类发明了<font color=red><strong>分时操作系统</strong></font>。分时操作系统给每个用户分配相同的时间段，导致不能优先处理一些紧急任务，为了解决这个问题，于是发明了<font color=red><strong>实时操作系统</strong></font>。</p><img src="https://pic.imgdb.cn/item/65fee6a19f345e8d03c96b4e.png" alt="操作系统（一）——计算机系统概述——操作系统发展小结.png"><h2 id="3-操作系统的运行环境"><a href="#3-操作系统的运行环境" class="headerlink" title="3. 操作系统的运行环境"></a>3. 操作系统的运行环境</h2><h3 id="3-1-处理器运行模式"><a href="#3-1-处理器运行模式" class="headerlink" title="3.1 处理器运行模式"></a>3.1 处理器运行模式</h3><h4 id="3-1-1-内核程序-应用程序"><a href="#3-1-1-内核程序-应用程序" class="headerlink" title="3.1.1 内核程序&amp;应用程序"></a>3.1.1 内核程序&amp;应用程序</h4><p>在计算机系统中，通常CPU执行两种不同性质的程序：一种是操作系统<font color=red><strong>内核程序</strong></font>；另一种是用户<font color=red><strong>自编程序</strong></font>（系统外层的应用程序，简称<font color=red><strong>应用程序</strong></font>）。</p><p>我们普通程序员写的程序是“应用程序”，而像微软公司有一部分人负责实现操作系统，他们写的就是“内核程序”。很多内核程序就组成了“操作系统内核”，简称<font color=red><strong>“内核”</strong></font>。</p><p><font color=blue><strong>内核是操作系统最重要最核心的部分，也是最接近硬件的部分。</strong></font></p><p>对于操作系统内核程序和用户自编程序，前者是后者的管理者，因此“管理程序”（内核程序）要执行一些特权指令，而“被管理程序”（用户自编程序）出于安全考虑不能执行这些特权指令。</p><h4 id="3-1-2-特权指令-非特权指令"><a href="#3-1-2-特权指令-非特权指令" class="headerlink" title="3.1.2 特权指令&amp;非特权指令"></a>3.1.2 特权指令&amp;非特权指令</h4><p>特权指令：是指不允许用户直接使用的指令，如I&#x2F;O指令、关中断指令等。（内核程序使用）</p><p>非特权指令：是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这是为了防止用户程序对系统造成破坏。（应用程序使用）</p><p>注意：CPU在设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。</p><h4 id="3-1-3-内核态-用户态"><a href="#3-1-3-内核态-用户态" class="headerlink" title="3.1.3 内核态&amp;用户态"></a>3.1.3 内核态&amp;用户态</h4><p>CPU的运行模式划分为两态：<font color=red><strong>用户态（又称目态）和核心态（又称管态、内核态）。</strong></font></p><p>用户态：不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间。（运行应用程序，只能执行非特权指令。）</p><p>内核态：系统中既有操作系统的程序，也有普通用户程序。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行。（运行内核程序，可以执行特权指令。）</p><p>拓展：CPU中有一个寄存器叫<font color=red><strong>程序状态字寄存器（PSW）</strong></font>，其中有个二进制位，1表示“内核态”，0表示“用户态”。</p><img src="https://pic.imgdb.cn/item/65ffe9419f345e8d03c1c85f.png" alt="操作系统（一）——计算机系统概述——内核态用户态切换.png"><h4 id="3-1-4-运行机制小结"><a href="#3-1-4-运行机制小结" class="headerlink" title="3.1.4 运行机制小结"></a>3.1.4 运行机制小结</h4><img src="https://pic.imgdb.cn/item/65ffe98b9f345e8d03c44428.png" alt="操作系统（一）——计算机系统概述——运行机制.png"><h3 id="3-2-中断和异常"><a href="#3-2-中断和异常" class="headerlink" title="3.2 中断和异常"></a>3.2 中断和异常</h3><p>在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态如何切换。要想使用户程序实现核心态功能，就需要通过<font color=red><strong>中断或异常</strong></font>。发生中断或异常时，运行用户态的CPU会立即进入核心态，而CPU进入核心态是通过<font color=red><strong>硬件实现</strong></font>的（可参考3.1.3中的核心态、用户态切换）。</p><h4 id="3-2-1-中断和异常的定义"><a href="#3-2-1-中断和异常的定义" class="headerlink" title="3.2.1 中断和异常的定义"></a>3.2.1 中断和异常的定义</h4><p>中断：又称外中断，是指来自CPU执行指令外部的事件，通常用于信息输入输出。</p><p>异常：又称内中断，是指来自CPU执行指令内部的时间，如程序的非法操作码，地址越界，陷入指令等。</p><p>注意：</p><p>异常和中断是计算机科学和工程领域中两个不同的概念，尽管它们在某些方面有相似之处，但并非彼此包含。</p><p>异常通常是在程序运行过程中，由于某种错误或不可预期的情况而发生的，它会中断程序的正常执行流程。异常处理机制是程序设计中用来处理运行时错误的重要部分，它允许程序在遇到问题时能够以一种可控的方式做出响应，而不是简单地崩溃。</p><p>而中断则更多地涉及到硬件和操作系统的交互。在计算机科学中，中断是一种由CPU外部的设备或事件触发的信号，要求CPU暂停当前正在执行的程序，转而处理这个中断请求。中断处理完毕后，CPU会返回到被中断的程序继续执行。中断常用于实现设备之间的通信、处理硬件事件等。</p><p>因此，虽然异常和中断都会导致程序或CPU的运行流程发生变化，但它们产生的原因、处理方式和应用场景是不同的。异常主要关注于程序运行时的错误处理，而中断则涉及到硬件和操作系统的交互。所以，异常并不是中断的一部分，它们是两个独立的概念。</p><h4 id="3-2-2-中断和异常的分类"><a href="#3-2-2-中断和异常的分类" class="headerlink" title="3.2.2 中断和异常的分类"></a>3.2.2 中断和异常的分类</h4><p>外中断可分为可屏蔽中断和不可屏蔽中断：</p><ol><li>可屏蔽中断：指通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。</li><li>不可屏蔽中断：指通过NMI线发出的中断请求，通常是紧急的硬件故障。</li></ol><p>异常可分为故障、自陷和终止：</p><ol><li>故障（Fault）：通常是由指令执行引起的异常。</li><li>自陷（Trap，又称陷入）：是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令、系统调用指令等。</li><li>终止（Abort）：是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。</li></ol><p>注意：</p><p>（1）故障异常和自陷异常属于<font color=green><strong>软件中断（程序性异常）</strong></font>，终止异常和外部中断属于<font color=green><strong>硬件中断</strong></font>。</p><p>（2）有时候应用程序想请求操作系统内核的服务，会执行<font color=red><strong>一条特殊的指令——陷入指令</strong></font>。执行“陷入指令”意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用就是通过陷入指令完成的”。</p><img src="https://pic.imgdb.cn/item/65fff5c39f345e8d0322065c.png" alt="操作系统（一）——计算机系统概述——中断分类.png"><h4 id="3-2-3-中断的作用"><a href="#3-2-3-中断的作用" class="headerlink" title="3.2.3 中断的作用"></a>3.2.3 中断的作用</h4><img src="https://pic.imgdb.cn/item/65fff4239f345e8d0315fa1a.png" alt="操作系统（一）——计算机系统概述——中断的作用.png"><h4 id="3-2-4-中断的基本原理"><a href="#3-2-4-中断的基本原理" class="headerlink" title="3.2.4 中断的基本原理"></a>3.2.4 中断的基本原理</h4><img src="https://pic.imgdb.cn/item/65fff6429f345e8d03252fe5.png" alt="操作系统（一）——计算机系统概述——中断机制的基本原理.png"><h4 id="3-2-5-中断小结"><a href="#3-2-5-中断小结" class="headerlink" title="3.2.5 中断小结"></a>3.2.5 中断小结</h4><img src="https://pic.imgdb.cn/item/65fff68e9f345e8d0327517b.png" alt="操作系统（一）——计算机系统概述——中断小结.png"><h3 id="3-3-系统调用"><a href="#3-3-系统调用" class="headerlink" title="3.3 系统调用"></a>3.3 系统调用</h3><h4 id="3-3-1-系统调用的定义及性质"><a href="#3-3-1-系统调用的定义及性质" class="headerlink" title="3.3.1 系统调用的定义及性质"></a>3.3.1 系统调用的定义及性质</h4><p>系统调用：指用户在程序中调用操作系统所提供的一些子功能，它可被视为特殊的公共子程序。</p><img src="https://pic.imgdb.cn/item/66001c639f345e8d03540a2d.png" alt="操作系统（一）——计算机系统概述——系统调用.png"><h4 id="3-3-2-系统调用的功能"><a href="#3-3-2-系统调用的功能" class="headerlink" title="3.3.2 系统调用的功能"></a>3.3.2 系统调用的功能</h4><p>（1）设备管理。完成设备的请求或释放，以及设备启动等功能。</p><p>（2）文件管理。完成文件的读、写、创建及删除等功能。</p><p>（3）进程控制。完成进程的创建，撤销，阻塞及唤醒等功能。</p><p>（4）进程通信。完成进程之间的消息传递或信号传递等功能。</p><p>（5）内存管理。完成内存的分配，回收以及获取作业占用内存区大小和起始地址等功能。</p><img src="https://pic.imgdb.cn/item/66001d799f345e8d035ee1d3.png" alt="操作系统（一）——计算机系统概述——系统调用功能.png"><h4 id="3-3-3-系统调用的过程"><a href="#3-3-3-系统调用的过程" class="headerlink" title="3.3.3 系统调用的过程"></a>3.3.3 系统调用的过程</h4><p><font color=fuchsia><strong>第一步</strong></font>：用户程序首先将系统调用号和所需的参数压入堆栈；接着，调用实际的调用指令，然后执行一个陷入指令，将CPU状态从用户态转为核心态，再后由硬件和操作系统内核程序保护被中断进程的现场，将程序计数器（PC）、程序状态字（PSW）及通用寄存器内容等压入堆栈。</p><p><font color=fuchsia><strong>第二步</strong></font>：分析系统调用类型，转入相应的系统调用处理子程序。在系统中配置了一张系统调用入口表，表中每个表项都对应一个系统调用，根据系统调用号可以找到该系统调用处理子程序的入口地址。</p><p><font color=fuchsia><strong>第三步</strong></font>：在系统调用处理子程序执行结束后，恢复被中断的或设置新进程的CPU现场，然后返回被中断进程或新进程，继续往下执行。</p><p>补充：</p><ol><li>陷入指令是非特权指令，在用户态执行，执行陷入指令后立即引发一个内中断，使CPU进入核心态。</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。</li></ol><img src="https://pic.imgdb.cn/item/660024769f345e8d03a26a31.png" alt="操作系统（一）——计算机系统概述——系统调用过程.png"><h4 id="3-3-4-系统调用小结"><a href="#3-3-4-系统调用小结" class="headerlink" title="3.3.4 系统调用小结"></a>3.3.4 系统调用小结</h4><img src="https://pic.imgdb.cn/item/6600224f9f345e8d038d4a09.png" alt="操作系统（一）——计算机系统概述——系统调用小结.png"><h2 id="4-操作系统体系结构"><a href="#4-操作系统体系结构" class="headerlink" title="4. 操作系统体系结构"></a>4. 操作系统体系结构</h2><h3 id="4-1-内核"><a href="#4-1-内核" class="headerlink" title="4.1 内核"></a>4.1 内核</h3><h4 id="4-1-1-内核的定义"><a href="#4-1-1-内核的定义" class="headerlink" title="4.1.1 内核的定义"></a>4.1.1 内核的定义</h4><p><font color=green><strong>内核：指的是一个提供硬件抽象层、磁盘及文件系统控制、多任务等功能的系统软件。</strong></font><font color=red><strong>内核是操作系统最基本，最核心的部分</strong></font>。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并且内核决定一个程序在什么时候对某部分硬件操作多长时间。直接对硬件操作是非常复杂的，所以内核通常提供一种硬件抽象的方法来完成这些操作。硬件抽象隐藏了复杂性，为应用软件和硬件提供了一套简洁，统一的接口，使程序设计更为简单。</p><p>简单来说，内核是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。</p><p>内核就是操作系统背后<strong>黑盒的核心</strong>。</p><img src="https://pic.imgdb.cn/item/660026b69f345e8d03b91c55.png" alt="操作系统（一）——计算机系统概述——操作系统内核.png"><h4 id="4-1-2-大内核-微内核"><a href="#4-1-2-大内核-微内核" class="headerlink" title="4.1.2 大内核&amp;微内核"></a>4.1.2 大内核&amp;微内核</h4><p>从操作系统的内核架构来划分，可分为宏内核和微内核。</p><p>宏内核：又称单内核或大内核，是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。</p><p>微内核：是指将内核中最基本的功能保留在内核，而将那些不需要再核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。</p><img src="https://pic.imgdb.cn/item/66002e219f345e8d03ff3b9d.png" alt="操作系统（一）——计算机系统概述——内核.png"><img src="https://pic.imgdb.cn/item/66002e909f345e8d0302b600.png" alt="操作系统（一）——计算机系统概述——大内核和微内核详细图解.png"><h4 id="4-1-3-宏内核和微内核的比较"><a href="#4-1-3-宏内核和微内核的比较" class="headerlink" title="4.1.3 宏内核和微内核的比较"></a>4.1.3 宏内核和微内核的比较</h4><table><thead><tr><th align="center"></th><th align="center">宏内核</th><th align="center">微内核</th></tr></thead><tbody><tr><td align="center">通信效率</td><td align="center">高（函数调用）</td><td align="center">低（进程间的通信）</td></tr><tr><td align="center">稳定性</td><td align="center">低（模块集成在一起）</td><td align="center">高（模块间互不影响）</td></tr><tr><td align="center">扩展性</td><td align="center">低（模块集成在一起）</td><td align="center">高（模块间互不影响）</td></tr><tr><td align="center">代码量</td><td align="center">多（需要实现所有模块）</td><td align="center">少（只需要实现核心功能）</td></tr></tbody></table><h4 id="4-1-4-补充知识——混合内核和外内核"><a href="#4-1-4-补充知识——混合内核和外内核" class="headerlink" title="4.1.4 补充知识——混合内核和外内核"></a>4.1.4 补充知识——混合内核和外内核</h4><p>混合内核：看了宏内核和微内核的实现，就会发现，两者各有千秋，也各有缺点，所以混合内核就是集中了两者的特点，让微内核中的一些核心模块运行在内核中，从而使内核效率更高一些。</p><p>外内核：外内核是把硬件暴露给应用程序，应用程序可以直接访问硬件，外内核对系统提供保护。目前还在研究阶段。</p><h4 id="4-1-4-内核小结"><a href="#4-1-4-内核小结" class="headerlink" title="4.1.4 内核小结"></a>4.1.4 内核小结</h4><img src="https://pic.imgdb.cn/item/66002edc9f345e8d0304f330.png" alt="操作系统（一）——计算机系统概述——内核小结.png"><h3 id="4-2-分层结构"><a href="#4-2-分层结构" class="headerlink" title="4.2  分层结构"></a>4.2  分层结构</h3><p>分层结构是将操作系统分为若干层，底层（0层）为硬件，顶层（层N）为用户接口。每层只能调用紧邻它的低层的功能和服务（单向依赖）。</p><img src="https://pic.imgdb.cn/item/660036ba9f345e8d0343d06f.png" alt="操作系统（一）——计算机系统概述——分层操作系统.png" width=30%><p>分层的优点：</p><ol><li>便于系统的调试和验证。</li><li>易扩充和易维护。</li></ol><p>分层的缺点：</p><ol><li>合理定义各层比较困难。</li><li>效率较差。</li></ol><h3 id="4-3-模块化结构"><a href="#4-3-模块化结构" class="headerlink" title="4.3 模块化结构"></a>4.3 模块化结构</h3><p>模块化结构是将操作系统按功能划分为若干具有一定独立性的模块（将内核划分为多模块）。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信。</p><img src="https://pic.imgdb.cn/item/660037c79f345e8d034bf8f8.png" alt="操作系统（一）——计算机系统概述——模块化.png"><h3 id="4-4-外核"><a href="#4-4-外核" class="headerlink" title="4.4 外核"></a>4.4 外核</h3><p>外核是针对不同的上层软件定制化开发对应的内核部分，它并不提供通用的服务能力，而是和应用程序联合起来作为一个整体，对用户程序提供操作硬件的能力，进而提高计算性能。外核操作系统提供对硬件资源的应用程序级别的管理，通过向应用程序提供一系列库文件的方式来实现这一目的。程序在编译时连接上这些库文件，就获得了操作硬件的能力。这种资源保护与管理的分离使得应用程序能够方便地扩展系统抽象层。</p><p>插一句，<strong>在操作系统中，外核和外内核是同一个概念</strong>。外内核（外核系统）也被称为纵向结构操作系统，它的设计理念是让用户程序的设计者来决定硬件接口的设计。外内核本身非常小，通常只负责系统保护和系统资源复用相关的服务。它允许应用程序直接访问硬件，比如直接请求一块特定的物理空间或磁盘块<font color=red><strong>（外核能给用户直接分配一个未经抽象的系统资源）</strong></font>。由于外核系统只提供比较低级的硬件操作，没有提供高级的硬件抽象，因此需要额外的运行库支持来为用户提供完整的功能。</p><p>总的来说，外核（外内核）在操作系统中是一个特定的设计概念，旨在改变应用程序与硬件的交互方式，提高系统的性能和灵活性。</p><h3 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h3><img src="https://pic.imgdb.cn/item/66003bdd9f345e8d036c3183.png" alt="操作系统（一）——计算机系统概述——操作系统结构小结.png"><h2 id="5-操作系统引导"><a href="#5-操作系统引导" class="headerlink" title="5. 操作系统引导"></a>5. 操作系统引导</h2><p>操作系统是一种程序，程序以数据的形式存放在硬盘中，而硬盘通常分为多个区，一台计算机中又可能有多个或多种外部存储设备。<strong>操作系统引导</strong>是指计算机利用CPU运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统。</p><p>常见操作系统引导过程：</p><ol><li>激活CPU。</li><li>硬件自检。</li><li>加载带有操作系统的硬盘。</li><li>加载主引导记录。</li><li>扫描硬盘分区表。</li><li>加载分区引导记录。</li><li>加载启动管理器。</li><li>加载操作系统。</li></ol><img src="https://pic.imgdb.cn/item/660153c39f345e8d03a8b3ac.png" alt="操作系统（一）——计算机系统概述——操作系统引导.png"><p>注：完整的<font color=red><strong>操作系统初始化程序（即启动管理器）</strong></font>可在根目录下找到。</p><h2 id="6-虚拟机"><a href="#6-虚拟机" class="headerlink" title="6. 虚拟机"></a>6. 虚拟机</h2><h3 id="6-1-虚拟机的基本概念"><a href="#6-1-虚拟机的基本概念" class="headerlink" title="6.1 虚拟机的基本概念"></a>6.1 虚拟机的基本概念</h3><p>虚拟机是指利用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境。有两类虚拟化方法，分别是第一类虚拟机管理程序和第二类虚拟机管理程序。</p><img src="https://pic.imgdb.cn/item/660157349f345e8d03ba5c6e.png" alt="操作系统（一）——计算机系统概述——虚拟机.png"><h4 id="6-1-1-第一类虚拟机管理程序"><a href="#6-1-1-第一类虚拟机管理程序" class="headerlink" title="6.1.1 第一类虚拟机管理程序"></a>6.1.1 第一类虚拟机管理程序</h4><p>第一类虚拟机管理程序就像一个操作系统，它不需要安装在实际的操作系统之上，在实际使用它的时候，它作为一个中间层，下面是运行操作系统需要的各种硬件，上面就是虚拟机需要支持的各种系统（windows,linux），操作系统们通过第一类虚拟机管理程序来完成对硬件的调用。</p><p>虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为<font color=blue><strong>虚拟内核态</strong></font>。虚拟机中的用户进程认为自己运行在用户态（实际上确实是）。</p><p>当虚拟机操作系统执行了一条CPU处于内核态才允许执行的指令时，会陷入虚拟机管理程序。在支持虚拟化的CPU上，虚拟机管理程序检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行；如果是后者，虚拟机管理程序将模拟真实硬件面对用户态执行敏感指令时的行为。</p><p>在过去不支持虚拟化的CPU上，真实硬件不会直接执行虚拟机中的敏感指令，这些敏感指令被转为对虚拟机管理程序的调用，由虚拟机管理程序模拟这些指令的功能。</p><h4 id="6-1-2-第二类虚拟机管理程序"><a href="#6-1-2-第二类虚拟机管理程序" class="headerlink" title="6.1.2 第二类虚拟机管理程序"></a>6.1.2 第二类虚拟机管理程序</h4><p>第二类虚拟机管理程序依赖于Windows、Linux等操作系统分配和调度资源的程序，很像一个普通的进程。它仍然把自己伪装成具有CPU和各种设备的完整计算机，实际上还是需要运行它的操作系统来提供大量的功能。当它启动的时候，也会像真实的操作系统启动那样，寻找DVD，U盘,CD-ROM。然后虚拟机管理程序运行DVD上的安装程序，把操作系统安装到虚拟磁盘中（虚拟机管理程序假装从DVD驱动器中读取操作系统的ISO文件，然后再安装这个操作系统，而这个ISO文件实际上是作为文件保存在计算机上的，同时，这个虚拟磁盘也是计算机中的一个文件，这也就印证了上面提到的伪装的说法，把自己的各种操作伪装成真实计算机操作的样子）。</p><p>运行在两类虚拟机管理程序上的操作系统称为<strong>客户操作系统</strong>。对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为<strong>宿主操作系统</strong>。</p><h3 id="6-2-虚拟机小结"><a href="#6-2-虚拟机小结" class="headerlink" title="6.2 虚拟机小结"></a>6.2 虚拟机小结</h3><img src="https://pic.imgdb.cn/item/6601602b9f345e8d03eb917d.png" alt="操作系统（一）——计算机系统概述——虚拟机小结.png"><p>注意：有的教材会将第一类虚拟化技术称为<strong>裸金属架构</strong>，将第二类虚拟化技术称为<strong>寄居架构</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（一）——计算机网络体系结构</title>
      <link href="/2024/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2024/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="1-计算机网络概述"><a href="#1-计算机网络概述" class="headerlink" title="1.计算机网络概述"></a>1.计算机网络概述</h2><h3 id="1-1-计算机网络概念"><a href="#1-1-计算机网络概念" class="headerlink" title="1.1 计算机网络概念"></a>1.1 计算机网络概念</h3><p>​计算机网络是一个将众多<font color=red><strong>分散的、自治的</strong></font><font color=blue><strong>计算机系统</strong></font>，通过<font color=green><strong>通信设备</strong></font>与<font color=green><strong>线路</strong></font>连接起来，由功能完善的<font color=red><strong>软件</strong></font>实现<font color=green><strong>资源共享</strong></font>和<font color=green><strong>信息传递</strong></font>的系统。</p><p>注意：</p><p>（1）区分internet（互连网）和Internet（互联网或因特网）</p><p>​internet：是一个通用名词，泛指由多个计算机网络互连而成的计算机网络。</p><p>​Internet：是一个专用名词，指当前全球最大的、开放的、由众多网络和路由器互连而成的特定计算机网络。</p><p>（2）网络把许多计算机连接在一起，而互联网则把许多网络连接在一起。因特网是世界上最大的互联网。</p><h3 id="1-2-计算机网络的组成"><a href="#1-2-计算机网络的组成" class="headerlink" title="1.2 计算机网络的组成"></a>1.2 计算机网络的组成</h3><p>从不同角度看，计算机网络有不同分类。</p><p>（1）从组成部分看可分为：硬件、软件、协议</p><p>（2）从工作方式看可分为：边缘部分、核心部分</p><img src="https://pic.imgdb.cn/item/65f689d59f345e8d03680a9a.png" alt="计算机网络（一）——计算机网络体系结构-边缘和核心.png"><p>（3）从功能组成看可分为：通信子网、资源子网</p><h3 id="1-3-计算机网络的功能"><a href="#1-3-计算机网络的功能" class="headerlink" title="1.3 计算机网络的功能"></a>1.3 计算机网络的功能</h3><ol><li>数据通信</li><li>资源共享</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡</li></ol><h3 id="1-4-电路交换、报文交换与分组交换"><a href="#1-4-电路交换、报文交换与分组交换" class="headerlink" title="1.4 电路交换、报文交换与分组交换"></a>1.4 电路交换、报文交换与分组交换</h3><p>参考我的CSDN：<a href="https://blog.csdn.net/qq_63040545/article/details/136405996?spm=1001.2014.3001.5501">三种分组交换方式</a></p><p>其余可参考资料：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=3&vd_source=7fb4b255ed876969a742738d7b84f461">计算机网络–湖科大–三种交换方式</a></p><h3 id="1-5-计算机网络分类"><a href="#1-5-计算机网络分类" class="headerlink" title="1.5 计算机网络分类"></a>1.5 计算机网络分类</h3><ol><li>按分布范围分类：广域网（WAN）、城域网（MAN）、局域网（LAN）、个人区域网（PAN）</li><li>按传输技术分类：广播式网络、点对点网络</li><li>按拓扑结构分类：总线形网络、星形网络、环形网络、网状网络</li><li>按使用者分类：公用网、专用网</li><li>按传输介质分类：有线、无线</li><li>按交换技术分类：电路交换、报文交换、分组交换</li></ol><h3 id="1-6-计算机网络性能指标"><a href="#1-6-计算机网络性能指标" class="headerlink" title="1.6 计算机网络性能指标"></a>1.6 计算机网络性能指标</h3><h4 id="1-6-1-速率"><a href="#1-6-1-速率" class="headerlink" title="1.6.1 速率"></a>1.6.1 速率</h4><p>​速率：指连接到网络上的结点在数字信道上传送数据的速率，也称数据传输速率、数据传输率、数据率或比特率。单位为b&#x2F;s（比特&#x2F;秒）或bit&#x2F;s（有时也写为bps）。当数据率较高时，可用kb&#x2F;s（k&#x3D;10<sup>3</sup>）、Mb&#x2F;s（M&#x3D;10<sup>6</sup>）或Gb&#x2F;s（G&#x3D;10<sup>9</sup>）表示。</p><img src="https://pic.imgdb.cn/item/65f6b0b89f345e8d0333cfd0.png" alt="计算机网络（一）——计算机网络体系结构-速率.png"><h4 id="1-6-2-带宽"><a href="#1-6-2-带宽" class="headerlink" title="1.6.2 带宽"></a>1.6.2 带宽</h4><p>​带宽：在计算机网络中，带宽表示网络的通信线路所能传送数据的能力，是数字信道所能传送的“最高数据传输速率”的同义语，单位是比特&#x2F;秒（b&#x2F;s）。</p><img src="https://pic.imgdb.cn/item/65f6b2119f345e8d033a821a.png" alt="计算机网络（一）——计算机网络体系结构-带宽.png"><h4 id="1-6-3-吞吐量"><a href="#1-6-3-吞吐量" class="headerlink" title="1.6.3 吞吐量"></a>1.6.3 吞吐量</h4><p>​吞吐量：指单位时间内通过某个网络（或信道、接口）的实际数据量。吞吐量常用在对实际网络的测量中，受网络带宽的限制。</p><img src="https://pic.imgdb.cn/item/65f6b37e9f345e8d03411f8d.png" alt="计算机网络（一）——计算机网络体系结构-吞吐量.png"><h4 id="1-6-4-时延"><a href="#1-6-4-时延" class="headerlink" title="1.6.4 时延"></a>1.6.4 时延</h4><p>​时延：指数据（一个报文或分组）从网络（或链路）的一端传送到另一端所需的总时间，它由4部分构成：发送时延、传播时延、处理时延和排队时延。</p><img src="https://pic.imgdb.cn/item/65f6b8639f345e8d035844ec.png" alt="计算机网络（一）——计算机网络体系结构-时延.png"><h4 id="1-6-5-时延带宽积"><a href="#1-6-5-时延带宽积" class="headerlink" title="1.6.5 时延带宽积"></a>1.6.5 时延带宽积</h4><p>​时延带宽积：指发送端发送的第一个比特即将到达终点时，发送端已发出了多少比特，又称以比特为单位的链路长度。即<font color=red>时延带宽积&#x3D;传播时延×信道带宽</font>。</p><img src="https://pic.imgdb.cn/item/65f6b95e9f345e8d035cb9e6.png" alt="计算机网络（一）——计算机网络体系结构-时延带宽积.png"><h4 id="1-6-6-往返时延"><a href="#1-6-6-往返时延" class="headerlink" title="1.6.6 往返时延"></a>1.6.6 往返时延</h4><p>​往返时延：指从发送端发出一个短分组，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认）总共经历的时延。在互联网中，往返时延还包括各中间结点的处理时延、排队时延及转发数据时的发送时延。</p><img src="https://pic.imgdb.cn/item/65f6bdf29f345e8d03720e88.png" alt="计算机网络（一）——计算机网络体系结构-往返时延.png"><h4 id="1-6-7-信道利用率"><a href="#1-6-7-信道利用率" class="headerlink" title="1.6.7 信道利用率"></a>1.6.7 信道利用率</h4><p>​信道利用率：用以指出某个信道有百分之多少的时间是有数据通过的。</p><p>​<font color=red>信道利用率&#x3D;有数据通过时间&#x2F;（有+无）数据通过时间</font></p><img src="https://pic.imgdb.cn/item/65f6bef99f345e8d0376cb7f.png" alt="计算机网络（一）——计算机网络体系结构-利用率.png"><h4 id="1-6-8-丢包率"><a href="#1-6-8-丢包率" class="headerlink" title="1.6.8 丢包率"></a>1.6.8 丢包率</h4><img src="https://pic.imgdb.cn/item/65f6c07a9f345e8d037db1cf.png" alt="计算机网络（一）——计算机网络体系结构-丢包率.png"><h2 id="2-计算机网络体系结构"><a href="#2-计算机网络体系结构" class="headerlink" title="2. 计算机网络体系结构"></a>2. 计算机网络体系结构</h2><h3 id="2-1-常见的计算机网络分层结构"><a href="#2-1-常见的计算机网络分层结构" class="headerlink" title="2.1 常见的计算机网络分层结构"></a>2.1 常见的计算机网络分层结构</h3><img src="https://pic.imgdb.cn/item/65f6c4599f345e8d038e75c7.png" alt="计算机网络（一）——计算机网络体系结构-常见分层结构.png"><p>分层的基本原则：</p><ol><li>每层都实现一种相对独立的功能，降低大系统的复杂度。</li><li>各层之间的接口自然清晰，易于理解，相互交流尽可能少。</li><li>各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现。</li><li>保持下层对上层的独立性，上层单向使用下层提供的服务。</li><li>整个分层结构应能促进标准化工作。</li></ol><h3 id="2-2-计算机网络分层的必要性"><a href="#2-2-计算机网络分层的必要性" class="headerlink" title="2.2 计算机网络分层的必要性"></a>2.2 计算机网络分层的必要性</h3><ol><li>计算机网络是个非常复杂的系统。</li><li>分层可将庞大而复杂的问题，转化为若干较小的局部问题。</li></ol><p>（下面是计算机网络面临的主要问题，以及这些问题划分的层次）</p><h4 id="2-2-1-物理层解决的主要问题"><a href="#2-2-1-物理层解决的主要问题" class="headerlink" title="2.2.1 物理层解决的主要问题"></a>2.2.1 物理层解决的主要问题</h4><ol><li>采用怎样的传输媒体（介质）</li><li>采用怎样的物理接口</li><li>使用怎样的信号表示比特0和1</li></ol><p>需要注意的是：严格来说，传输媒体不属于物理层，它不包含在体系结构中。</p><p>举例：在A电脑上使用QQ发送信息给B电脑上的QQ。物理层解决的就是将这组信息转换可在链路上传播的比特流。</p><h4 id="2-2-2-数据链路层解决的主要问题"><a href="#2-2-2-数据链路层解决的主要问题" class="headerlink" title="2.2.2 数据链路层解决的主要问题"></a>2.2.2 数据链路层解决的主要问题</h4><ol><li>如何标识网络中的各主机（主机编址问题，例如MAC地址）</li><li>如何从信号所表示的一连串比特流中区分出地址和数据（分组的封装格式问题）</li><li>如何协调各主机争用总线</li></ol><p>举例：在一段网络上有A、B、C三台电脑。想让A电脑上QQ发送的信息传给B电脑上的QQ。数据链路层解决的就是将这组信息传送到B电脑而不是C电脑。同时保证此时A传给B的消息不会跟C传给B的消息在总线上产生碰撞堵塞。</p><h4 id="2-2-3-网络层解决的主要问题"><a href="#2-2-3-网络层解决的主要问题" class="headerlink" title="2.2.3 网络层解决的主要问题"></a>2.2.3 网络层解决的主要问题</h4><ol><li>如何标识各网络以及网络中的各主机（网络和主机共同编址的问题，例如IP地址）</li><li>路由器如何转发分组，如何进行路由选择</li></ol><p>举例：想让网络N1上的A电脑上QQ发送的信息传给网络N2上B电脑上的QQ，但这中间还包含着网络段N3、N4，所以传输路径不止一条。而网络层就是解决这组信息走那一段网络中的链路进行传输，路由器将分组转发到哪一标识IP地址的设备上。</p><h4 id="2-2-4-传输层解决的主要问题"><a href="#2-2-4-传输层解决的主要问题" class="headerlink" title="2.2.4 传输层解决的主要问题"></a>2.2.4 传输层解决的主要问题</h4><ol><li>如何解决进程之间基于网络的通信问题</li><li>出现传输错误时，如何处理</li></ol><p>举例：A电脑有QQ，B电脑上有微信和QQ。想让A电脑上QQ发送的信息传给B电脑上的QQ。传输层就是解决A上的信息传给B上的QQ，而不是B上的微信。当然如果数据出现误码，则会被处理。至于怎样处理就是传输层解决的问题。</p><h4 id="2-2-5-应用层解决的主要问题"><a href="#2-2-5-应用层解决的主要问题" class="headerlink" title="2.2.5 应用层解决的主要问题"></a>2.2.5 应用层解决的主要问题</h4><ol><li>通过应用进程间的交互来完成特定的网络应用</li></ol><p>举例：使用什么样的协议进行数据传输。例如使用http协议进行网页访问。应用层的作用就是指定应用层协议，并根据协议编写应用程序，通过应用进程间交互完成网络应用。</p><h4 id="2-2-6-原理体系结构分层解决问题的总结"><a href="#2-2-6-原理体系结构分层解决问题的总结" class="headerlink" title="2.2.6 原理体系结构分层解决问题的总结"></a>2.2.6 原理体系结构分层解决问题的总结</h4><img src="https://pic.imgdb.cn/item/65f6cade9f345e8d03ab9c1f.png" alt="计算机网络（一）——计算机网络体系结构-分层处理问题.png"><h3 id="2-3-计算机网络分层体系结构的相关术语及其概念"><a href="#2-3-计算机网络分层体系结构的相关术语及其概念" class="headerlink" title="2.3 计算机网络分层体系结构的相关术语及其概念"></a>2.3 计算机网络分层体系结构的相关术语及其概念</h3><h4 id="2-3-1-实体"><a href="#2-3-1-实体" class="headerlink" title="2.3.1 实体"></a>2.3.1 实体</h4><p>实体：指任何可发送或接收信息的硬件或软件进程，通常是某个特定的软件模块。不同机器上的同一层称为<font color=red>对等层</font>，同一层的实体称为<font color=red>对等实体</font>。</p><h4 id="2-3-2-协议数据单元（PDU）"><a href="#2-3-2-协议数据单元（PDU）" class="headerlink" title="2.3.2 协议数据单元（PDU）"></a>2.3.2 协议数据单元（PDU）</h4><p>协议数据单元（PDU）：对等层之间传送的数据单位称为该层的协议数据单元。</p><h4 id="2-3-3-服务数据单元（SDU）"><a href="#2-3-3-服务数据单元（SDU）" class="headerlink" title="2.3.3 服务数据单元（SDU）"></a>2.3.3 服务数据单元（SDU）</h4><p>服务数据单元（SDU）：为完成用户所要求的功能而传送的数据。第n层的SDU记为n-SDU。</p><p>注意：当在各层之间传输数据时，将从第n+1层收到的PDU作为第n层的SDU。加上第n层的PCI，就封装成了第n层的PDU，交给n-1层后作为SDU发送。</p><h4 id="2-3-4-协议控制信息（PCI）"><a href="#2-3-4-协议控制信息（PCI）" class="headerlink" title="2.3.4 协议控制信息（PCI）"></a>2.3.4 协议控制信息（PCI）</h4><p>协议控制信息（PCI）：控制协议操作的信息。第n层的PCI记为n-PCI。</p><h4 id="2-3-5-协议"><a href="#2-3-5-协议" class="headerlink" title="2.3.5 协议"></a>2.3.5 协议</h4><p>协议：在网络中进行数据交换而建立的规则、标准或约定称为网络协议。网络协议是控制在对等实体之间进行通信的规则的集合、是水平的。</p><p>协议由语法、语义和同步三部分组成：</p><ol><li>语法：数据与控制信息的格式。</li><li>语义：即需要发出何种控制信息、完成何种动作及做出何种应答。</li><li>同步(或时序)：执行各种操作的条件、时序关系等，即时间实现顺序的详细说明。</li></ol><h4 id="2-3-6-接口"><a href="#2-3-6-接口" class="headerlink" title="2.3.6 接口"></a>2.3.6 接口</h4><p>接口：同一结点内相邻两层间交换信息的连接点就是接口。而同一结点内相邻两层的实体交换信息的逻辑接口称为服务访问点（SAP）。每层只能为紧邻的层之间定义接口，而不能跨层定义接口。</p><h4 id="2-3-7-服务"><a href="#2-3-7-服务" class="headerlink" title="2.3.7 服务"></a>2.3.7 服务</h4><p>服务：是指下层为紧邻的上层提供的功能调用，是垂直的。对等实体在协议的控制下，使得本层能为上层提供服务，但要实现本次协议，还需要使用下层提供的服务。</p><p>当上层使用下层提供的服务时，必须与下层交换一些命令，这些命令称为服务原语。</p><p>OSI模型将原语划分为四类：请求、指示、响应、证实。</p><p>服务的三种分类方式：</p><ol><li><p>面向连接服务与无连接服务</p><p>面向连接服务：通信前双方必须先建立连接。</p><p>无连接服务：通信前双方不需要先建立连接。</p></li><li><p>可靠服务和不可靠服务</p><p>可靠服务：网络具有纠错、检错、应答机制。</p><p>不可靠服务：网络的正确性、可靠性要由应用或用户来保障。</p></li><li><p>有应答服务和无应答服务</p><p>有应答服务：接收方在收到数据后向发送方给出相应的应答。</p><p>无应答服务：接收方在收到数据后不自动给出应答，如需应答，则由高层实现。</p></li></ol><h4 id="2-3-8-总结"><a href="#2-3-8-总结" class="headerlink" title="2.3.8 总结"></a>2.3.8 总结</h4><img src="https://pic.imgdb.cn/item/65f6e7c99f345e8d0348f128.png" alt="计算机网络（一）——计算机网络体系结构-术语总结.png"><h2 id="3-OSI模型与TCP-IP模型"><a href="#3-OSI模型与TCP-IP模型" class="headerlink" title="3. OSI模型与TCP&#x2F;IP模型"></a>3. OSI模型与TCP&#x2F;IP模型</h2><h3 id="3-1-OSI参考模型"><a href="#3-1-OSI参考模型" class="headerlink" title="3.1 OSI参考模型"></a>3.1 OSI参考模型</h3><img src="https://pic.imgdb.cn/item/65f6e84c9f345e8d034c3d44.png" alt="计算机网络（一）——计算机网络体系结构-OSI七层模型.png"><p>国际标准化组织（ISO）提出的网络体系结构模型称为开放系统互连参考模型，通常简称为OSI参考模型。</p><h3 id="3-2-OSI模型各层应用"><a href="#3-2-OSI模型各层应用" class="headerlink" title="3.2 OSI模型各层应用"></a>3.2 OSI模型各层应用</h3><h4 id="3-2-1-物理层"><a href="#3-2-1-物理层" class="headerlink" title="3.2.1 物理层"></a>3.2.1 物理层</h4><p>物理层主要任务是在物理媒体上实现比特流的透明传输。物理传输单位是比特。</p><p>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送。</p><p>物理层功能：</p><ol><li>定义接口特性</li><li>定义传输模式（单工、半双工、双攻）</li><li>定义传输速率</li><li>比特同步</li><li>比特编码</li></ol><p>主要协议：Rj45、802.3</p><h4 id="3-2-2-数据链路层"><a href="#3-2-2-数据链路层" class="headerlink" title="3.2.2 数据链路层"></a>3.2.2 数据链路层</h4><p>数据链路层主要任务是把网络层传下来的数据报组装成帧（实现点到点传输）。数据链路层&#x2F;练练车的传输单位是帧。</p><p>数据链路层功能：</p><ol><li>物理寻址</li><li>成帧（定义帧的开始和结束）</li><li>差错控制（帧错+位错）</li><li>流量控制（相邻结点间）</li><li>访问（接入）控制（控制对信道的访问）</li></ol><p>主要协议：SDLC、HDLC、PPP、STP</p><h4 id="3-2-3-网络层"><a href="#3-2-3-网络层" class="headerlink" title="3.2.3 网络层"></a>3.2.3 网络层</h4><p>网络层主要任务是分组把源端传到目的端，为分组交换网上的不同主机提供通信服务（实现主机到主机的通信）。网络层的传输单位是数据报。</p><p>网络层的功能：</p><ol><li>路由选择（最佳路径）</li><li>流量控制（整个网络中）</li><li>差错控制</li><li>拥塞控制</li></ol><p>注意：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施，缓解这种拥塞。</p><p>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p><h4 id="3-2-4-传输层"><a href="#3-2-4-传输层" class="headerlink" title="3.2.4 传输层"></a>3.2.4 传输层</h4><p>传输层主要任务是负责主机中两个进程的通信，即端到端的通信（实现主机的进程之间的通信）。传输单位是报文段或用户数据报。</p><p>传输层功能：</p><ol><li>可靠传输、不可靠传输</li><li>差错控制</li><li>流量控制（端到端）</li><li>复用分用（复用：多个应用层进程可同时使用下面运输层的服务。分用：运输层把收到的信息分别交付给上面应用层中相应的进程。</li></ol><p>主要协议：TCP、UDP</p><h4 id="3-2-5-会话层"><a href="#3-2-5-会话层" class="headerlink" title="3.2.5 会话层"></a>3.2.5 会话层</h4><p>会话层的主要任务是向表示层实体&#x2F;用户进程提供建立连接并在连接上有序地传输数据。这是会话，也是建立同步。</p><p>会话层功能：</p><ol><li>建立、管理、终止会话</li><li>使用校验点可使会话在通信失效时从校验点&#x2F;同步点继续恢复通信，实现数据同步。</li></ol><p>主要协议：ADSP、ASP</p><h4 id="3-2-6-表示层"><a href="#3-2-6-表示层" class="headerlink" title="3.2.6 表示层"></a>3.2.6 表示层</h4><p>表示层用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p><p>表示层的功能：</p><ol><li>数据格式变换</li><li>数据加密解密</li><li>数据压缩和恢复</li></ol><p>主要协议：JPEG、ASCLL</p><h4 id="3-2-7-应用层"><a href="#3-2-7-应用层" class="headerlink" title="3.2.7 应用层"></a>3.2.7 应用层</h4><p>应用层：所有能和用户交换产生网络流量的程序。</p><p>典型的应用层服务：</p><ol><li>文件传输（FTP）</li><li>电子邮件（SMTP）</li><li>万维网（HTTP）</li></ol><h3 id="3-3-OSI模型通信过程"><a href="#3-3-OSI模型通信过程" class="headerlink" title="3.3 OSI模型通信过程"></a>3.3 OSI模型通信过程</h3><img src="https://pic.imgdb.cn/item/65f6eeb79f345e8d037ce8aa.png" alt="计算机网络（一）——计算机网络体系结构-OS通信.png"><h3 id="3-4-TCP-IP参考模型"><a href="#3-4-TCP-IP参考模型" class="headerlink" title="3.4 TCP&#x2F;IP参考模型"></a>3.4 TCP&#x2F;IP参考模型</h3><img src="https://pic.imgdb.cn/item/65f6ef699f345e8d0382b872.png" alt="计算机网络（一）——计算机网络体系结构-TCP.png"><h3 id="3-5-TCP-IP模型层次结构及各层的主要协议"><a href="#3-5-TCP-IP模型层次结构及各层的主要协议" class="headerlink" title="3.5 TCP&#x2F;IP模型层次结构及各层的主要协议"></a>3.5 TCP&#x2F;IP模型层次结构及各层的主要协议</h3><img src="https://pic.imgdb.cn/item/65f6f3649f345e8d03a00b2d.png" alt="计算机网络（一）——计算机网络体系结构-TCP各层协议.png"><p>注意：</p><ol><li>TCP&#x2F;IP体系结构的网络接口层并没有规定具体的内容，这样做的目的是可以互连全世界各种不同的网络接口。因此本质上TCP&#x2F;IP体系结构只有上面的三层。</li><li>TCP向应用层提供可靠传输的服务；UDP向应用层提供不可靠传输服务。</li></ol><h3 id="3-6-OSI与TCP-IP模型的比较"><a href="#3-6-OSI与TCP-IP模型的比较" class="headerlink" title="3.6 OSI与TCP&#x2F;IP模型的比较"></a>3.6 OSI与TCP&#x2F;IP模型的比较</h3><h4 id="3-6-1-相同之处"><a href="#3-6-1-相同之处" class="headerlink" title="3.6.1 相同之处"></a>3.6.1 相同之处</h4><ol><li>二者都采取分层的体系结构，且分层功能大体相似。</li><li>二者都是基于独立的协议栈的概念。</li><li>二者都可解决异构网络的互连，实现不同厂家生产的计算机之间的通信。</li></ol><h4 id="3-6-2-不同之处"><a href="#3-6-2-不同之处" class="headerlink" title="3.6.2 不同之处"></a>3.6.2 不同之处</h4><ol><li>OSI参考模型精确定义了服务、协议和接口。而TCP&#x2F;IP模型在这三个概念上没有明确区分。</li><li>TCP&#x2F;IP模型将OSI参考模型的表示层和会话层的功能合并到了应用层，还将数据链路层和物理层合并为网络接口层。</li><li>OSI参考模型先有模型，后有协议规范，通用性良好，适合各种网络。TCP&#x2F;IP模型先有协议栈，后有模型，因此不适合其他的非TCP&#x2F;IP网络。</li><li>OSI参考模型在网络层支持无连接和面向连接的通信，而在传输层仅有面向连接的通信。而TCP&#x2F;IP模型认为可靠性是端到端的问题，它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接两种模式。</li></ol><h3 id="3-7-补充"><a href="#3-7-补充" class="headerlink" title="3.7 补充"></a>3.7 补充</h3><p>补充一个写的挺好的大佬博客（详细且慷慨！）：<a href="https://blog.csdn.net/wwy0324/article/details/109310658">OSI七层模型、TCP&#x2F;IP四层模型（超详细！！！！！）-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（一）——线性表</title>
      <link href="/2024/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2024/03/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构（一）——线性表"><a href="#数据结构（一）——线性表" class="headerlink" title="数据结构（一）——线性表"></a>数据结构（一）——线性表</h1><h2 id="1-顺序表"><a href="#1-顺序表" class="headerlink" title="1. 顺序表"></a>1. 顺序表</h2><h3 id="1-1-顺序表的定义"><a href="#1-1-顺序表的定义" class="headerlink" title="1.1 顺序表的定义"></a>1.1 顺序表的定义</h3><p>线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得<font color=red>逻辑上相邻</font>的两个元素在<font color=red>物理位置上也相邻</font>。第1个元素存储在顺序表的起始位置，第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素a<sub>i</sub>在顺序表中的位序。因此，顺序表的特点是表中元素的<font color="red"><u>逻辑顺序与其存储的物理顺序相同</u></font>。</p><h3 id="1-2-顺序表的实现"><a href="#1-2-顺序表的实现" class="headerlink" title="1.2 顺序表的实现"></a>1.2 顺序表的实现</h3><h4 id="1-2-1-静态分配"><a href="#1-2-1-静态分配" class="headerlink" title="1.2.1 静态分配"></a>1.2.1 静态分配</h4><p>静态分配的顺序表存储结构，范围和大小已经事先固定（不可再更改），一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态分配的顺序表存储结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10 <span class="comment">//设置最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">//用“静态”数组存放数据元素 </span></span><br><span class="line"><span class="comment">//ElemType为元素类型代指，可定义为（int等）</span></span><br><span class="line">ElemType data[Maxsize]; </span><br><span class="line"><span class="comment">//顺序表当前长度</span></span><br><span class="line"><span class="type">int</span> length; </span><br><span class="line">&#125;Sqlist;  <span class="comment">//顺序表的类型定义</span></span><br></pre></td></tr></table></figure><h4 id="1-2-2-动态分配"><a href="#1-2-2-动态分配" class="headerlink" title="1.2.2 动态分配"></a>1.2.2 动态分配</h4><p>动态分配的顺序表存储结构，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，将原表中的元素全部拷贝到新空间，从而达到扩充数组存储空间的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态分配的顺序表存储结构</span></span><br><span class="line"><span class="comment">//InitSize为表长度的初始定义，用来开辟表存储空间以及设置表最大容量</span></span><br><span class="line"><span class="comment">//使用方式可参考1.1.2动态存储结构的初始化</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">ElemType* data;</span><br><span class="line"><span class="comment">//顺序表的最大容量</span></span><br><span class="line"><span class="type">int</span> Maxsize;</span><br><span class="line"><span class="comment">//顺序表的当前长度</span></span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SeqList; <span class="comment">//顺序表的类型定义</span></span><br></pre></td></tr></table></figure><h4 id="1-2-3-顺序表的声明"><a href="#1-2-3-顺序表的声明" class="headerlink" title="1.2.3 顺序表的声明"></a>1.2.3 顺序表的声明</h4><p>顺序表存储结构建立以后，要在主函数声明一个顺序表变量，顺序表才算建立完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//静态</span></span><br><span class="line">SqList L;</span><br><span class="line"><span class="comment">//动态</span></span><br><span class="line">SeqList L;</span><br><span class="line"><span class="comment">//二者根据自己的分配建立方式，声明一个即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-动态存储结构的扩容"><a href="#1-3-动态存储结构的扩容" class="headerlink" title="1.3 动态存储结构的扩容"></a>1.3 动态存储结构的扩容</h3><p>动态存储结构的扩容的核心思想就是开辟一个更大的存储空间，将原数据复制进新区域，再释放原存储内存。</p><p>需要注意的是，<strong>静态分配的顺序存储不可以类比动态存储结构一样扩容</strong>。这是因为静态分配的顺序存储是基于静态数组实现的，其大小在声明时就已经确定，并且在程序的整个生命周期（从程序启动到程序结束整个阶段的全过程）内都是固定的，无法改变。</p><p>静态如果需要扩容，只能程序员通过更改程序进行扩容（其实就是程序员建了一个存储空间更大的新表）。而动态分配的存储结构如果扩容，可以通过以下程序在程序的生命周期内进行扩容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态存储结构扩容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="comment">//定义新的指针变量指向原存储结构首地址</span></span><br><span class="line">ElemType *p = L.data;</span><br><span class="line"><span class="comment">//新分配一个存储空间更大动态存储结构</span></span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>((L.Maxsize+len) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="comment">//通过循环将数据复制到新区域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">L.data[i] = p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顺序表最大长度增加len</span></span><br><span class="line">L.Maxsize = L.Maxsize + len;</span><br><span class="line"><span class="comment">//释放原来的内存空间</span></span><br><span class="line"><span class="built_in">free</span>(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-顺序表的初始化"><a href="#1-4-顺序表的初始化" class="headerlink" title="1.4 顺序表的初始化"></a>1.4 顺序表的初始化</h3><h4 id="1-4-1-静态分配存储结构初始化"><a href="#1-4-1-静态分配存储结构初始化" class="headerlink" title="1.4.1 静态分配存储结构初始化"></a>1.4.1 静态分配存储结构初始化</h4><p>静态分配初始化简单，只需要将表长设置为0即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化表结构</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initlist</span><span class="params">(Sqlist &amp;L)</span> &#123;</span><br><span class="line"><span class="comment">//************************************************</span></span><br><span class="line"><span class="comment">//该段对表中数据进行初始化赋值为0。但是这段可以省略。</span></span><br><span class="line"><span class="comment">//如果省略这段，通过全部打印会发现，表中数据值可能会出现内存遗留“脏数据”。（也有可能不出现）</span></span><br><span class="line"><span class="comment">//但是正常情况下，我们不会通过Maxsize来全部打印。而是通过lenght来打印出表中已有的数据。</span></span><br><span class="line"><span class="comment">//所以，此段初始化循环可省略，但L.lenght初始化表长不可省略。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Maxsize; i++)</span><br><span class="line">&#123;</span><br><span class="line">L.data[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//************************************************</span></span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-动态分配存储结构初始化"><a href="#1-4-2-动态分配存储结构初始化" class="headerlink" title="1.4.2 动态分配存储结构初始化"></a>1.4.2 动态分配存储结构初始化</h4><p>动态分配初始化就稍微麻烦点，首先要创建存储分配空间，还要指出存储空间首地址。其次要将表长和最大存储容量初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这里的InitSize，在1.1.2里已经定义，下面程序中两个使用InitSize的地方要保持一致。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initlist</span><span class="params">(Seqlist &amp;L)</span> &#123;</span><br><span class="line"><span class="comment">//用malloc函数申请一片连续的存储空间用来分配</span></span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(InitSize * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"><span class="comment">//初始化顺序表长度为0</span></span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//初始存储容量</span></span><br><span class="line">L.Maxsize = InitSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-补充–malloc函数和free函数"><a href="#1-4-3-补充–malloc函数和free函数" class="headerlink" title="1.4.3 补充–malloc函数和free函数"></a>1.4.3 补充–malloc函数和free函数</h4><p><strong>malloc函数</strong></p><p><code>malloc</code>函数用于在堆上动态分配指定字节数的内存空间。其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p><code>size</code> 参数表示要分配的字节数。</p><p>如果分配成功，<code>malloc</code>返回一个指向分配的内存的指针；如果分配失败（例如，由于内存不足），则返回<code>NULL</code>。</p><p>使用<code>malloc</code>分配的内存空间在程序运行期间持续存在，直到使用<code>free</code>函数显式释放，或者程序结束。</p><p><strong>free函数</strong></p><p><code>free</code>函数用于释放之前通过<code>malloc</code>（或<code>calloc</code>、<code>realloc</code>等）分配的内存空间。其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p><code>ptr</code>参数是一个指向之前分配的内存的指针。</p><p>调用<code>free</code>后，应将指针设置为<code>NULL</code>，以防止悬挂指针（dangling pointer），即指向已经被释放的内存的指针。</p><p>使用<code>free</code>释放内存后，这块内存空间就不再属于程序，并且不应再被访问。尝试访问已释放的内存可能导致未定义行为，包括程序崩溃。</p><h3 id="1-5-顺序表的插入操作"><a href="#1-5-顺序表的插入操作" class="headerlink" title="1.5 顺序表的插入操作"></a>1.5 顺序表的插入操作</h3><p>顺序表的插入操作就是在顺序表L的第i(1&lt;&#x3D;i&lt;&#x3D;L.length+1)个位置插入新元素e。若i的输入不合法，则返回false，表示插入失败；否则，将第i个元素及其后的所有元素依次往后移动一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的插入操作 时间复杂度为O(n)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span>||i&gt;L.length+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断数据是否溢出</span></span><br><span class="line"><span class="keyword">if</span> (L.length&gt;Maxsize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> j = L.length; j &gt;= i; j--)</span><br><span class="line">&#123;</span><br><span class="line">L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在i位置放入e</span></span><br><span class="line">L.data[i - <span class="number">1</span>] = e;</span><br><span class="line"><span class="comment">//表长加1</span></span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-顺序表的删除操作"><a href="#1-6-顺序表的删除操作" class="headerlink" title="1.6 顺序表的删除操作"></a>1.6 顺序表的删除操作</h3><p>顺序表的删除操作即将表L中第i(1&lt;&#x3D;i&lt;&#x3D;L.length)个位置的元素，用引用变量e返回。若i的输入不合法，则返回false；否则，将被删元素赋给引用变量e，并将第i+1个元素及其后的所有元素依次往前移动一个位置，返回true。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的删除操作 时间复杂度O(n)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(Sqlist&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span>||i&gt;L.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j++)</span><br><span class="line">&#123;</span><br><span class="line">L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//表长减1</span></span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-顺序表的查找"><a href="#1-7-顺序表的查找" class="headerlink" title="1.7 顺序表的查找"></a>1.7 顺序表的查找</h3><h4 id="1-7-1-按值查找"><a href="#1-7-1-按值查找" class="headerlink" title="1.7.1 按值查找"></a>1.7.1 按值查找</h4><p>顺序表的按值查找就是在顺序表L中找第一个元素值等于e的元素，并返回其位序<font color="red">（<strong>注意位序是逻辑结构上的位置排序，而非物理结构</strong>）。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序表的按值查找操作，时间复杂度O(n)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(Sqlist L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//查找元素e的下标</span></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.data[i]==e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//退出循环依旧未找到，返回false，说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-2-按位查找"><a href="#1-7-2-按位查找" class="headerlink" title="1.7.2 按位查找"></a>1.7.2 按位查找</h4><p>顺序表的按位查找就是在顺序表L中直接查找指定位置的元素值，并将其返回出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于顺序表具有随机访问的优点，所以可以根据位序直接查找元素，时间复杂度为O(1)</span></span><br><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(Sqlist L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-单链表"><a href="#2-单链表" class="headerlink" title="2. 单链表"></a>2. 单链表</h2><h3 id="2-1-单链表的定义"><a href="#2-1-单链表的定义" class="headerlink" title="2.1 单链表的定义"></a>2.1 单链表的定义</h3><p>线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除存放元素自身的信息之外，还需要存放一个指向其后继的指针。</p><h3 id="2-2-单链表的实现"><a href="#2-2-单链表的实现" class="headerlink" title="2.2 单链表的实现"></a>2.2 单链表的实现</h3><p>单链表结点结构由数据域和指针域组成。数据域可以定义为data，用来存放数据元素；指针域定义为next，用来存放后继结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//数据域</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="comment">//指针域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, * LinkList;</span><br><span class="line"><span class="comment">//注意这里使用typedef将LNode类型重名为LNode和其指针类型的LinkList</span></span><br><span class="line"><span class="comment">//原理上LNode*等价于LinkList，但是仍旧选择这样定义的原因是为了方便程序的可阅读性</span></span><br><span class="line"><span class="comment">//使用LinkList，更突出想表达这是一个单链表</span></span><br><span class="line"><span class="comment">//使用LNode*，则是为了突出表达这是一个结点</span></span><br></pre></td></tr></table></figure><h3 id="2-3-单链表的初始化"><a href="#2-3-单链表的初始化" class="headerlink" title="2.3 单链表的初始化"></a>2.3 单链表的初始化</h3><p>单链表有两种写法，一种是带头结点的，一种是不带头结点的。具体区别如下图：</p><img src="https://pic.imgdb.cn/item/65eeff3c9f345e8d039155e2.png" width=50%><p>对于单链表，不管带不带头结点，头指针都指向单链表的第一个结点。而带头结点的单链表中，头结点作为第一个结点，往往不存储信息。所有带头结点和不带头结点的单链表的初始化操作是不同的。带头结点的单链表初始化时，需要创建一个头结点，并让头指针指向头结点，头结点的next域初始化为NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头结点的单链表的初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList&amp; L)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建头结点</span></span><br><span class="line">L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode*));</span><br><span class="line"><span class="comment">//头结点之后暂时还没有元素结点</span></span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不带头结点的单链表初始化时，只需将头指针L初始化为NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不带头结点的单链表初始化</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList&amp; L)</span></span><br><span class="line">&#123;</span><br><span class="line">L = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-单链表建立"><a href="#2-4-单链表建立" class="headerlink" title="2.4 单链表建立"></a>2.4 单链表建立</h3><h4 id="2-4-1-头插法建立单链表"><a href="#2-4-1-头插法建立单链表" class="headerlink" title="2.4.1 头插法建立单链表"></a>2.4.1 头插法建立单链表</h4><p>该方法从一个空表开始，生成新结点，并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后。具体实现过程如下图所示：</p><img src="https://pic.imgdb.cn/item/65f00f239f345e8d03eb8263.png" alt="数据结构（一）——线性表_头插法建立表.png" width=50%><p>算法实现过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法建立带头结点的单链表</span></span><br><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList&amp; L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创立结点变量，并设置一个输入的数据类型</span></span><br><span class="line">LNode* s; <span class="type">int</span> x;</span><br><span class="line">    <span class="comment">//创建头结点</span></span><br><span class="line">L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="comment">//初始为空链表，注意这一句最好加上，如果不加L-&gt;next会指向未知的区域，或许会存留脏数据，以后可能会出现bug</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//输入插入结点的值</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    <span class="comment">//设置特殊数字，输入9999，则插入结束</span></span><br><span class="line"><span class="keyword">while</span> (x!=<span class="number">9999</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//创建新结点</span></span><br><span class="line">s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="comment">// 如果分配内存失败，则处理错误  </span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line"><span class="comment">//头插法建立表数据</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">s-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line">        <span class="comment">//输入下一个需要插入结点的数据</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用头插法建立单链表时，读入数据的顺序与生成的链表中元素的顺序是相反的，<font color="red"><strong>可用来实现链表的逆置</strong></font>。每个结点插入的时间为O(1)，设单链表长为n，则总时间复杂度为O(n)。</p><p>上述采用头插法建立的单链表是带有头结点的，接下来补充一下不带头结点的头插法建立单链表。不在头结点的单链表在进行头插法时，每次插入新结点后，都需要将它的地址赋值给头指针L。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头插法建立不带头结点的单链表  </span></span><br><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList&amp; L)</span> &#123;  </span><br><span class="line">    <span class="comment">//创立结点变量，并设置一个输入的数据类型</span></span><br><span class="line">LNode* s; <span class="type">int</span> x;</span><br><span class="line">    <span class="comment">// 初始化链表为空  </span></span><br><span class="line">    L = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="comment">// 输入插入结点的值  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);  </span><br><span class="line">    <span class="comment">// 设置特殊数字，输入9999，则插入结束  </span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 创建新结点  </span></span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">        <span class="comment">// 如果分配内存失败，则处理错误  </span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 头插法建立表数据  </span></span><br><span class="line">        s-&gt;data = x;  </span><br><span class="line">        s-&gt;next = L; <span class="comment">// 新节点指向当前头节点  </span></span><br><span class="line">        L = s; <span class="comment">// 更新头节点为新节点  </span></span><br><span class="line">        <span class="comment">// 输入下一个需要插入结点的数据  </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="2-4-2-采用尾插法建立单链表"><a href="#2-4-2-采用尾插法建立单链表" class="headerlink" title="2.4.2 采用尾插法建立单链表"></a>2.4.2 采用尾插法建立单链表</h4><p>头插法建立单链表生成的链表中结点的次序和输入数据的顺序不一致。若希望两者次序一致，则可采用尾插法。该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r<font color=blue>（设置了尾指针r，其时间复杂度就和头插法相同。否则，每次插入都需要遍历查找到最后一个结点进行插入，时间复杂度达到O(n<sup>2</sup>)）</font>，使其始终指向当前链表的尾节点。具体过程如图所示：</p><img src="https://pic.imgdb.cn/item/65f029829f345e8d0353fbd7.png" alt="数据结构（一）——线性表_尾插法建立表.png" width=50%><p>算法实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法建立带头结点的单链表</span></span><br><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList&amp; L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置插入结点的数据类型</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">    <span class="comment">//创建头结点</span></span><br><span class="line">L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line"><span class="comment">//定义一个结点变量S，以及尾指针r</span></span><br><span class="line">    LNode* s, * r = L;</span><br><span class="line">    <span class="comment">//输入结点的值</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="comment">//输入特定数值9999表示结束</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//开辟插入结点</span></span><br><span class="line">s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">// 如果分配内存失败，则处理错误  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line">        &#125;  </span><br><span class="line"><span class="comment">//尾插法建立表</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">r-&gt;next = s;</span><br><span class="line">r = s; <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="comment">//输入新的插入数据</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//尾结点指针置空</span></span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾插法建立不带头结点的单链表  </span></span><br><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList&amp; L)</span> &#123;  </span><br><span class="line">    <span class="comment">// 设置插入结点的数据类型  </span></span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    <span class="comment">// 初始化链表为空  </span></span><br><span class="line">    L = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="comment">// 定义一个尾指针r，初始时指向NULL  </span></span><br><span class="line">    LNode* r = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="comment">// 输入结点的值  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);  </span><br><span class="line">    <span class="comment">// 输入特定数值9999表示结束  </span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;  </span><br><span class="line">        <span class="comment">// 开辟插入结点  </span></span><br><span class="line">        LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">// 如果分配内存失败，则处理错误  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 尾插法建立表  </span></span><br><span class="line">        s-&gt;data = x;  </span><br><span class="line">        s-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 新节点的next初始化为NULL  </span></span><br><span class="line">        <span class="comment">// 如果链表为空，新节点就是头节点  </span></span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">NULL</span>) </span><br><span class="line">        &#123;  </span><br><span class="line">            L = s;  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">// 否则，将新节点插入到当前尾节点的后面  </span></span><br><span class="line">            r-&gt;next = s;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 更新尾指针  </span></span><br><span class="line">        r = s;  </span><br><span class="line">        <span class="comment">// 输入新的插入数据  </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="2-5-单链表的查找"><a href="#2-5-单链表的查找" class="headerlink" title="2.5 单链表的查找"></a>2.5 单链表的查找</h3><h4 id="2-5-1-按序号查找结点"><a href="#2-5-1-按序号查找结点" class="headerlink" title="2.5.1 按序号查找结点"></a>2.5.1 按序号查找结点</h4><p>从单链表的第一个结点开始，沿着next域从前往后依次搜索，直到找到第i个结点为止，则返回该结点的指针；若i小于单链表的表长，则返回NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按序号查找带头结点的单链表 时间复杂度O(n)</span></span><br><span class="line">LNode* <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针P指向当前扫描到的结点</span></span><br><span class="line">LNode* p;</span><br><span class="line"><span class="comment">//当前P指向的是第几个结点</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//让p从头结点开始查找</span></span><br><span class="line">p = L;</span><br><span class="line"><span class="keyword">while</span> (p!= <span class="literal">NULL</span> &amp;&amp; j &lt; i)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按序号查找不带头结点的单链表，时间复杂度O(n)  </span></span><br><span class="line">LNode* <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || L == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 如果序号小于1或链表为空，则返回NULL  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 指针p指向当前扫描到的结点  </span></span><br><span class="line">    LNode* p = L;  </span><br><span class="line">    <span class="comment">// 当前p指向的是第几个结点（从1开始计数）  </span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// 让p从第一个数据节点开始查找  </span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;  </span><br><span class="line">        p = p-&gt;next;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果找到了第i个节点，返回它；否则返回NULL  </span></span><br><span class="line">    <span class="keyword">if</span> (j == i) &#123;  </span><br><span class="line">        <span class="keyword">return</span> p;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="2-5-2-按值查找表结点"><a href="#2-5-2-按值查找表结点" class="headerlink" title="2.5.2 按值查找表结点"></a>2.5.2 按值查找表结点</h4><p>从单链表的第一个结点开始，从前往后依次比较表中各结点的数据域，若某结点的data域等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找带表头的表结点 时间复杂度为O(n)</span></span><br><span class="line">LNode* <span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">LNode* p = L-&gt;next;</span><br><span class="line"><span class="comment">//从第一个结点开始查找数据域为e的结点</span></span><br><span class="line"><span class="keyword">while</span> (p!= <span class="literal">NULL</span> &amp;&amp; p-&gt;data!= e)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值查找不带头结点的单链表 时间复杂度为O(n)  </span></span><br><span class="line">LNode* <span class="title function_">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> &#123;  </span><br><span class="line">    LNode* p = L; <span class="comment">// 不带头结点，直接从第一个数据节点开始  </span></span><br><span class="line">    <span class="comment">// 从第一个数据节点开始查找数据域为e的结点  </span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">    &#123;  </span><br><span class="line">        p = p-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 找到后返回该结点指针，否则返回NULL  </span></span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="2-6-插入结点操作"><a href="#2-6-插入结点操作" class="headerlink" title="2.6 插入结点操作"></a>2.6 插入结点操作</h3><p>插入结点操作将值为x的新结点插入到单链表的第i个位置。先检查插入操作位置的合法性，然后找到待插入位置的前驱，即第i-1个结点，再在其后插入。操作过程如下图所示：</p><img src="https://pic.imgdb.cn/item/65f02dee9f345e8d0366454c.png" alt="数据结构（一）——线性表_插入结点操作.png" width=50%><p>具体算法如下，首先查找第i-1个结点，假设第i-1个结点为 *p，然后令新结点 *s 的指针域指向 *p 的后继，再令结点 *p的指针域指向新插入的结点 *s。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带头结点的链表的插入操作 时间复杂度为O(n)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">LNode* p = L;</span><br><span class="line">    <span class="comment">//记录当前结点的位序</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环找找到第i-1个结点</span></span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span><span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="comment">//插入操作</span></span><br><span class="line">s-&gt;data = e;</span><br><span class="line">    <span class="comment">//步骤1和步骤2不能颠换</span></span><br><span class="line">s-&gt;next = p-&gt;next; <span class="comment">//图中操作步骤1</span></span><br><span class="line">p-&gt;next = s;       <span class="comment">//图中操作步骤2</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带头结点的链表的插入操作，时间复杂度为O(n)  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType e)</span> &#123;  </span><br><span class="line">    <span class="comment">// 检查插入位置是否合法  </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 插入位置不合法  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 创建一个新节点  </span></span><br><span class="line">    LNode* s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 内存分配失败  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    s-&gt;data = e;  </span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="comment">// 指针p指向当前扫描到的节点  </span></span><br><span class="line">    LNode* p = L;  </span><br><span class="line">    <span class="comment">// 记录当前节点的位序（从1开始）  </span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">// 找到第i-1个节点  </span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;  </span><br><span class="line">        p = p-&gt;next;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果p为NULL，说明链表长度小于i-1，插入位置不合法  </span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">free</span>(s); <span class="comment">// 释放新节点的内存  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 插入新节点  </span></span><br><span class="line">    s-&gt;next = p-&gt;next;  </span><br><span class="line">    p-&gt;next = s;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在单链表的插入算法中，通常都采用后插操作。但是除了后插操作还可以采用前插操作，前插操作是指在某结点的前插入一个新结点。但是前插操作需要在传递链表时将表头也传输过来，否则在前插操作就会找不到前驱结点的位置。为了解决这个问题，可以采用伪前驱的方式进行插入操作，即将新结点插入需要进行前插结点的后方，然后将两个结点的数据域与指针域都进行交换，便可实现伪前插操作。代码片段如下(将元素e插入p结点前方)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入元素e，申请新结点存储元素e</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = s; <span class="comment">//新结点s连到p之后</span></span><br><span class="line">s-&gt;data = p-&gt;data; <span class="comment">//将p中元素复制到s中</span></span><br><span class="line">p-&gt;data = e; <span class="comment">//p中元素覆盖为e</span></span><br></pre></td></tr></table></figure><h3 id="2-7-删除结点操作"><a href="#2-7-删除结点操作" class="headerlink" title="2.7 删除结点操作"></a>2.7 删除结点操作</h3><p>删除结点操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i-1个结点，即被删除结点的前驱，再删除第i个结点。操作过程如下图：</p><img src="https://pic.imgdb.cn/item/65f0383c9f345e8d03945bde.png" alt="数据结构（一）——线性表_删除结点操作.png" width=50%><p>具体算法如下，假设结点 *p 为找到的被删结点的前驱，为实现这一操作后的逻辑关系的变化，仅需修改 *p的指针域，将 *p的指针域next指向 *q的下一结点，然后释放 *q的存储空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    LNode* p;</span><br><span class="line">    <span class="comment">//当前p指向的结点</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//L指向头结点，头结点是第0个结点(不存数据)</span></span><br><span class="line">p = L;</span><br><span class="line">    <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp;j&lt;i<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>|| p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//令q指向被删除结点</span></span><br><span class="line">LNode* q = p-&gt;next;</span><br><span class="line"><span class="comment">//用e返回元素的值</span></span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    <span class="comment">//将*q结点从链中断开</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="comment">//释放结点存储空间</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带头结点的链表的删除操作  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList&amp; L, <span class="type">int</span> i, ElemType&amp; e)</span> &#123;  </span><br><span class="line">    <span class="comment">// 检查删除位置是否合法  </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || L == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 删除位置不合法或链表为空  </span></span><br><span class="line">    &#125;   </span><br><span class="line">    LNode* p = L; <span class="comment">// 从第一个数据节点开始  </span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>; <span class="comment">// 从1开始计数  </span></span><br><span class="line">    <span class="comment">// 找到第i-1个节点  </span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) </span><br><span class="line">    &#123;  </span><br><span class="line">        p = p-&gt;next;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果链表长度小于i，或p为NULL（即第i个节点不存在），返回false  </span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// q指向要删除的节点  </span></span><br><span class="line">    LNode* q = p-&gt;next;  </span><br><span class="line">    <span class="comment">// 保存要删除节点的数据  </span></span><br><span class="line">    e = q-&gt;data;  </span><br><span class="line">    <span class="comment">// 删除操作：将p的next指向q的next  </span></span><br><span class="line">    p-&gt;next = q-&gt;next;  </span><br><span class="line">    <span class="comment">// 释放q节点占用的内存  </span></span><br><span class="line">    <span class="built_in">free</span>(q);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>要删除某个给定结点 *p，通常做法是先从链表头结点开始顺序找到其前驱，然后执行删除操作。除此以外，也可以用删除 *p 的后继来实现，实质就是将其后继的值赋予其自身，然后删除后继。代码片段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q=p-&gt;next; <span class="comment">//令q指向p的后继结点</span></span><br><span class="line">p-&gt;data=p-&gt;next-&gt;data; <span class="comment">//用后继结点的数据域覆盖</span></span><br><span class="line">p-&gt;next=q-&gt;next; <span class="comment">//将q结点从链中断开</span></span><br><span class="line"><span class="built_in">free</span>(q); <span class="comment">//释放后继结点的存储空间</span></span><br></pre></td></tr></table></figure><h2 id="3-双链表"><a href="#3-双链表" class="headerlink" title="3. 双链表"></a>3. 双链表</h2><h3 id="3-1-双链表的实现"><a href="#3-1-双链表的实现" class="headerlink" title="3.1 双链表的实现"></a>3.1 双链表的实现</h3><p>双链表示意图：</p><img src="https://pic.imgdb.cn/item/65f040749f345e8d03bc6722.png" alt="数据结构（一）——线性表_双链表示意图.png"><p>双链表结点类型描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表链表结构类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line"><span class="comment">//数据域</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="comment">//前驱和后继指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>* <span class="title">prior</span>, * <span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br></pre></td></tr></table></figure><h3 id="3-2-双链表的插入操作"><a href="#3-2-双链表的插入操作" class="headerlink" title="3.2 双链表的插入操作"></a>3.2 双链表的插入操作</h3><p>双链表中p所指的结点之后插入结点 *s。过程如下图：</p><img src="https://pic.imgdb.cn/item/65f041029f345e8d03bf1a02.png" alt="数据结构（一）——线性表_双链表插入结点.png" width=50%><p>操作代码片段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将结点s插入p之后</span></span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = s; </span><br><span class="line">s-&gt;prior = p; </span><br><span class="line">p-&gt;next = s; </span><br></pre></td></tr></table></figure><h3 id="3-3-双链表的删除操作"><a href="#3-3-双链表的删除操作" class="headerlink" title="3.3 双链表的删除操作"></a>3.3 双链表的删除操作</h3><p>删除双链表中结点 *p的后继 *q。过程如下图：</p><img src="https://pic.imgdb.cn/item/65f041829f345e8d03c1a158.png" alt="数据结构（一）——线性表_双链表删除结点.png" width=60%><p>删除操作代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;  <span class="comment">//步骤1</span></span><br><span class="line">q-&gt;next-&gt;prior = p; <span class="comment">//步骤2</span></span><br><span class="line"><span class="built_in">free</span>(q);<span class="comment">//释放空间结点</span></span><br></pre></td></tr></table></figure><h2 id="4-循环链表"><a href="#4-循环链表" class="headerlink" title="4. 循环链表"></a>4. 循环链表</h2><h3 id="4-1-循环单链表"><a href="#4-1-循环单链表" class="headerlink" title="4.1 循环单链表"></a>4.1 循环单链表</h3><p>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。在循环单链表中，表位结点 *r的next域指向L，故表中没有指针域为NULL的结点，因此，循环单链表的判空条件是r是否指向L。下图为循环单链表的示意图：</p><img src="https://pic.imgdb.cn/item/65f03d179f345e8d03abb019.png" width=75%><h3 id="4-2-循环双链表"><a href="#4-2-循环双链表" class="headerlink" title="4.2 循环双链表"></a>4.2 循环双链表</h3><p>循环双链表中，多出一个头结点的prior指针还要指向表尾结点。当某结点 *p 为尾结点时，p-&gt;next&#x3D;&#x3D;L；当循环双链表为空表时，其头结点的prior域和next域都等于L。下图为循环双链表的示意图：</p><img src="https://pic.imgdb.cn/item/65f03d189f345e8d03abb7a4.png" alt="数据结构（一）——线性表_循环双链表.png"><h2 id="5-静态链表"><a href="#5-静态链表" class="headerlink" title="5. 静态链表"></a>5. 静态链表</h2><p>静态链表是用数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，但与链表不同的是，这里的指针是结点在数组中的相对地址（数组下标），又称游标。和顺序表一样，静态链表也要预先分配一块连续的内存空间。</p><p>静态链表和单链表对应关系如图（静态链表以next&#x3D;&#x3D;-1作为其结束标志）：</p><img src="https://pic.imgdb.cn/item/65f03ddd9f345e8d03af8690.png" alt="数据结构（一）——线性表_静态链表.png"><p>静态链表结构类型描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态链表的最大长度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="comment">//静态链表结构类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">//存储数据元素</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="comment">//下一个元素的数组下标</span></span><br><span class="line"><span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo搭建的个人博客常见问题处理</title>
      <link href="/2024/03/02/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
      <url>/2024/03/02/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基于hexo搭建的个人博客常见问题处理"><a href="#基于hexo搭建的个人博客常见问题处理" class="headerlink" title="基于hexo搭建的个人博客常见问题处理"></a>基于hexo搭建的个人博客常见问题处理</h1><h3 id="1-Error-Spawn-failed处理"><a href="#1-Error-Spawn-failed处理" class="headerlink" title="1.Error: Spawn failed处理"></a>1.Error: Spawn failed处理</h3><p>在使用hexo cl ; hexo g ; hexo d推送博客时出现以下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (C:\blog\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (node:events:517:28)</span><br><span class="line">    at cp.emit (C:\blog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">    at ChildProcess._handle.onexit (node:internal/child_process:292:12)</span><br></pre></td></tr></table></figure><p>可以使用以下方法解决该问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##进入站点根目录</span><br><span class="line">cd /usr/local/myblog/</span><br><span class="line"></span><br><span class="line">##删除git提交内容文件夹</span><br><span class="line">rm -rf .deploy_git/</span><br><span class="line"></span><br><span class="line">##执行</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line"></span><br><span class="line">##最后</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>绝大多数情况，使用此方法以后，hexo d都没问题，但也存在少数情况，使用以后仍出现这种问题。例如下图报错，我在更改以后仍然显示此报错：</p><img src="https://pic.imgdb.cn/item/65eda1909f345e8d03529149.png" alt="1" width=100% /><p>这个时候我们一定要先确定一下网络有没有连接上，如果网络已连接，则可以使用下述命令去看看自己的公钥有没有连接上github。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>出现下面两种情况，说明我们的连接没有建立。</p><img src="https://pic.imgdb.cn/item/65eda1979f345e8d0352c553.png" alt="2" width=100% /><img src="https://pic.imgdb.cn/item/65eda5889f345e8d036df59f.png" alt="3" width=100% /><p>这种情况下，可以先采用2的方法查看一下是否是git配置文件出现问题，重新设置用户名和邮箱，然后再hexo三连，如果还是失败了。就只能采取重新与GitHub建立连接的方法了。</p><h3 id="2-fatal-bad-config-line-1-in-file-C-Users-lenvo-gitconfig"><a href="#2-fatal-bad-config-line-1-in-file-C-Users-lenvo-gitconfig" class="headerlink" title="2.fatal: bad config line 1 in file C:&#x2F;Users&#x2F;lenvo&#x2F;.gitconfig"></a>2.fatal: bad config line 1 in file C:&#x2F;Users&#x2F;lenvo&#x2F;.gitconfig</h3><p>在git里执行git config –global core.autocrlf false时，出现fatal: bad config line 1 in file C:&#x2F;Users&#x2F;lenvo&#x2F;.gitconfig报错。这种情况下，一般都是git配置文件出了问题，找到提示的目录，把该文件下 .gitconfig文件删除。</p><p>然后重新打开git，执行以下配置命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##设置用户名，将your name替换为自己的github用户名</span><br><span class="line">git config --global user.name &quot;your name&quot;</span><br><span class="line"></span><br><span class="line">##设置邮箱，将your email替换为自己的github邮箱</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure><p>然后，刚刚删除的 .gitconfig文件就会重新生成，我们可以在刚刚的路径下查看到新的.gitconfig文件。此时就可以重新使用，git config –global core.autocrlf false命令也可以执行成功。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS基础语法及应用</title>
      <link href="/2024/02/08/CSS%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2024/02/08/CSS%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS基础语法及应用"><a href="#CSS基础语法及应用" class="headerlink" title="CSS基础语法及应用"></a>CSS基础语法及应用</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在前面有关HTML5的语法中我们有说过，CSS主要用来对网页元素的外观和位置等页面样式进行设置（<a href="HTML5%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8.md">H5语法连接：HTML5基本语法大全</a>），是前端开发中的重要一环。</p><p>而CSS在我们的开发中主要有3种引入方式，分别是内嵌式、外联式和行内式。</p><p><strong>内嵌式</strong>：CSS写在style标签中。而style标签可以写在任意位置，但是我们习惯将style标签写在head标签下。以下是内嵌式程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>外联式：</strong>CSS写在一个单独的 <strong>.CSS</strong> 文件中，但是我们需要通过<strong>link标签</strong>在网页引入。以下是外联式程序示例，第一段程序是HTML文件程序，第二段程序是被HTML文件引用的include.css程序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;include.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>行内式：</strong>CSS写在标签的style属性中，通常配合js使用。以下是行内式程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过以上了解，我们可以初步认识CSS的作用以及它的引用方式和应用场景。内嵌式的开发方式多用于小案例的演示；外联式的开发方式多用来项目开发；行内式的使用多用来配合js。本文作演示的程序都是小案例，所以基本上都采用内嵌式的方式进行示例。</p><h2 id="二、CSS基本语法"><a href="#二、CSS基本语法" class="headerlink" title="二、CSS基本语法"></a>二、CSS基本语法</h2><h3 id="1-选择器"><a href="#1-选择器" class="headerlink" title="1.选择器"></a>1.选择器</h3><p>作用：选择想要添加样式的HTML标签。例如：我们在开发网页时，想将div标签中的文字内容设置为红色，那我们就需要先通过选择器选中div标签，才能再通过color将其设置为红色。</p><p>选择器分为四大类：标签选择器、类选择器、id选择器、通配符选择器。</p><h4 id="1-1-标签选择器"><a href="#1-1-标签选择器" class="headerlink" title="1.1 标签选择器"></a>1.1 标签选择器</h4><p><strong>结构：标签名 { css属性名 : 属性值 ; }</strong></p><p>作用：通过标签名找到页面中所有这类标签，设置样式。需要注意的是，标签选择器可以找到不论经过多少次嵌套的标签，而且它选中的是这<strong>一类标签</strong>，并不是单独某一个，例如：文件里写了多个div标签，那通过div标签选择器设置红色文字，那所有div标签里的文字都将变为红色。以下是标签选择器程序使用示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-2-类选择器"><a href="#1-2-类选择器" class="headerlink" title="1.2 类选择器"></a>1.2 类选择器</h4><p><strong>结构：.类名 { css属性名 : 属性值 ; }</strong></p><p>作用：通过类名，找到页面中所有带有这个类名的标签，设置样式。所有标签上都有class属性，class属性的属性值称为<strong>类名</strong>。类名由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头。而且，一个标签可以同时有多个类名，类名之间以空格隔开。类名也可以重复，一个类选择器可以同时选中多个标签。以下是类选择器使用示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.color</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.size</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">66px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;color size&quot;</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-id选择器"><a href="#1-3-id选择器" class="headerlink" title="1.3 id选择器"></a>1.3 id选择器</h4><p><strong>结构：#id属性值 { css属性名 : 属性值 ; }</strong></p><p>作用：通过id属性值，找到页面中带有这个id属性值的标签，设置样式。同class属性，所有标签上也都有id属性，但是id属性类似于身份证，在一个页面中是唯一的，不可重复。一个标签上只能有个id属性值，而一个id选择器也只能选中一个标签。以下是id选择器使用案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#colour</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;colour&quot;</span>&gt;</span>hello world！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-4-通配符选择器"><a href="#1-4-通配符选择器" class="headerlink" title="1.4 通配符选择器"></a>1.4 通配符选择器</h4><p><strong>结构：*{ css属性名 : 属性值 ; }</strong></p><p>作用：找到页面中所有的标签，设置样式。通配符选择器在开发中很少使用，一般常用来去除标签默认的margin（外边距）和padding（内边距）。以下是使用案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    *&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-选择器后代"><a href="#1-5-选择器后代" class="headerlink" title="1.5 选择器后代"></a>1.5 选择器后代</h4><p><strong>结构：选择器1 选择器2 {css}</strong></p><p>作用：根据HTML标签的嵌套关系，选择父元素后代中满足条件的元素。</p><p>如结构，具体含义是在选择器1所找到标签的后代（标签1里包含的所有嵌套标签，一级嵌套、二级嵌套等等）中，找到满足选择器2的标签，设置样式。注意后代包括不只子代，还有孙代、重孙代等等。另外使用后代选择器，选择器1和选择器2之间需要通过<strong>空格</strong>隔开。以下为案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-6-选择器子代"><a href="#1-6-选择器子代" class="headerlink" title="1.6 选择器子代"></a>1.6 选择器子代</h4><p><strong>结构：选择器1&gt;选择器2{css}</strong></p><p>作用：根据HTML标签的嵌套关系，选择父元素子代中满足条件的元素。</p><p>如结构，在选择器1所找到标签的子代中，找到满足选择器2的标签，设置样式。需要注意的是，这里的子代是仅指儿子一代，，也就是一级嵌套标签，不包括后面的孙代，重孙代。另外选择器之间通过 <strong>&gt;</strong> 隔开。以下为案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&gt;<span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-7-选择器并集"><a href="#1-7-选择器并集" class="headerlink" title="1.7 选择器并集"></a>1.7 选择器并集</h4><p><strong>结构：选择器1 , 选择器2{css}</strong></p><p>作用：同时选择多组标签，设置相同的样式</p><p>如结构，找到选择器1和选择器2选中的标签，设置样式。这里也有需要注意的地方，首先第一点并集选择器中的每组选择器之间通过 <strong>“ , ”</strong> 分隔。其次，并集选择器中的每组选择器可以是基础选择器或者复合选择器。另外，并集选择器中的每组选择器通常一行写一个，从而提高代码的可读性。</p><p> 案例演示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>,<span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-8-选择器交集"><a href="#1-8-选择器交集" class="headerlink" title="1.8 选择器交集"></a>1.8 选择器交集</h4><p><strong>结构：选择器1选择器2{css}</strong></p><p>作用：选中页面中同时满足多个选择器的标签。</p><p>如结构：找到页面中既能被选择器1选中，又能被选择器2选中的标签，设置样式。这里需要注意两点。第一点，交集选择器中的选择器之间是紧挨着的，没有东西分隔。第二点，交集选择器中如果有标签选择器，标签选择器必须写在最前面。以下是案例演示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.a</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-9-选择器伪类"><a href="#1-9-选择器伪类" class="headerlink" title="1.9 选择器伪类"></a>1.9 选择器伪类</h4><p><strong>结构：选择器 : hover{css}</strong></p><p>作用：选中鼠标悬停在标签上的状态，设置样式。</p><p>这里要注意的是，伪类选择器选中的是元素的某种状态。通过对结构中的css进行设置，可以实现当鼠标悬停在某个结构标签上时，更改标签样式。</p><p>案例演示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-文字"><a href="#2-文字" class="headerlink" title="2.文字"></a>2.文字</h3><p>在文章中，我们常常排版布局时，会对文字大小，字体等方面进行样式设置，在网页中也一样，我们在开发时为了美观，也会对文字进行样式设置，这部分主要对文字的样式属性进行一个总结。</p><h4 id="2-1-字体大小"><a href="#2-1-字体大小" class="headerlink" title="2.1 字体大小"></a>2.1 字体大小</h4><p><strong>属性名：font-size</strong></p><p><strong>取值：数字+px</strong></p><p>注意：谷歌浏览器默认文字大小是16px，这里的px是单位，我们在开发时一定要写px，不然属性设置会无效。以下是字体大小程序设置示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-size</span>: <span class="number">32px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-字体粗细"><a href="#2-2-字体粗细" class="headerlink" title="2.2 字体粗细"></a>2.2 字体粗细</h4><p><strong>属性名：font-weight</strong></p><p><strong>取值：字体粗细有两种取值方式。</strong></p><p><strong>第一种：关键字</strong></p><table><thead><tr><th>正常</th><th>normal</th></tr></thead><tbody><tr><td>加粗</td><td>bold</td></tr></tbody></table><p><strong>第二种：纯数字，100~900的整百数</strong></p><table><thead><tr><th>正常</th><th>400</th></tr></thead><tbody><tr><td>加粗</td><td>700</td></tr></tbody></table><p>需注意的是，不是所有字体都提供了九种粗细，因此部分取值页面中无变化。而在实际开发中，以正常、加粗两种取值使用最多。以下是程序使用案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-weight</span>: <span class="number">700</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-字体样式（是否倾斜）"><a href="#2-3-字体样式（是否倾斜）" class="headerlink" title="2.3 字体样式（是否倾斜）"></a>2.3 字体样式（是否倾斜）</h4><p><strong>属性名：font-style</strong></p><p><strong>取值：正常（默认值）：normal    倾斜：italic</strong></p><p>字体倾斜样式均是向左倾斜，与word文档里的倾斜方式一样，以下是使用案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-style</span>: italic;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-字体"><a href="#2-4-字体" class="headerlink" title="2.4 字体"></a>2.4 字体</h4><p><strong>属性名：font-family</strong></p><p><strong>取值：具体字体1,具体字体2,……,字体系列</strong></p><p>具体字体：微软雅黑、黑体、楷体……</p><p>字体系列：sans-serif、serif、monospace……</p><p>渲染规则：左右往右按顺序查找，如果电脑中未安装左边字体，则显示下一个字体，如果都不支持，一般在程序开发中会写一个字体系列，此时会显示电脑支持的，在字体系列里的字体。</p><p>需要注意的是，字体名称中存在多个单词时，推荐使用引号包裹，但最后一项字体系列不需要引号包裹。另外还需要注意的是，Windows系统默认字体为微软雅黑，macOS系统默认字体为苹方。以下是程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 如果用户电脑没有安装微软雅黑，则按黑体显示文字 */</span></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 如果用户电脑也没有安装黑体，就按任意一种非衬线字体系列显示 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font-family</span>: 微软雅黑,黑体,sans-serif;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，为了方便以后对网页的开发，我们对字体也进行一个拓展了解，常用的字体大致分为三大系列，分别是无衬线字体、衬线字体、等宽字体，我们对其稍微进行一个深入的分类使用说明：</p><table><thead><tr><th><strong>字体系列</strong></th><th><strong>特点</strong></th><th><strong>应用场景</strong></th><th><strong>常见的该系列字体</strong></th></tr></thead><tbody><tr><td>无衬线字体（sans-serif）</td><td>文字笔画粗细均匀，并且首位无装饰</td><td>网页中大多采用无衬线字体</td><td>黑体</td></tr><tr><td>衬线字体（serif）</td><td>文字笔画粗细不均，并且首位有笔锋装饰</td><td>报刊书籍中应用广泛</td><td>宋体</td></tr><tr><td>等宽字体（monospace）</td><td>每个字母或文字的宽度相等</td><td>一般用于程序代码编写</td><td>Consolas</td></tr></tbody></table><h4 id="2-5-font的复合属性"><a href="#2-5-font的复合属性" class="headerlink" title="2.5 font的复合属性"></a>2.5 font的复合属性</h4><p><strong>属性名：font（复合属性）</strong></p><p><strong>取值：font：style weight size family（顺序不可改变）</strong></p><p>注：前两个值可以省略，如果省略了相当于设置了默认值。另外，如果要同时设置单独和连写形式，要么把单独的样式写在连写的下面，要么把单独的样式写在连写的里面。以下是程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font</span>: normal <span class="number">700</span> <span class="number">32px</span> 宋体;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-文本"><a href="#3-文本" class="headerlink" title="3.文本"></a>3.文本</h3><h4 id="3-1-文本缩进"><a href="#3-1-文本缩进" class="headerlink" title="3.1 文本缩进"></a>3.1 文本缩进</h4><p><strong>属性名：text-indent</strong></p><p><strong>取值：第一种：数字+px    第二种：数字+em（1em&#x3D;当前标签的font-size的大小）</strong></p><p>我们在程序里常常使用em做首行缩进，这样不论字体大小怎么变化，可以保证首行都是缩进两个字符长度。如果使用数字+px的方式进行缩进，如果font-size大小发生变化，则首行缩进就不再是两个字符。以下为案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world！</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-文本水平对齐"><a href="#3-2-文本水平对齐" class="headerlink" title="3.2 文本水平对齐"></a>3.2 文本水平对齐</h4><p><strong>属性名：text-align</strong></p><p><strong>取值：</strong></p><table><thead><tr><th><strong>属性值</strong></th><th><strong>效果</strong></th></tr></thead><tbody><tr><td>left</td><td>左对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr><tr><td>right</td><td>右对齐</td></tr></tbody></table><p>这部分需要注意一点，如果需要让文本水平居中，text-align属性要给到<strong>文本所在标签（文本的父元素）</strong>设置。例如，对文本、span标签，h标签，input标签、img标签等进行元素居中时，需要在父元素进行设置。而对h标签等标签，则可以进行直接设置。对于text-align的放置牵扯到显示模式等多方因素，可以根据实际项目需求考虑清楚再放置。以下是使用案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-文本修饰"><a href="#3-3-文本修饰" class="headerlink" title="3.3 文本修饰"></a>3.3 文本修饰</h4><p><strong>属性名：text-decoration</strong></p><p><strong>取值：</strong></p><table><thead><tr><th><strong>属性值</strong></th><th><strong>效果</strong></th></tr></thead><tbody><tr><td>underline</td><td>下划线（常用）</td></tr><tr><td>line-through</td><td>删除线（不常用）</td></tr><tr><td>overline</td><td>上划线（几乎不用）</td></tr><tr><td>none</td><td>无装饰线（常用）</td></tr></tbody></table><p>开发中，常常会使用 text-decoration : none ; 来清楚a标签默认的下划线。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-行高"><a href="#4-行高" class="headerlink" title="4.行高"></a>4.行高</h3><p><strong>属性名：line-height</strong></p><p><strong>取值：两种。第一种：数字+px    第二种：倍数（当前标签font-size的倍数）</strong></p><p>作用：控制一行的上下行间距。</p><p>一般两种应用场景：</p><p>​    第一种：让单行文本垂直居中可以设置 line-height : 文字父元素高度。</p><p>​    第二种：网页精准布局时，会设置 line-height : 1 可以取消上下间距。</p><p>在前面我们有提过font复合属性，在这里，行高也可以和font连写，但要注意覆盖问题。</p><p>连写格式为：font : style weight size&#x2F;line-height family ; （注意格式顺序不可变）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.a</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">line-height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.b</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">font</span>: italic <span class="number">700</span> <span class="number">36px</span>/<span class="number">2</span> family;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-颜色取值"><a href="#5-颜色取值" class="headerlink" title="5.颜色取值"></a>5.颜色取值</h3><p>在前端设计中，有很多地方需要对颜色进行一个选取，但颜色的选取主要由设计师进行设计选取，而程序员只需要根据设计师的设计直接在程序里设置即可，所以我们在此处说一下颜色的几种写法，具体参考下表。</p><table><thead><tr><th><strong>颜色表示方式</strong></th><th><strong>表示含义</strong></th><th><strong>属性值（举例）</strong></th></tr></thead><tbody><tr><td>关键词</td><td>预定义的颜色名</td><td>red、green</td></tr><tr><td>rgb表示法</td><td>红绿蓝三原色。每项取值范围：0~255</td><td>rgb（0,0,0）</td></tr><tr><td>rgba表示法</td><td>红绿蓝三原色+a表示透明度，取值范围0~1</td><td>rgba（255,255,255,0.5）</td></tr><tr><td>十六进制表示法</td><td>#开头，将数字转换成十六进制表示</td><td>#000000、#ff0000 简写：#000、#f00</td></tr></tbody></table><h3 id="6-标签居中"><a href="#6-标签居中" class="headerlink" title="6.标签居中"></a>6.标签居中</h3><p><strong>结构：margin : 0 auto ;</strong></p><p>在项目中，我们还会遇到给div、p、h等做大盒子（盒子可以理解为作为外层标签）的标签设置水平居中的情况，如果我们在这里使用 text-align : center ; 只会让这些标签里的内容水平居中，并不能做到让标签本身的范围居中，这时，我们就用到了 margin : 0 auto; ，只需要给当前标签本身设置即可实现标签居中。</p><p>还需注意，这种方法一般针对于固定宽度的盒子，如果大盒子没有设置宽度，此时会默认占满父元素的宽度。以下是程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-背景"><a href="#7-背景" class="headerlink" title="7.背景"></a>7.背景</h3><h4 id="7-1-背景颜色"><a href="#7-1-背景颜色" class="headerlink" title="7.1 背景颜色"></a>7.1 背景颜色</h4><p><strong>属性名：background-color</strong></p><p><strong>属性值：颜色取值（参考前面5.颜色取值部分）</strong></p><p>背景色默认值是透明的，但我们在项目中，会采用赋值背景颜色的方式，来查看盒子的大小和位置，所以我们需要学会在布局时，通过设置背景颜色来查看布局。以下为程序案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.a</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="7-2-背景图片"><a href="#7-2-背景图片" class="headerlink" title="7.2 背景图片"></a>7.2 背景图片</h4><p><strong>属性名：background-image</strong></p><p><strong>属性值：background-image : url ( ‘ 图片路径 ‘ ) ;</strong></p><p>这里有一点需要注意，如果背景图片的尺寸小于盒子尺寸，则会采用水平平铺和垂直平铺的方式将盒子铺满，就像铺地砖一样，采用多个同样的地砖将地面铺满。如果盒子尺寸小于图片尺寸，那只会显示盒子尺寸大小的部分图片，并不能完整显示。以下为程序案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.a</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;./helloworld.png&#x27;</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="7-3-背景平铺"><a href="#7-3-背景平铺" class="headerlink" title="7.3 背景平铺"></a>7.3 背景平铺</h4><p><strong>属性名：background-repeat</strong></p><p><strong>属性值：</strong></p><table><thead><tr><th><strong>取值</strong></th><th><strong>效果</strong></th></tr></thead><tbody><tr><td>repeat</td><td>（默认值）水平和垂直方向都平铺</td></tr><tr><td>no-repeat</td><td>不平铺</td></tr><tr><td>repeat-x</td><td>沿着水平方向（x轴）平铺</td></tr><tr><td>repeat-y</td><td>沿着垂直方向（y轴）平铺</td></tr></tbody></table><p>在7.2，我们了解了背景图片在盒子里的平铺排列以后，这部分我们使用background-repeat来取消这种平铺方式。具体使用方式可参考上表。以下为程序案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.a</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;./helloworld.png&#x27;</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="7-4-背景位置"><a href="#7-4-背景位置" class="headerlink" title="7.4 背景位置"></a>7.4 背景位置</h4><p><strong>属性名：background-position</strong></p><p><strong>属性值：background-position : 水平方向位置 垂直方向位置 ;</strong> </p><p><strong>这里的属性值水平方向位置和垂直方向位置有两种取值方式：</strong></p><p>​    第一种：采用方位名词：水平方向：left &#x2F; center &#x2F; right    垂直方向：top &#x2F; center &#x2F; bottom</p><p>​    第二种：采用 数字+px：坐标系就是以左上角为原点（0,0），x轴水平向右，y轴垂直向下。</p><p>方位名词和坐标取值可以混着使用，但需要记住第一个取值表示水平，第二个取值表示垂直。以下为程序案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.a</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;./helloworld.png&#x27;</span>);</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-repeat</span>: no-repeat;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-position</span>: left bottom;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="7-5-背景相关属性"><a href="#7-5-背景相关属性" class="headerlink" title="7.5 背景相关属性"></a>7.5 背景相关属性</h4><p><strong>属性名：background</strong></p><p><strong>属性值：background : color image repeat position （顺序可变）</strong></p><p>这一栏是background的复合属性写法，同font复合属性，但不同的是，background复合属性顺序可以随便颠倒，但是font不行。但是有一点需要注意，如果采用数值确定背景图片的位置，那数值就不能颠倒，系统会默认前一个数值是x轴方向，后一个数值是y轴方向的。以下为程序案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span><span class="selector-class">.a</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background</span>: red <span class="built_in">url</span>(<span class="string">./1.png</span>) no-repeat right center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-显示模式"><a href="#8-显示模式" class="headerlink" title="8.显示模式"></a>8.显示模式</h3><h4 id="8-1-块级标签"><a href="#8-1-块级标签" class="headerlink" title="8.1 块级标签"></a>8.1 块级标签</h4><p>显示特点：</p><p>​    1.独占一行（一行只能显示一个）。</p><p>​    2.宽度默认是父元素的宽度，高度默认由内容撑开。</p><p>​    <strong>3.可以设置宽高</strong></p><p>代表标签：<strong>div、p、h系列</strong>、ul、li、dl、dt、dd、form、header、……</p><h4 id="8-2-行内标签"><a href="#8-2-行内标签" class="headerlink" title="8.2 行内标签"></a>8.2 行内标签</h4><p>显示特点：</p><p>​    1.一行可以显示多个。</p><p>​    2.宽度和高度默认由内容撑开。</p><p>​    <strong>3.不可以设置宽高</strong></p><p>代表标签：a<strong>、span、</strong>b、u、i、s、strong、……</p><h4 id="8-3-行内块"><a href="#8-3-行内块" class="headerlink" title="8.3 行内块"></a>8.3 行内块</h4><p>显示特点：</p><p>​    1.一行可以显示多个。</p><p>​    <strong>2.可以设置宽高</strong></p><p>代表标签：<strong>input、textarea</strong>、button、select、……</p><h4 id="8-4-显示模式之间的转换"><a href="#8-4-显示模式之间的转换" class="headerlink" title="8.4 显示模式之间的转换"></a>8.4 显示模式之间的转换</h4><p><strong>语法：</strong></p><table><thead><tr><th>属性</th><th>效果</th><th>使用频率</th></tr></thead><tbody><tr><td>display: block</td><td>转换成块级元素</td><td>较多</td></tr><tr><td>display: inline-block</td><td>转换成行内块元素</td><td>较多</td></tr><tr><td>display: inline</td><td>转换成行内元素</td><td>极少</td></tr></tbody></table><p>在8.1~8.3，我们介绍了三种显示模式，分别是块、行内、行内块。这三种显示模式代表着不同标签的布局方式，但为了让标签布局符合我们设计的要求，显得更加美观，有时候我们需要更改某些标签的尺寸等，但对于某些标签来说，它本身就带有一部分效果，那我们再去更改时，会发现不允许我们更改，这时候我们需要更改它的显示模式，再去进行设置。</p><p>举个简单的例子，我们想一行显示多个块级标签，这就需要我们将块元素改成行内块元素才行。以下为案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: red;;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-标签嵌套"><a href="#9-标签嵌套" class="headerlink" title="9.标签嵌套"></a>9.标签嵌套</h3><p>在了解完显示模式以后，我们讲两个关于标签嵌套规范的问题。</p><p>第一个：块级元素一般作为大容器，可以嵌套：文本、块级元素、行内元素、行内块元素等……</p><p>​    <strong>但是：p标签中不要嵌套div、p、h等块级元素。</strong></p><p>第二个：a标签内部可以嵌套任意元素</p><p>​    <strong>但是：a标签不能嵌套a标签。</strong></p><h3 id="10-CSS特性"><a href="#10-CSS特性" class="headerlink" title="10.CSS特性"></a>10.CSS特性</h3><h4 id="10-1-继承性"><a href="#10-1-继承性" class="headerlink" title="10.1 继承性"></a>10.1 继承性</h4><p>特性：子元素有默认继承父元素样式的特点</p><p>可以继承的常见属性（<strong>文字控制属性都可以继承</strong>）</p><p>​    1.color</p><p>​    2.font-size、font-weight、font-size、font-family</p><p>​    3.text-indent、text-align</p><p>​    4.line-height</p><p>​    5.……</p><p>注意：继承会存在失效的特殊情况。</p><p>如果元素有浏览器默认样式，此时继承性依然存在，但部分默认样式仍然会保留原样。</p><p>如a标签的color会继承失效 h系列标签的font-size会继承失效。</p><p>以下为继承性案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    hello world</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="10-2-层叠性"><a href="#10-2-层叠性" class="headerlink" title="10.2 层叠性"></a>10.2 层叠性</h4><p>特性：</p><p>1.给同一个标签设置不同的样式，此时样式会层叠叠加，然后共同作用在标签上。</p><p>2.给同一个标签设置相同的样式，此时样式会层叠覆盖，最终写在最后的样式会生效。</p><p>注意，当样式冲突时，只有当选择器优先级相同时，才能通过层叠性判断结果。</p><p>以下是层叠性案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 同一标签不同样式 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.hello</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.hello</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 同一标签相同样式 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.world</span>&#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;world&quot;</span>&gt;</span>world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网页开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5基本语法大全</title>
      <link href="/2024/02/01/HTML5%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/"/>
      <url>/2024/02/01/HTML5%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5基本语法大全"><a href="#HTML5基本语法大全" class="headerlink" title="HTML5基本语法大全"></a>HTML5基本语法大全</h1><h2 id="一、基本认知"><a href="#一、基本认知" class="headerlink" title="一、基本认知"></a><strong>一、基本认知</strong></h2><p>在进行HTML5学习之前，需要先了解一下Web标准，所谓Web标准是由于当前使用的浏览器颇多，而不同浏览器的渲染引擎不同，对于相同代码解析的效果会存在差异。为了缩小差异，提高浏览器兼容性，进而统一出的一个网页开发标准。</p><h3 id="1-1-Web标准组成"><a href="#1-1-Web标准组成" class="headerlink" title="1.1 Web标准组成"></a>1.1 Web标准组成</h3><p>Web标准不是某一个标准，而是一系列标准的集合，主要包含以下三部分：</p><table><thead><tr><th align="left"><strong>构成</strong></th><th><strong>语言</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">结构</td><td>HTML</td><td align="left">对页面元素和内容进行整理和分类</td></tr><tr><td align="left">表现</td><td>CSS</td><td align="left">对网页元素的外观和位置等页面样式进行设置（颜色、大小等）</td></tr><tr><td align="left">行为</td><td>JavaScript</td><td align="left">网页模型的定义和页面交互</td></tr></tbody></table><p> HTML就是其中之一，主要负责对页面元素和内容进行整理和分类。而HTML5是HTML的第五个版本，它对HTML进行了许多改进和扩展，使得网页开发更加丰富和便利。</p><h3 id="1-2-HTML初识"><a href="#1-2-HTML初识" class="headerlink" title="1.2 HTML初识"></a>1.2 HTML初识</h3><p>HTML译为：超文本标记语言。专门用于网页开发的语言，主要通过<strong>HTML标签</strong>对网页中的文本、图片、音频、视频等内容进行描述。</p><p>以下是HTML5的骨架，也是我们编写HTML5程序的第一步，先创建一个<strong>HTML5骨架</strong>，在vscode中可通过shift+!+Tab一键创建。其中<code>&lt;html&gt;</code> <code>&lt;head&gt;</code> <code>&lt;body&gt;</code>等均是标签，而不同的标签也代指不同的含义（标签的组成和关系可参考2.1）。需注意，本文所有语法程序全都应用在<code>&lt;body&gt;&lt;/body&gt;</code>这一组标签下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="二、HTML5基本语法"><a href="#二、HTML5基本语法" class="headerlink" title="二、HTML5基本语法"></a>二、HTML5基本语法</h2><h3 id="2-1-标签组成和关系"><a href="#2-1-标签组成和关系" class="headerlink" title="2.1 标签组成和关系"></a>2.1 标签组成和关系</h3><h4 id="2-1-1-标签的组成"><a href="#2-1-1-标签的组成" class="headerlink" title="2.1.1 标签的组成"></a>2.1.1 标签的组成</h4><p>标签由&lt;、&gt;、&#x2F;、英文单词或字母组成。并把标签中&lt;&gt;包括起来的英文单词或字母称为<strong>标签名</strong>。</p><p>常见的标签由两部分组成，我们称之为<strong>双标签</strong>，前部分叫<strong>开始标签</strong>，后部分叫<strong>结束标签</strong>，两部分之间包裹的内容便是此标签所应用的内容。列如骨架里的<code>&lt;title&gt;</code>标签，此标签的含义是网页的标题，而<code>&lt;title&gt;&lt;/title&gt;</code>之间的Document就是网页的标题。同理，html标签之间的就是网页的整体，而head标签之间的就是网页的头部，而body标签之间的则是网页的身体。在下面的程序示例里，我们使用strong标签，该标签代表着加粗，所以其中的123会被加粗显示。</p><p>当然，也有一些标签仅由一部分组成，我们称之为<strong>单标签</strong>。此类标签自成一体，无法包裹内容。如<code>&lt;br&gt;</code>标签，此标签意味着换行，例如下面的程序示例里，<code>123&lt;br&gt;</code>45则表示在3之后的位置进行换行，所以45要另起一行显示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">strong</span>&gt;</span>123<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">  123<span class="tag">&lt;<span class="name">br</span>&gt;</span>45</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：此处程序只显示body标签内的程序，因为本文程序在不做说明的情况下，全都应用在body标签下，所以省略了其他HTML骨架标签。实际编写时应包含整个骨架。这是本文第一次出现，所以在此阐述，之后便不再赘述。</p><h4 id="2-1-2-标签间的关系"><a href="#2-1-2-标签间的关系" class="headerlink" title="2.1.2 标签间的关系"></a>2.1.2 标签间的关系</h4><p>标签之间的关系可分为两种关系：<strong>父子关系</strong>（嵌套关系）和<strong>兄弟关系</strong>（并列关系）。以下两种演示第一种为父子关系，第二种则是兄弟关系。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-标题和段落"><a href="#2-2-标题和段落" class="headerlink" title="2.2 标题和段落"></a>2.2 标题和段落</h3><h4 id="2-2-1-标题标签"><a href="#2-2-1-标题标签" class="headerlink" title="2.2.1 标题标签"></a>2.2.1 标题标签</h4><p><strong>代码：h系列标签</strong></p><p>标题标签代码为h系列标签，分别是<code>&lt;h1&gt;</code>、<code>&lt;h2&gt;</code>、<code>&lt;h3&gt;</code>、<code>&lt;h4&gt;</code>、<code>&lt;h5&gt;</code>、<code>&lt;h6&gt;</code>，代表1~6级6种标题，重要程度依次递减。标题标签一般用于凸显主题。下面是程序演示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-段落标签"><a href="#2-2-2-段落标签" class="headerlink" title="2.2.2 段落标签"></a>2.2.2 段落标签</h4><p><strong>代码：<code>&lt;p&gt;&lt;/p&gt;</code></strong></p><p>段落标签代码为p标签，主要用于网页中的分段显示。下面是程序演示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-换行和水平线"><a href="#2-3-换行和水平线" class="headerlink" title="2.3 换行和水平线"></a>2.3 换行和水平线</h3><h4 id="2-3-1-换行标签"><a href="#2-3-1-换行标签" class="headerlink" title="2.3.1 换行标签"></a>2.3.1 换行标签</h4><p><strong>代码：<code>&lt;br&gt;</code></strong></p><p>换行标签主要用于让网页文字强制换行显示。下面是程序演示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  换行<span class="tag">&lt;<span class="name">br</span>&gt;</span>标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-水平线标签"><a href="#2-3-2-水平线标签" class="headerlink" title="2.3.2 水平线标签"></a>2.3.2 水平线标签</h4><p><strong>代码：<code>&lt;hr&gt;</code></strong></p><p>水平线标签主要用于分割不同主题内容。下面是程序演示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  水平线<span class="tag">&lt;<span class="name">hr</span>&gt;</span>标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-文本格式化"><a href="#2-4-文本格式化" class="headerlink" title="2.4 文本格式化"></a>2.4 文本格式化</h3><p><strong>代码：</strong></p><table><thead><tr><th align="left"><strong>标签</strong></th><th><strong>说明</strong></th><th><strong>标签</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">b</td><td>加粗</td><td>strong</td><td>加粗</td></tr><tr><td align="left">u</td><td>下划线</td><td>ins</td><td>下划线</td></tr><tr><td align="left">i</td><td>倾斜</td><td>em</td><td>倾斜</td></tr><tr><td align="left">s</td><td>删除线</td><td>del</td><td>删除线</td></tr></tbody></table><p>文本格式化标签主要用于让文字加粗、下划线、倾斜、删除线等效果。上述表格里第一列与第三列标签是同一含义，但是第三列标签比第一列标签表示强调的语义更为强烈。</p><h3 id="2-5-图片"><a href="#2-5-图片" class="headerlink" title="2.5 图片"></a>2.5 图片</h3><h4 id="2-5-1-图片标签"><a href="#2-5-1-图片标签" class="headerlink" title="2.5.1 图片标签"></a>2.5.1 图片标签</h4><p><strong>代码：<code>&lt;img src=&quot; &quot; alt=&quot; &quot;&gt;</code></strong></p><p>图片标签是<strong>单标签</strong>，主要用来在网页中显示图片。另外img标签如果需要展示对应的效果，需要借助<strong>标签的属性</strong>进行设置。</p><p>这里提到标签属性一词，在这里解释一下，所谓标签属性，就是用来对标签进行各种效果展示的设置。一般以 <strong>属性名</strong>&#x3D;<strong>“属性值”</strong> 的形式出现。上述img标签里的 src&#x3D;” “ 就是标签属性，src是属性名，而 “ “ 里就是属性值。</p><p>此外，对于属性我们需要注意以下5点：</p><p>  1.标签的属性写在开始标签内部</p><p>  2.标签上可以同时存在多个属性</p><p>  3.属性之间以空格隔开</p><p>  4.标签名与属性之间必须以空格隔开</p><p>  5.属性之间没有顺序之分</p><h4 id="2-5-2-图片标签的src属性"><a href="#2-5-2-图片标签的src属性" class="headerlink" title="2.5.2 图片标签的src属性"></a>2.5.2 图片标签的src属性</h4><p><strong>属性名：src</strong></p><p>src属性的属性值是目标图片的路径，主要用来在网页显示目标路径的图片。如果当前网页和目标图片在同一个文件夹中，路径直接写目标图片的名字即可，包括后缀名。（路径相关知识可参考2.6）</p><h4 id="2-5-3-图片标签的alt属性"><a href="#2-5-3-图片标签的alt属性" class="headerlink" title="2.5.3 图片标签的alt属性"></a>2.5.3 图片标签的alt属性</h4><p><strong>属性名：alt</strong></p><p>alt属性名主要用来替换文本，当网页图片加载失败时，就会显示alt文本内容，文本内容所显示的就是alt标签的属性值。</p><h4 id="2-5-4-图片标签的title属性"><a href="#2-5-4-图片标签的title属性" class="headerlink" title="2.5.4 图片标签的title属性"></a>2.5.4 图片标签的title属性</h4><p><strong>属性名：title</strong></p><p>title属性主要用来做提示文本，当鼠标悬停在图片时，会显示出title文本内容。</p><h4 id="2-5-5-图片标签的width和height属性"><a href="#2-5-5-图片标签的width和height属性" class="headerlink" title="2.5.5 图片标签的width和height属性"></a>2.5.5 图片标签的width和height属性</h4><p><strong>属性名：width、height</strong></p><p>width和height属性是用来设置图片的宽度和高度的。如果只设置width和height中的一个，另一个没设置的会自动等比例缩放；如果同时设置了width和height两个，若设置不当此时图片可能会变形。</p><h4 id="2-5-6-图片标签程序示例"><a href="#2-5-6-图片标签程序示例" class="headerlink" title="2.5.6 图片标签程序示例"></a><strong>2.5.6 图片标签程序示例</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;5.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;替换文本&quot;</span> <span class="attr">title</span>=<span class="string">&quot;提示文本&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-6-路径"><a href="#2-6-路径" class="headerlink" title="2.6 路径"></a>2.6 路径</h3><p>网页加载图片和视频等内容时，需要通过路径去寻找。而路径又分为绝对路径和相对路径。</p><h4 id="2-6-1-绝对路径"><a href="#2-6-1-绝对路径" class="headerlink" title="2.6.1 绝对路径"></a>2.6.1 绝对路径</h4><p>所谓绝对路径就是指目录下的绝对位置，可直接到达目标位置，通常是从盘符开始的路径。</p><p>例如：C:\Windows\1.png</p><h4 id="2-6-2-相对路径"><a href="#2-6-2-相对路径" class="headerlink" title="2.6.2 相对路径"></a>2.6.2 相对路径</h4><p>相对路径一般是从当前文件开始出发寻找对应目标文件的过程。相对路径也是我们常用的一种路径寻找方式。相对路径又分为三类：同级目录、下级目录、上级目录。</p><h5 id="2-6-2-1-同级目录"><a href="#2-6-2-1-同级目录" class="headerlink" title="2.6.2.1 同级目录"></a>2.6.2.1 同级目录</h5><p>同级目录：当前文件和目标文件在同一目录中。一般在程序里直接写目标文件名即可。</p><p>有两种代码书写方式：</p><p>  方法一：<code>&lt;img src=&quot;目标图片.png&quot;&gt;</code></p><p>  方法二：<code>&lt;img src=&quot;./目标图片.png&quot;&gt;</code></p><h5 id="2-6-2-2-下级目录"><a href="#2-6-2-2-下级目录" class="headerlink" title="2.6.2.2 下级目录"></a>2.6.2.2 下级目录</h5><p>下级目录：目标文件在下级目录中。一般在程序里先进入下级目录文件夹再写目标文件名。</p><p>代码书写方式：<code>&lt;img src=&quot;windows/目标图片.png&quot;&gt;</code></p><h5 id="2-6-2-3-上级目录"><a href="#2-6-2-3-上级目录" class="headerlink" title="2.6.2.3 上级目录"></a>2.6.2.3 上级目录</h5><p>上级目录：目标文件在上级目录中。写程序时先用 “..&#x2F;” 回到上级文件夹，再写目标文件。</p><p>代码书写方式：<code>&lt;img src=&quot;../目标图片.png&quot;&gt;</code></p><h4 id="2-6-3-路径的总结"><a href="#2-6-3-路径的总结" class="headerlink" title="2.6.3 路径的总结"></a>2.6.3 路径的总结</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 绝对路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;C:\Windows\5.png&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 相对路径-同级目录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;5.png&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./5.png&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 相对路径-下级目录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;文件/6.png&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 相对路径-上级目录 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../4.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-7-音频"><a href="#2-7-音频" class="headerlink" title="2.7 音频"></a>2.7 音频</h3><p><strong>代码：<code>&lt;audio src=&quot; &quot;&gt; &lt;/audio&gt;</code></strong></p><p>音频标签主要用来在页面中插入音频。</p><p>常见的<strong>音频标签属性</strong>：</p><table><thead><tr><th align="left"><strong>属性名</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td align="left">src</td><td>音频的路径</td></tr><tr><td align="left">controls</td><td>显示播放的控件</td></tr><tr><td align="left">autoplay</td><td>自动播放（部分浏览器不支持）</td></tr><tr><td align="left">loop</td><td>循环播放</td></tr></tbody></table><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;./音乐.mp3&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-8-视频"><a href="#2-8-视频" class="headerlink" title="2.8 视频"></a>2.8 视频</h3><p><strong>代码：<code>&lt;video src=&quot; &quot;&gt; &lt;/video&gt;</code></strong></p><p>视频标签主要用来在页面中插入视频。需注意视频标签仅支持MP4、WebM、Ogg三种格式。</p><p>常见的<strong>视频标签属性</strong>：</p><table><thead><tr><th align="left"><strong>属性名</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td align="left">src</td><td>视频的路径</td></tr><tr><td align="left">controls</td><td>显示播放的控件</td></tr><tr><td align="left">autoplay</td><td>自动播放（谷歌浏览器中需配合muted实现静音播放）</td></tr><tr><td align="left">loop</td><td>循环播放</td></tr></tbody></table><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;./视频.mp4&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-9-超链接"><a href="#2-9-超链接" class="headerlink" title="2.9 超链接"></a>2.9 超链接</h3><h4 id="2-9-1-超链接标签"><a href="#2-9-1-超链接标签" class="headerlink" title="2.9.1 超链接标签"></a>2.9.1 超链接标签</h4><p><strong>代码：<code>&lt;a href=&quot; &quot;&gt; &lt;/a&gt;</code></strong></p><p>超链接用来从一个页面跳转到另一个页面。一般在双标签间写上超链接名称，在href属性值里写跳转的网页地址。</p><p>程序示例：跳转csdn主页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.csdn.net/&quot;</span>&gt;</span>csdn<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-9-2-超链接标签的target属性"><a href="#2-9-2-超链接标签的target属性" class="headerlink" title="2.9.2 超链接标签的target属性"></a>2.9.2 超链接标签的target属性</h4><p><strong>属性名：target</strong></p><p>target属性是用来确定目标网页的打开形式，其属性值不同决定打开方式不同。</p><table><thead><tr><th align="left"><strong>取值</strong></th><th><strong>效果</strong></th></tr></thead><tbody><tr><td align="left">_sef</td><td>默认值，在当前窗口中跳转（覆盖原网页）</td></tr><tr><td align="left">_blank</td><td>在新窗口中跳转（保留原网页）</td></tr></tbody></table><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.csdn.net/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>csdn<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.csdn.net/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>csdn<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-10-列表"><a href="#2-10-列表" class="headerlink" title="2.10 列表"></a>2.10 列表</h3><p>列表在网页中用来按照<strong>行</strong>展示<strong>关联性</strong>的内容。比如排行榜、账单等。而列表又分为<strong>无序列表、有序列表和自定义列表</strong>三类。</p><h4 id="2-10-1-无序列表"><a href="#2-10-1-无序列表" class="headerlink" title="2.10.1 无序列表"></a>2.10.1 无序列表</h4><p>无序列表用来在网页中表示一组无顺序之分的列表，如：新闻列表。</p><p>无序列表的标签不再是单独一个标签，而是由两个标签组成：</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">ul</td><td>表示无序列表的整体，用于包裹li标签</td></tr><tr><td align="left">li</td><td>表示无序列表的每一项，用于包含每一行的内容</td></tr></tbody></table><p>显示特点：无序列表显示时，列表的每一项前默认显示圆点标识。 </p><p>程序示例（ul中只允许嵌套li标签，li标签中可以嵌套任意内容）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-10-2-有序列表"><a href="#2-10-2-有序列表" class="headerlink" title="2.10.2 有序列表"></a>2.10.2 有序列表</h4><p>有序列表用来在网页中表示一组有顺序之分的列表，如：排行榜。</p><p>有序列表的标签同样是由两个标签组成：</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">ol</td><td>表示有序列表的整体，用于包裹li标签</td></tr><tr><td align="left">li</td><td>表示有序列表的每一项，用于包含每一行的内容</td></tr></tbody></table><p>显示特点 ：有序列表显示时，列表的每一项前默认显示序号标识。</p><p>程序示例（ol中只允许嵌套li标签，li标签中可以嵌套任意内容）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一名<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二名<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-10-3-自定义列表"><a href="#2-10-3-自定义列表" class="headerlink" title="2.10.3 自定义列表"></a>2.10.3 自定义列表</h4><p>自定义列表一般用在网页底部导航处。</p><p>自定义列表由标签由三个标签组成：</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">dl</td><td>表示自定义列表的整体，用于包裹dt&#x2F;dd标签</td></tr><tr><td align="left">dt</td><td>表示自定义列表的主题</td></tr><tr><td align="left">dd</td><td>表示自定义列表的针对主题的每一项内容</td></tr></tbody></table><p>显示特点：dd前会默认显示缩进效果。</p><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>订单<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>时间<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>购买人<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-11-表格"><a href="#2-11-表格" class="headerlink" title="2.11 表格"></a>2.11 表格</h3><h4 id="2-11-1-表格标签"><a href="#2-11-1-表格标签" class="headerlink" title="2.11.1 表格标签"></a>2.11.1 表格标签</h4><p>表格用来在网页中以<strong>行+列</strong>的单元格的方式整齐展示数据。如：个人成绩单等。</p><p>表格标签：</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">table</td><td>表格整体，可用于包裹多个tr</td></tr><tr><td align="left">tr</td><td>表格每行，可用于包裹td</td></tr><tr><td align="left">td</td><td>表格单元格，可用于包裹内容</td></tr></tbody></table><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>科目<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-11-2-表格属性"><a href="#2-11-2-表格属性" class="headerlink" title="2.11.2 表格属性"></a>2.11.2 表格属性</h4><p>表格属性用来设置表格基本展示效果，实际开发多用CSS设置，这里不过多阐释。 但需注意，表格的属性要写在<table>开始标签内。</p><p>常见表格相关属性：</p><table><thead><tr><th align="left"><strong>属性名</strong></th><th><strong>属性值</strong></th><th><strong>效果</strong></th></tr></thead><tbody><tr><td align="left">border</td><td>数字</td><td>边框宽度</td></tr><tr><td align="left">width</td><td>数字</td><td>表格宽度</td></tr><tr><td align="left">height</td><td>数字</td><td>表格高度</td></tr></tbody></table><h4 id="2-11-3-表格标题和表头单元格"><a href="#2-11-3-表格标题和表头单元格" class="headerlink" title="2.11.3 表格标题和表头单元格"></a>2.11.3 表格标题和表头单元格</h4><p>表格标题和表头单元格分别用来表示整体大标题和一列小标题。</p><p>标签组成：</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">caption</td><td>表格大标题</td><td>表示表格整体大标题，默认在表格整体顶部居中位置显示</td></tr><tr><td align="left">th</td><td>表头单元格</td><td>表示一列小标题，通常用于表格第一行，默认内部文字加粗并居中显示</td></tr></tbody></table><p>注意点：caption标签写在tablet标签内部。th标签写在tr标签内部用于替换td标签。</p><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>成绩单<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>科目<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-11-4-表格的结构标签"><a href="#2-11-4-表格的结构标签" class="headerlink" title="2.11.4 表格的结构标签"></a>2.11.4 表格的结构标签</h4><p>表格结构标签主要用来对表格内容结构进行分组，突出表格的不同部分（头部、主体、底部）。同时，在程序里书写表格结构标签也方便其他程序员理解与开发。</p><p>结构标签：</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>名称</strong></th></tr></thead><tbody><tr><td align="left">thead</td><td>表格头部</td></tr><tr><td align="left">tbody</td><td>表格主题</td></tr><tr><td align="left">tfoot</td><td>表格底部</td></tr></tbody></table><p> 程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>成绩单<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>科目<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>总结<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-11-5-合并单元格"><a href="#2-11-5-合并单元格" class="headerlink" title="2.11.5 合并单元格"></a>2.11.5 合并单元格</h4><p>合并单元格用于将表格的水平或垂直的多个单元格合并成一个单元格。</p><p>合并单元格遵循左上原则，如果上下合并，则保留最上的单元格，删除其它的单元格（包括表格内数据）；如果左右合并，则保留最左的单元格，删除其它的单元格（同样包括表格数据）。</p><p>单元格合并两种属性：<strong>跨行合并</strong>和<strong>跨列合并</strong>。</p><table><thead><tr><th align="left"><strong>属性名</strong></th><th><strong>属性值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">rowspan</td><td>合并单元格的个数</td><td>跨行合并，将多行的单元格垂直合并</td></tr><tr><td align="left">colspan</td><td>合并单元格的个数</td><td>跨列合并，将多列的单元格水平合并</td></tr></tbody></table><p>注意：只有同一个结果标签中的单元格才能合并，不能跨结果标签合并。</p><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>成绩单<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>科目<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>体育<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>100分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>编程<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-12-表单"><a href="#2-12-表单" class="headerlink" title="2.12 表单"></a>2.12 表单</h3><p>表单一般应用于登录界面、注册界面和搜索栏的搭建。</p><p>表单包含5大类标签，分别是<strong>input系列标签</strong>、<strong>button按钮标签</strong>、<strong>select下拉菜单标签</strong>、<strong>textarea文本域标签</strong>和<strong>label标签</strong>。</p><h4 id="2-12-1-input标签"><a href="#2-12-1-input标签" class="headerlink" title="2.12.1 input标签"></a>2.12.1 input标签</h4><p>**代码：<code>&lt;input type=&quot; &quot;&gt;</code>  **</p><p>input标签在网页中多用于显示收集用户信息的表单效果，如：登录页、注册页等。除此以外，input标签还可以通过<strong>type属性值的不同</strong>，展示不同效果。</p><p>type属性值：</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>type属性值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">input</td><td>text</td><td>文本框，用于输入单行文本</td></tr><tr><td align="left">input</td><td>password</td><td>密码框，用于输入密码</td></tr><tr><td align="left">input</td><td>radio</td><td>单选框，用于多选一</td></tr><tr><td align="left">input</td><td>checkbox</td><td>多选框，用于多选多</td></tr><tr><td align="left">input</td><td>file</td><td>文件选择，用于之后上传文件</td></tr><tr><td align="left">input</td><td>submit</td><td>提交按钮，用于提交</td></tr><tr><td align="left">input</td><td>reset</td><td>重置按钮，用于重置</td></tr><tr><td align="left">input</td><td>button</td><td>普通按钮，默认无功能，之后配合js添加功能</td></tr></tbody></table><h5 id="2-12-1-1-input系列标签–文本框和密码框"><a href="#2-12-1-1-input系列标签–文本框和密码框" class="headerlink" title="2.12.1.1 input系列标签–文本框和密码框"></a>2.12.1.1 input系列标签–文本框和密码框</h5><p><strong>type属性值：text、password</strong></p><p>text和password标签主要用于网页中显示输入单行文本和密码的表单控件。</p><p>常用属性：</p><table><thead><tr><th align="left"><strong>属性名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">placeholder</td><td>占位符。提示用户输入内容的文本</td></tr></tbody></table><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;账号&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-12-1-2-input系列标签–单选框"><a href="#2-12-1-2-input系列标签–单选框" class="headerlink" title="2.12.1.2 input系列标签–单选框"></a>2.12.1.2 input系列标签–单选框</h5><p><strong>type属性值：radio</strong></p><p>radio主要用于网页中显示多选一的单选表单控件。例如：注册页面的性别一栏。</p><p>常用属性：</p><table><thead><tr><th align="left"><strong>属性名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">name</td><td>分组。有相同name属性值的单选框为一组，一组中同时只能有一个被选中</td></tr><tr><td align="left">checked</td><td>默认选中</td></tr></tbody></table><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">checked</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>女</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多选框的用法与单选框一致，此处就省略不写了。</p><h5 id="2-12-1-3-input系列标签–上传文件"><a href="#2-12-1-3-input系列标签–上传文件" class="headerlink" title="2.12.1.3 input系列标签–上传文件"></a>2.12.1.3 input系列标签–上传文件</h5><p><strong>type属性值：file</strong></p><p>file主要用于网页中显示文件选择的表单控件。</p><p>常用属性：</p><table><thead><tr><th align="left"><strong>属性名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">multiple</td><td>多文件选择</td></tr></tbody></table><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-12-1-4-input系列标签–按钮"><a href="#2-12-1-4-input系列标签–按钮" class="headerlink" title="2.12.1.4 input系列标签–按钮"></a>2.12.1.4 input系列标签–按钮</h5><p><strong>type属性值：submit、reset、button</strong></p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>type属性值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">input</td><td>submit</td><td>提交按钮。点击之后提交数据给后端服务器</td></tr><tr><td align="left">input</td><td>reset</td><td>重置按钮。点击之后恢复表单默认值</td></tr><tr><td align="left">input</td><td>button</td><td>普通按钮。默认无功能，之后配合js添加功能</td></tr></tbody></table><p>注意：想要实现以上按钮功能，需要配合form标签使用。将form标签作为表单域的父级，将submit和reset包含进去，，提交和重置按钮才能有效·。</p><p>补充：value属性，配合button按钮使用，value的属性值表示button按钮名。</p><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;普通按钮&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-12-2-button按钮标签"><a href="#2-12-2-button按钮标签" class="headerlink" title="2.12.2 button按钮标签"></a>2.12.2 button按钮标签</h4><p><strong>代码：<code>&lt;button&gt;&lt;/button&gt;</code></strong> </p><p>button标签主要用于网页中显示用户点击的按钮。</p><p><strong>type属性值（同input）：</strong></p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>type属性值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">button</td><td>submit</td><td>提交按钮。点击之后提交数据给后端服务器</td></tr><tr><td align="left">button</td><td>reset</td><td>重置按钮。点击之后恢复表单默认值</td></tr><tr><td align="left">button</td><td>button</td><td>普通按钮。默认无功能，之后配合js添加功能</td></tr></tbody></table><p>注意：</p><p>  button标签在谷歌浏览器中默认为提交按钮。</p><p>  button标签是双标签，更便于包裹内容，也是我们最常用的标签之一。</p><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>普通按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-12-3-select下拉菜单标签"><a href="#2-12-3-select下拉菜单标签" class="headerlink" title="2.12.3 select下拉菜单标签"></a>2.12.3 select下拉菜单标签</h4><p><strong>代码： <code>&lt;select&gt; &lt;/select&gt;</code></strong></p><p>select下拉菜单标签多用于在网页中提供多个选择项的下拉菜单表单控件。</p><p>标签组成：</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">select</td><td>下拉菜单的整体</td></tr><tr><td align="left">option</td><td>下拉菜单的每一项</td></tr></tbody></table><p><strong>常见属性：selected（下拉菜单的默认选中）</strong></p><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>星期一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>星期二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>星期三<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-12-4-textarea文本域标签"><a href="#2-12-4-textarea文本域标签" class="headerlink" title="2.12.4 textarea文本域标签"></a>2.12.4 textarea文本域标签</h4><p><strong>代码： <code>&lt;textarea cols=&quot; &quot; rows=&quot; &quot;&gt;&lt;/textarea&gt;</code></strong></p><p>textarea文本域标签多用于在网页中提供可输入多行文本的表单控件。</p><p>常见属性：</p><table><thead><tr><th align="left"><strong>属性名</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">cols</td><td>规定了文本域内可见宽度</td></tr><tr><td align="left">rows</td><td>规定了文本域内可见行数</td></tr></tbody></table><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-12-5-label标签"><a href="#2-12-5-label标签" class="headerlink" title="2.12.5 label标签"></a>2.12.5 label标签</h4><p><strong>代码：<code>&lt;label for=&quot; &quot;&gt; &lt;/label&gt;</code></strong></p><p>label标签常用于绑定内容与表单标签的关系。</p><p>label标签由两种使用方法：</p><p>第一种：使用label标签把内容包裹起来，然后在表单上添加id属性，再在label标签的for属性中设置对应的id属性值。</p><p>第二种：直接使用label标签把内容和表单标签一起包裹起来，label标签的for属性删除即可。</p><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  性别：</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-13-语义化标签"><a href="#2-13-语义化标签" class="headerlink" title="2.13 语义化标签"></a>2.13 语义化标签</h3><h4 id="2-13-1-没有语义的布局标签"><a href="#2-13-1-没有语义的布局标签" class="headerlink" title="2.13.1 没有语义的布局标签"></a>2.13.1 没有语义的布局标签</h4><p><strong>标签名：div和span</strong></p><p>div标签：一行只显示一个（独占一行）</p><p>span标签：一行可以显示多个</p><p>注意，在开发网页时，这两个标签我们会大量且频繁的使用。</p><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-13-2-有语义的布局标签（了解）"><a href="#2-13-2-有语义的布局标签（了解）" class="headerlink" title="2.13.2 有语义的布局标签（了解）"></a>2.13.2 有语义的布局标签（了解）</h4><p>在HTML5新版本中，也推出了一些有语义的布局标签供开发者使用。</p><p>标签：</p><table><thead><tr><th align="left"><strong>标签名</strong></th><th><strong>语义</strong></th></tr></thead><tbody><tr><td align="left">header</td><td>网页头部</td></tr><tr><td align="left">nav</td><td>网页导航</td></tr><tr><td align="left">footer</td><td>网页底部</td></tr><tr><td align="left">aside</td><td>网页侧边栏</td></tr><tr><td align="left">section</td><td>网页区块</td></tr><tr><td align="left">article</td><td>网页文章</td></tr></tbody></table><p>程序示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span>网页头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span>&gt;</span>网页导航<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>网页底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aside</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span>网页区块<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span>文章<span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-14-字符实体"><a href="#2-14-字符实体" class="headerlink" title="2.14 字符实体"></a>2.14 字符实体</h3><p><strong>结构：&amp;英文;</strong></p><p>字符实体就是在网页中展示特殊符号效果时，需要用字符实体代替。</p><p>常见的字符实体：</p><table><thead><tr><th align="left"><strong>显示结果</strong></th><th><strong>描述</strong></th><th><strong>实体名称</strong></th></tr></thead><tbody><tr><td align="left"></td><td>空格</td><td>&nbsp;</td></tr><tr><td align="left">&lt;</td><td>小于号</td><td>&lt;</td></tr><tr><td align="left">&gt;</td><td>大于号</td><td>&gt;</td></tr><tr><td align="left">&amp;</td><td>和</td><td>&amp;</td></tr><tr><td align="left">“</td><td>引号</td><td>&quot;</td></tr></tbody></table><p>注意：字符实体在使用时，想要在网页中显示几个字符，就要写几个字符实体。</p>]]></content>
      
      
      <categories>
          
          <category> 网页开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青春男大遇到不会写的Markdown语法</title>
      <link href="/2024/01/01/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/01/01/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="青春男大遇到不会写的Markdown语法"><a href="#青春男大遇到不会写的Markdown语法" class="headerlink" title="青春男大遇到不会写的Markdown语法"></a>青春男大遇到不会写的Markdown语法</h1><h3 id="1-文字字体设置"><a href="#1-文字字体设置" class="headerlink" title="1. 文字字体设置"></a>1. 文字字体设置</h3><p>示例：<font face="楷体">我是楷体</font></p><p>代码：<code>&lt;font face=&quot;楷体&quot;&gt;楷体&lt;/font&gt;</code></p><h3 id="2-文字大小设置"><a href="#2-文字大小设置" class="headerlink" title="2. 文字大小设置"></a>2. 文字大小设置</h3><p>示例：<font size="5px">尺寸为5px</font></p><p>代码：<code>&lt;font size=&quot;5px&quot;&gt;尺寸为5px&lt;/font&gt;</code></p><h3 id="3-文字颜色设置"><a href="#3-文字颜色设置" class="headerlink" title="3. 文字颜色设置"></a>3. 文字颜色设置</h3><p>示例：<font color="red">红色</font></p><p>代码：<code>&lt;font color=&quot;red&quot;&gt;红色&lt;/font&gt;</code></p><h3 id="4-文字上角标"><a href="#4-文字上角标" class="headerlink" title="4. 文字上角标"></a>4. 文字上角标</h3><p>示例：a<sup>i</sup></p><p>代码：<code>a&lt;sup&gt;i&lt;/sup&gt;</code></p><h3 id="5-文字下角标"><a href="#5-文字下角标" class="headerlink" title="5. 文字下角标"></a>5. 文字下角标</h3><p>示例：a<sub>i</sub></p><p>代码：<code>a&lt;sub&gt;i&lt;/sub&gt;</code></p><h3 id="6-文字下划线"><a href="#6-文字下划线" class="headerlink" title="6. 文字下划线"></a>6. 文字下划线</h3><p>示例：<u>下划线</u></p><p>代码：<code>&lt;u&gt;下划线&lt;/u&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
