<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络（四）——网络层 | 无名高手🍭</title><meta name="author" content="liujinC"><meta name="copyright" content="liujinC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="乐子人的计算机网络第四章学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络（四）——网络层">
<meta property="og:url" content="http://bandit-ljc-1.github.io/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/index.html">
<meta property="og:site_name" content="无名高手🍭">
<meta property="og:description" content="乐子人的计算机网络第四章学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://bandit-ljc-1.github.io/myphotos/article_cover/8.jpg">
<meta property="article:published_time" content="2024-04-24T09:57:00.000Z">
<meta property="article:modified_time" content="2024-05-04T10:29:00.000Z">
<meta property="article:author" content="liujinC">
<meta property="article:tag" content="408学习笔记">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://bandit-ljc-1.github.io/myphotos/article_cover/8.jpg"><link rel="shortcut icon" href="/myphotos/icon.png"><link rel="canonical" href="http://bandit-ljc-1.github.io/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络（四）——网络层',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-04 18:29:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/light.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/snow.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4451089_fok8y2foa3.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/page_style.css"><span id="fps"></span><link rel="stylesheet" href="/css/pangu_control.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="/css/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/swiper/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/css/wowjs/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/myphotos/article_cover/8.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="无名高手🍭"><span class="site-name">无名高手🍭</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络（四）——网络层</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-24T09:57:00.000Z" title="发表于 2024-04-24 17:57:00">2024-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-04T10:29:00.000Z" title="更新于 2024-05-04 18:29:00">2024-05-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络（四）——网络层"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机网络（四）——网络层"><a href="#计算机网络（四）——网络层" class="headerlink" title="计算机网络（四）——网络层"></a>计算机网络（四）——网络层</h1><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6629f3500ea9cb1403f27d8c.png" alt="计算机网络（四）——网络层——本章思维框架.png">

<p>上面是本章思维框架，在学习完本章以后，可以结合这张思维框架图，进行整体的把握与理解。</p>
<h2 id="1-网络层的功能"><a href="#1-网络层的功能" class="headerlink" title="1. 网络层的功能"></a>1. 网络层的功能</h2><h3 id="1-1-网络层的基本功能"><a href="#1-1-网络层的基本功能" class="headerlink" title="1.1 网络层的基本功能"></a>1.1 网络层的基本功能</h3><p><strong>网络层提供<font color=red>主机到主机的通信服务</font>，主要任务是将<font color=red>分组</font>从源主机经过多个网络和多段链路传输到目的主机。</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6629f3d20ea9cb1403f3b618.png" alt="计算机网络（四）——网络层——网络层的基本功能.png">

<p>网络层传输单位是<strong>数据报</strong>，注意区分数据报与分组，数据报是个比较长的数据，而分组是把这个数据报进行切割而划分出来的一个片段就叫做分组。</p>
<p><strong>网络层的功能：</strong></p>
<p><strong>功能一：路由选择与分组转发。</strong></p>
<p>路由选择就是通过路由算法找到最佳的传输路径，然后把分组按照路由顺序发送出去。</p>
<p>注意区分转发与路由选择，转发是路由器内部进行，将一组数据从接收端口转发到发送端口。而路由选择是在路由器外进行的，即在整个路由链路上找到最佳传输路径，将数据从一个路由器发送到另一个路由器。</p>
<p><strong>功能二：异构网络互联。</strong></p>
<p>异构网络互联就是指将使用不同寻址方案、网络接入机制、差错处理方法和路由选择机制等的计算机网络（即异构网络），通过一定的方法，用一种或多种通信处理设备相互连接起来，构成更大的网络系统。</p>
<p>在异构网络互联中，路由器通常用于进行网络互联和路由选择。</p>
<p><strong>功能三：拥塞控制。</strong></p>
<p>拥塞控制指所有结点都来不及接受分组，有大量分组会被丢弃，网络就处于拥塞状态。因此要采取一定措施来缓解这种拥塞。</p>
<p>这里可以看到，拥塞控制与流量控制不是一个概念，拥塞控制是一种全局性概念，是指网络中负载过重，每一结点都在非常忙碌的工作，所以导致分组转发的速率很慢，进而导致大部分分组被丢弃。而流量控制是指发送方发送速率过快，接收方接收不了，所以要告诉发送方发慢点。</p>
<p>拥塞控制有两种方法，一种静态的开环控制，一种动态的闭环控制。</p>
<p>开环控制，即网络开始工作前，就把所有能产生拥塞的因素给考虑到，然后进行预先的控制。</p>
<p>闭环控制，就是预先不去设想，当网络运行起来以后，自动调整控制。</p>
<h3 id="1-2-网络层提供的两种服务"><a href="#1-2-网络层提供的两种服务" class="headerlink" title="1.2 网络层提供的两种服务"></a>1.2 网络层提供的两种服务</h3><p>分组交换网根据其通信子网向端点系统提供的服务，还可进一步分为面向连接的虚电路服务和无连接的数据报服务。这两种服务方式都是由网络层提供。</p>
<h4 id="1-2-1-面向连接的虚电路服务"><a href="#1-2-1-面向连接的虚电路服务" class="headerlink" title="1.2.1 面向连接的虚电路服务"></a>1.2.1 面向连接的虚电路服务</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6629f87e0ea9cb1403fe7405.png" alt="计算机网络（四）——网络层——面向连接的虚电路服务.png">

<h4 id="1-2-2-无连接的数据报服务"><a href="#1-2-2-无连接的数据报服务" class="headerlink" title="1.2.2 无连接的数据报服务"></a>1.2.2 无连接的数据报服务</h4><p>因特网的先驱者并没有采用面向连接的虚电路服务而是采用了无连接的数据报服务。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6629f8e60ea9cb1403ff40af.png" alt="计算机网络（四）——网络层——无连接的数据报服务.png">

<h4 id="1-2-3-两种服务对比"><a href="#1-2-3-两种服务对比" class="headerlink" title="1.2.3 两种服务对比"></a>1.2.3 两种服务对比</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6629f90c0ea9cb1403ffb6b9.png" alt="计算机网络（四）——网络层——网络层服务对比.png">

<h3 id="1-3-SDN基本概念"><a href="#1-3-SDN基本概念" class="headerlink" title="1.3 SDN基本概念"></a>1.3 SDN基本概念</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6629fabe0ea9cb140303b76b.png" alt="计算机网络（四）——网络层——数据平面&控制平面.png">

<p><strong>网络层的主要任务是<font color=red>转发和路由选择</font>。</strong></p>
<p>可以将网络层抽象地划分为数据平面（也称转发层面）和控制平面，转发是数据平面实现的功能，而路由选择是控制平面实现的功能。</p>
<p>数据平面主要用于数据处理和转发，只在一个路由器内部进行，所以时间短，通常用硬件解决。</p>
<p>控制平面主要用于控制和管理网络协议，通常在网络上运行，需要时间长，通常采用软件解决。</p>
<p><strong>接下里详细的看一下数据平面和控制平面：</strong></p>
<h4 id="1-3-1-数据平面"><a href="#1-3-1-数据平面" class="headerlink" title="1.3.1 数据平面"></a>1.3.1 数据平面</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6629fbab0ea9cb140305d45f.png" alt="计算机网络（四）——网络层——数据平面.png">

<p>数据平面就是一个单纯的搬运工，只需要根据转发表将数据转发即可。所以数据平面实现在路由器里，每一个路由器都有一个数据平面。</p>
<p>但数据平面执行的转发功能非常频繁，因为网络上数据只要一传输，经过路由器时就会有转发的过程。</p>
<h4 id="1-3-2-控制平面"><a href="#1-3-2-控制平面" class="headerlink" title="1.3.2 控制平面"></a>1.3.2 控制平面</h4><p>控制平面有两种实现方法：传统方法（也称每路由器法）和SDN法。</p>
<p><strong>传统方法：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6629fd530ea9cb140309df97.png" alt="计算机网络（四）——网络层——控制平面（传统方法）.png">

<p>传统方法中，每一个路由器既能进行路由选择也能进行转发。所以，传统方法会把路由选择和数据转发集成在每一个路由器当中。</p>
<p>具体来说，传统方法实现的控制平面是一个路由器中的选择算法与其他路由器中的路由选择算法通信，进而计算出路由表和转发表。</p>
<p>综合来说，传统方法中，控制平面和数据平面是在一个路由器内进行的。数据平面充当搬运工，控制平面计算转发表。</p>
<p><strong>SDN方法：</strong></p>
<p>SDN即软件定义网络是近年流行的一种创新网络架构，它采用集中式的控制平面和分布式的数据平面，两个平面相互分离，控制平面利用控制-数据接口对数据平面上的路由器进行集中控制，方便软件来控制网络。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662a07ad0ea9cb140325bc27.png" alt="计算机网络（四）——网络层——控制平面（SDN方法）.png">

<p>如上是SDN方法，数据平面和传统方法一样，但是控制平面却差异巨大。</p>
<p>在SDN方法中，路由器只需要执行转发功能，路由选择功能开始由远程控制器计算并分发转发表以供每台路由器使用。所以远程控制器相当于路由器真正的”大脑”。</p>
<p>远程控制器计算转发表以及和路由器通信全都是通过软件实现的，而且是可编程的软件实现，所以把SDN方法称为软件定义网络。</p>
<h4 id="1-3-3-控制平面中的路由选择处理器"><a href="#1-3-3-控制平面中的路由选择处理器" class="headerlink" title="1.3.3 控制平面中的路由选择处理器"></a>1.3.3 控制平面中的路由选择处理器</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662a096a0ea9cb14032a2705.png" alt="计算机网络（四）——网络层——控制平面的路由选择处理器.png">

<p>在路由器里，会有这么一个模块叫路由选择处理器。</p>
<p>在传统方法中，路由选择处理器用来执行平面控制的功能，即进行路由选择和维护路由选择表并计算转发表等功能。</p>
<p>但是在SDN方法里，控制平面的功能由远程控制器执行，路由选择处理器的事情被远程控制器抢了，路由选择处理器就要进行别的工作，所以在SDN方法里，路由选择处理负责与远程控制器通信，来接收转发表和路由选择相关信息。</p>
<h4 id="1-3-4-SDN控制平面"><a href="#1-3-4-SDN控制平面" class="headerlink" title="1.3.4 SDN控制平面"></a>1.3.4 SDN控制平面</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662a0af20ea9cb14032deff9.png" alt="计算机网络（四）——网络层——SDN控制平面.png">

<p>SDN的控制平面分成SDN控制器和网络控制应用程序两部分。</p>
<p>SDN控制器主要维护准确的网络状态信息，并能将这些信息采集传输到网络控制应用程序。（上图里有表述不恰当的地方，上面所有的交换机都应该换成路由器，这里说交换机是想指路由器的）</p>
<p>网络控制应用程序是控制平面真正的大脑，他可以将SDN控制器采集来的信息进行计算，从而得到转发表和路由选择等信息。</p>
<p>另外，SDN的可编程性通过为开发者提供强大的编程接口，使得网络具有很好的编程性。对上层应用的开发者，SDN提供的编程接口称为北向接口；SDN控制器和转发设备建立双向会话的接口称为南向接口；SDN控制器集群内部控制器之间的通信接口称为东西向接口。</p>
<h4 id="1-3-4-SDN控制器的三个层次"><a href="#1-3-4-SDN控制器的三个层次" class="headerlink" title="1.3.4 SDN控制器的三个层次"></a>1.3.4 SDN控制器的三个层次</h4><p>进一步探索SDN控制平面，可以将SDN控制器继续分为网络控制应用程序的接口、网络范围状态管理层、通信层。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662a0dc70ea9cb140335256c.png" alt="计算机网络（四）——网络层——SDN控制器的三个层次.png">

<p>从上图可以看到，网络控制管理的真正实施者是网络范围状态管理层。</p>
<p>这里可能会把SDN控制器跟网络控制应用程序的功能出现混淆，所以，我查了点资料，在这里做个辨析。</p>
<p>在SDN（软件定义网络）架构中，网络控制应用程序和SDN控制器各自扮演着不同的角色，但它们共同协作以实现网络的集中控制和管理。</p>
<p>网络控制应用程序是基于SDN控制器的应用程序，它们负责实现各种网络服务，比如负载均衡、流量控制、安全管理等。这些应用程序可以基于特定的算法来制定策略，如流量调度算法、安全过滤规则等，以优化网络性能和保障网络安全。</p>
<p>而SDN控制器是整个SDN架构的核心，它负责管理和控制整个网络。它通过与网络设备进行通信，实现对网络设备的集中化配置、监控和管理。SDN控制器根据网络控制应用程序提供的策略或指令，执行具体的控制操作，如转发决策、流量调度、安全策略实施等。因此，可以说SDN控制器是真正的控制实施者。</p>
<p>综上所述，网络控制应用程序和SDN控制器在SDN架构中各有分工，前者负责提供策略或算法，后者负责执行具体的控制操作。它们相互协作，共同实现网络的集中控制和管理。</p>
<h2 id="2-IPv4"><a href="#2-IPv4" class="headerlink" title="2. IPv4"></a>2. IPv4</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662a10670ea9cb14033ae8b9.png" alt="计算机网络（四）——网络层——TCP-IP协议栈.png">

<p>首先看下TCP&#x2F;IP协议栈的构造，网络层协议主要是ARP、IP、ICMP、IGMP四个。</p>
<p>从图中不难看出，ARP在最下面，所以ARP要为IP协议服务，而ICMP和IGMP在上面，所以IP协议要为这两个协议服务。而IP协议占领大部分地方，说明IP协议在该层有着举足轻重的作用。</p>
<h3 id="2-1-IP数据报"><a href="#2-1-IP数据报" class="headerlink" title="2.1 IP数据报"></a>2.1 IP数据报</h3><h4 id="2-1-1-IP数据报格式"><a href="#2-1-1-IP数据报格式" class="headerlink" title="2.1.1 IP数据报格式"></a>2.1.1 IP数据报格式</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662a11b00ea9cb14033d640c.png" alt="计算机网络（四）——网络层——IP数据报.png">

<p>IP数据报由首部和数据部分组成，数据部分是从传输层交付下来的，在本章不考虑。首部是在网络层添加的，由固定部分和可变部分组成，其中固定部分是每个IP数据报都要有的东西，而可变部分可有可无。</p>
<p>值得一提的是，在网络层IP数据报和分组是不用太区分的，可以暂时把这两个当成一样的东西，但是要清楚的是，他们两个还是有一定区别的。如果IP数据报过大，就会对其进行分片，而分片下来的小单位就是网络层的传输单元，即分组。</p>
<p>接下来看一下首部具体有哪些字段：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662a12f60ea9cb1403400d8b.png" alt="计算机网络（四）——网络层——IP数据报各部分字段.png">

<p>这里我检重点说一下，从上图可以看到，IP数据报的固定部分有五个存储行，每个存储行都是32bit，所以固定部分一共占32bit×5&#x3D;160bit&#x3D;20B的存储空间。而可变部分长度不固定，但是只能在0~40B的范围内。</p>
<p>首部长度字段内，记录当前首部有多长，单位是4B且最小为5，这个限制可能会无法理解。其实4B就是IP首部的一行，说白了IP首部以存储行为单位，每一行32bit即4B，因为前5行是固定部分，每一个IP数据报都要有，所以首部长度是固定20B，即5行，所以最小为5，单位是4B。另外，首部字段使用4个bit来表示首部长度，也就是说首部字段取值范围是0101<del>1111，这就表明IP数据报首部长度的范围是5×4B</del>15×4B，即20B<del>60B，这也解释了为什么可变部分长度是0</del>40B。根据这种方式，我们也可以通过首部长度字段的数值计算出该IP数据报首部多长，进而可以求出可变部分的长度。</p>
<p>上面的几个点是我觉得比较重要的，剩下的，我感觉就需要个人去记忆了。</p>
<h4 id="2-1-2-IP数据报分片"><a href="#2-1-2-IP数据报分片" class="headerlink" title="2.1.2 IP数据报分片"></a>2.1.2 IP数据报分片</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c89610ea9cb140318a538.png" alt="计算机网络（四）——网络层——MTU.png">

<p>首先回顾一下最大传送单元的概念，在链路层中每一个数据帧都有一个最大可封装数据的上限，这个上限就是MTU，像以太网的MTU就是1500B。</p>
<p>如上图，IP分组下送到链路层，经数据链路层封装，在IP分组前添加帧头和帧尾，在这里，IP分组就构成了数据链路层的数据封装部分，这部分数据是有上限的，上限就是该数据链路层的MTU，如果一个IP分组超出了数据链路层可封装数据的上限，就要分片。</p>
<p>需要注意，IP分组的分片是要看IP分组允不允许被分片，如果不允许，则IP分组是无法往下传递，因此会返回一个ICMP差错报文（ICMP在后面讲）。</p>
<p>接下来看一下可以分片的IP数据报是如何分片的：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c8b340ea9cb14031c6e96.png" alt="计算机网络（四）——网络层——IP分片.png">

<p>在2.1.1里，介绍IP数据报格式的时候，没有介绍标识、标志和片偏移三个字段的作用，这部分来介绍一下，这三个字段是用来做IP数据报分片标记的。</p>
<p>在介绍这三个字段之前，首先要明确一点，IP分片的结构，当IP数据报过长时，会按一定规则把IP数据报的数据部分进行分片处理，即将一组数据数据部分分成几组。被分出来的组，每一组都会添加一个IP首部，构成一个IP数据报，然后将这些IP数据报发送出去。举个例子，我要发送一组IP数据报过长，就将其分数据部分成三组，每一组都要添加一个IP首部，所以发出去的是三组IP数据报。</p>
<p>接收方是如何根据自己接收到的多组IP数据报来确定自己接收的是一个完整的，还是分片后的，又或者接收到哪里才算接收完一组IP数据报的呢？这就跟标识、标志和片偏移三个字段有关。</p>
<p>标识：同一数据报的分片使用同一标识。接收方可根据标识来确定分片属于哪一个数据报。</p>
<p>标志：标志有三位，但只有后两位有用，中间位是DF，DF&#x3D;1表示该数据报不允许被分片，DF&#x3D;0，则表示该数据报允许被分片。最低位是MF，MF&#x3D;1，表示后面还有分片；MF&#x3D;0，表示后面没有分片。不难看出，当DF&#x3D;1时，就不需要管MF。 </p>
<p>片偏移：指出较长分组分片后，某片在原分组中的相对位置，以<font color=red><strong>8B</strong></font>为单位。接收方根据片偏移来复原原数据报。</p>
<p>有了三个标记字段，接收方就可以将接收到的多个IP数据报分组进行分类复原，得到正确的数据。</p>
<p>这里要注意一点，在片偏移里，单位是8B，如果题目中给出了数据长是多少B，还要除8才可得到正确的片偏移量。</p>
<p>为了加深理解，下面贴一道例题：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c90230ea9cb1403272abc.png" alt="计算机网络（四）——网络层——IP分片例题.png">

<p>可以发现，在IP首部里，每个字段的单位是非常重要的，都是考试时易错的点，这里再汇总一下：</p>
<ol>
<li>总长度单位是1B。</li>
<li>片偏移单位是8B。</li>
<li>首部长度单位是4B。</li>
</ol>
<h3 id="2-2-IPV4地址与NAT"><a href="#2-2-IPV4地址与NAT" class="headerlink" title="2.2 IPV4地址与NAT"></a>2.2 IPV4地址与NAT</h3><h4 id="2-2-1-IPV4地址"><a href="#2-2-1-IPV4地址" class="headerlink" title="2.2.1 IPV4地址"></a>2.2.1 IPV4地址</h4><p>IP地址是给互联网上的每台主机（或路由器）的每个接口分配的一个在全球范围内唯一的32位表示符。IP地址由互联网名字和数字分配机构ICANN进行分配。</p>
<p>互联网早期采用分类的IP地址，分类如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c933b0ea9cb14032d45cd.png" alt="计算机网络（四）——网络层——IP分类.png">

<p>上图展示了IP地址的分类编制，可以看到不论是哪类IP地址，都由网络号和主机号两部分组成。上图右显示着注意事项，这些注意事项展示了一些特殊的IP地址，可以参考下面的图。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c93d90ea9cb14032e88c8.png" alt="计算机网络（四）——网络层——特殊IP地址.png">

<p>下面，分类看一下常考的A、B、C三类IP地址。</p>
<p><strong>（1）A类IP地址</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c94710ea9cb1403315fb9.png" alt="计算机网络（四）——网络层——A类IP地址.png">

<p><strong>（2）B类IP地址</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c94aa0ea9cb14033251d4.png" alt="计算机网络（四）——网络层——B类IP地址.png">

<p><strong>（3）C类地址</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c94cf0ea9cb140332ace2.png" alt="计算机网络（四）——网络层——C类IP地址.png">

<p>发现两道知识点考的比较全的例题，拿捏不了，建议进厂：</p>
<p><strong>例题1：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c950b0ea9cb14033336a7.png" alt="计算机网络（四）——网络层——例题1.png">

<p><strong>例题2：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662c958a0ea9cb140334663e.png" alt="计算机网络（四）——网络层——例题2.png">

<h4 id="2-2-2-网络地址转换NAT"><a href="#2-2-2-网络地址转换NAT" class="headerlink" title="2.2.2 网络地址转换NAT"></a>2.2.2 网络地址转换NAT</h4><p>上面在2.2.1里讲的IP地址分类，其中A类中的10.0.0.0～10.255.255.255，B类中的172.16.0.0～172.31.255.255以及C类中的192.168.0.0～192.168.255.255都属于私有地址，这些IP地址之所以叫私有IP是因为它们只能在本地网络、专用网络使用，而在大的互联网、广域网当中，路由器及其它主机是无法识别这些IP地址的，即<font color=red><strong>路由器对目的地址是私有IP地址的数据报一律不进行转发</strong></font>。</p>
<p><strong>私有网络要想与因特网进行外部通信就需要借助网络地址转换技术</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662ca2a70ea9cb14035327ac.png" alt="计算机网络（四）——网络层——NAT.png">

<p>实现这种网络地址转换技术的方式很简单，只需要在专用网和因特网之间的路由器上安装NAT软件，安装NAT软件的路由器就变声为NAT路由器。这个路由器至少有一个有效的外部全球IP地址，当然也可以有多个。所有使用本地地址的主机和外部进行通信时，都需要经过NAT路由器的地址转换。</p>
<p>下面结合上图以一个具体的示例，来讲解网络地址转换过程。如上图假设有两台主机A、C。A的IP地址为192.168.0.3，C的IP地址为192.168.0.4。他们俩都处在专用网络192.168.0.0上。在专用网络与因特网之间有一个NAT路由器，其全球IP地址为172.38.1.5，这就是专用网络的代表地址。专用网络上的主机想要与因特网通信，都要借助NAT的全球IP地址作为自己的伪装，用这个地方和外部进行通信。外部网络的主机要想和本地主机通信，也需要把数据发到代表地址上，即发到全球IP地址，再由代表地址分发给专用网络主机。</p>
<p>实现上述过程的关键就是NAT路由器有一个NAT转换表（如图），转换表分为两列，一列是广域网段，一列是局域网段。每一列信息都包含两段，一段是点分十进制（即IP），另一端是端口号（端口号的概念会在传输层里学，端口号是用来唯一标识主机中的某一进程，在同一主不同进程的端口不同，不同主机的不同进程端口号可能相同）。</p>
<p>在上图，若现在A主机向B发送一数据报，在传输层先添加端口号，然后在网络层处要封装原IP和目的IP。该数据报到NAT路由器处就会实现网络地址转换，具体转换过程就是NAT路由器根据转换表，将源主机IP和端口号替换成对外的全球IP和端口号，如上图A发送的数据报源IP和端口号若为1982.168.0.3:30000，则NAT路由器会将其替换成172.38.1.5:40001，该组数据报到达B端可以被顺利接收。</p>
<p>若现在B主机向C主机发送数据，同A向B发送一样，也有源IP和目的IP和端口号。但是在A向B处，在目的IP写的是B的IP，而在B向C处，目的地址里写的不是C的IP，而是NAT路由器的IP。NAT路由器接收到B的数据报，根据转换表，将目的IP和端口号，替换成内部专用网络的IP和端口号。例如B发送到C数据写的目的IP和端口号位172.38.1.5:40002，NAT路由器会根据转发表将其转换成192.168.0.4:30001，然后将数据发送到C主机。</p>
<h3 id="2-3-划分子网与路由集合"><a href="#2-3-划分子网与路由集合" class="headerlink" title="2.3 划分子网与路由集合"></a>2.3 划分子网与路由集合</h3><h4 id="2-3-1-划分子网"><a href="#2-3-1-划分子网" class="headerlink" title="2.3.1 划分子网"></a>2.3.1 划分子网</h4><p>前面所说的A、B、C类IP地址存在一些弱点。首先，他们的IP地址空间的利用率有时很低，例如一个小公司使用C类网络就可以够用，但公司出于对未来扩充的考虑，所以会申请B类网络，这就导致有很多地址空间被浪费。其次，对于将IP地址划分为网络号和主机号这样的两级IP地址，其不够灵活，比如还是那个小公司，他想在另一个地点马上开通一个新的网络，但是在开通前，要先跟ISP（因特网服务供应商）申请一系列新的IP地址网络号。</p>
<p>所以为了避免IP空间被浪费，还能随时随地增加自己的网络而不用跟ISP申请新的网络号，就产生了子网划分的方法。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cab6f0ea9cb1403666d10.png" alt="计算机网络（四）——网络层——子网划分.png">

<p>上面就是子网划分的结构，在两级IP地址上，将主机号划分为子网号和主机号，进而形成了一个三年级IP地址，而子网号多少位，都是可以由公司自己定。</p>
<p>根据子网划分就可以看出，网络号表示网络段，而子网号就是在这个网络段上再划分几片区域，主机号则是在区域上的主机标志。用个很贴切的例子来描述就是，使用两级IP地址，就是一个公司直接记录所有员工信息；而使用三级IP地址（子网划分），就是一个公司分成几个部门，几个部门分别记录员工信息。</p>
<p><font color=green><strong>注意，子网划分以后，对外仍表现原网络号，即外部看不到内部的子网划分。另外，由于主机号全0全1是没有意义的，所以主机号至少要留2位。</strong></font></p>
<p>题目中还可能会考察子网和主机能不能全0和全1，对于子网号来说，能否全0或全1是要看具体情况的，在最开始时子网是不能全0和全1的，但随着CIDR技术的广泛应用，全0和全1也是可以的，所以要根据题目来解题。主机号就显而易见的不能全0或全1。</p>
<p>接下来用一个例子介绍子网划分和数据传输。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cae6e0ea9cb14036ca1bd.png" alt="计算机网络（四）——网络层——子网划分过程.png">

<p>如上图，假设某单位申请到一个B类地址号145.13.0.0分配到上图的路由器上，现在所有想到达该网络段的数据，都要经过该路由器。从图中可以看到，该单位划分三个子网，假设子网号占8位，则主机号也占8位。即使划分子网，但对外展示的仍然是一个网络145.13.0.0。假设现在有一个数据报，其目的地址是145.13.3.10，但是它是从外部来的，只知道发给路由器，那么该如何传到主机呢？</p>
<p>这就要先说一下子网掩码：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cb0710ea9cb1403713c62.png" alt="计算机网络（四）——网络层——子网掩码.png">

<p>子网掩码是一个与IP地址相对应的二进制串，由一串1和一串0组成，1对应网络号和子网号、0对应主机号。主机和路由器只需将IP地址和其对应子网掩码逐位相与即可得到相应子网的网络地址。</p>
<p>本例中，路由器根据数据报的目的IP地址，与子网掩码相与，就可以得到该发送哪个子网，先把数据报发到对应子网，进而发到对应主机上。</p>
<p>现在要考虑一下，从外部来的分组，通过路由器，应该怎么转发，怎么利用子网掩码，才能把数据报正确的送到子网内对应的主机上呢？结合下图，来介绍一下使用子网划分以后，分组转发的过程。</p>
<p><strong>（这部分内容结合王道25书的147页4.2.4 网络层转发分组的过程）</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cb6f10ea9cb1403810830.png" alt="计算机网络（四）——网络层——子网划分以后分组转发.png">

<p>这里讲一个前提条件，对于每个路由器都有一个转发表，如果划分了子网，这个路由表里就会包含以下三项，第一个是目的网络地址；第二个是目的网络子网掩码；第三个是下一跳地址，下一跳指的是接下来走哪个接口。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cb6f10ea9cb1403810830.png">

<p>如果来了一个外部分组，路由器会提取目的IP地址，然后再判断是否可直接交付（直接交付就是路由器可以直接把这组数据给到当前所连的子网，而间接交付则是当前路由器没有该目的地址，要转到下一个路由器，也有可能要转很多路由器才能到目的主机），就像上面的例子，路由器通过目的地址与子网掩码相与，得到了子网号，发现是自己所连的，就可以直接交付。</p>
<p>若路由发现相与得出的子网在与自己相连的网段内没有匹配的，就会检查特定主机路由，所谓特定主机路由，就是一些特殊的IP地址。若有匹配的可直接发送。</p>
<p>若检查特定主机路由仍没有发现匹配的，就会检查路由表当中有没有合适的路径，即使用目的地址和路由表当中的每一行子网掩码进行相与，查看有没有匹配的目的网络，若有匹配的，就按照那一行的下一跳地址进行转发。</p>
<p>若仍没有发现匹配的，则把分组交给默认路由0.0.0.0，默认路由会把分组交给另一个路由器，然后循环上面的步骤，若找到则直接发送，若仍没有找到，则返还给默认路由，默认路由再转发给另外的路由器。若经过来回转发，达到生存时间仍没有找到，就会丢弃该分组，再报告分组出错。</p>
<h4 id="2-3-2-无分类编制CIDR"><a href="#2-3-2-无分类编制CIDR" class="headerlink" title="2.3.2 无分类编制CIDR"></a>2.3.2 无分类编制CIDR</h4><p>早期B类地址由于性价比的超高性，很快就被分配完毕。另外伴随着网络普及，越来越多设备加入互联网，所以路由表中的项目急剧增长，对于一个庞大路由表很难维护，所以人们就发明了无分类编址形式CIDR。</p>
<p>CIDR在子网划分的启发下，将网络号和子网号划分到一起，称为网络前缀，再次回到二级IP地址的形式，看似与之前的二级地址一样，但这个网络前缀是可变长的，所以CIDR可以很灵活的调整网络前缀长度以及主机号长度。</p>
<p>下图是CIDR相关基础概念：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cb8d60ea9cb1403855afc.png" alt="计算机网络（四）——网络层——CIDR.png">

<p>如果想表示一个IP的网络前缀，只需在IP地址后加上”&#x2F;“然后写上数字即可，数字表示网络前缀所占位数。</p>
<p>对于网络前缀相同的连续的IP地址称为一个”CIDR地址块”。</p>
<p>主机号全0和全1对应这个地址块的最小地址和最大地址。</p>
<p>CIDR若想接着进行网络划分，只需要从主机号里取几位放到网络前缀里即可。</p>
<p>下面看一下CIDR的两个重要应用：</p>
<p><strong>(1) 构成超网</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cbddc0ea9cb1403906a7b.png" alt="计算机网络（四）——网络层——构成超网.png">

<p>将多个子网聚合成一个较大的子网，叫做构成超网，或路由聚合。</p>
<p>如上图，有路由器R1和R2，R2连接两个网络。R1路由器维护一个路由表，路由表里包含两个主要信息目的网络和要传递数据到这个目的网络所要走的接口。到网络1和网络2都要走接口a，这样两个目的网络信息就占了两行，如果还有别的网络信息，那路由表就会向下扩充，当表过长，路由器就不太好维护。这时候就会采用路由聚合方式缩短路由表长。</p>
<p>路由聚合的方法就是网络地址取交集，本质上就是缩短网络前缀。</p>
<p>如上图，网络1:206.1.0.0&#x2F;17和网络2:206.1.128.0&#x2F;17的前16位相同，从第17位开始出现差异，所以取交集就是取前16位，而从第17位到32位都写成0，最后得到的网络合体就是206.1.0.0&#x2F;16。</p>
<p>到这里不难发现，划分子网是一个由少到多的过程。而构成超网则是由多到少的过程。</p>
<p><strong>(2) 最长前缀匹配</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cc48d0ea9cb1403a10de0.png" alt="计算机网络（四）——网络层——最长前缀匹配.png">

<p>使用CIDR时，查找路由表，将目的地址与网络掩码相与运算，得到的结果与网络号匹配时，可能会出现几个匹配成功的结果，这时候要取前缀长的路由。、</p>
<p>至于为什么这么做，说下我的理解，这里基于CIDR的网络前缀，给我的感觉就是子网划分层级的问题。说白了就是一个公司分配了一个网络，其中网络前缀占16位，主机号占16位。但是在此基础上，公司从主机号里取两位用来划分部门，所以对于部门来说，网络前缀就有18位，主机号只有14位。而部门又从主机号里取两位来划分小组，则对于小组来说，网络前缀有20位，主机号有12位，层层向下，那越向下，他的网络前缀就越长。这个时候，若有一组数据要发送到该公司1号部门的1号小组内，那这数组据要想顺利分到位，他肯定要经过公司、部门、小组三个网络号，也就意味着，这组数据的目的地址与公司网络掩码、部门网络掩码相和小组网络掩码相与运算以后，进行匹配操作时，肯定是匹配成功，这时候要发到位，肯定是发到组里，由于组的级别在最低级，所以，要选网络前缀最长的那个。</p>
<p>下面给道例题：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cc8d80ea9cb1403a9d3f0.png" alt="计算机网络（四）——网络层——最长前缀匹配例题.png">

<p>这道题通过计算可以知道，A、B都能匹配成功，所以要选网络前缀最长的，所以本题答案为B。</p>
<p>另外，注意一下D选项，D是默认路由，如果目的网络里没有任何网络可以匹配，这时候就要走默认路由。所以如果题目里A、B、C都不匹配，就要选D走默认路由。</p>
<h3 id="2-4-地址解析协议（ARP）"><a href="#2-4-地址解析协议（ARP）" class="headerlink" title="2.4 地址解析协议（ARP）"></a>2.4 地址解析协议（ARP）</h3><p>网络网络层使用什么协议，在实际网络的连路上传送数据帧时，最终必须使用硬件地址。所以需要一种方法来完成IP地址到MAC地址的映射，这就是地址解析协议（ARP）。</p>
<p>由于每个主机都有一个ARP高速缓存区，里面存储IP地址与MAC地址的映射。但这个高速缓存，存储的表项都是局域网内部的。所以接下来，根据数发送是否在同一个网段内来进行ARP的协议的介绍。</p>
<p><strong>(1) 在同一网段内</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cd3e50ea9cb1403c5acdd.png" alt="计算机网络（四）——网络层——同一网络内ARP.png">

<p>如上图，主机1发送文件到同一网段内的主机3，如果文件比较大，在传输层先分段。网络层先取其中一个分段1进行封装，添加IP1和IP3来分别表示源地址和目的地址（目的地址在传输层可以根据DNS获得，具体内容在传输层介绍）。假设网络层的数据报不大于MTU，其在链路层不需要分片。该IP数据报在链路层封装成帧，要在帧头添加源MAC地址（即MAC1）和目的MAC地址（即MAC3），由于在同一个网络内，所以可以直接在主机1的ARP高速缓存里查找到主机3的MAC地址。在帧尾一般添加FCS检验序列。</p>
<p>如果在ARP高速缓存里未发现主机3的MAC地址，就要广播一个ARP分组请求，如上图右下，目的地址里写全F，代表在局域网内一个有广播效应的帧（这个帧的意思就是：我的IP是IP1，我想给IP3的主机发送信息，我的物理地址是MAC1，3号主机你的物理地址MAC3是多少）。该分组从主机发出，经过集线器到交换机，交换机一般不会随意转发分组，但若是一个广播分组，便会从交换机的所有端口转发出去，2号、3号和路由器的接口都会收到这个分组。由于分组是发给3号的，所以只有3号会响应，这时3号主机返回一个单播ARP响应分组，这个分组只包含两部分，即3号主机的IP地址和物理地址（意思是：我的IP是多少，我的MAC是多少）。1号主机根据3号主机的反馈，将MAC3写入帧里再封装加尾部就构成链路层的传输单元，进而可以放到物理层进行传输。</p>
<p><strong>(2) 不在同一网络内</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cd9a90ea9cb1403d18e76.png" alt="计算机网络（四）——网络层——不在同一网络内ARP.png">

<p>还是这个链路，现在1号主机要和5号主机通信，主机1的ARP只映射了本局域网内的主机IP和MAC地址，所以肯定查不到5号主机的MAC。这时候1号主机会用子网掩码和IP5先相与，发现不在同一个网段内，这时候1号主机就会查询自己与外界沟通所经过的路由器的地址，即查询默认网关，然后在目的物理地址处添加默认网关的地址。</p>
<p>主机1使用ARP协议，即发送广播ARP分组，获得默认网关的物理地址MAC6，然后将数据发送到默认网关处，路由器从MAC6接口收到数据，要从MAC7转发出去，同样使用ARP协议获得与之相连的路由接口的MAC地址MAC8，然后将分组的原物理地址和目的物理地址改称MAC7和MAC8，路由器2从MAC9转发出去，路由器查找到了IP为IP5的5号主机，然后使用ARP协议获得5号主机的MAC地址MAC5，然后把数据传输到5号主机，到此，实现了1号主机和5号主机的通信。</p>
<p>注意，上图中两个路由器是点对点连接，所以可以使用PPP协议，将目的物理地址MAC8改成全1也可以。</p>
<p><strong>ARP协议的小结：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662cdb080ea9cb1403d5fcdc.png" alt="计算机网络（四）——网络层——ARP小结.png">

<p>ARP协议是自动进行的，主机的用户对于这种地址解析的过程是完全不知道的，要是这个主机和路由器跟其他主机进行通信的话，ARP会自动完成这个地址解析过程，然后数据就可以在链路上传输。</p>
<h3 id="2-5-DHCP协议（动态主机配置协议）"><a href="#2-5-DHCP协议（动态主机配置协议）" class="headerlink" title="2.5 DHCP协议（动态主机配置协议）"></a>2.5 DHCP协议（动态主机配置协议）</h3><p>我们都知道，主机在进行通信时，需要具备一个IP地址，那主机是如何获得IP地址的呢？有两种方法，一种是静态配置，一种是动态配置。</p>
<p>静态配置IP，也称为静态IP地址或固定IP地址，是长期分配给一台计算机或网络设备使用的IP地址。这种地址是由网络管理员手动配置并固定分配给特定设备的，不会随着网络状态的变化而改变。像学校的机房，每台设备的位置都固定了，就可以采用静态IP的方式分配IP地址。</p>
<p>动态配置IP，就是这部分要说的DHCP协议，采用DHCP服务器，动态的为主机分配IP。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662e285f0ea9cb140372759f.png" alt="计算机网络（四）——网络层——DHCP.png">

<p>DHCP服务器和DHCP客户（IP申请方）的交换过程：</p>
<ol>
<li>DHCP客户广播”DHCP发现”消息，试图找到网络中的DHCP服务器，以便从DHCP服务器获得一个IP地址。</li>
<li>DHCP服务器收到”DHCP发现”消息后，广播“DHCP提供”消息，其中包括提供给DHCP客户机的IP地址。</li>
<li>DHCP客户收到“DHCP提供”消息，若接受该IP地址，则广播”DHCP请求”消息向DHCP服务器请求提供IP地址。</li>
<li>DHCP服务器广播“DHCP”确认消息，将IP地址分配给DHCP客户。</li>
</ol>
<h3 id="2-6-ICMP协议（网际控制报文协议）"><a href="#2-6-ICMP协议（网际控制报文协议）" class="headerlink" title="2.6 ICMP协议（网际控制报文协议）"></a>2.6 ICMP协议（网际控制报文协议）</h3><h4 id="2-6-1-ICMP报文结构"><a href="#2-6-1-ICMP报文结构" class="headerlink" title="2.6.1 ICMP报文结构"></a>2.6.1 ICMP报文结构</h4><p>为了有效地转发IP数据报和提高交付成功的机会，在网络层使用了网际控制报文协议(ICMP)，让主机或路由器报告差错和异常情况。</p>
<p>首先看下ICMP结构：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662e29fe0ea9cb140375d0fb.png" alt="计算机网络（四）——网络层——ICMP.png">

<p>ICMP协议，支持主机或路由器实现一个差错或异常的报告以及网络的探询，因为在实际过程中，总会有一些分组出错，对于出错的分组，在网络层的处理就是将其丢弃掉，但是仅丢弃不行，还要发送一个ICMP的差错报告报文。</p>
<p>根据上面ICMP报告告文可以看到，ICMP报文是装在IP数据报的数据部分，所以ICMP是网络层的协议，ICMP报文加上首部就可以形成一个ICMP差错报告告文进行发送。</p>
<p>ICMP报告报文有1字节的类型，1字节的代码和两字节的检验和，中间4个字节取决于ICMP报文的类型，最后面是ICMP数据部分，其长度也取决于类型。</p>
<p>前面的1字节类型，决定着ICMP属于哪一类。代码字段是为了进一步区分某种类型当中一些不同的情况。检验和字段是用来检验整个ICMP报文。注意在IP数据报首部里也有检验和，但那个检验和只用来检验首部，并不检验数据报的数据部分，所以首部的检验和无法保证数据部分一定没错，因此数据部分要有自己的检验和。</p>
<p>ICMP分为ICMP差错报文和ICMP询问报文。接下来分别看一下这两种分类。</p>
<h4 id="2-6-2-ICMP差错报文"><a href="#2-6-2-ICMP差错报文" class="headerlink" title="2.6.2 ICMP差错报文"></a>2.6.2 ICMP差错报文</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662e2cc40ea9cb14037d8041.png" alt="计算机网络（四）——网络层——ICMP差错报文.png">

<p>上图第二点是源点抑制类型。不过ICMP标准在不断更新，最新的ICMP标准已不再使用“源点抑制报文”。</p>
<p>下面看一下，ICMP差错报告告文数据字段具体是什么样的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662e2d510ea9cb14037eda6a.png" alt="计算机网络（四）——网络层——ICMP差错报文结构.png">

<p>所有的ICMP差错报告报文的数据字段的格式都是一样的，要把收到的需要进行差错报告的IP数据报的首部以及前8个字节取出来，做为ICMP的数据字段，再加上ICMP差错报告报文的前8个字节，就构成了一个完整的ICMP差错报告报文。接下来再加上IP数据报的首部，就构成了一个完整的数据报。这就是形成ICMP差错报告报文以及装入IP数据报的过程。</p>
<p>需注意，不是所有出错的情况都要返回一个ICMP差错报告报文，下面列举几个不需要返回的情况：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662e2f260ea9cb1403830b53.png" alt="计算机网络（四）——网络层——不需返回ICMP差错报文的情况.png">

<h4 id="2-6-3-ICMP询问报文"><a href="#2-6-3-ICMP询问报文" class="headerlink" title="2.6.3 ICMP询问报文"></a>2.6.3 ICMP询问报文</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662e2f440ea9cb1403834ae8.png" alt="计算机网络（四）——网络层——ICMP询问报文.png">

<p>ICMP询问报文有以上四种，但是掩码地址请求和回答报文、路由器询问和通告报文已经不再使用。</p>
<h4 id="2-6-4-ICMP应用"><a href="#2-6-4-ICMP应用" class="headerlink" title="2.6.4 ICMP应用"></a>2.6.4 ICMP应用</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662e2faf0ea9cb140384324f.png" alt="计算机网络（四）——网络层——ICMP应用.png">

<p>ICMP两个常见的应用是分组网间探测PING和Traceroute。</p>
<p>这里说一下Traceroute的工作过程，假设有两台主机（源主机和目的主机），中间连接着很多路由器。源主机会发送一连串的数据报，这些数据报的差别在于他们的TTL（生存时间）设置不一样，假设第一个报文的TTL&#x3D;1，当第一个数据报到达路径上的第一个路由器，这个路由器就会先把第一个报文收下，然后再把TTL的值减1，减完1以后，第一个数据报文的TTL就变为0。当第一个数据报的TT;&#x3D;0时，路由器就会把这个报文丢弃，然后返还主机一个时间超过的ICMP差错报告报文。第二个数据报TTL设置为2，则该报文在第二个路由器处会被丢弃，并收到一个返回的时间超过的ICMP差错报告报文。通过这样的方式，当收到目的主机返回的差错报告报文时，就可以测算出源点到终点的距离。</p>
<h2 id="3-IPv6"><a href="#3-IPv6" class="headerlink" title="3. IPv6"></a>3. IPv6</h2><p>目前广泛使用的IPv4在2011年2月，已经被耗尽，为了解决“IP地址耗尽”问题，采取了以下三种措施：</p>
<ol>
<li>采用无分类编制CIDR。</li>
<li>采用网络地址转换（NAT）方法以节省全球IP地址。</li>
<li>采用具有更大地址空间的新版本的IPv6。</li>
</ol>
<p>前两种方法只是延长路IPv4使用寿命，只有第三种方法能从根本上解决IP地址耗尽问题。</p>
<h3 id="3-1-IPv6数据报"><a href="#3-1-IPv6数据报" class="headerlink" title="3.1 IPv6数据报"></a>3.1 IPv6数据报</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662f1bd10ea9cb140331c9a5.png" alt="计算机网络（四）——网络层——IPv6数据报格式.png">

<p>上面是IPv6数据报格式，与IPv4不同，IPv6的数据报分为首部和有效载荷，其中首部固定为40B，有效载荷又分为选项和数据部分。选项里是有编号的扩展首部，扩展首部里存放着一些对数据报的新的要求，例如一些对数据报的扩展功能就是放到扩展首部里。</p>
<p>接下来看一下IPv6数据报中具体的字段。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662f1d9b0ea9cb140334e908.png" alt="计算机网络（四）——网络层——IPv6数据报具体字段.png">

<p>这里说一下流标签，这个字段类似于IPv4里的标识位，但是IPv4的标识位，是对这个数据报进行分片以后，每个分片都有同一个标识位。而这里的流是指，一连串的IPv6数据报，都有同一个流标签，注意，不是一个IPv6数据报分片，而是几个IPv6数据报属于一个流。</p>
<p>这里补充一个知识点，IPv6只有源主机才能分片，是端到端的，不允许类似IPv4传输路径中的路由分片。</p>
<p>再说一下下一个首部字段，这个字段在每一个首部里都有（包括IPv6数据报首部和扩展首部），用来标识下一个扩展首部或上层协议首部，说白了就是看有没有扩展首部，如果有则标识下一个扩展首部的类型，没有就指向数据，标识数据是何种协议单元。举个例子，假设一个IPv6数据报有3个扩展首部，则首部的下一个首部标识字段标识扩展首部1的类型；扩展首部1的下一个首部标识字段标识扩展首部2的类型；扩展首部2的下一个首部标识字段标识扩展首部3的类型；扩展首部3的后面由于没有扩展首部了，所以他的下一个首部标识字段标识数据的协议。（下一个首部字段标识数据时，类似于IPv4里的协议字段）</p>
<p>跳数限制就是IPv4里的TTL，即生存时间。 </p>
<p>下面看一下IPv6和IPv4的区别：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662f236f0ea9cb140340d77a.png" alt="计算机网络（四）——网络层——IPv6和IPv4.png">

<h3 id="3-2-IPv6地址表示形式"><a href="#3-2-IPv6地址表示形式" class="headerlink" title="3.2 IPv6地址表示形式"></a>3.2 IPv6地址表示形式</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662f239b0ea9cb1403412489.png" alt="计算机网络（四）——网络层——IPv6地址表示形式.png">

<p>IPv4地址采用点分十进制的方式表示，但是IPv6的地址有128位，采用点分十进制表示会很长，所以使用冒号十六进制来表示。即把IPv6的二进制地址串，按照每4位转换成1个十六进制的方法，将128位二进制，转换成32位十六进制，两4个十六进制加一个冒号，用于划分间隔，这就是冒号十六进制，也是IPv6地址的一般形势。</p>
<p>一般形式可以压缩，就是4个一组的十六进制里，如果前面出现0，则可把0省去，如果一组里的四个十六进制全是0，则要保留一个0，这就是压缩形式。</p>
<p>如果IPv6的一般形式里连续几组都是0，则可以把这连续的几组都省略掉，用两个冒号表示，这就是零压缩。</p>
<p>各种压缩过程与方法可参考上图。</p>
<h3 id="3-3-IPv6基本地址类型"><a href="#3-3-IPv6基本地址类型" class="headerlink" title="3.3 IPv6基本地址类型"></a>3.3 IPv6基本地址类型</h3><p>IPv6数据报的目的地址有以下三种基本类型：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662f23cd0ea9cb1403417eb1.png" alt="计算机网络（四）——网络层——IPv6地址基本类型.png">

<p>这里提一下任播，任播很容易理解，就是和多个目标中的一个进行通信。</p>
<h3 id="3-4-IPv4和IPv6的过渡策略"><a href="#3-4-IPv4和IPv6的过渡策略" class="headerlink" title="3.4 IPv4和IPv6的过渡策略"></a>3.4 IPv4和IPv6的过渡策略</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662f24580ea9cb1403426d38.png" alt="计算机网络（四）——网络层——IPv6和IPv4的过渡策略.png">

<p>由于IPv4和IPv6不兼容，所以需要通过特殊的方法来进行两者间的过渡。这里的特殊方法就是上图的双栈协议和隧道技术。</p>
<p>双栈协议很好理解，所以说一下隧道技术。</p>
<p>隧道技术，就是将接收到的数据报重新封装再发送。如上图的例子，左主机给右主机发送信息，与路由器1接口连接，使用的是IPv6的协议，但路由器1发给路由器2的接口使用的是IPv4协议，所以路由器1要把IPv6数据报当成数据，前面再添加一个IPv4的首部进行重新封装，然后发给路由器2，路由器2把数据转给路由器3，路由器3发现路由器4的接口是IPv6，所以把IPv4首部去掉，重新转换成IPv6数据报发送出去，路由器4将接收到的IPv6数据报发给右主机。</p>
<h3 id="3-5-IPv6小结"><a href="#3-5-IPv6小结" class="headerlink" title="3.5 IPv6小结"></a>3.5 IPv6小结</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/662f24a00ea9cb140342f3b9.png" alt="计算机网络（四）——网络层——IPv6小结.png">

<h2 id="4-路由算法与路由协议"><a href="#4-路由算法与路由协议" class="headerlink" title="4. 路由算法与路由协议"></a>4. 路由算法与路由协议</h2><h3 id="4-1-路由算法"><a href="#4-1-路由算法" class="headerlink" title="4.1 路由算法"></a>4.1 路由算法</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634daa30ea9cb14030bc528.png" alt="计算机网络（四）——网络层——路由算法引言.png">

<p>如图，路由器本身会有一个路由表&#x2F;转发表，通过这个表，我们会知道分组经过这个路由器之后，接下来该往哪里走，路由表中的每一行是通过路由算法得到的。</p>
<p>一个路由器可能会连着很多个路由器，那么它的下一跳也有很多种方向，那如何决定是哪个方向呢，这也是路由算法决定的事，路由算法会选择一个最佳路由添加到表项里，在网络层这章，最佳路由往往都是基于路径最短而选择的。</p>
<p>接下来看一下路由算法的分类：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634dc310ea9cb14030f8b7d.png" alt="计算机网络（四）——网络层——路由算法分类.png">

<p>路由算法分为静态路由算法和动态路由算法，而动态路由算法又可以分为全局性的链路状态路由算法和分散性的距离向量路由算法。</p>
<p>我们现在的因特网规模很大，如果让所有的路由器都知道每个网络怎么样到达的话，路由表就会很庞大，处理起来也很花时间。另外，有一些公司不想让外界知道自己使用的是什么路由协议，但又想连入因特网。结合这两个原因，就产生了分层次的路由选择协议。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634dd150ea9cb140311c475.png" alt="计算机网络（四）——网络层——分层次路由协议.png">

<p>分层次的路由协议，具体来说，就是把因特网分为了许多个小的团体，每一个小团体都称为一个自治系统AS，一个自治系统内的协议外部是不知道的，这样就可以减少每一个路由器的表项，还能让公司内部的协议对外界透明。</p>
<p>路由选择协议分为内部网关协议和外部网关协议。对应的就是应用在自治系统内部分和自治系统外部。</p>
<p>内部网关协议IGP由RIP和OSPF，外部网关协议EGP有BGP。</p>
<p>这里补充一下路由算法和路由选择的概念：</p>
<p>路由算法：路由算法是指在计算机网络中，根据网络拓扑结构和路由策略，计算出数据包从源节点到目的节点的最佳路径的算法。</p>
<p>路由选择：路由选择是指选择通过互连网络从源节点向目的节点传输信息的通道，而且信息至少通过一个中间节点。路由选择工作在OSI参考模型的网络层。</p>
<h3 id="4-2-RIP协议与距离向量算法"><a href="#4-2-RIP协议与距离向量算法" class="headerlink" title="4.2 RIP协议与距离向量算法"></a>4.2 RIP协议与距离向量算法</h3><p>从前面我们知道，RIP协议是内部网关协议，主要用于自治系统内部。</p>
<p>RIP协议具体内容如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634e3fa0ea9cb1403266cb6.png" alt="计算机网络（四）——网络层——RIP协议.png">

<p>如上图，介绍了什么RIP协议，RIP协议的优点以及适用于小互联网。上图右下是根据RIP协议建立的R2路由表，里面有目的网络，距离以及下一跳路由器，通过路由表，R2路由器可以将分组转发至对应网络。</p>
<p>这里有一个问题，R2的路由表是如何建立的呢？R2路由表的建立是通过与其它路由器之间交换信息才逐渐完善起来的，这里就又牵扯出了一些更深的问题，R2路由器和哪些路由器交换信息？在什么时候交换信息？交换什么信息？这就是接下来要讨论的问题。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634e6190ea9cb14032cf62e.png" alt="计算机网络（四）——网络层——RIP协议的路由表建立.png">

<p>上图回答了前面遗留的三个问题，即路由器仅和相邻路由器交换信息，信息内容是自己的路由表，每30秒交换一次。</p>
<p>除了回答上面三个问题，上图中间还解释了收敛的过程。举个例子来说，如上图有5个路由器，对其编号为1~5，假设这5个路由器是5个人，1号有5亿资产，2号有2亿资产，3号有1亿资产，4号有3亿资产，5号有4亿资产。以2和3号为例，一开始2号知道1号和3号的资产，3号知道2和4号的资产，通过交换信息，2号从3号得知4号的资产，3号从2号得知1号的资产。同理，2号也可以和1号交换，3号也可以和4号交换，4号也可以和5号交换，最后每一个都知道别的人的资产。</p>
<p>所以，经过若干次更新后，所有路由器最终都会知道到达本自治系统任何一个网络的最短距离和下一跳路由器的地址。这里有个很重要的问题，最短距离是怎么通过交换信息得到的，换句话说，路由表是怎么更新的？这里要结合距离向量算法深入了解。</p>
<p>在了解距离向量算法之前，首先要知道有一种报文叫RIP报文，**<font color=blue>RIP报文所包含的信息，就是前面所说的路由表的全部信息</font>**。也就是说相邻两个路由器交换信息的实质就是交换RIP报文。</p>
<p>RIP报文如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634ea140ea9cb1403384047.png" alt="计算机网络（四）——网络层——RIP报文.png">

<p>RIP报文有很多字段，但考研不要求记忆。但根据这个报文格式可以知道，RIP报文是首部和路由部分装到了UDP用户数据报里，而UDP是传输层协议，所以UDP的数据单元就是由高层传下来的，所以RIP是应用层协议，这一点要知道。</p>
<p>除了上面那一点，还要知道一个RIP报文最多可传送25个路由表项信息，也就是25个路由，如果一个路由表有好几十个路由信息，就要发送几个报文进行传输。</p>
<p>接下来看距离向量算法的过程：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634e9880ea9cb140336e217.png" alt="计算机网络（四）——网络层——距离向量算法.png">

<p>下面给两道例题来辅助理解距离向量算法的过程：</p>
<p>例题1：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634eb620ea9cb14033c22bc.png" alt="计算机网络（四）——网络层——距离向量算法练习1.png">

<p>例题2：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634ebbe0ea9cb14033d31c6.png" alt="计算机网络（四）——网络层——距离向量算法练习2.png">

<p><strong>最后看一下RIP协议的特点，即好消息传得快，坏消息传的慢。</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634ecae0ea9cb14034008db.png" alt="计算机网络（四）——网络层——RIP协议特点.png">

<p>RIP 路由器每隔 30 秒（默认设置）就会向邻居路由器发送一次完整的路由表更新。这种定期更新的机制确保了当网络发生变化时，好的路由信息（例如新路径的出现）能够快速地传播到整个网络。此外，RIP 使用跳数作为度量值来确定到达目的地的最佳路径。默认情况下，最大跳数限制为 15。当某个路由器检测到新的、更短的路径时，它会立即向邻居广播这个“好消息”。</p>
<p>好消息传播的快，但是坏消息传播的很慢，以上图为例，假设网1出现故障，R1自然就到不了网1，便把路由表更新为“1，16，-”表示到网1距离是16（无法到达）是直接交付。但是很可能这样更新好的报文，要经过30s后才能发给R2。而R2可能已经先把自己的有关网1的报文“1，2，R1”先给到R1，即在R2收到R1的更新报文前，还发送原来的报文，因为这时R2并不知道R1发生了故障。</p>
<p>R1收到R2的更新报文后，误认为可经过R2到达网1，于是更新自己的路由表为“1，3，R2”，R2收到该路由信息，又会把自己的路由表更新为“1，4，R1”，诸如此循环，这样不断更新下去，直到R1和R2到网1的距离都增大到16时，R1和R2才知道网1是不可到达的，这就是坏消息传递慢的原因。</p>
<h3 id="4-3-OSPF协议与链路状态算法"><a href="#4-3-OSPF协议与链路状态算法" class="headerlink" title="4.3 OSPF协议与链路状态算法"></a>4.3 OSPF协议与链路状态算法</h3><h4 id="4-3-1-OSPF相关概念"><a href="#4-3-1-OSPF相关概念" class="headerlink" title="4.3.1 OSPF相关概念"></a>4.3.1 OSPF相关概念</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f0840ea9cb14034bae02.png" alt="计算机网络（四）——网络层——OSPF相关概念.png">

<p>补充一下，与RIP适合小型网络不同，OSPF适应于大型网络。</p>
<p>RIP协议基于距离向量，而OSPF基于链路状态，链路状态则是指本路由器都和那些路由器相邻，以及相应链路的代价。</p>
<p>这里的代价用来表示费用、距离、时延等，这些都由网络管理人员来决定。</p>
<p>下面以思科路由器为例，看一下思科路由器的OSPF计算代价的方法：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f1820ea9cb14034e4379.png" alt="计算机网络（四）——网络层——OSPF代价计算举例.png">

<h4 id="4-3-2-OSPF的工作原理"><a href="#4-3-2-OSPF的工作原理" class="headerlink" title="4.3.2 OSPF的工作原理"></a>4.3.2 OSPF的工作原理</h4><p>OSPF协议中，相邻路由器之间通过交互问候分组，建立和维护邻居关系，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f28c0ea9cb1403516927.png" alt="计算机网络（四）——网络层——OSPF的问候分组.png">

<p>问候分组被封装在IP数据报中，发往组播地址224.0.0.5，其中IP首部的协议号字段取值应为89，来表明IP数据报的数据载荷为OSPF分组。</p>
<p>问候分组发送周期为10s，若40s未收到来自邻居路由器的问候分组，则认为该邻居路由器不可达，若收到，则重新开启40s计时。</p>
<p>使用OSPF的每个路由器都会产生链路状态通告，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f3ee0ea9cb140355ae5b.png" alt="计算机网络（四）——网络层——OSPF的链路状态通告.png">

<p>使用OSPF的每个路由器还都有一个链路状态数据库用于存储链路状态通告，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f4900ea9cb14035793ee.png" alt="计算机网络（四）——网络层——OSPF的链路状态数据库.png">

<p>各路由器有了LSDB以后，便可基于LSDB进行最短路径优先SPF计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f5400ea9cb14035991e4.png" alt="计算机网络（四）——网络层——OSPF的最短路径.png">

<p>对于一个比较简单的网络拓扑，人类可以很轻松找到每个路由器到达其它路由器的最短路径。但是如果网络拓扑比较复杂，该项工作对人类而言就比较复杂，因此可以使用Dijkstra最短路径优先算法编制程序，让路由器执行该程序。</p>
<h4 id="4-3-3-OSPF的五种分组类型"><a href="#4-3-3-OSPF的五种分组类型" class="headerlink" title="4.3.3 OSPF的五种分组类型"></a>4.3.3 OSPF的五种分组类型</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f6fa0ea9cb14035e8abb.png" alt="计算机网络（四）——网络层——OSPF的五种分组类型.png">

<h4 id="4-3-4-举例说明OSPF的工作过程"><a href="#4-3-4-举例说明OSPF的工作过程" class="headerlink" title="4.3.4 举例说明OSPF的工作过程"></a>4.3.4 举例说明OSPF的工作过程</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f7970ea9cb140360860d.png" alt="计算机网络（四）——网络层——OSPF的工作过程.png">

<p>上图举例说明OSPF的工作过程，首先，相邻路由器周期性发送问候分组，以便建立和维护邻居关系。</p>
<p>建立邻居关系后，给邻居路由器发送数据库描述分组，也就是将自己的链路状态数据库中的所有链路状态项目的摘要信息发送给邻居路由器。例如，R1收到R2的数据库描述分组后，发现自己缺少其中的某些链路状态项目，于是就给R2发送链路状态请求分组。R2收到后，将R1缺少的链路状态项目的详细信息封装在链路状态更新分组中发送给R1。R1收到后，将缺少的信息添加到自己的链路数据库里，并且向R2发送链路状态确认分组。当然R2也可以向R1请求自己链路状态缺少的信息。最终R1和R2的链路状态数据库达到一致，也就是链路状态数据库达到同步。</p>
<p>每30分钟或链路状态发送变化时，路由器都会发送链路状态更新分组，收到该分组的其它路由器将洪泛转发该分组，并给该路由器发回链路状态确认分组，这又称为新情况下的链路状态数据库同步。</p>
<h4 id="4-3-5-OSPF在多点接入网络中路由器邻居关系的建立"><a href="#4-3-5-OSPF在多点接入网络中路由器邻居关系的建立" class="headerlink" title="4.3.5 OSPF在多点接入网络中路由器邻居关系的建立"></a>4.3.5 OSPF在多点接入网络中路由器邻居关系的建立</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f7f60ea9cb140361820e.png" alt="计算机网络（四）——网络层——OSPF的邻居关系建立.png">

<p>OSPF路由器在多点接入网络建立邻居关系时，如果不采用其他机制，将会产生大量的多播分组。</p>
<p>如上图，5台路由器接入多播网络，它们周期性地发送问候分组以建立和维护邻居关系，这些路由器中的任意两个路由器都互为邻居关系。如图右下所示，邻居关系数据为n(n-1)&#x2F;2，其中n是路由器数量，这样每个路由器要向其他（n-1）个路由器发送问候分组和链路状态更新分组。</p>
<p>为了减少发送分组的数量，OSPF采用选举指定路由器DR和备用的指定路由器BDR的方法。</p>
<p>如图左下，假设两台路由器被选为DR和BDR，所有的非BD&#x2F;BDR只与BR&#x2F;BDR建立邻居关系，邻居关系数量可降为2(n-2)+1。非BR&#x2F;BDR之间不能直接交换信息，需通过DR&#x2F;BDR交换。若DR出现问题，则由BDR顶替DR。</p>
<p>实现DR和BDR的选举就是各路由器之间交换一些选举参数，例如优先级、ID、接口等，然后根据选取规则选取BD&#x2F;BDR。</p>
<h4 id="4-3-6-OSPF的区域划分"><a href="#4-3-6-OSPF的区域划分" class="headerlink" title="4.3.6 OSPF的区域划分"></a>4.3.6 OSPF的区域划分</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f8440ea9cb14036246a1.png" alt="计算机网络（四）——网络层——OSPF的区域划分.png">

<p>如图，在该自治系统内，所有路由器都采用OSPF协议，OSPF将该自治系统再划分为4个更小的区域，每个区域都有一个32比特的标识符，可以用点分十进制表示，例如主干区域的标识符必须为0，也可以表示成0.0.0.0。</p>
<p>主干区域用于连通其他区域，其他区域的标识符不能为0且互不相同。</p>
<p>每个区域规模不宜太大，一般所包含的路由器不宜超过200个。</p>
<p>划分区域的好处是，把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个自治系统，这样举减少了整个网络上的通信量。</p>
<p>如果路由器的所有接口都在一个区域内，则该路路由器称为区域内路由器。</p>
<p>用于实现区域连通的路由器称为区域边界路由器，该路由器一个接口用于连接自身所在区域，另一个接口用于连接主干区域。</p>
<p>主干区域内的路由器称为主干路由器，也可以把区域边界路由器看做是主干路由器。</p>
<p>在主干区域内还有一个路由器在专门和自治系统外的其它自主系统交换路由信息，这个路由器称为自治系统边界路由器。</p>
<p>采用分层次划分区域的方法，虽然使交换信息的种类增多了，同时也使OSPF协议更加复杂了，但这样做却能使每一个区域内部，交换路由信息的通信量大大减少，因而使OSPF协议能够用于规模很大的自治系统重。</p>
<h3 id="4-4-边界网关协议BGP"><a href="#4-4-边界网关协议BGP" class="headerlink" title="4.4 边界网关协议BGP"></a>4.4 边界网关协议BGP</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f9070ea9cb1403642ca3.png" alt="计算机网络（四）——网络层——BGP的提出1.png">

<p>在不同的自治系统内，可以通过不同协议，通过不同的方式确定最佳路径，因此，在不同自治系统内，度量路由的代价可能不同，这就导致对于自治系统之间的路由选择，使用代价作为度量来寻找最佳路由是不行的。如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663596d90ea9cb140393c786.png" alt="计算机网络（四）——网络层——代价度量.png">

<p>AS4到AS5可以有很多路径，但这些路径由于没有统一的度量，所以找不到最佳路由。</p>
<p>除此以外，自治系统之间的路由选择还必须考虑相关策略（如政治、经济、安全等），如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663597a00ea9cb140395c55d.png" alt="计算机网络（四）——网络层——自治系统选择路径策略.png">

<p>上图左AS4想到达AS5，最好的路径肯定是走国内的自治系统。</p>
<p>而上图右，由于AS3不允许通过，所以只能走通过AS2的路。</p>
<p>由以上可以看出，BGP只能是力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。</p>
<p>下面来看BGP：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66359e120ea9cb1403a44a2a.png" alt="计算机网络（四）——网络层——BGP发言人.png">

<p>在配置BGP时，首先要至少确定一个BGP发言人，一般来说两个BGP发言人都是通过一个共享网络连接在一起的，而BGP发言人往往就是BGP边界路由器。</p>
<p>不同自治系统发言人要交换路由信息。BGP发言人除了运行BGP外，还必须运行自己所在自治系统所能使用的内部网关协议IGP。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66359ef10ea9cb1403a700e5.png" alt="计算机网络（四）——网络层——BGP自治系统连通图.png">

<p>BGP发言人交换网络可达性的信息，当BGP发言人互相交换了网络可达性信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各自治系统的较好的路由。也就是构造出树形结构，不存在回路的自治系统连通图，如上图右下，是自治系统AS1的某个BGP发言人构造的自治系统连通图。</p>
<p>BGP适用于多级结构的因特网，下面给出一个BGP发言人交换路径向量的例子：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635a2b90ea9cb1403aff81b.png" alt="计算机网络（四）——网络层——路径交换例子.png">

<p>如上图，AS2的BGP发言人告诉AS1要到达N1,N2,N3,N4可经过AS2，AS1收到以后其发言人告诉AS3要到达N1,N2,N3,N4可沿路径（AS1,AS2），这里的（AS1,AS2）就是路径向量。AS3收到这条路径信息后，如果AS3也包含在其中，则不能采用这条路径，否则会兜圈子。</p>
<p>接下来介绍比较常用的BGP-4（BGP版本4）中规定的四种报文：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635a3990ea9cb1403b28028.png" alt="计算机网络（四）——网络层——BGP-4报文.png">

<p>这里贴一道比较有结合性的考研真题：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635a3c30ea9cb1403b2d294.png" alt="计算机网络（四）——网络层——例题.png">

<p>下面对BGP进行总结：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635a4380ea9cb1403b3c84b.png" alt="计算机网络（四）——网络层——BGP相关知识总结.png">

<h2 id="5-IP多播"><a href="#5-IP多播" class="headerlink" title="5. IP多播"></a>5. IP多播</h2><h3 id="5-1-IP多播技术的相关基本概念"><a href="#5-1-IP多播技术的相关基本概念" class="headerlink" title="5.1 IP多播技术的相关基本概念"></a>5.1 IP多播技术的相关基本概念</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635b78f0ea9cb1403e65d2a.png" alt="计算机网络（四）——网络层——IP数据报的三种传输方式.png">

<p>多播是一种实现一对多通信的技术，与传统单播一对一通信相比，多播可以极大地节省网络资源。</p>
<p>在因特网上进行的多播称为IP多播。</p>
<p>多播与单播和广播不同，单播是一对一，广播是一对多的全部，而多播则是一对多的部分。</p>
<p>下图给出多播的示例：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635b85d0ea9cb1403e89d77.png" alt="计算机网络（四）——网络层——多播例子.png">

<p>上图左为单播通信的方式，上图右为多播通信的方式，从图中不难看出，当多播组的成员数量很大时，采用多播方式可以显著地减少网络中各种资源的消耗。</p>
<p>接下来介绍一下IP多播地址和多播组：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635b97e0ea9cb1403ebbabe.png" alt="计算机网络（四）——网络层——IP多播地址和多播组知识点.png">

<p>多播地址就是IPv4中的D类地址，根据D类地址的规则，我们可以得出IP多播地址的范围与最大多播地址和最小多播地址，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635b9f10ea9cb1403ecb14c.png" alt="计算机网络（四）——网络层——IP多播地址的范围.png">

<p>对于IPv4多播地址，还可以分为以下几类：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635ba5a0ea9cb1403edcc88.png" alt="计算机网络（四）——网络层——IPv4多播地址的分类.png">

<p>对于IP的多播，可以分为只在本局域网上进行的硬件多播和在因特网上进行的多播，如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635ba9e0ea9cb1403ee955a.png" alt="计算机网络（四）——网络层——IP多播.png">

<p>但是在因特网进行的多播，在把多播数据报交付给多播组成员时，最后阶段还是要经过硬件多播，所以接下来着重看一下硬件多播的问题。</p>
<h3 id="5-2-在局域网上进行硬件多播"><a href="#5-2-在局域网上进行硬件多播" class="headerlink" title="5.2 在局域网上进行硬件多播"></a>5.2 在局域网上进行硬件多播</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635bc070ea9cb1403f28229.png" alt="计算机网络（四）——网络层——硬件多播.png">

<p>硬件多播的概念如上图，封装过程就是把IP多播数据报交给链路层添加一个帧头和帧尾，使之封装成一个多播MAC帧。IP多播数据报首部中的目的IP地址字段的值，是某个IP多播地址。多播MAC帧帧头中的目的MAC地址，就是由该IP多播地址映射而来的某个多播MAC地址。</p>
<p>接下来看一下多播MAC地址的构成：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635bdea0ea9cb1403f7c36e.png" alt="计算机网络（四）——网络层——多播MAC地址.png">

<p>多播MAC地址由48比特组成，第一个字节发送1表示是多播MAC地址，前24位固定为01-00-5E，第25位也固定为0。剩余23个比特可任意变化，全取0，可以得到最小多播MAC地址01-00-5E-00-00-00，全取1，可以得到最大多播MAC地址01-00-5E-7F-FF-FF。</p>
<p>下面，介绍一下把32bit的IPv4地址映射成48bit的多播MAC地址的具体方法。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635cf550ea9cb14032b8020.png" alt="计算机网络（四）——网络层——32bitIP映射成48bitMAC.png">

<p>32bitIP映射成48bitMAC的方式如上图，D类IP一共32位，前4位固定为1110，剩余28位可变化，而MAC一共48位，前25位固定，所以剩23位可变化，将IP映射成MAC就是将IP的后23位放到MAC的后23位里。</p>
<p>由于IP多播地址可变化的28比特前5个比特无法映射到MAC多播地址，这会造成IP多播地址与多播MAC地址的映射关系并不是唯一的。比如下面的例子：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635d0b40ea9cb14032fb563.png" alt="计算机网络（四）——网络层——多个IP映射成一个MAC.png">

<p>从上面可以看到，如果两个IP多播地址仅在未映射的5位有变化，则两个IP多播地址映射成的多播MAC地址是一样的。这也说明了，<font color=green><strong>IP多播地址与多播MAC地址的映射关系不是唯一的</strong></font>，因此收到IP多播数据报的主机还要在网际层利用软件进行过滤。如下面的例子：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635d2540ea9cb1403343291.png" alt="计算机网络（四）——网络层——硬件多播处理同MAC.png">

<p>如图，假设有一个封装有IP多播数据报的多播MAC帧传送到了这些多播组所在的局域网，该多播数据报的目的IP地址是226.128.9.26，多播MAC帧的目的MAC地址就是该IP多播地址映射出的多播MAC地址01-00-5E-00-09-1A。当该多播MAC帧到达各主机后，先匹配多播MAC地址，上图左和中的主机匹配成功，MAC层接受该MAC帧，右主机匹配失败，MAC层丢弃MAC帧。匹配成功的主机将MAC帧里封装的IP多播数据报交付上层网际层处理，网际层根据多播数据报的目的IP地址为IP多播地址226.128.9.26再次进行匹配处理，匹配成功网际层接受；匹配失败，网际层丢弃。</p>
<h3 id="5-3-在因特网上进行IP多播需要的两种协议"><a href="#5-3-在因特网上进行IP多播需要的两种协议" class="headerlink" title="5.3 在因特网上进行IP多播需要的两种协议"></a>5.3 在因特网上进行IP多播需要的两种协议</h3><p>要在因特网上进行IP多播，就必须要考虑<strong>IP多播数据报经过多个多播路由器进行转发</strong>的问题。<strong>多播路由器</strong>必须根据IP多播数据报首部中的<strong>IP多播地址</strong>，将其转发到有该多播组成员的局域网。</p>
<p>这里就产生了疑问，路由器如何知道自己各接口所在局域网中是否有某个多播组的成员？这就需要使用网际组管理协议IGMP。</p>
<p>IGMP相关概念如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635dbc50ea9cb14034e7132.png" alt="计算机网络（四）——网络层——IGMP协议.png">

<p>仅使用IGMP并不能在因特网上进行IP多播，还需要使用多播路由选择协议。</p>
<p>多播路由选择协议的工作原理如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635dc390ea9cb14034fca12.png" alt="计算机网络（四）——网络层——多播路由选择协议.png">

<p>经过对IGMP和多播路由选择协议的初步了解，不难发现，多播源先通过多播路由选择协议，找到拥有该多播组成员的路由器，然后路由器通过IGMP协议将多播数据报发给网段内对应的多播组成员。具体例子可以参考下图下半部分。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635dd4d0ea9cb14035484cd.png" alt="计算机网络（四）——网络层——多播路由选择协议和IGMP结合的例子.png">

<p>对于多播路由选择和IGMP实现的IP多播，有一点要说一下，为了覆盖多播组的所有成员，多播转发树可能要经过一些没有多播组成员的路由器，如上图R2，所以题目里如果出现类似R2的路由器，不要怀疑题目出错了。</p>
<h3 id="5-4-网际组管理协议IGMP"><a href="#5-4-网际组管理协议IGMP" class="headerlink" title="5.4 网际组管理协议IGMP"></a>5.4 网际组管理协议IGMP</h3><h4 id="5-4-1-IGMP报文"><a href="#5-4-1-IGMP报文" class="headerlink" title="5.4.1 IGMP报文"></a>5.4.1 IGMP报文</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635ed2c0ea9cb14037f765f.png" alt="计算机网络（四）——网络层——IGMP报文.png">

<p>IGMP应用于网段内，路由器通过IGMP协议将报文发送到该网段内的对应的组员处。</p>
<p>接下来，举例看一下IGMP的工作原理。</p>
<h4 id="5-4-2-加入多播组"><a href="#5-4-2-加入多播组" class="headerlink" title="5.4.2 加入多播组"></a>5.4.2 加入多播组</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635ee240ea9cb140381b634.png" alt="计算机网络（四）——网络层——IGMP加入多播组.png">

<p>一开始主机C属于多播组228.1.1.1，在R1的多播组列表里已经记录有该多播组，主机D不属于任何多播组。现在主机A和B都希望加入多播组226.0.9.26。假设主机B首先向以太网发送IGMP成员报告报文，其内有所希望加入的多播组的IP多播地址、IP数据报的目的地址及以太网多播帧的目的地址。</p>
<p>以太网中A、C、D和R1都会收到该多播帧。</p>
<p>D不属于任何多播组，所以会直接将该帧丢弃。</p>
<p>C发现多播MAC地址不匹配也会直接丢弃。</p>
<p>A发现该多播帧的目的地址与自己希望加入的IP多播组的多播MAC地址相同，因此在MAC层接受该帧，并将其所封装的IP数据报交付上层的网际层处理，网际层发现该多播数据报的目的地址与自己希望加入的多播组的IP多播地址相同，因此接受该多播数据报，并将其所封装的IGMP成员报告报文交付IGMP进行解析。这样A就知道这是来自同一IP多播组的另一个成员的IGMP成员报告报文，于是取消自己准备发送的IGMP成员报告报文。</p>
<p>R1收到该多播帧后，提出其中的IGMP成员报告报文，解析该报文后就知道了自己所直连网络中，有一个新的IP多播组226.0.9.26。因此将IP多播组地址226.0.9.26添加到自己的多播组列表中。</p>
<h4 id="5-4-3-监视多播组成员的变化"><a href="#5-4-3-监视多播组成员的变化" class="headerlink" title="5.4.3 监视多播组成员的变化"></a>5.4.3 监视多播组成员的变化</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635f94d0ea9cb1403a10b8d.png" alt="计算机网络（四）——网络层——IGMP监视多播组的成员变化.png">

<p>多播路由器每隔125秒就向其直连网络发送一个封装有IGMP成员查询报文的IP多播数据报。IGMP成员查询报文内主要是要查询的特定多播组的IP多播地址，这里以IP多播地址226.0.9.26为例，当然也可以是0.0.0.0，这表示查询全部多播组。IP数据报的目的地址是224.0.0.1，这是一个特殊的IP多播地址，在本网络中所有参加多播的主机和路由器的网际层都会接受该多播数据报。以太网多播帧的目的地址是由IP多播数据报的目的地址224.0.0.1映射而来的多播MAC地址。</p>
<p>以太网中A、B、C、D都会收到该多播帧，由于D不属于任何多播组会直接丢弃该帧。</p>
<p>主机A、B、C发现该多播帧的目的地址是01-00-5E-00-00-01，其可能对应的IP多播地址为224.0.0.1这个特殊的IP多播地址，于是在MAC层接受该多播帧，在网际层接受该多播帧所封装的IP多播数据报，并将IP多播数据报所封装的IGMP成员查询报文交付IGMP进行解析。</p>
<p>这时主机B就知道这是来自多播路由器的IGMP成员查询报文，由于查询的多播组与自己的多播组是同一个多播组，于是决定2s后进行响应。</p>
<p>同理主机A就知道这是来自多播路由器的IGMP成员查询报文，由于查询的多播组与自己的多播组是同一个多播组，于是决定8s后进行响应。</p>
<p>主机C就知道这是来自多播路由器的IGMP成员查询报文，由于查询的多播组与自己的多播组不是同一个多播组，于是决定不响应。</p>
<p>收到IGMP成员查询报文的被查询多播组的任何成员，将会发送IGMP成员报告报文作为应答，为了减少不必要的重复应答，每个多播组只需要有一个成员应答即可，因此采用了一种延迟响应的策略，那就是收到IGMP成员查询报文的主机，并不是立即响应，而是在1~10s的范围内，等待一段随机时间后再进行响应，如果在这段随机时间内，收到了同组其他成员发送的IGMP成员报告报文就取消响应。</p>
<p>在本例中，主机B决定在2秒后响应，主机A决定在8秒后响应，大约2s后，主机B发送IGMP成员报告报文，下面的过程与加入多播组的情况一致，主机A收到后，取消相应。R1收到后，会更新对226.0.9.26的125s计时。</p>
<p>下面假设一下，主机C不再是多播组228.1.1.1的成员，该如何进行呢？</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635fafa0ea9cb1403a46c2f.png" alt="计算机网络（四）——网络层——IGMP监视多播组的成员不再属于多播组.png">

<p>如上，当C不是228.1.1.1的成员，每隔125s，多播路由器会发送查询报文，当发送对228.1.1.1的查询报文时，主机C、D的MAC层丢弃该帧，主机A、B的MAC层接受该帧，网际层接受该多播帧封装的IP多播数据报，并将IP多播数据报所封装的IGMP成员查询报文交付IGMP进行解析，发现是查询228.1.1.1的，与自己无关，因此不响应。R1由于长时间收不到该多播组的响应，于是将其从多播列表中删除。</p>
<p>这里有几点需要说明一下，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635fc1d0ea9cb1403a6c48e.png" alt="计算机网络（四）——网络层——IGMP监视多播组的说明.png">

<h4 id="5-4-4-退出多播组"><a href="#5-4-4-退出多播组" class="headerlink" title="5.4.4 退出多播组"></a>5.4.4 退出多播组</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635fccd0ea9cb1403a8e453.png" alt="计算机网络（四）——网络层——IGMP退出多播组.png">

<p>下面举例说明退出多播组的过程：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635fd470ea9cb1403aa647c.png" alt="计算机网络（四）——网络层——IGMP退出多播组工作过程.png">

<p>假设主机C要退出该多播组，可以主动发送一个IGMP离开组报文，而不必等待多播路由器R1的查询。IGMP离开组报文的封装细节如上图右上，离开祖报文的内容要包含主机要退出的多播组的地址，封装离开组报文的IP多播数据报的目的地址位224.0.0.2，这也是一个特殊的IP多播地址，在本网络中的所有多播路由器的网际层都会接受该多播数据报。</p>
<p>以太网里的A、B、D、R1都会收到封装有IGMP离开组报文的多播帧，主机D的MAC层丢弃。主机A、B的MAC层接受，但根据其封装的IP多播数据报的目的地址与自己的不一样，会在网际层丢弃。R1收到后就知道有成员离开了，但暂时不删除该多播组，而是重新会发送一个该多播组的查询报文，查看是否还有其他主机属于该多播组成员，如果没有响应，就会删除该多播组。</p>
<h3 id="5-5-多播路由选择协议"><a href="#5-5-多播路由选择协议" class="headerlink" title="5.5 多播路由选择协议"></a>5.5 多播路由选择协议</h3><p>写在开头：这部分在王道里没有细讲，只看王道很难理解，所以这部分的知识是在湖科大的课里学的，这里把视频链接贴在这，不懂的可以跳转视频：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16f4y1Z7bS/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.1~4.7.2 IP多播技术的相关基本概念、IP多播地址和多播组_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pV4y1n7wG/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.3 在局域网上进行硬件多播_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dv4y1T7oH/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.4 在因特网上进行IP多播需要的两种协议_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cU4y1D797/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.5 网际组管理协议IGMP_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1YB4y1e7NV/?spm_id_from=333.788&vd_source=7fb4b255ed876969a742738d7b84f461">深入浅出计算机网络 - 4.7.6 多播路由选择协议_哔哩哔哩_bilibili</a></p>
<h4 id="5-5-1-多播路由器协议基础"><a href="#5-5-1-多播路由器协议基础" class="headerlink" title="5.5.1 多播路由器协议基础"></a>5.5.1 多播路由器协议基础</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6635ff280ea9cb1403af64a0.png" alt="计算机网络（四）——网络层——多播路由选择基础.png">

<p>目前有两种方法构建多播转发树，一个是基于源树，另一个是组共享树。</p>
<h4 id="5-5-2-基于源树多播路由选择"><a href="#5-5-2-基于源树多播路由选择" class="headerlink" title="5.5.2 基于源树多播路由选择"></a>5.5.2 基于源树多播路由选择</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663600500ea9cb1403b1a982.png" alt="计算机网络（四）——网络层——基于源树多播路由选择.png">

<p>要建立广播转发树，除了使用反向路径广播算法还可以使用洪泛法，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663600c70ea9cb1403b2d269.png" alt="计算机网络（四）——网络层——洪泛法.png">

<p>上图是使用洪泛法构建广播转发树的情况，在无环路网络中，R1向R3发送广播分组，R3收到后，复制该广播分组，并向自己的所有下游邻居路由器转发，即向除R1外的所有路由器转发，以此类推，这种方法最终可将广播分组的副本传送到网络中的所有结点。</p>
<p>但是，如果网络中存在环路，使用洪泛法会产生严重的问题，即广播分组的一个或多个副本会在环路中永久兜圈，如上图右，这种无休止的广播分组和转发，最终将导致该网络中产生大量的广播分组，使得网络带宽被完全占用。</p>
<p>利用反向路径广播RPB算法生成的广播转发树，就不会存在环路。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663602570ea9cb1403b7f6fd.png" alt="计算机网络（四）——网络层——RPB.png">

<p>下面举例说明反向路径多播（RPM）算法：</p>
<p>源点向R1发送一个广播分组，R1收到后向其邻居路由器R2，R3转发，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6636048f0ea9cb1403bd8814.png" alt="计算机网络（四）——网络层——RPM1.png">

<p>R2，R3互相丢弃彼此收到的分组：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663604e50ea9cb1403be4740.png" alt="计算机网络（四）——网络层——RPM2.png">

<p>R4，R5转发：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663605200ea9cb1403bebfec.png" alt="计算机网络（四）——网络层——RPM3.png">

<p>R4，R5互相丢弃彼此收到的分组：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6636054c0ea9cb1403bf1e3a.png" alt="计算机网络（四）——网络层——RPM4.png">

<p>有多个最短路径时，选择IP小的做最短路径：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663605790ea9cb1403bfa722.png" alt="计算机网络（四）——网络层——RPM5.png">

<p>得到广播转发树：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663605f10ea9cb1403c13b9d.png" alt="计算机网络（四）——网络层——RPM6.png">

<p>判断非成员路由器，准备进行剪出：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663606340ea9cb1403c2216e.png" alt="计算机网络（四）——网络层——RPM7.png">

<p>非成员路由器向上层发送剪枝报完，将自己剪除，形成多播转发树：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663606810ea9cb1403c32ba8.png" alt="计算机网络（四）——网络层——RPM8.png">

<p>如果被剪除的路由器通过IGMP又发现了新的多播组成员，则会向上游路由器发送一个嫁接报文，并重新加入到多播转发树中：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20240504175902622.png" alt="image-20240504175902622"></p>
<p>这里有一点要说明一下，尽管R2没有多播组成员，但也要保留R2以确保多播转发树的连通性。</p>
<h4 id="5-5-3-组共享树多播路由选择"><a href="#5-5-3-组共享树多播路由选择" class="headerlink" title="5.5.3 组共享树多播路由选择"></a>5.5.3 组共享树多播路由选择</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/663607b40ea9cb1403c93785.png" alt="计算机网络（四）——网络层——组共享树多播路由选择过程.png">

<p>上面是组共享树多播路由选择的工作过程，下面给个例子：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66360bb60ea9cb1403d3f1bf.png" alt="计算机网络（四）——网络层——基于核心的生成树的建立过程.png">

<p>生成树的建立过程很简单，便不说了，根据上面的步骤可以自己推导，有问题可以去5.5开头的地方跳转视频。</p>
<p>这里讲一下假设源主机给该多播组发送了一个多播分组，当R1收到后，会将该多播分组封装到目的地址为核心路由器R5的单播分组中，将该单播分组发送给R5，R5收到后，将被封装在单播分组中的多播分组解封出来，在多播转发树上洪泛转发。</p>
<h4 id="5-5-4-因特网的多播路由选择协议"><a href="#5-5-4-因特网的多播路由选择协议" class="headerlink" title="5.5.4 因特网的多播路由选择协议"></a>5.5.4 因特网的多播路由选择协议</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/66360c400ea9cb1403d5c40c.png" alt="计算机网络（四）——网络层——因特网的多播路由选择协议.png">

<h2 id="6-移动IP"><a href="#6-移动IP" class="headerlink" title="6. 移动IP"></a>6. 移动IP</h2><p>首先，据下图，了解一下有关移动IP的相关概念：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f97c0ea9cb1403655644.png" alt="计算机网络（四）——网络层——移动IP概念.png">

<p>上面的概念，用一个例子来说，就是某个用户在A地买了个手机，办理了相关上网服务，那这个手机就具有了永久IP地址，永久居所为A地，所以A地为本地代理。当该用户去了B地，那该设备就要暂时归属B地代理，因为该手机的永久居所不是B地，所以此时B地就是外部代理，由于手机在B地，手机通信需要通过B地的网络，此时B地给手机转发信息的地址就是转交地址。</p>
<p>下面通过一个移动IP通信过程实例，来加深理解：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634f9ba0ea9cb140365efad.png" alt="计算机网络（四）——网络层——移动IP通信过程.png">

<h2 id="7-网络层设备"><a href="#7-网络层设备" class="headerlink" title="7. 网络层设备"></a>7. 网络层设备</h2><p>网络层的主要设备是路由器，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634fc1a0ea9cb14036ea2a2.png" alt="计算机网络（四）——网络层——路由器.png">

<p>上图是路由器的内部结构图，可以看到主要由路由选择和分组转发两部分组成。</p>
<p>路由选择部分也叫控制部分，这部分的核心组件是路由选择处理机，其功能是根据路由选择协议构造路由表毛病定期维护和更新。</p>
<p>分组转发部分又包含三个部分，分别是多个输入端口，交换接口，多个输出端口。这部分核心的结构是交换结构，其可以根据转发表对分组进行转发。</p>
<p>这里再次区分一下转发和路由选择，转发是在路由器内部，决定从哪个端口转发，而路由选择则是宏观的，决定着走哪条路径，把信息从源站发往目的站。</p>
<p>注意，路由器收到不同的分组，其处理过程不一样，如果是RIP、OSPF等分组，会把分组交由路由选择处理机处理，若收到数据分组，则查找转发表直接输出。</p>
<p>接下来看一下输入端口和输出端口的详细信息：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634fc530ea9cb14036f56e4.png" alt="计算机网络（四）——网络层——路由器的输入端口.png">

<p>上面是输入端口的详细信息，首先会从线路上接收分组，交由物理层处理，物理层只进行比特接受。接下里到链路层，链路层按照协议，接收数据帧，然后把帧头帧尾去掉，交由网络层。网络层会对分组进行判断，决定着把分组直接转发还是交付处理机。</p>
<p>从上图，还可以看到，在网络层处理时，会有分组排队，这是因为有时延产生，因为第一个分组到此处，会决定着交付处理机还是转发，转发还需要查表，在这段延迟时间内，会有接二连三的分组来到这里等待处理，所以需要排队。</p>
<p>下面看输出端口是怎么对分组进行处理的：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634fc7e0ea9cb14036fd36e.png" alt="计算机网络（四）——网络层——路由器的输出端口.png">

<p>输出端口会先从交换结构处获得分组，然后再通过链路层和物理层向线路发送分组。</p>
<p>上图也不难看出，在网络层处依然设计了一个分组排队缓存区，如果交换结构传过来的分组速度超出链路发送速度，就会有一些分组在缓存处排队。当缓存处溢出，就会丢弃后面再进入队列的分组，所以说路由器中的输入输出队列产生溢出是造成分组丢失的重要原因。</p>
<p>下面可以看一下，路由器与其他两层设备的区别：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634fca10ea9cb1403703b24.png" alt="计算机网络（四）——网络层——三层设备的区别.png">

<p>接下来看最后一个知识点，路由表和路由转发，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/6634fcdf0ea9cb140370f192.png" alt="计算机网络（四）——网络层——路由表和路由转发.png">

<p>总结一下，路由表根据路由选择算法得到，转发表根据路由表得到。路由表主要选择下一跳走哪个路由器或下一跳IP地址是什么，转发表还要根据主机的具体信息，确定输出的端口。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://bandit-ljC-1.github.io">liujinC</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://bandit-ljc-1.github.io/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/">http://bandit-ljc-1.github.io/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://bandit-ljC-1.github.io" target="_blank">无名高手🍭</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/408%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">408学习笔记</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="/myphotos/article_cover/8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/" title="计算机网络（五）——传输层"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/article_cover/5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络（五）——传输层</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" title="计算机组成原理（四）——指令系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/article_cover/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机组成原理（四）——指令系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" title="计算机网络（一）——计算机网络体系结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/article_cover/12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-17</div><div class="title">计算机网络（一）——计算机网络体系结构</div></div></a></div><div><a href="/2024/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" title="计算机网络（三）——数据链路层"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/article_cover/7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-10</div><div class="title">计算机网络（三）——数据链路层</div></div></a></div><div><a href="/2024/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/" title="计算机网络（二）——物理层"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/article_cover/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-31</div><div class="title">计算机网络（二）——物理层</div></div></a></div><div><a href="/2024/05/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/" title="计算机网络（五）——传输层"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/article_cover/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-10</div><div class="title">计算机网络（五）——传输层</div></div></a></div><div><a href="/2024/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/" title="计算机网络（六）——应用层"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/article_cover/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-12</div><div class="title">计算机网络（六）——应用层</div></div></a></div><div><a href="/2024/03/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="操作系统（一）——计算机系统概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/article_cover/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-22</div><div class="title">操作系统（一）——计算机系统概述</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/myphotos/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">liujinC</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://home.liujinc.cn"><i class="fab fa-github"></i><span>网站主页</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="/myphotos/WeChat.png" target="_blank" title="微信"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-weixin"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/myphotos/QQ.jpg" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1941048387?spm_id_from=333.1007.0.0" target="_blank" title="B站"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://blog.csdn.net/qq_63040545?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-csdn"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://github.com/Bandit-ljC-1" target="_blank" title="GitHub"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github1"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">今年18岁傍50岁富婆，来年50岁包18岁姑娘。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-text">计算机网络（四）——网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%BC%95%E8%A8%80"><span class="toc-text">0. 引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">1. 网络层的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-text">1.1 网络层的基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1"><span class="toc-text">1.2 网络层提供的两种服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%99%9A%E7%94%B5%E8%B7%AF%E6%9C%8D%E5%8A%A1"><span class="toc-text">1.2.1 面向连接的虚电路服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E6%97%A0%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1"><span class="toc-text">1.2.2 无连接的数据报服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%AF%B9%E6%AF%94"><span class="toc-text">1.2.3 两种服务对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-SDN%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.3 SDN基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2"><span class="toc-text">1.3.1 数据平面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="toc-text">1.3.2 控制平面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">1.3.3 控制平面中的路由选择处理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-SDN%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="toc-text">1.3.4 SDN控制平面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-SDN%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-text">1.3.4 SDN控制器的三个层次</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-IPv4"><span class="toc-text">2. IPv4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-IP%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-text">2.1 IP数据报</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.1.1 IP数据报格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87"><span class="toc-text">2.1.2 IP数据报分片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-IPV4%E5%9C%B0%E5%9D%80%E4%B8%8ENAT"><span class="toc-text">2.2 IPV4地址与NAT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-IPV4%E5%9C%B0%E5%9D%80"><span class="toc-text">2.2.1 IPV4地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2NAT"><span class="toc-text">2.2.2 网络地址转换NAT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E4%B8%8E%E8%B7%AF%E7%94%B1%E9%9B%86%E5%90%88"><span class="toc-text">2.3 划分子网与路由集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91"><span class="toc-text">2.3.1 划分子网</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%97%A0%E5%88%86%E7%B1%BB%E7%BC%96%E5%88%B6CIDR"><span class="toc-text">2.3.2 无分类编制CIDR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE%EF%BC%88ARP%EF%BC%89"><span class="toc-text">2.4 地址解析协议（ARP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-DHCP%E5%8D%8F%E8%AE%AE%EF%BC%88%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-text">2.5 DHCP协议（动态主机配置协议）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-ICMP%E5%8D%8F%E8%AE%AE%EF%BC%88%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE%EF%BC%89"><span class="toc-text">2.6 ICMP协议（网际控制报文协议）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-ICMP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-text">2.6.1 ICMP报文结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87"><span class="toc-text">2.6.2 ICMP差错报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-ICMP%E8%AF%A2%E9%97%AE%E6%8A%A5%E6%96%87"><span class="toc-text">2.6.3 ICMP询问报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4-ICMP%E5%BA%94%E7%94%A8"><span class="toc-text">2.6.4 ICMP应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-IPv6"><span class="toc-text">3. IPv6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-text">3.1 IPv6数据报</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-IPv6%E5%9C%B0%E5%9D%80%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="toc-text">3.2 IPv6地址表示形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-IPv6%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.3 IPv6基本地址类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-IPv4%E5%92%8CIPv6%E7%9A%84%E8%BF%87%E6%B8%A1%E7%AD%96%E7%95%A5"><span class="toc-text">3.4 IPv4和IPv6的过渡策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-IPv6%E5%B0%8F%E7%BB%93"><span class="toc-text">3.5 IPv6小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE"><span class="toc-text">4. 路由算法与路由协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-text">4.1 路由算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-RIP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95"><span class="toc-text">4.2 RIP协议与距离向量算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-OSPF%E5%8D%8F%E8%AE%AE%E4%B8%8E%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%AE%97%E6%B3%95"><span class="toc-text">4.3 OSPF协议与链路状态算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-OSPF%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">4.3.1 OSPF相关概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-OSPF%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">4.3.2 OSPF的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-OSPF%E7%9A%84%E4%BA%94%E7%A7%8D%E5%88%86%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.3.3 OSPF的五种分组类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8EOSPF%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">4.3.4 举例说明OSPF的工作过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-OSPF%E5%9C%A8%E5%A4%9A%E7%82%B9%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C%E4%B8%AD%E8%B7%AF%E7%94%B1%E5%99%A8%E9%82%BB%E5%B1%85%E5%85%B3%E7%B3%BB%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-text">4.3.5 OSPF在多点接入网络中路由器邻居关系的建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-OSPF%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86"><span class="toc-text">4.3.6 OSPF的区域划分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AEBGP"><span class="toc-text">4.4 边界网关协议BGP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-IP%E5%A4%9A%E6%92%AD"><span class="toc-text">5. IP多播</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-IP%E5%A4%9A%E6%92%AD%E6%8A%80%E6%9C%AF%E7%9A%84%E7%9B%B8%E5%85%B3%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1 IP多播技术的相关基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8A%E8%BF%9B%E8%A1%8C%E7%A1%AC%E4%BB%B6%E5%A4%9A%E6%92%AD"><span class="toc-text">5.2 在局域网上进行硬件多播</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%9C%A8%E5%9B%A0%E7%89%B9%E7%BD%91%E4%B8%8A%E8%BF%9B%E8%A1%8CIP%E5%A4%9A%E6%92%AD%E9%9C%80%E8%A6%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8D%8F%E8%AE%AE"><span class="toc-text">5.3 在因特网上进行IP多播需要的两种协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E7%BD%91%E9%99%85%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AEIGMP"><span class="toc-text">5.4 网际组管理协议IGMP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-IGMP%E6%8A%A5%E6%96%87"><span class="toc-text">5.4.1 IGMP报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E5%8A%A0%E5%85%A5%E5%A4%9A%E6%92%AD%E7%BB%84"><span class="toc-text">5.4.2 加入多播组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E7%9B%91%E8%A7%86%E5%A4%9A%E6%92%AD%E7%BB%84%E6%88%90%E5%91%98%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">5.4.3 监视多播组成员的变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-%E9%80%80%E5%87%BA%E5%A4%9A%E6%92%AD%E7%BB%84"><span class="toc-text">5.4.4 退出多播组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%A4%9A%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-text">5.5 多播路由选择协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-%E5%A4%9A%E6%92%AD%E8%B7%AF%E7%94%B1%E5%99%A8%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80"><span class="toc-text">5.5.1 多播路由器协议基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-%E5%9F%BA%E4%BA%8E%E6%BA%90%E6%A0%91%E5%A4%9A%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="toc-text">5.5.2 基于源树多播路由选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-3-%E7%BB%84%E5%85%B1%E4%BA%AB%E6%A0%91%E5%A4%9A%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9"><span class="toc-text">5.5.3 组共享树多播路由选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-4-%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E5%A4%9A%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-text">5.5.4 因特网的多播路由选择协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%A7%BB%E5%8A%A8IP"><span class="toc-text">6. 移动IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-text">7. 网络层设备</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By liujinC</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><canvas id="snow"></canvas><script async src="/js/snow.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/mouse.js"></script><script async src="//at.alicdn.com/t/c/font_4451089_fok8y2foa3.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/festival/lunar.js"></script><script defer src="/js/festival/day.js"></script><script async src="/js/fps.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://bandit-ljC-1.github.io/tags/408学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 路漫漫其修远，我探索不了一点。 (25)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://bandit-ljC-1.github.io/tags/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 前端UI到转行平面设计 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://bandit-ljC-1.github.io/tags" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/myphotos/article_cover/1.jpg);"> <a class="categoryBar-list-link" href="categories/网页开发/">网页开发</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">优秀的设计师</span></li><li class="categoryBar-list-item" style="background:url(/myphotos/article_cover/2.jpg);"> <a class="categoryBar-list-link" href="categories/hexo/">hexo</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">五等分的blog</span></li><li class="categoryBar-list-item" style="background:url(/myphotos/article_cover/3.jpg);"> <a class="categoryBar-list-link" href="categories/学习笔记/">学习笔记</a><span class="categoryBar-list-count">25</span><span class="categoryBar-list-descr">埼玉的成长之路</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/01/01/Markdown语法/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="myphotos/article_cover/8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-01</span><a class="blog-slider__title" href="2024/01/01/Markdown语法/" alt="">青春男大遇到不会写的Markdown语法</a><div class="blog-slider__text">本文是博主写博客时遇到的一些不会写的Markdown语法，特在此汇总</div><a class="blog-slider__button" href="2024/01/01/Markdown语法/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/03/07/数据结构（一）——线性表/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="myphotos/article_cover/5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-07</span><a class="blog-slider__title" href="2024/03/07/数据结构（一）——线性表/" alt="">数据结构（一）——线性表</a><div class="blog-slider__text">本文是数据结构中有关线性表的复习笔记，因此只记录一些重点知识与兄弟们交流，并不适合零基础的兄弟。</div><a class="blog-slider__button" href="2024/03/07/数据结构（一）——线性表/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/03/02/基于hexo搭建的个人博客常见问题处理/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="myphotos/article_cover/5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-02</span><a class="blog-slider__title" href="2024/03/02/基于hexo搭建的个人博客常见问题处理/" alt="">基于hexo搭建的个人博客常见问题处理</a><div class="blog-slider__text">该文主要是站长对使用hexo搭建博客时出现的一些问题进行了整理</div><a class="blog-slider__button" href="2024/03/02/基于hexo搭建的个人博客常见问题处理/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/02/08/CSS基础语法及应用/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="myphotos/article_cover/7.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-02-08</span><a class="blog-slider__title" href="2024/02/08/CSS基础语法及应用/" alt="">CSS基础语法及应用</a><div class="blog-slider__text">本文主要整理CSS的基本语法，可以搭配HTML5基本语法进行学习</div><a class="blog-slider__button" href="2024/02/08/CSS基础语法及应用/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/02/01/HTML5基础语法大全/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="myphotos/article_cover/8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-02-01</span><a class="blog-slider__title" href="2024/02/01/HTML5基础语法大全/" alt="">HTML5基本语法大全</a><div class="blog-slider__text">本文主要整理了HTML5的基本语法，方便初学者快速入门</div><a class="blog-slider__button" href="2024/02/01/HTML5基础语法大全/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/clock.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="/css/wowjs/wow.min.js"></script><script defer src="/css/wowjs/wow_init.js"></script><!-- hexo injector body_end end --></body></html>